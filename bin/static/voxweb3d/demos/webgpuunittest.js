(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VoxWebGPU"] = factory();
	else
		root["VoxWebGPU"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fae3");
/******/ })
/************************************************************************/
/******/ ({

/***/ "005f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class WGRUniform {
  constructor(ctx) {
    this.mUid = WGRUniform.sUid++;
    this.mCloned = false;
    this.mSubUfs = [];
    this.index = -1;
    this.layoutName = "";
    /**
     * bind group index
     */

    this.groupIndex = -1;
    this.mCtx = ctx;
    this.mWGC = ctx.getWGCtx();
  }

  getUid() {
    return this.mUid;
  }

  setValue(value, index = 0) {
    const v = this.versions[index];

    if (v.ver != value.version) {
      v.ver = value.version; // console.log("WGRUniform::setValue(), shared: ", v.shared, ', shdVarName: ',v.shdVarName);

      this.mWGC.buffer.updateUniformBuffer(this.buffers[index], value.data, this.ivs[index], value.byteOffset);
    }
  }

  isEnabled() {
    return this.buffers != null;
  }

  __$$updateSubUniforms() {
    const ufs = this.mSubUfs;

    if (ufs && this.buffers) {
      for (let i = 0, ln = ufs.length; i < ln; i++) {
        this.copySelfTo(ufs[i]);
      }
    }
  }

  copySelfTo(u) {
    u.index = this.index;
    u.layoutName = this.layoutName;
    u.buffers = this.buffers;
    u.bindGroup = this.bindGroup;
    u.groupIndex = this.groupIndex;
    u.versions = this.versions.slice(0); // console.log("copySelfTo(), u.versions: ", u.versions);
  }

  clone() {
    const u = new WGRUniform(this.mCtx);
    u.index = this.index;
    u.layoutName = this.layoutName;
    u.buffers = this.buffers;
    u.bindGroup = this.bindGroup;
    u.groupIndex = this.groupIndex;
    u.mCloned = true;
    this.mSubUfs.push(u);
    return u;
  }

  cloneMany(total) {
    const ls = new Array(total);

    for (let i = 0; i < total; ++i) {
      ls[i] = this.clone(); // ls[i].uid = 1000 + i;
    }

    return ls;
  }

  destroy() {
    if (this.mCtx) {
      this.mSubUfs = [];
      this.uvfs = null;

      if (this.mCloned) {
        this.index = -1;
        this.groupIndex = -1;
        this.buffers = null;
        this.bindGroup = null;
      } else {
        this.mCtx.removeUniform(this);
      }

      this.mCtx = null;
    }
  }

  __$$destroy() {
    this.groupIndex = -1;
    this.index = -1;
    this.mWGC = null;
    this.buffers = null;
  }

}

WGRUniform.sUid = 0;
exports.WGRUniform = WGRUniform;

/***/ }),

/***/ "0069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const BoxGeometry_1 = __importDefault(__webpack_require__("a229"));

class CubeEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {};
    let h = 50;

    if (param.cubeSize !== undefined) {
      h = Math.abs(param.cubeSize * 0.5);
    }

    const minPos = [-h, -h, -h];
    const maxPos = [h, h, h];
    return new BoxGeometry_1.default().initialize(minPos, maxPos);
  }

}

exports.CubeEntity = CubeEntity;

/***/ }),

/***/ "0142":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRendererPassImpl_1 = __webpack_require__("3e2f");

exports.WGRPassParam = WGRendererPassImpl_1.WGRPassParam;
exports.WGRendererPassImpl = WGRendererPassImpl_1.WGRendererPassImpl;

const WGRPColorAttachment_1 = __webpack_require__("8e9d");

const WGRPDepthStencilAttachment_1 = __webpack_require__("1d61");

const WGTextureDataDescriptor_1 = __webpack_require__("37b8");

class WGRendererPass {
  constructor(wgCtx, drawing = true) {
    this.mDrawing = true;
    this.name = "";
    this.passColors = [new WGRPColorAttachment_1.WGRPColorAttachment()];
    this.separate = false;
    this.enabled = true; // console.log("WGRendererPass::constructor(), drawing: ", drawing);

    this.mDrawing = drawing;

    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  isDrawing() {
    return this.mDrawing;
  }

  get depthTexture() {
    return this.mDepthTexture;
  }

  initialize(wgCtx) {
    this.mWGCtx = wgCtx;
  }

  getPassParams() {
    return this.mParam;
  }

  build(params) {
    console.log("WGRendererPass::build() mDrawing: ", this.mDrawing, "params: ", params);

    if (this.mDrawing) {
      params.multisampleEnabled = params.sampleCount && params.sampleCount > 1;
      this.mParam = params;

      if (this.prevPass) {
        this.mDepthTexture = this.prevPass.mDepthTexture;
        this.colorView = this.prevPass.colorView;
      } else {
        this.createRenderPassTexture(params);
      }
    }
  }

  updateColorAttachmentView(colorAtt, t, onlyViewChange = false) {
    if (!colorAtt.view) {
      if (!onlyViewChange) {
        colorAtt.setParam(t);
      }

      if (!colorAtt.view) {
        let td = WGTextureDataDescriptor_1.texDescriptorFilter(t.texture);

        if (td) {
          const rttData = td.rttTexture;

          if (rttData) {
            const ctx = this.mWGCtx;

            if (rttData.texture === undefined) {
              const rtt = ctx.texture.createColorRTTTexture({
                format: td.format
              });
              rttData.texture = rtt;
              rttData.textureView = rtt.createView(); // colorAtt.gpuTexture = rtt;

              colorAtt.textureFormat = rtt.format;
              colorAtt.view = rttData.textureView;
              colorAtt.view.label = td.uuid;
              console.log("动态创建一个 color rtt gpu texture instance, colorAtt.textureFormat: ", colorAtt.textureFormat); // console.log("动态创建一个 color rtt gpu texture instance, view: ", colorAtt.view);

              console.log("动态创建一个 color rtt gpu texture instance, td: ", td);
            } else {
              colorAtt.view = rttData.textureView;
            } // console.log("updateColorAttachmentView(), rttData.textureView: ", rttData.textureView);


            colorAtt.texture = t.texture;
          }
        }
      }
    }
  }

  createRenderPassTexture(param) {
    const ctx = this.mWGCtx;
    let separate = this.separate;
    let sampleCount = 1;
    const multisampled = param.multisampleEnabled === true;
    param.multisampleEnabled = multisampled;

    if (multisampled) {
      sampleCount = param.sampleCount;
    }

    let size = [ctx.canvasWidth, ctx.canvasHeight];
    let pcs = this.passColors;
    let colorAtt = pcs[0]; // console.log("createRenderPassTexture(), this.separate: ", this.separate);
    // console.log("createRenderPassTexture(), sampleCount: ", sampleCount, ", multisampled: ", multisampled);

    if (separate) {
      let ls = param.colorAttachments;
      this.mColorAttachments = ls;

      if (ls && ls.length > 0) {
        for (let i = 1; i < ls.length; ++i) {
          pcs.push(new WGRPColorAttachment_1.WGRPColorAttachment());
        }

        for (let i = 0; i < ls.length; ++i) {// this.updateColorAttachmentView(colorAtt, ls[i]);
        }

        this.clearColor.setColor(pcs[0].clearValue); // console.log("xxx xxx pcs: ", pcs);
      } else {
        const texture = ctx.texture.createRTTTexture({
          size,
          sampleCount,
          format: ctx.presentationFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
        this.colorView = texture.createView();
        colorAtt.view = this.colorView;
        colorAtt.viewTexture = texture;
      }
    } else {
      if (multisampled) {
        const texture = ctx.texture.createRTTTexture({
          size,
          sampleCount,
          format: ctx.presentationFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
        this.colorView = texture.createView();
        colorAtt.view = this.colorView;
        colorAtt.viewTexture = texture;
      }
    }

    if (!(param.depthTestEnabled === false) || param.depthStencilAttachment) {
      let dsp = param.depthStencilAttachment;
      let dsAtt = this.passDepthStencil;
      if (!dsAtt) dsAtt = new WGRPDepthStencilAttachment_1.WGRPDepthStencilAttachment().setParam(dsp);
      this.passDepthStencil = dsAtt;

      if (!dsAtt.view) {
        size = [ctx.canvasWidth, ctx.canvasHeight];
        let format = "depth24plus";
        if (param.depthFormat !== undefined) format = param.depthFormat;
        const depthTexDesc = {
          size,
          sampleCount,
          format,
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        };
        const depthTexture = ctx.texture.createRTTTexture(depthTexDesc);
        this.mDepthTexture = depthTexture;
        dsAtt.view = depthTexture.createView();
        dsAtt.viewTexture = depthTexture;
      }
    } // console.log("depthTexDesc: ", depthTexDesc, ", depthTexture: ", depthTexture);

  }

  runBegin() {
    const ctx = this.mWGCtx;
    const prev = this.prevPass;

    if (prev) {
      this.enabled = this.enabled && prev.enabled;
    }

    if (this.enabled && ctx.enabled) {
      const device = ctx.device;
      const param = this.mParam;
      this.commandEncoder = device.createCommandEncoder();
      const cmdEncoder = this.commandEncoder;

      if (this.mDrawing) {
        let pcs = this.passColors;
        const colorT = pcs[0];
        let dsAtt = this.passDepthStencil;
        const multisampleEnabled = param.multisampleEnabled;

        if (prev) {
          const prevColorAtt = prev.passColors[0];
          const prevDSAtt = prev.passDepthStencil;
          colorT.loadOp = "load";

          if (multisampleEnabled) {
            colorT.view = prevColorAtt.view;
            colorT.resolveTarget = prevColorAtt.resolveTarget;
          } else {
            colorT.view = prevColorAtt.view;
          }

          if (prevDSAtt) {
            if (!dsAtt) {
              dsAtt = new WGRPDepthStencilAttachment_1.WGRPDepthStencilAttachment();
              dsAtt.depthLoadOp = "load";
              this.passDepthStencil = dsAtt;
            }

            dsAtt = this.passDepthStencil;
            dsAtt.view = prevDSAtt.view;
          }
        } else {
          if (pcs.length == 1) {
            pcs[0].clearValue.copyFrom(this.clearColor);
          }

          if (this.separate) {
            // console.log("run a rpass, this.separate: ", this.separate,", multisampleEnabled: ", multisampleEnabled);
            const cts = this.mColorAttachments;

            if (cts !== undefined) {
              for (let i = 0; i < pcs.length; ++i) {
                const ct = pcs[i];
                const p = ct.param;
                const t = cts[i];

                if (!ct.view || p !== t || ct.texture !== t.texture) {
                  if (t.texture !== undefined) {
                    ct.view = null;
                    this.updateColorAttachmentView(ct, t, p === t);

                    if (i < 1 && p !== t) {
                      this.clearColor.setColor(ct.clearValue);
                    }
                  }
                }
              }
            }
          } else {
            if (multisampleEnabled) {
              colorT.resolveTarget = colorT.resolveTargetTexture ? colorT.resolveTarget : ctx.createCurrentView();
            } else {
              colorT.view = colorT.viewTexture ? colorT.view : ctx.createCurrentView();
            }
          }
        }

        let colorAttachments = this.passColors; // for test
        // if (this.separate) {
        // 	// const ca = colorAttachments[0];
        // 	let ca = colorAttachments[0];
        // 	console.log("xxx xxx ca0: ", ca);
        // 	ca = colorAttachments[1];
        // 	console.log("xxx xxx ca1: ", ca);
        // }

        let renderPassDescriptor;

        if (dsAtt) {
          renderPassDescriptor = {
            colorAttachments: colorAttachments,
            depthStencilAttachment: dsAtt
          };
        } else {
          renderPassDescriptor = {
            colorAttachments: colorAttachments
          };
        }

        this.passEncoder = cmdEncoder.beginRenderPass(renderPassDescriptor);
      } else {
        this.compPassEncoder = cmdEncoder.beginComputePass();
      }
    }
  }

  runEnd() {
    const ctx = this.mWGCtx;

    if (this.enabled && ctx.enabled) {
      if (this.mDrawing) {
        this.passEncoder.end();
      } else {
        this.compPassEncoder.end();
      }

      return this.commandEncoder.finish();
    }

    return null;
  }

  destroy() {
    this.mColorAttachments = null;
  }

}

exports.WGRendererPass = WGRendererPass;

/***/ }),

/***/ "0444":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(4) var<uniform> albedo: vec4f;\r\n@group(0) @binding(5) var<uniform> arm: vec4f;\r\n\r\nconst PI = 3.141592653589793;\r\nconst PI2 = 6.283185307179586;\r\nconst PI_HALF = 1.5707963267948966;\r\nconst RECIPROCAL_PI = 0.3183098861837907;\r\nconst RECIPROCAL_PI2 = 0.15915494309189535;\r\nconst EPSILON = 1e-6;\r\n\r\nfn approximationSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(srgbColor, vec3<f32>(2.2));\r\n}\r\nfn approximationLinearToSRCB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfn accurateSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    let linearRGBLo = srgbColor / 12.92;\r\n    let linearRGBHi = pow((srgbColor + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n\tif( all( srgbColor <= vec3(0.04045) ) ) {\r\n\t\treturn linearRGBLo;\r\n\t}\r\n    return linearRGBHi;\r\n}\r\nfn accurateLinearToSRGB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    let srgbLo = linearColor * 12.92;\r\n    let srgbHi = (pow(abs(linearColor), vec3(1.0 / 2.4)) * 1.055) - 0.055;\r\n    if(all(linearColor <= vec3(0.0031308))) {\r\n\t\treturn srgbLo;\r\n\t}\r\n    return srgbHi;\r\n}\r\n\r\n// Trowbridge-Reitz(Generalized-Trowbridge-Reitz,GTR)\r\nfn DistributionGTR1(NdotH: f32, roughness: f32) -> f32 {\r\n    if (roughness >= 1.0) {\r\n\t\treturn 1.0/PI;\r\n\t}\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0)*NdotH*NdotH;\r\n    return (a2 - 1.0) / (PI * log(a2) *t);\r\n}\r\nfn DistributionGTR2(NdotH: f32, roughness: f32) -> f32 {\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\r\n    return a2 / (PI * t * t);\r\n}\r\n\r\n\r\nfn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {\r\n    let a = roughness*roughness;\r\n    let a2 = a*a;\r\n    let NdotH = max(dot(N, H), 0.0);\r\n    let NdotH2 = NdotH*NdotH;\r\n\r\n    let nom   = a2;\r\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n\r\n\r\nfn GeometryImplicit(NdotV: f32, NdotL: f32) -> f32 {\r\n    return NdotL * NdotV;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\r\n    let r = (roughness + 1.0);\r\n    let k = (r*r) / 8.0;\r\n\r\n    let nom   = NdotV;\r\n    let denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {\r\n    let NdotV = max(dot(N, V), 0.0);\r\n    let NdotL = max(dot(N, L), 0.0);\r\n    let ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    let ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// @param cosTheta is clamp(dot(H, V), 0.0, 1.0)\r\nfn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\r\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\r\n}\r\nfn fresnelSchlick2(specularColor: vec3<f32>, L: vec3<f32>, H: vec3<f32>) -> vec3<f32> {\r\n   return specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(L, H)), 5.0);\r\n}\r\n//fresnelSchlick2(specularColor, L, H) * ((SpecularPower + 2) / 8 ) * pow(saturate(dot(N, H)), SpecularPower) * dotNL;\r\n\r\nconst OneOnLN2_x6 = 8.656171;// == 1/ln(2) * 6 (6 is SpecularPower of 5 + 1)\r\n// dot -> dot(N,V) or\r\nfn fresnelSchlick3(specularColor: vec3<f32>, dot: f32, glossiness: f32) -> vec3<f32> {\r\n\treturn specularColor + (max(vec3(glossiness), specularColor) - specularColor) * exp2(-OneOnLN2_x6 * dot);\r\n}\r\nfn fresnelSchlickWithRoughness(specularColor: vec3<f32>, L: vec3<f32>, N: vec3<f32>, gloss: f32) -> vec3<f32> {\r\n   return specularColor + (max(vec3(gloss), specularColor) - specularColor) * pow(1.0 - saturate(dot(L, N)), 5.0);\r\n}\r\n\r\nconst A = 2.51f;\r\nconst B = 0.03f;\r\nconst C = 2.43f;\r\nconst D = 0.59f;\r\nconst E = 0.14f;\r\nfn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32> {\r\n\r\n\tlet c = color * adapted_lum;\r\n\treturn (c * (A * c + B)) / (c * (C * c + D) + E);\r\n}\r\n\r\n//color = color / (color + vec3(1.0));\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn reinhard_extended(v: vec3<f32>, max_white: f32) -> vec3<f32> {\r\n    let numerator = v * (1.0f + (v / vec3(max_white * max_white)));\r\n    return numerator / (1.0f + v);\r\n}\r\nfn luminance(v: vec3<f32>) -> f32 {\r\n    return dot(v, vec3<f32>(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn change_luminance(c_in: vec3<f32>, l_out: f32) -> vec3<f32> {\r\n    let l_in = luminance(c_in);\r\n    return c_in * (l_out / l_in);\r\n}\r\nfn reinhard_extended_luminance(v: vec3<f32>, max_white_l: f32) -> vec3<f32> {\r\n    let l_old = luminance(v);\r\n    let numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\r\n    let l_new = numerator / (1.0f + l_old);\r\n    return change_luminance(v, l_new);\r\n}\r\nfn ReinhardToneMapping( color: vec3<f32>, toneMappingExposure: f32 ) -> vec3<f32> {\r\n\r\n\tlet c = color * toneMappingExposure;\r\n\treturn saturate( c / ( vec3( 1.0 ) + c ) );\r\n\r\n}\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nconst highp_a = 12.9898;\r\nconst highp_b = 78.233;\r\nconst highp_c = 43758.5453;\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n\tlet dt = dot( uv.xy, vec2<f32>( highp_a, highp_b ) );\r\n\tlet sn = modf( dt / PI ).fract;\r\n\treturn fract(sin(sn) * highp_c);\r\n}\r\n// // based on https://www.shadertoy.com/view/MslGR8\r\nfn dithering( color: vec3<f32>, fragCoord: vec2<f32> ) -> vec3<f32> {\r\n    //Calculate grid position\r\n    let grid_position = rand( fragCoord );\r\n\r\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n    var dither_shift_RGB = vec3<f32>( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n    //modify shift acording to grid position.\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n    //shift the color by dither_shift\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nconst dis = 600.0;\r\nconst disY = 400.0;\r\nconst u_lightPositions = array<vec3<f32>, 4>(\r\n\tvec3<f32>(-dis, disY, dis),\r\n\tvec3<f32>(dis, disY, dis),\r\n\tvec3<f32>(-dis, disY, -dis),\r\n\tvec3<f32>(dis, disY, -dis)\r\n);\r\nconst colorValue = 300.0;\r\nconst u_lightColors = array<vec3<f32>, 4>(\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n);\r\n\r\nfn calcPBRColor3(Normal: vec3<f32>, WorldPos: vec3<f32>, camPos: vec3<f32>) -> vec3<f32> {\r\n\r\n\tvar color = vec3<f32>(0.0);\r\n\r\n    var ao = arm.x;\r\n    var roughness = arm.y;\r\n    var metallic = arm.z;\r\n\r\n\tvar N = normalize(Normal);\r\n    var V = normalize(camPos.xyz - WorldPos);\r\n    var dotNV = clamp(dot(N, V), 0.0, 1.0);\r\n\r\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\r\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\r\n    var F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo.xyz, metallic);\r\n\r\n    // reflectance equation\r\n    var Lo = vec3(0.0);\r\n\r\n\tfor (var i: i32 = 0; i < 4; i++) {\r\n\t\t// calculate per-light radiance\r\n        let L = normalize(u_lightPositions[i].xyz - WorldPos);\r\n        let H = normalize(V + L);\r\n        let distance = length(u_lightPositions[i].xyz - WorldPos);\r\n\r\n        let attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0003 * distance * distance);\r\n        let radiance = u_lightColors[i].xyz * attenuation;\r\n\r\n        // Cook-Torrance BRDF\r\n        let NDF = DistributionGGX(N, H, roughness);\r\n        let G   = GeometrySmith(N, V, L, roughness);\r\n        //vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\r\n        let F    = fresnelSchlick3(F0,clamp(dot(H, V), 0.0, 1.0), 0.9);\r\n        //vec3 F    = fresnelSchlick3(F0,dotNV, 0.9);\r\n\r\n        let nominator    = NDF * G * F;\r\n        let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\r\n        let specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\r\n\r\n        // kS is equal to Fresnel\r\n        let kS = F;\r\n        // for energy conservation, the diffuse and specular light can't\r\n        // be above 1.0 (unless the surface emits light); to preserve this\r\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\r\n        var kD = vec3<f32>(1.0) - kS;\r\n        // multiply kD by the inverse metalness such that only non-metals\r\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\r\n        // have no diffuse light).\r\n        kD *= 1.0 - metallic;\r\n\r\n        // scale light by NdotL\r\n        let NdotL = max(dot(N, L), 0.0);\r\n\r\n        // add to outgoing radiance Lo\r\n        // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\r\n        Lo += (kD * albedo.xyz / PI + specular) * radiance * NdotL;\r\n\t}\r\n\t// ambient lighting (note that the next IBL tutorial will replace\r\n    // this ambient lighting with environment lighting).\r\n    let ambient = vec3<f32>(0.03) * albedo.xyz * ao;\r\n\r\n    color = ambient + Lo;\r\n    // HDR tonemapping\r\n    color = reinhard( color );\r\n    // gamma correct\r\n    color = pow(color, vec3<f32>(1.0/2.2));\r\n\treturn color;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>,\r\n  @location(3) camPos: vec3<f32>\r\n) -> @location(0) vec4<f32> {\r\n  var color4 = vec4(calcPBRColor3(normal, pos.xyz, camPos), 1.0);\r\n  return color4;\r\n}");

/***/ }),

/***/ "0540":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const AABBCalc_1 = __webpack_require__("79d0");

class RectPlaneGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.offsetU = 0.0;
    this.offsetV = 0.0;
    this.uScale = 1.0;
    this.vScale = 1.0;
    /**
     * flip vertical uv value
     */

    this.flipY = false;
    /**
     * axisType = 0 is XOY plane,
     * axisType = 1 is XOZ plane,
     * axisType = 2 is YOZ plane
     */

    this.axisType = 0;
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  setUVS(uvsLen8) {
    if (uvsLen8 != null && uvsLen8.length == 8) {
      if (this.muvs == null) {
        this.muvs = uvsLen8.slice(0);
      } else {
        this.muvs.set(uvsLen8);
      }
    }
  }

  getNVS() {
    return this.mnvs;
  }

  initialize(startX, startY, pwidth, pheight) {
    if (this.mvs) {
      return;
    }

    let minX = startX;
    let minY = startY;
    let maxX = startX + pwidth;
    let maxY = startY + pheight;
    let pz = 0.0; // ccw is positive, left-bottom pos(minX,minY) -> right-bottom pos(maxX,minY) -> right-top pos(maxX,maxY)  -> right-top pos(minX,maxY)

    this.mivs = new Uint16Array([0, 1, 2, 0, 2, 3]); //this.mivs = new Uint32Array([0,1,2,0,2,3]);

    switch (this.axisType) {
      case 0:
        // XOY plane
        this.mvs = new Float32Array([minX, minY, pz, maxX, minY, pz, maxX, maxY, pz, minX, maxY, pz]);
        break;

      case 1:
        // XOZ plane
        this.mvs = new Float32Array([maxX, pz, minY, minX, pz, minY, minX, pz, maxY, maxX, pz, maxY]);
        break;

      case 2:
        // YOZ plane
        this.mvs = new Float32Array([pz, minX, minY, pz, maxX, minY, pz, maxX, maxY, pz, minX, maxY]);
        break;

      default:
        break;
    }

    if (!this.bounds) this.bounds = new AABB_1.default();
    this.bounds.addFloat32Arr(this.mvs);
    this.bounds.updateFast();

    if (!this.muvs) {
      if (this.flipY) {
        this.muvs = new Float32Array([this.offsetU + 0.0 * this.uScale, this.offsetV + 1.0 * this.vScale, this.offsetU + 1.0 * this.uScale, this.offsetV + 1.0 * this.vScale, this.offsetU + 1.0 * this.uScale, this.offsetV + 0.0 * this.vScale, this.offsetU + 0.0 * this.uScale, this.offsetV + 0.0 * this.vScale]);
      } else {
        this.muvs = new Float32Array([this.offsetU + 0.0 * this.uScale, this.offsetV + 0.0 * this.vScale, this.offsetU + 1.0 * this.uScale, this.offsetV + 0.0 * this.vScale, this.offsetU + 1.0 * this.uScale, this.offsetV + 1.0 * this.vScale, this.offsetU + 0.0 * this.uScale, this.offsetV + 1.0 * this.vScale]);
      }
    }

    if (true) {
      switch (this.axisType) {
        case 0:
          this.mnvs = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0]);
          break;

        case 1:
          this.mnvs = new Float32Array([0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0]);
          break;

        case 2:
          this.mnvs = new Float32Array([1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0]);
          break;

        default:
          break;
      }
    }

    this.vtxTotal = 4;
    this.trisNumber = 2;
    this.vtCount = this.mivs.length;
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    if (this.mPolyhedral) return -1;

    if (boundsHit) {
      let boo = AABBCalc_1.AABBCalc.IntersectionRL2(rltv, rlpv, this.bounds, outV);
      return boo ? 1 : -1;
    }

    return -1;
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;

      super.__$destroy();
    }
  }

}

exports.default = RectPlaneGeometry;

/***/ }),

/***/ "07b0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> color: vec4f;\r\n@fragment\r\nfn main(\r\n  @location(0) vertColor: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  var color4 = vertColor * color;\r\n  return color4;\r\n}");

/***/ }),

/***/ "0884":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "0a09":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const WGRPassNodeGraph_1 = __webpack_require__("f083");

const WGMaterial_1 = __webpack_require__("943f");

const MouseInteraction_1 = __webpack_require__("213f");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const blurHTex_frag_wgsl_1 = __importDefault(__webpack_require__("d3d0"));

const blurVTex_frag_wgsl_1 = __importDefault(__webpack_require__("5dcd"));

const primitive_vert_wgsl_1 = __importDefault(__webpack_require__("d9d5"));

const primitiveVPos_frag_wgsl_1 = __importDefault(__webpack_require__("8637"));

const vposRead_frag_wgsl_1 = __importDefault(__webpack_require__("8b6a"));

const depthBlur_frag_wgsl_1 = __importDefault(__webpack_require__("0db1"));

const TorusEntity_1 = __webpack_require__("5118");

const blurRTTTex0 = {
  diffuse: {
    uuid: "rtt0",
    rttTexture: {}
  }
};
const blurRTTTex1 = {
  diffuse: {
    uuid: "rtt1",
    rttTexture: {}
  }
};
const rtts = [blurRTTTex0, blurRTTTex1];
const attachment = {
  texture: blurRTTTex0,
  clearValue: [],
  loadOp: "clear",
  storeOp: "store"
};
const colorAttachments = [attachment];
const colorRTTTex = {
  diffuse: {
    uuid: "colorRTT",
    rttTexture: {}
  }
};
const vposRTTTex = {
  diffuse: {
    uuid: "floatRTT",
    rttTexture: {},
    format: 'rgba16float'
  }
};

class PassGraph extends WGRPassNodeGraph_1.WGRPassNodeGraph {
  constructor() {
    super();
  }

  run() {
    let pass = this.passes[0];
    const entity = this.blurEntity;
    let ms = entity.materials;

    for (let i = 0; i < 11; ++i) {
      const ia = i % 2;
      const ib = (i + 1) % 2;
      pass.colorAttachments[0].clearEnabled = i < 1;
      this.srcEntity.visible = i < 1;
      this.blurEntity.visible = i > 0;
      attachment.texture = rtts[ia];
      ms[ia].visible = false;
      ms[ib].visible = true;
      pass.render();
    }
  }

}

class DepthBlur {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mGraph = new PassGraph();
    this.uniformValues = [{
      data: new Float32Array([512, 512, 3.0, 0])
    }];

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("DepthBlur::initialize() ...");
    let multisampleEnabled = true;
    let depthTestEnabled = false;
    let rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam,
      camera: {
        eye: [260, 260, 260]
      }
    });
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shadinguuid, textures, type) {
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: type > 0 ? blurVTex_frag_wgsl_1.default : blurHTex_frag_wgsl_1.default,
        uuid: "frag"
      }
    };
    shadinguuid += "-" + type;
    let pipelineDefParam = {
      depthWriteEnabled: false
    };
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid,
      shaderSrc,
      pipelineDefParam
    });
    material.uniformValues = this.uniformValues;
    material.addTextures(textures);
    return material;
  }

  applyBlurPass(clearColor, extent) {
    let rs = this.mRscene;
    const graph = this.mGraph;
    attachment.clearValue = clearColor;
    let rPass = rs.createRenderPass({
      separate: true,
      colorAttachments
    });
    graph.passes = [rPass];
    let materials = [this.createMaterial("shd-00", [blurRTTTex0], 0), this.createMaterial("shd-01", [blurRTTTex1], 1)];
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-1, -1, 2, 2],
      flipY: true,
      textures: [colorRTTTex]
    });
    rttEntity.uuid = "src-entity";
    rPass.addEntity(rttEntity);
    graph.srcEntity = rttEntity;
    rs.setPassNodeGraph(graph);
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      materials
    });
    entity.materials[0].visible = false;
    entity.uuid = "blur-entity";
    rPass.addEntity(entity);
    graph.blurEntity = entity;
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: depthBlur_frag_wgsl_1.default,
        uuid: "depthBlur"
      }
    }; // display blur rendering result

    let textures = [colorRTTTex, blurRTTTex0, vposRTTTex];
    extent = [-0.8, -0.8, 1.6, 1.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: false,
      shaderSrc,
      textures,
      shadinguuid: "blurRenderingResult"
    });
    rs.addEntity(entity);
  }

  applyMRTPass(extent) {
    let rs = this.mRscene;
    const attachment0 = {
      texture: colorRTTTex,
      clearValue: [0.15, 0.15, 0.15, 1.0]
    };
    const attachment1 = {
      texture: vposRTTTex,
      clearValue: [0.2, 0.25, 0.2, 1.0] // clearValue: [800, 800, 800, 1]

    };
    const colorAttachments = [attachment0, attachment1];
    let rPass = rs.createRenderPass({
      separate: true,
      colorAttachments
    });
    let shaderSrc = {
      vert: {
        code: primitive_vert_wgsl_1.default,
        uuid: "vertMRT"
      },
      frag: {
        code: primitiveVPos_frag_wgsl_1.default,
        uuid: "fragMRT"
      }
    };
    let torus = new TorusEntity_1.TorusEntity({
      shaderSrc,
      radius: 150
    });
    torus.setAlbedo([0.7, 0.02, 0.1]);
    rPass.addEntity(torus);
    shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: vposRead_frag_wgsl_1.default,
        uuid: "readNromal"
      }
    }; // display depth value drawing result

    extent = [-0.95, -0.95, 0.6, 0.6];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      shaderSrc,
      textures: [vposRTTTex],
      shadinguuid: "readDepth"
    });
    rs.addEntity(entity); // display albedo drawing result

    extent = [-0.33, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [colorRTTTex]
    });
    rs.addEntity(entity); // display blur drawing result

    extent = [0.3, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [blurRTTTex0]
    });
    rs.addEntity(entity);
  }

  initScene() {
    this.applyBlurPass([0.0, 0.0, 0.03, 1.0], [-1, -1, 2, 2]);
    this.applyMRTPass([-1, -1, 2, 2]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.DepthBlur = DepthBlur;

/***/ }),

/***/ "0bc4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<storage> param: vec4f;\r\n@group(0) @binding(4) var mySampler: sampler;\r\n@group(0) @binding(5) var myTexture: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragUV: vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n  var color4 = textureSample(myTexture, mySampler, fragUV) * fragPosition * param;\r\n  color4 = vec4(color4.xyz, 1.0);\r\n  return color4;\r\n}\r\n");

/***/ }),

/***/ "0c34":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("2fc9");
/**
let tex = {
            diffuse: { uuid: "cubeTexBrn", dataTexture: { datas: datas, width, height }, viewDimension: 'cube', format: "rgba8unorm", generateMipmaps: false }
            // diffuse: { uuid: "texCubeBrn", viewDimension: "cube", dataTexture: { texture }, format: "rgba8unorm", generateMipmaps: false }
        };
 */


class SpecularEnvBrnTexture {
  constructor() {
    this.specularEnv = {
      uuid: "SpecularEnvBrnTexture",
      dataTexture: {
        datas: [],
        width: 128,
        height: 128
      },
      viewDimension: 'cube',
      format: "rgba8unorm",
      generateMipmaps: false
    };
  }

  set datas(datas) {
    this.specularEnv.dataTexture.datas = datas;
  }

  set width(w) {
    this.specularEnv.dataTexture.width = w;
  }

  set height(h) {
    this.specularEnv.dataTexture.width = h;
  }

  load(url) {
    new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
      this.parse(buf);
    });
    return this;
  }

  parse(buffer) {
    let data16 = new Uint16Array(buffer);
    let currBytes = new Uint8Array(buffer);
    let begin = 0;
    let width = data16[4];
    let height = data16[5];
    let mipMapMaxLv = data16[6];
    console.log("SpecularEnvBrnTexture, width: ", width, "height: ", height, "mipMapMaxLv: ", mipMapMaxLv);
    let size = 0;
    let bytes = currBytes.subarray(32);
    let dataU8;
    let datas = [];
    let tex = this.specularEnv.dataTexture;
    tex.width = width;
    tex.height = height;
    let currW = width;
    let currH = height;

    for (let j = 0; j < mipMapMaxLv; j++) {
      for (let i = 0; i < 6; i++) {
        size = currW * currW * 4; // console.log("parseMultiHdrBrn, j: ", j, ", currW: ", currW, ", currH: ", currH);

        dataU8 = bytes.subarray(begin, begin + size);
        datas.push(dataU8);
        begin += size;
      }

      currW >>= 1;
      currH >>= 1;
    }

    tex.datas = datas;
  }

}

exports.SpecularEnvBrnTexture = SpecularEnvBrnTexture;

/***/ }),

/***/ "0d53":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> albedo: vec4f;\r\n@group(0) @binding(4) var<uniform> arm: vec4f;\r\n\r\nconst PI = 3.141592653589793;\r\nconst PI2 = 6.283185307179586;\r\nconst PI_HALF = 1.5707963267948966;\r\nconst RECIPROCAL_PI = 0.3183098861837907;\r\nconst RECIPROCAL_PI2 = 0.15915494309189535;\r\nconst EPSILON = 1e-6;\r\n\r\nfn approximationSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(srgbColor, vec3<f32>(2.2));\r\n}\r\nfn approximationLinearToSRCB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfn accurateSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    let linearRGBLo = srgbColor / 12.92;\r\n    let linearRGBHi = pow((srgbColor + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n\tif( all( srgbColor <= vec3(0.04045) ) ) {\r\n\t\treturn linearRGBLo;\r\n\t}\r\n    return linearRGBHi;\r\n}\r\nfn accurateLinearToSRGB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    let srgbLo = linearColor * 12.92;\r\n    let srgbHi = (pow(abs(linearColor), vec3(1.0 / 2.4)) * 1.055) - 0.055;\r\n    if(all(linearColor <= vec3(0.0031308))) {\r\n\t\treturn srgbLo;\r\n\t}\r\n    return srgbHi;\r\n}\r\n\r\n// Trowbridge-Reitz(Generalized-Trowbridge-Reitz,GTR)\r\nfn DistributionGTR1(NdotH: f32, roughness: f32) -> f32 {\r\n    if (roughness >= 1.0) {\r\n\t\treturn 1.0/PI;\r\n\t}\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0)*NdotH*NdotH;\r\n    return (a2 - 1.0) / (PI * log(a2) *t);\r\n}\r\nfn DistributionGTR2(NdotH: f32, roughness: f32) -> f32 {\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\r\n    return a2 / (PI * t * t);\r\n}\r\n\r\n\r\nfn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {\r\n    let a = roughness*roughness;\r\n    let a2 = a*a;\r\n    let NdotH = max(dot(N, H), 0.0);\r\n    let NdotH2 = NdotH*NdotH;\r\n\r\n    let nom   = a2;\r\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n\r\n\r\nfn GeometryImplicit(NdotV: f32, NdotL: f32) -> f32 {\r\n    return NdotL * NdotV;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\r\n    let r = (roughness + 1.0);\r\n    let k = (r*r) / 8.0;\r\n\r\n    let nom   = NdotV;\r\n    let denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {\r\n    let NdotV = max(dot(N, V), 0.0);\r\n    let NdotL = max(dot(N, L), 0.0);\r\n    let ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    let ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// @param cosTheta is clamp(dot(H, V), 0.0, 1.0)\r\nfn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\r\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\r\n}\r\nfn fresnelSchlick2(specularColor: vec3<f32>, L: vec3<f32>, H: vec3<f32>) -> vec3<f32> {\r\n   return specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(L, H)), 5.0);\r\n}\r\n//fresnelSchlick2(specularColor, L, H) * ((SpecularPower + 2) / 8 ) * pow(saturate(dot(N, H)), SpecularPower) * dotNL;\r\n\r\nconst OneOnLN2_x6 = 8.656171;// == 1/ln(2) * 6 (6 is SpecularPower of 5 + 1)\r\n// dot -> dot(N,V) or\r\nfn fresnelSchlick3(specularColor: vec3<f32>, dot: f32, glossiness: f32) -> vec3<f32> {\r\n\treturn specularColor + (max(vec3(glossiness), specularColor) - specularColor) * exp2(-OneOnLN2_x6 * dot);\r\n}\r\nfn fresnelSchlickWithRoughness(specularColor: vec3<f32>, L: vec3<f32>, N: vec3<f32>, gloss: f32) -> vec3<f32> {\r\n   return specularColor + (max(vec3(gloss), specularColor) - specularColor) * pow(1.0 - saturate(dot(L, N)), 5.0);\r\n}\r\n\r\nconst A = 2.51f;\r\nconst B = 0.03f;\r\nconst C = 2.43f;\r\nconst D = 0.59f;\r\nconst E = 0.14f;\r\nfn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32> {\r\n\r\n\tlet c = color * adapted_lum;\r\n\treturn (c * (A * c + B)) / (c * (C * c + D) + E);\r\n}\r\n\r\n//color = color / (color + vec3(1.0));\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn reinhard_extended(v: vec3<f32>, max_white: f32) -> vec3<f32> {\r\n    let numerator = v * (1.0f + (v / vec3(max_white * max_white)));\r\n    return numerator / (1.0f + v);\r\n}\r\nfn luminance(v: vec3<f32>) -> f32 {\r\n    return dot(v, vec3<f32>(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn change_luminance(c_in: vec3<f32>, l_out: f32) -> vec3<f32> {\r\n    let l_in = luminance(c_in);\r\n    return c_in * (l_out / l_in);\r\n}\r\nfn reinhard_extended_luminance(v: vec3<f32>, max_white_l: f32) -> vec3<f32> {\r\n    let l_old = luminance(v);\r\n    let numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\r\n    let l_new = numerator / (1.0f + l_old);\r\n    return change_luminance(v, l_new);\r\n}\r\nfn ReinhardToneMapping( color: vec3<f32>, toneMappingExposure: f32 ) -> vec3<f32> {\r\n\r\n\tlet c = color * toneMappingExposure;\r\n\treturn saturate( c / ( vec3( 1.0 ) + c ) );\r\n\r\n}\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nconst highp_a = 12.9898;\r\nconst highp_b = 78.233;\r\nconst highp_c = 43758.5453;\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n\tlet dt = dot( uv.xy, vec2<f32>( highp_a, highp_b ) );\r\n\tlet sn = modf( dt / PI ).fract;\r\n\treturn fract(sin(sn) * highp_c);\r\n}\r\n// // based on https://www.shadertoy.com/view/MslGR8\r\nfn dithering( color: vec3<f32>, fragCoord: vec2<f32> ) -> vec3<f32> {\r\n    //Calculate grid position\r\n    let grid_position = rand( fragCoord );\r\n\r\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n    var dither_shift_RGB = vec3<f32>( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n    //modify shift acording to grid position.\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n    //shift the color by dither_shift\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nconst dis = 1500.0;\r\nconst disY = 600.0;\r\nconst lightPositions = array<vec3<f32>, 4>(\r\n\tvec3<f32>(-dis, disY, dis),\r\n\tvec3<f32>(dis, disY, dis),\r\n\tvec3<f32>(-dis, disY, -dis),\r\n\tvec3<f32>(dis, disY, -dis)\r\n);\r\nconst colorValue = 700.0;\r\nconst lightColors = array<vec3<f32>, 4>(\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n);\r\n\r\nfn calcPBRColor3(Normal: vec3<f32>, WorldPos: vec3<f32>, camPos: vec3<f32>) -> vec3<f32> {\r\n\r\n\tvar color = vec3<f32>(0.0);\r\n\r\n    var ao = arm.x;\r\n    var roughness = arm.y;\r\n    var metallic = arm.z;\r\n\r\n\tvar N = normalize(Normal);\r\n    var V = normalize(camPos.xyz - WorldPos);\r\n    var dotNV = clamp(dot(N, V), 0.0, 1.0);\r\n\r\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\r\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\r\n    var F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo.xyz, metallic);\r\n\r\n    // reflectance equation\r\n    var Lo = vec3(0.0);\r\n\r\n\tfor (var i: i32 = 0; i < 4; i++) {\r\n\t\t// calculate per-light radiance\r\n        let L = normalize(lightPositions[i].xyz - WorldPos);\r\n        let H = normalize(V + L);\r\n        let distance = length(lightPositions[i].xyz - WorldPos);\r\n\r\n        let attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0003 * distance * distance);\r\n        let radiance = lightColors[i].xyz * attenuation;\r\n\r\n        // Cook-Torrance BRDF\r\n        let NDF = DistributionGGX(N, H, roughness);\r\n        let G   = GeometrySmith(N, V, L, roughness);\r\n        //vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\r\n        let F    = fresnelSchlick3(F0,clamp(dot(H, V), 0.0, 1.0), 0.9);\r\n        //vec3 F    = fresnelSchlick3(F0,dotNV, 0.9);\r\n\r\n        let nominator    = NDF * G * F;\r\n        let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\r\n        let specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\r\n\r\n        // kS is equal to Fresnel\r\n        let kS = F;\r\n        // for energy conservation, the diffuse and specular light can't\r\n        // be above 1.0 (unless the surface emits light); to preserve this\r\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\r\n        var kD = vec3<f32>(1.0) - kS;\r\n        // multiply kD by the inverse metalness such that only non-metals\r\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\r\n        // have no diffuse light).\r\n        kD *= 1.0 - metallic;\r\n\r\n        // scale light by NdotL\r\n        let NdotL = max(dot(N, L), 0.0);\r\n\r\n        // add to outgoing radiance Lo\r\n        // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\r\n        Lo += (kD * albedo.xyz / PI + specular) * radiance * NdotL;\r\n\t}\r\n\t// ambient lighting (note that the next IBL tutorial will replace\r\n    // this ambient lighting with environment lighting).\r\n    let ambient = vec3<f32>(0.03) * albedo.xyz * ao;\r\n\r\n    color = ambient + Lo;\r\n    // HDR tonemapping\r\n    color = reinhard( color );\r\n    // gamma correct\r\n    color = pow(color, vec3<f32>(1.0/2.2));\r\n\treturn color;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>,\r\n  @location(3) camPos: vec3<f32>\r\n) -> @location(0) vec4<f32> {\r\n  var color4 = vec4(calcPBRColor3(normal, pos.xyz, camPos), 1.0);\r\n  return color4;\r\n}");

/***/ }),

/***/ "0d77":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("const PI = 3.141592653589793;\r\nconst PI2 = 6.283185307179586;\r\nconst PI_HALF = 1.5707963267948966;\r\nconst RECIPROCAL_PI = 0.3183098861837907;\r\nconst RECIPROCAL_PI2 = 0.15915494309189535;\r\nconst EPSILON = 1e-6;\r\n\r\nfn approximationSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(srgbColor, vec3<f32>(2.2));\r\n}\r\nfn approximationLinearToSRCB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfn accurateSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    let linearRGBLo = srgbColor / 12.92;\r\n    let linearRGBHi = pow((srgbColor + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n\tif( all( srgbColor <= vec3(0.04045) ) ) {\r\n\t\treturn linearRGBLo;\r\n\t}\r\n    return linearRGBHi;\r\n}\r\nfn accurateLinearToSRGB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    let srgbLo = linearColor * 12.92;\r\n    let srgbHi = (pow(abs(linearColor), vec3(1.0 / 2.4)) * 1.055) - 0.055;\r\n    if(all(linearColor <= vec3(0.0031308))) {\r\n\t\treturn srgbLo;\r\n\t}\r\n    return srgbHi;\r\n}\r\n\r\n// Trowbridge-Reitz(Generalized-Trowbridge-Reitz,GTR)\r\nfn DistributionGTR1(NdotH: f32, roughness: f32) -> f32 {\r\n    if (roughness >= 1.0) {\r\n\t\treturn 1.0/PI;\r\n\t}\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0)*NdotH*NdotH;\r\n    return (a2 - 1.0) / (PI * log(a2) *t);\r\n}\r\nfn DistributionGTR2(NdotH: f32, roughness: f32) -> f32 {\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\r\n    return a2 / (PI * t * t);\r\n}\r\n\r\n\r\nfn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {\r\n    let a = roughness*roughness;\r\n    let a2 = a*a;\r\n    let NdotH = max(dot(N, H), 0.0);\r\n    let NdotH2 = NdotH*NdotH;\r\n\r\n    let nom   = a2;\r\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n\r\n\r\nfn GeometryImplicit(NdotV: f32, NdotL: f32) -> f32 {\r\n    return NdotL * NdotV;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\r\n    let r = (roughness + 1.0);\r\n    let k = (r*r) / 8.0;\r\n\r\n    let nom   = NdotV;\r\n    let denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {\r\n    let NdotV = max(dot(N, V), 0.0);\r\n    let NdotL = max(dot(N, L), 0.0);\r\n    let ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    let ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// @param cosTheta is clamp(dot(H, V), 0.0, 1.0)\r\nfn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\r\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\r\n}\r\nfn fresnelSchlick2(specularColor: vec3<f32>, L: vec3<f32>, H: vec3<f32>) -> vec3<f32> {\r\n   return specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(L, H)), 5.0);\r\n}\r\n//fresnelSchlick2(specularColor, L, H) * ((SpecularPower + 2) / 8 ) * pow(saturate(dot(N, H)), SpecularPower) * dotNL;\r\n\r\nconst OneOnLN2_x6 = 8.656171;// == 1/ln(2) * 6 (6 is SpecularPower of 5 + 1)\r\n// dot -> dot(N,V) or\r\nfn fresnelSchlick3(specularColor: vec3<f32>, dot: f32, glossiness: f32) -> vec3<f32> {\r\n\treturn specularColor + (max(vec3(glossiness), specularColor) - specularColor) * exp2(-OneOnLN2_x6 * dot);\r\n}\r\nfn fresnelSchlickWithRoughness(specularColor: vec3<f32>, L: vec3<f32>, N: vec3<f32>, gloss: f32) -> vec3<f32> {\r\n   return specularColor + (max(vec3(gloss), specularColor) - specularColor) * pow(1.0 - saturate(dot(L, N)), 5.0);\r\n}\r\n\r\nconst A = 2.51f;\r\nconst B = 0.03f;\r\nconst C = 2.43f;\r\nconst D = 0.59f;\r\nconst E = 0.14f;\r\nfn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32> {\r\n\r\n\tlet c = color * adapted_lum;\r\n\treturn (c * (A * c + B)) / (c * (C * c + D) + E);\r\n}\r\n\r\n//color = color / (color + vec3(1.0));\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn reinhard_extended(v: vec3<f32>, max_white: f32) -> vec3<f32> {\r\n    let numerator = v * (1.0f + (v / vec3(max_white * max_white)));\r\n    return numerator / (1.0f + v);\r\n}\r\nfn luminance(v: vec3<f32>) -> f32 {\r\n    return dot(v, vec3<f32>(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn change_luminance(c_in: vec3<f32>, l_out: f32) -> vec3<f32> {\r\n    let l_in = luminance(c_in);\r\n    return c_in * (l_out / l_in);\r\n}\r\nfn reinhard_extended_luminance(v: vec3<f32>, max_white_l: f32) -> vec3<f32> {\r\n    let l_old = luminance(v);\r\n    let numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\r\n    let l_new = numerator / (1.0f + l_old);\r\n    return change_luminance(v, l_new);\r\n}\r\nfn ReinhardToneMapping( color: vec3<f32>, toneMappingExposure: f32 ) -> vec3<f32> {\r\n\r\n\tlet c = color * toneMappingExposure;\r\n\treturn saturate( c / ( vec3( 1.0 ) + c ) );\r\n\r\n}\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nconst highp_a = 12.9898;\r\nconst highp_b = 78.233;\r\nconst highp_c = 43758.5453;\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n\tlet dt = dot( uv.xy, vec2<f32>( highp_a, highp_b ) );\r\n\tlet sn = modf( dt / PI ).fract;\r\n\treturn fract(sin(sn) * highp_c);\r\n}\r\n// // based on https://www.shadertoy.com/view/MslGR8\r\nfn dithering( color: vec3<f32>, fragCoord: vec2<f32> ) -> vec3<f32> {\r\n    //Calculate grid position\r\n    let grid_position = rand( fragCoord );\r\n\r\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n    var dither_shift_RGB = vec3<f32>( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n    //modify shift acording to grid position.\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n    //shift the color by dither_shift\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nconst dis = 700.0;\r\nconst disZ = 400.0;\r\nconst u_lightPositions = array<vec3<f32>, 4>(\r\n\tvec3<f32>(-dis, dis, disZ),\r\n\tvec3<f32>(dis, dis, disZ),\r\n\tvec3<f32>(-dis, -dis, disZ),\r\n\tvec3<f32>(dis, -dis, disZ)\r\n);\r\nconst colorValue = 300.0;\r\nconst u_lightColors = array<vec3<f32>, 4>(\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n);\r\n\r\nfn calcPBRColor3(Normal: vec3<f32>, WorldPos: vec3<f32>, camPos: vec3<f32>, albedo: vec3<f32>, param: vec3<f32>) -> vec3<f32> {\r\n\r\n\tvar color = vec3<f32>(0.0);\r\n\r\n    var ao = param.x;\r\n    var roughness = param.y;\r\n    var metallic = param.z;\r\n\r\n\tvar N = normalize(Normal);\r\n    var V = normalize(camPos.xyz - WorldPos);\r\n    var dotNV = clamp(dot(N, V), 0.0, 1.0);\r\n\r\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\r\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\r\n    var F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo.xyz, metallic);\r\n\r\n    // reflectance equation\r\n    var Lo = vec3(0.0);\r\n\r\n\tfor (var i: i32 = 0; i < 4; i++) {\r\n\t\t// calculate per-light radiance\r\n        let L = normalize(u_lightPositions[i].xyz - WorldPos);\r\n        let H = normalize(V + L);\r\n        let distance = length(u_lightPositions[i].xyz - WorldPos);\r\n\r\n        let attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0003 * distance * distance);\r\n        let radiance = u_lightColors[i].xyz * attenuation;\r\n\r\n        // Cook-Torrance BRDF\r\n        let NDF = DistributionGGX(N, H, roughness);\r\n        let G   = GeometrySmith(N, V, L, roughness);\r\n        //vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\r\n        let F    = fresnelSchlick3(F0,clamp(dot(H, V), 0.0, 1.0), 0.9);\r\n        //vec3 F    = fresnelSchlick3(F0,dotNV, 0.9);\r\n\r\n        let nominator    = NDF * G * F;\r\n        let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\r\n        let specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\r\n\r\n        // kS is equal to Fresnel\r\n        let kS = F;\r\n        // for energy conservation, the diffuse and specular light can't\r\n        // be above 1.0 (unless the surface emits light); to preserve this\r\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\r\n        var kD = vec3<f32>(1.0) - kS;\r\n        // multiply kD by the inverse metalness such that only non-metals\r\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\r\n        // have no diffuse light).\r\n        kD *= 1.0 - metallic;\r\n\r\n        // scale light by NdotL\r\n        let NdotL = max(dot(N, L), 0.0);\r\n\r\n        // add to outgoing radiance Lo\r\n        // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\r\n        Lo += (kD * albedo.xyz / PI + specular) * radiance * NdotL;\r\n\t}\r\n\t// ambient lighting (note that the next IBL tutorial will replace\r\n    // this ambient lighting with environment lighting).\r\n    let ambient = vec3<f32>(0.03) * albedo.xyz * ao;\r\n\r\n    color = ambient + Lo;\r\n    // HDR tonemapping\r\n    color = reinhard( color );\r\n    // gamma correct\r\n    color = pow(color, vec3<f32>(1.0/2.2));\r\n\treturn color;\r\n}\r\n\r\n@fragment\r\nfn fragMain(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>,\r\n  @location(3) camPos: vec3<f32>,\r\n  @location(4) albedo: vec3<f32>,\r\n  @location(5) param: vec3<f32>,\r\n) -> @location(0) vec4<f32> {\r\n  let color3 = calcPBRColor3(normal, pos.xyz, camPos, albedo, param);\r\n  var color4 = vec4(color3, 1.0);\r\n  return color4;\r\n}\r\n");

/***/ }),

/***/ "0db1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var colorSampler0: sampler;\r\n@group(0) @binding(2) var colorTexture0: texture_2d<f32>;\r\n@group(0) @binding(3) var blurSampler1: sampler;\r\n@group(0) @binding(4) var blurTexture1: texture_2d<f32>;\r\n@group(0) @binding(5) var vposSampler1: sampler;\r\n@group(0) @binding(6) var vposTexture1: texture_2d<f32>;\r\n\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n\r\n    var color = textureSample(colorTexture0, colorSampler0, uv) * param;\r\n    var blurColor = textureSample(blurTexture1, blurSampler1, uv);\r\n    var vpos = textureSample(vposTexture1, vposSampler1, uv);\r\n\tvar f = clamp((length(vpos.xyz) - 300.0)/200.0, 0.0, 1.0);\r\n\tf = 1.0 - f * f;\r\n\t// f = f * f;\r\n\tvar result = vec4f(color.xyz * (1.0 - f) + f * blurColor.xyz, 1.0);\r\n\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "0dcf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>,\r\n  @location(3) camPos : vec3<f32>\r\n}\r\n\r\nfn m44ToM33(m: mat4x4<f32>) -> mat3x3<f32> {\r\n\treturn mat3x3(m[0].xyz, m[1].xyz, m[2].xyz);\r\n}\r\nfn inverseM33(m: mat3x3<f32>)-> mat3x3<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2];\r\n    let b01 = a22 * a11 - a12 * a21;\r\n    let b11 = -a22 * a10 + a12 * a20;\r\n    let b21 = a21 * a10 - a11 * a20;\r\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3x3<f32>(\r\n\t\tvec3<f32>(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11)) / det,\r\n                vec3<f32>(b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det,\r\n                vec3<f32>(b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det);\r\n}\r\nfn inverseM44(m: mat4x4<f32>)-> mat4x4<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\r\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\r\n    let b00 = a00 * a11 - a01 * a10;\r\n    let b01 = a00 * a12 - a02 * a10;\r\n    let b02 = a00 * a13 - a03 * a10;\r\n    let b03 = a01 * a12 - a02 * a11;\r\n    let b04 = a01 * a13 - a03 * a11;\r\n    let b05 = a02 * a13 - a03 * a12;\r\n    let b06 = a20 * a31 - a21 * a30;\r\n    let b07 = a20 * a32 - a22 * a30;\r\n    let b08 = a20 * a33 - a23 * a30;\r\n    let b09 = a21 * a32 - a22 * a31;\r\n    let b10 = a21 * a33 - a23 * a31;\r\n    let b11 = a22 * a33 - a23 * a32;\r\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\treturn mat4x4<f32>(\r\n\t\tvec4<f32>(a11 * b11 - a12 * b10 + a13 * b09,\r\n\t\ta02 * b10 - a01 * b11 - a03 * b09,\r\n\t\ta31 * b05 - a32 * b04 + a33 * b03,\r\n\t\ta22 * b04 - a21 * b05 - a23 * b03) / det,\r\n\t\t\tvec4<f32>(a12 * b08 - a10 * b11 - a13 * b07,\r\n\t\ta00 * b11 - a02 * b08 + a03 * b07,\r\n\t\ta32 * b02 - a30 * b05 - a33 * b01,\r\n\t\ta20 * b05 - a22 * b02 + a23 * b01) / det,\r\n\t\tvec4<f32>(a10 * b10 - a11 * b08 + a13 * b06,\r\n\t\ta01 * b08 - a00 * b10 - a03 * b06,\r\n\t\ta30 * b04 - a31 * b02 + a33 * b00,\r\n\t\ta21 * b02 - a20 * b04 - a23 * b00) / det,\r\n\t\tvec4<f32>(a11 * b07 - a10 * b09 - a12 * b06,\r\n\t\ta00 * b09 - a01 * b07 + a02 * b06,\r\n\t\ta31 * b01 - a30 * b03 - a32 * b00,\r\n\t\ta20 * b03 - a21 * b01 + a22 * b00) / det);\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>\r\n) -> VertexOutput {\r\n  let wpos = objMat * vec4(position.xyz, 1.0);\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * wpos;\r\n  output.uv = uv;\r\n\r\n  let invMat33 = inverseM33( m44ToM33( objMat ) );\r\n  output.normal = normalize( normal * invMat33 );\r\n  output.camPos = (inverseM44(viewMat) * vec4<f32>(0.0,0.0,0.0, 1.0)).xyz;\r\n  output.pos = wpos;\r\n  return output;\r\n}\r\n");

/***/ }),

/***/ "0f15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var mySampler: sampler;\r\n@group(0) @binding(4) var myTexture: texture_cube<f32>;\r\nconst hdrBrnDecodeVec4 = vec4f(255.0, 2.55, 0.0255, 0.000255);\r\nfn rgbaToHdrBrn(color: vec4f) -> f32 {\r\n    return dot(hdrBrnDecodeVec4, color);\r\n}\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  // Our camera and the skybox cube are both centered at (0, 0, 0)\r\n  // so we can use the cube geomtry position to get viewing vector to sample the cube texture.\r\n  // The magnitude of the vector doesn't matter.\r\n  var cubemapVec = fragPosition.xyz - vec3(0.5);\r\n//   var c4 = textureSample(myTexture, mySampler, cubemapVec);\r\n  var c4 = textureSampleLevel(myTexture, mySampler, cubemapVec, 2.0);\r\n  let v3 = vec3( rgbaToHdrBrn(c4) );\r\n  c4 = vec4(v3, 1.0);\r\n  return c4;\r\n//   return textureSample(myTexture, mySampler, cubemapVec);\r\n}\r\n");

/***/ }),

/***/ "0f9f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class SysEvtNode {
  constructor() {
    this.ls = [];
    this.funcs = [];
  }

  add(l, func) {
    let i = 0;
    let ls = this.ls;

    for (; i < this.ls.length; ++i) {
      if (l == ls[i]) {
        break;
      }
    }

    if (i >= this.ls.length) {
      ls.push(l);
      this.funcs.push(func);
    }
  }

  remove(l) {
    let ls = this.ls;

    for (let i = 0; i < this.ls.length; ++i) {
      if (l == ls[i]) {
        ls.splice(i, 1);
        this.funcs.splice(i, 1);
        break;
      }
    }
  }

  run(evt) {
    for (let i = 0; i < this.ls.length; ++i) {
      this.funcs[i](evt);
    }
  }

}

class SysEvtMana {
  constructor() {
    this.evts = null;
  }

  init() {
    if (this.evts == null) {
      this.evts = [];

      for (let i = 0; i < 2; ++i) {
        this.evts.push(new SysEvtNode()); // [new SysEvtNode(), new SysEvtNode()]
      }
    }

    var pdocument = null;
    var pwindow = null;

    if (document) {
      pdocument = document;
      pwindow = window;

      pdocument.onmouseup = evt => {
        this.evts[1].run(evt);
      };
    }

    if (pwindow) {
      pwindow.onresize = evt => {
        this.evts[0].run(evt);
      };
    }
  }

  addWindowResizeEvt(l, func) {
    this.evts[0].add(l, func);
  }

  removeWindowResizeEvt(l) {
    this.evts[0].remove(l);
  }

  addDocMouUpEvt(l, func) {
    this.evts[1].add(l, func);
  }

  removeDocMouUpEvt(l) {
    this.evts[1].remove(l);
  }

}

class ContextMouseEvtDispatcher {
  constructor() {
    this.m_singleDown = false;
    this.m_mouseX = 0;
    this.m_mouseY = 0;
    this.m_mouseClickTime = 0;
    this.sysEvt = null;
    this.dpr = 1.0;
    this.m_canvas = null;
    this.sysEvt = ContextMouseEvtDispatcher.s_sevt;
    this.sysEvt.init();
  }

  initMobile(canvas, div, stage) {
    var pdocument = null;

    try {
      if (document) {
        pdocument = document;
      }
    } catch (err) {
      console.log("ContextMouseEvtDispatcher::initMobile(), document is undefined.");
    }

    if (pdocument) {
      let selfT = this;
      div.addEventListener('touchstart', evt => {
        /*
        e.touches：当前位于屏幕上的所有手指的列表
        e.targetTouches：位于当前DOM元素上手指的列表
        e.changedTouches：涉及当前事件手指的列表
        */
        //获取手指的位置
        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (list.length < 2) {
          px = 0 | this.dpr * evt.targetTouches[0].pageX;
          py = 0 | this.dpr * evt.targetTouches[0].pageY;
          stage.mouseX = px;
          stage.mouseY = stage.stageHeight - py;
          stage.mouseViewX = px;
          stage.mouseViewY = py;
          this.m_singleDown = true;
          this.m_mouseX = stage.mouseX;
          this.m_mouseY = stage.mouseY;
          this.m_mouseClickTime = Date.now();
          stage.mouseDown(1);
        } else {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiDown(posArray);
          this.m_singleDown = false;
        }

        evt.preventDefault();
        evt.stopPropagation();
      }, false);
      div.addEventListener('touchend', evt => {
        //获取手指的位置
        this.m_singleDown = false;
        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (list.length < 1) {
          stage.mouseUp(1);
          this.m_mouseClickTime = Date.now() - this.m_mouseClickTime;

          if (Math.abs(this.m_mouseX - stage.mouseX) < 2 && Math.abs(this.m_mouseY - stage.mouseY) < 2 && this.m_mouseClickTime < 900) {
            this.m_mouseX = stage.mouseX;
            this.m_mouseY = stage.mouseY;
            stage.mouseClick();
          }
        } else {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiUp(posArray);
        }

        evt.preventDefault();
      }, false);
      div.addEventListener('touchcancel', e => {
        //获取手指的位置
        selfT.m_singleDown = false;
        let list = e.targetTouches;
        stage.mouseCancel();
        e.preventDefault();
      }, false);
      div.addEventListener('touchmove', evt => {
        evt.preventDefault(); //阻止屏幕滚动的默认行为

        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (this.m_singleDown) {
          px = 0 | this.dpr * list[0].pageX;
          py = 0 | this.dpr * list[0].pageY;
          stage.mouseViewX = px;
          stage.mouseViewY = py;
          stage.mouseX = px;
          stage.mouseY = stage.stageHeight - py;
          stage.mouseMove();
        }

        if (list.length > 1) {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiMove(posArray);
        } //DivLog.ShowLog("touchmove "+list.length+", px,py: "+(px|0)+","+(0|py));

      }, {
        passive: false
      }, false); // if (RendererDevice.IsIpadOS()) {
      //     let meta = document.createElement('meta');
      //     meta.name = "viewport";
      //     meta.content = "width=device-width,initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no";
      //     document.getElementsByTagName('head')[0].appendChild(meta);
      // }
    }
  }

  initialize(canvas, div, stage) {
    // let flag = RendererDevice.IsMobileWeb() || RendererDevice.IsIpadOS();
    let flag = false;

    if (flag) {
      this.initMobile(canvas, div, stage);
    } else {
      this.initPC(canvas, div, stage);
      this.initMobile(canvas, div, stage);
    }
  }

  initPC(canvas, div, stage) {
    var pdocument = null;

    if (this.m_canvas != null) {
      let pcanvas = this.m_canvas;
      pcanvas.onmousewheel = null;
      pcanvas.onmousedown = null;
      pcanvas.onmouseup = null;
      pcanvas.onmousemove = null;
      pcanvas.onclick = null;
      pcanvas.canvas = null;
    }

    try {
      if (document != undefined) {
        pdocument = document;
      }
    } catch (err) {
      console.log("ContextMouseEvtDispatcher::initPC(), document is undefined.");
    }

    if (pdocument != null) {
      this.m_canvas = canvas;

      if (canvas.onmousewheel == undefined && canvas.addEventListener != undefined) {
        //use firefox browser mousewheel evt
        let func = function (evt) {
          evt.wheelDeltaY = -evt.detail;
          stage.mouseWheel(evt);
        };

        canvas.addEventListener('DOMMouseScroll', func, false);
      }

      canvas.onmousewheel = evt => {
        evt.preventDefault();
        evt.stopPropagation();
        stage.mouseWheel(evt);
      };

      canvas.onmousedown = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        this.m_mouseX = stage.mouseX;
        this.m_mouseY = stage.mouseY;
        this.m_mouseClickTime = Date.now(); // console.log("ContextMouseEvtDispatcher::onmousedown(),evt.button: ", evt.button);

        if (evt.button == 0) {
          stage.mouseDown(1);
        } else if (evt.button == 1) {
          stage.mouseMiddleDown();
        } else if (evt.button == 2) {
          stage.mouseRightDown(1);
        }
      };

      canvas.onmouseup = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py; // console.log("ContextMouseEvtDispatcher::onmouseup(),evt.button: ", evt.button);

        if (evt.button == 0) {
          stage.mouseUp(1);
        } else if (evt.button == 1) {
          stage.mouseMiddleUp();
        } else if (evt.button == 2) {
          stage.mouseRightUp(1);
        }
      }; // document.onmouseup = (evt: any): void => {
      //     if (evt.button == 0) {
      //         stage.mouseWindowUp(1);
      //     }
      //     else if (evt.button == 1) {
      //         // stage.mouseMiddleUp();
      //     }
      //     else if (evt.button == 2) {
      //         stage.mouseWindowRightUp(1);
      //     }
      // }


      let docOnmouseup = evt => {
        if (evt.button == 0) {
          stage.mouseWindowUp(1);
        } else if (evt.button == 1) {// stage.mouseMiddleUp();
        } else if (evt.button == 2) {
          stage.mouseWindowRightUp(1);
        }
      };

      this.sysEvt.addDocMouUpEvt(this, docOnmouseup);

      canvas.onmousemove = evt => {
        // console.log("ContextMouseEvtDispatcher::onmouseMove"+evt.pageX+","+evt.pageY);
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        stage.mouseMove();
      };

      canvas.onclick = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        this.m_mouseClickTime = Date.now() - this.m_mouseClickTime;

        if (Math.abs(this.m_mouseX - stage.mouseX) < 2 && Math.abs(this.m_mouseY - stage.mouseY) < 2 && this.m_mouseClickTime < 900) {
          this.m_mouseX = stage.mouseX;
          this.m_mouseY = stage.mouseY; //console.log("ContextMouseEvtDispatcher::onclick()," + stage.mouseViewX + "," + stage.mouseViewY + ",evt.button: " + evt.button);

          if (evt.button == 0) {
            stage.mouseClick();
          } else if (evt.button == 2) {
            stage.mouseRightClick();
          }
        }
      };

      canvas.ondblclick = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py; // console.log("ContextMouseEvtDispatcher::ondoubleclick()," + stage.mouseViewX + "," + stage.mouseViewY + ",evt.button: " + evt.button);

        if (evt.button == 0) {
          stage.mouseDoubleClick();
        } else if (evt.button == 2) {// stage.mouseRightDoubleClick();
        }
      };
    }
  }

}

ContextMouseEvtDispatcher.s_sevt = new SysEvtMana();
exports.default = ContextMouseEvtDispatcher;

/***/ }),

/***/ "163b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CoSpaceAppData_1 = __webpack_require__("b876");

exports.CoGeomDataType = CoSpaceAppData_1.CoGeomDataType;
exports.CoDataFormat = CoSpaceAppData_1.CoDataFormat;

const CoDataModule_1 = __webpack_require__("5476");

class CoGeomModelLoader {
  constructor() {
    this.m_loadedCall = null;
    this.m_loadedAllCall = null;
    this.m_loadTotal = 0;
    this.m_loadedTotal = 0;
    this.verTool = null;
  }

  setListener(loadedCallback, loadedAllCallback) {
    this.m_loadedCall = loadedCallback;
    this.m_loadedAllCall = loadedAllCallback;
  }

  load(urls, typeNS = "") {
    CoGeomModelLoader.s_coapp.verTool = this.verTool;

    if (urls != null && urls.length > 0) {
      CoGeomModelLoader.s_coapp.initialize(null, true);
      let purls = urls.slice(0);
      CoGeomModelLoader.s_coapp.deferredInit(() => {
        for (let i = 0; i < purls.length; ++i) {
          this.loadModel(purls[i], typeNS);
        }
      });
    }
  }

  loadWithType(urls, types) {
    CoGeomModelLoader.s_coapp.verTool = this.verTool;

    if (urls != null && urls.length > 0) {
      CoGeomModelLoader.s_coapp.initialize(null, true);
      let purls = urls.slice(0);
      CoGeomModelLoader.s_coapp.deferredInit(() => {
        for (let i = 0; i < purls.length; ++i) {
          this.loadModel(purls[i], types[i]);
        }
      });
    }
  }

  reset() {
    this.m_loadedTotal = 0;
    this.m_loadTotal = 0;
  }

  loadModel(url, typeNS = "") {
    console.log("CoGeomModelLoader::loadModel(), url: ", url);
    let ns = typeNS;

    if (typeNS == "") {
      let k0 = url.lastIndexOf(".") + 1;
      let k1 = url.lastIndexOf("?");
      ns = k1 < 0 ? url.slice(k0) : url.slice(k0, k1);
    }

    ns = ns.toLocaleLowerCase();
    let type = CoSpaceAppData_1.CoDataFormat.Undefined;

    switch (ns) {
      case "obj":
        type = CoSpaceAppData_1.CoDataFormat.OBJ;
        break;

      case "fbx":
        type = CoSpaceAppData_1.CoDataFormat.FBX;
        break;

      case "drc":
        type = CoSpaceAppData_1.CoDataFormat.Draco;
        break;

      case "ctm":
        type = CoSpaceAppData_1.CoDataFormat.CTM;
        break;

      default:
        break;
    }

    if (type != CoSpaceAppData_1.CoDataFormat.Undefined) {
      this.loadGeomModel(url, type);
    } else {
      console.error("Can't support this model data format, url: ", url);
    }
  }

  loadGeomModel(url, format) {
    let ins = CoGeomModelLoader.s_coapp;

    if (ins != null) {
      let unit = ins.getCPUDataByUrlAndCallback(url, format, (unit, status) => {
        if (format != CoSpaceAppData_1.CoDataFormat.FBX) {
          this.loadedModels(unit.data.models, unit.data.transforms, format, unit.url);
          this.m_loadTotal++;
          this.loadedModelFromUnit(unit, status);
        }
      }, true);

      if (format == CoSpaceAppData_1.CoDataFormat.FBX) {
        unit.data.modelReceiver = (models, transforms, index, total) => {
          // console.log("Loaded a fbx model XXX: ", index, ",", total);
          if (index == 0) {
            this.m_loadTotal++;
          }

          this.loadedModels(models, transforms, format, unit.url);
          this.loadedModelFromUnit(unit, 0, index + 1 == total);
        };
      }
    }
  }

  loadedModels(models, transforms, format, url) {
    if (this.m_loadedCall != null) {
      this.m_loadedCall(models, transforms, format, url);
    }
  }

  loadedModelFromUnit(unit, status = 0, flag = true) {
    if (flag) this.m_loadedTotal++;

    if (this.m_loadedTotal >= this.m_loadTotal) {
      let total = this.m_loadedTotal;
      this.reset();
      this.m_loadedAllCall(total, unit.url);
    }
  }

  destroy() {
    this.m_loadedCall = null;
  }

}

CoGeomModelLoader.s_coapp = new CoDataModule_1.CoDataModule();
exports.CoGeomModelLoader = CoGeomModelLoader;

/***/ }),

/***/ "1934":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = textureSample(texture0, sampler0, uv) * color;\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "19e8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

const KeyboardEvent_1 = __importDefault(__webpack_require__("bcc5"));

const Keyboard_1 = __importDefault(__webpack_require__("3cf9"));

const StageBase_1 = __importDefault(__webpack_require__("e315"));

class Stage3D extends StageBase_1.default {
  constructor(rcuid, pdocument) {
    super(rcuid);
    this.m_resize_listener = []; // private m_resize_ers: any[] = [];

    this.m_enterFrame_listener = []; // private m_enterFrame_ers: any[] = [];

    this.m_keyEvt = new KeyboardEvent_1.default();
    this.m_keyDown_listener = []; // private m_keyDown_ers: any[] = [];

    this.m_keyUp_listener = []; // private m_keyUp_ers: any[] = [];

    this.m_enterFrameEvt = new EventBase_1.default();

    if (!Stage3D.s_document) {
      Stage3D.s_document = pdocument;

      pdocument.onkeydown = function (evt) {
        Keyboard_1.default.KeyDown(evt);
      };

      pdocument.onkeyup = function (evt) {
        Keyboard_1.default.KeyUp(evt);
      };
    }

    Keyboard_1.default.AddEventListener(KeyboardEvent_1.default.KEY_DOWN, this, this.keyDown);
    Keyboard_1.default.AddEventListener(KeyboardEvent_1.default.KEY_UP, this, this.keyUp);
  }

  enterFrame() {
    this.m_enterFrameEvt.type = EventBase_1.default.ENTER_FRAME;
    const ls = this.m_enterFrame_listener;
    let len = ls.length;

    for (var i = 0; i < len; ++i) {
      ls[i](this.m_enterFrameEvt);
    }
  }

  setViewPort(px, py, pw, ph) {
    this.m_autoSynViewAndStageSize = false;
    this.m_viewX = px;
    this.m_viewY = py;

    if (pw != this.m_viewW || ph != this.m_viewH) {
      this.m_viewW = pw;
      this.m_viewH = ph;
      this.updateViewUData();
    }
  }

  updateViewUData() {
    // this.uProbe.setVec4Data(2.0 / this.stageWidth, 2.0 / this.stageHeight, this.stageWidth, this.stageHeight);
    // this.uProbe.update();
    this.m_preStageWidth = this.m_viewW;
    this.m_preStageHeight = this.m_viewH;
  }

  update() {
    if (this.m_preStageWidth != this.stageWidth || this.m_preStageHeight != this.stageHeight) {
      if (this.m_autoSynViewAndStageSize) {
        this.m_viewW = this.stageWidth;
        this.m_viewH = this.stageHeight;
        this.updateViewUData();
      }

      this.m_stW = this.stageWidth;
      this.m_stH = this.stageHeight;
      this.stageHalfWidth = 0.5 * this.m_stW;
      this.stageHalfHeight = 0.5 * this.m_stH;
      this.m_baseEvt.target = this;
      this.m_baseEvt.type = EventBase_1.default.RESIZE;
      this.m_baseEvt.phase = 1;
      this.sendResizeEvt(this.m_baseEvt);
    } else {
      this.stageWidth = this.m_stW;
      this.stageHeight = this.m_stH;
      this.stageHalfWidth = 0.5 * this.m_stW;
      this.stageHalfHeight = 0.5 * this.m_stH;
    }
  }

  keyDown(evt) {
    this.m_keyEvt.phase = 1;
    this.m_keyEvt.type = KeyboardEvent_1.default.KEY_DOWN;
    this.m_keyEvt.altKey = evt.altKey;
    this.m_keyEvt.ctrlKey = evt.ctrlKey;
    this.m_keyEvt.shiftKey = evt.shiftKey;
    this.m_keyEvt.repeat = evt.repeat;
    this.m_keyEvt.key = evt.key;
    this.m_keyEvt.keyCode = evt.keyCode;
    this.m_keyEvt.location = evt.location;
    let len = this.m_keyDown_listener.length;

    for (var i = 0; i < len; ++i) {
      this.m_keyDown_listener[i](this.m_keyEvt);
    }
  }

  keyUp(evt) {
    this.m_keyEvt.phase = 1;
    this.m_keyEvt.type = KeyboardEvent_1.default.KEY_UP;
    this.m_keyEvt.altKey = evt.altKey;
    this.m_keyEvt.ctrlKey = evt.ctrlKey;
    this.m_keyEvt.shiftKey = evt.shiftKey;
    this.m_keyEvt.repeat = evt.repeat;
    this.m_keyEvt.key = evt.key;
    this.m_keyEvt.keyCode = evt.keyCode;
    this.m_keyEvt.location = evt.location;
    this.m_keyEvt.target = this;
    let len = this.m_keyUp_listener.length;

    for (var i = 0; i < len; ++i) {
      this.m_keyUp_listener[i](this.m_keyEvt);
    }
  }

  sendResizeEvt(evt) {
    let len = this.m_resize_listener.length; //console.log("Stage3D::sendResizeEvt(), m_resize_listener.length: ",this.m_resize_listener.length);

    for (var i = 0; i < len; ++i) {
      this.m_resize_listener[i](evt);
    }
  }

  addEventListener(type, func, captureEnabled = true, bubbleEnabled = true) {
    if (func) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          this.addTarget(this.m_resize_listener, func);
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.addTarget(this.m_enterFrame_listener, func);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          this.addTarget(this.m_keyDown_listener, func);
          break;

        case KeyboardEvent_1.default.KEY_UP:
          this.addTarget(this.m_keyUp_listener, func);
          break;

        default:
          this.m_dp.addEventListener(type, func, captureEnabled, bubbleEnabled);
          break;
      }
    }
  }

  removeEventListener(type, func) {
    if (func) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          this.removeTarget(this.m_resize_listener, func);
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.removeTarget(this.m_enterFrame_listener, func);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          this.removeTarget(this.m_keyDown_listener, func);
          break;

        case KeyboardEvent_1.default.KEY_UP:
          this.removeTarget(this.m_keyUp_listener, func);
          break;

        default:
          this.m_dp.removeEventListener(type, func);
          break;
      }
    }
  }

}

Stage3D.s_document = null;
exports.default = Stage3D;

/***/ }),

/***/ "19f9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGTextureWrapper_1 = __webpack_require__("58c4");

exports.WGTextureDataDescriptor = WGTextureWrapper_1.WGTextureDataDescriptor;

const WGMaterial_1 = __webpack_require__("943f");

class WGCompMaterial extends WGMaterial_1.WGMaterial {
  constructor(descriptor) {
    super(descriptor);

    if (descriptor) {
      const wts = descriptor.workcounts;

      if (wts) {
        this.setWorkcounts(wts[0], wts.length > 1 ? wts[1] : 0, wts.length > 2 ? wts[2] : 0);
      }
    }
  }
  /**
   * @param x workgroupCountX
   * @param y workgroupCountY
   * @param z workgroupCountZ
   */


  setWorkcounts(x, y, z) {
    if (!this.workcounts) {
      this.workcounts = new Uint16Array([1, 1, 0, 0]);
    }

    const ts = this.workcounts;
    ts[0] = x;
    ts[1] = y !== undefined ? y : 0;
    ts[2] = z !== undefined ? z : 0;
    return this;
  }

}

exports.WGCompMaterial = WGCompMaterial;

/***/ }),

/***/ "1a9d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var mySampler: sampler;\r\n@group(0) @binding(4) var myTexture: texture_cube<f32>;\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  // Our camera and the skybox cube are both centered at (0, 0, 0)\r\n  // so we can use the cube geomtry position to get viewing vector to sample the cube texture.\r\n  // The magnitude of the vector doesn't matter.\r\n  var cubemapVec = fragPosition.xyz - vec3(0.5);\r\n  return textureSample(myTexture, mySampler, cubemapVec);\r\n}\r\n");

/***/ }),

/***/ "1d61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CommonUtils_1 = __webpack_require__("fe0b");

class WGRPDepthStencilAttachment {
  constructor() {
    this.depthClearValue = 1.0;
    this.depthLoadOp = "clear";
    this.depthStoreOp = "store";
  }

  setParam(param) {
    if (param) {
      CommonUtils_1.copyFromObjectValueWithKey(param, this);
    }

    return this;
  }

}

exports.WGRPDepthStencilAttachment = WGRPDepthStencilAttachment;

/***/ }),

/***/ "1eb2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* unused harmony default export */ var _unused_webpack_default_export = (null);


/***/ }),

/***/ "1ee1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Line3DEntity_1 = __webpack_require__("648f");

const __v8List = [new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default()];

function createPosDataWith8Pos(vertices8) {
  const vps = __v8List;
  let len = vertices8.length < 8 ? vertices8.length : 8;

  for (let i = 0; i < len; ++i) {
    vps[i].setXYZ(0, 0, 0).setVector3(vertices8[i]);
  } // let posarr = [
  // 	// bottom frame
  // 	vps[0].x, vps[0].y, vps[0].z, vps[1].x, vps[1].y, vps[1].z,
  // 	vps[1].x, vps[1].y, vps[1].z, vps[2].x, vps[2].y, vps[2].z,
  // 	vps[2].x, vps[2].y, vps[2].z, vps[3].x, vps[3].y, vps[3].z,
  // 	vps[3].x, vps[3].y, vps[3].z, vps[0].x, vps[0].y, vps[0].z,
  // 	// wall frame
  // 	vps[0].x, vps[0].y, vps[0].z, vps[4].x, vps[4].y, vps[4].z,
  // 	vps[1].x, vps[1].y, vps[1].z, vps[5].x, vps[5].y, vps[5].z,
  // 	vps[2].x, vps[2].y, vps[2].z, vps[6].x, vps[6].y, vps[6].z,
  // 	vps[3].x, vps[3].y, vps[3].z, vps[7].x, vps[7].y, vps[7].z,
  // 	// top frame
  // 	vps[4].x, vps[4].y, vps[4].z, vps[5].x, vps[5].y, vps[5].z,
  // 	vps[5].x, vps[5].y, vps[5].z, vps[6].x, vps[6].y, vps[6].z,
  // 	vps[6].x, vps[6].y, vps[6].z, vps[7].x, vps[7].y, vps[7].z,
  // 	vps[7].x, vps[7].y, vps[7].z, vps[4].x, vps[4].y, vps[4].z
  // ];


  let linePositions = [vps[0], vps[1], vps[1], vps[2], vps[2], vps[3], vps[3], vps[0], vps[0], vps[4], vps[1], vps[5], vps[2], vps[6], vps[3], vps[7], vps[4], vps[5], vps[5], vps[6], vps[6], vps[7], vps[7], vps[4]];
  return linePositions;
}

function createPosList8WithOBB(obb, scale = 1.0) {
  // bottom frame plane wit "-y axes"
  let et = obb.extent.clone().scaleBy(scale);
  let cv = obb.center;
  let max_vx = obb.axes[0].clone().scaleBy(et.x);
  let max_vy = obb.axes[1].clone().scaleBy(et.y);
  let max_vz = obb.axes[2].clone().scaleBy(et.z);
  let min_vx = max_vx.clone().scaleBy(-1);
  let min_vy = max_vy.clone().scaleBy(-1);
  let min_vz = max_vz.clone().scaleBy(-1); // 与"y"轴垂直的center positon之上的面

  let v0 = max_vx.clone().addBy(max_vy).addBy(max_vz).addBy(cv); // max pos

  let v1 = max_vx.clone().addBy(max_vy).addBy(min_vz).addBy(cv);
  let v2 = min_vx.clone().addBy(max_vy).addBy(min_vz).addBy(cv);
  let v3 = min_vx.clone().addBy(max_vy).addBy(max_vz).addBy(cv); // 与"y"轴垂直的center positon之下的面

  let p0 = max_vx.clone().addBy(min_vy).addBy(max_vz).addBy(cv);
  let p1 = max_vx.clone().addBy(min_vy).addBy(min_vz).addBy(cv);
  let p2 = min_vx.clone().addBy(min_vy).addBy(min_vz).addBy(cv);
  let p3 = min_vx.clone().addBy(min_vy).addBy(max_vz).addBy(cv);
  let ls = [v0, v1, v2, v3, p0, p1, p2, p3];
  return ls;
}

function buildPosData(param) {
  if (param.obb) {
    let scale = param.obbFrameScale !== undefined ? param.obbFrameScale : 1;
    param.vertices8 = createPosList8WithOBB(param.obb, scale);
  }

  if (param.vertices8) {
    param.linePositions = createPosDataWith8Pos(param.vertices8);
    return;
  }

  let min = new Vector3_1.default();
  let max = new Vector3_1.default();
  let flag = true;

  if (param.bounds !== undefined) {
    const b = param.bounds;
    min.setVector3(b.min);
    max.setVector3(b.max);
    flag = false;
  }

  if (param.minPos !== undefined) {
    min.setVector3(param.minPos);
    flag = false;
  }

  if (param.maxPos !== undefined) {
    max.setVector3(param.maxPos);
    flag = false;
  }

  if (flag) {
    min.setXYZ(-50, -50, -50);
    max.setXYZ(50, 50, 50);
  }

  let linePositions = [new Vector3_1.default(min.x, min.y, min.z), new Vector3_1.default(min.x, min.y, max.z), new Vector3_1.default(min.x, min.y, min.z), new Vector3_1.default(max.x, min.y, min.z), new Vector3_1.default(min.x, min.y, max.z), new Vector3_1.default(max.x, min.y, max.z), new Vector3_1.default(max.x, min.y, min.z), new Vector3_1.default(max.x, min.y, max.z), // wall frame
  new Vector3_1.default(min.x, min.y, min.z), new Vector3_1.default(min.x, max.y, min.z), new Vector3_1.default(min.x, min.y, max.z), new Vector3_1.default(min.x, max.y, max.z), new Vector3_1.default(max.x, min.y, min.z), new Vector3_1.default(max.x, max.y, min.z), new Vector3_1.default(max.x, min.y, max.z), new Vector3_1.default(max.x, max.y, max.z), // top frame plane: +y
  new Vector3_1.default(min.x, max.y, min.z), new Vector3_1.default(min.x, max.y, max.z), new Vector3_1.default(min.x, max.y, min.z), new Vector3_1.default(max.x, max.y, min.z), new Vector3_1.default(min.x, max.y, max.z), new Vector3_1.default(max.x, max.y, max.z), new Vector3_1.default(max.x, max.y, min.z), new Vector3_1.default(max.x, max.y, max.z)];
  param.linePositions = linePositions;
}

function buildColorData(param) {
  let c = new Color4_1.default();
  let len = param.linePositions.length;
  param.lineColors = new Array(len);
  let cs = param.frameColors;
  let csLen = Math.min(Math.floor(len / 2), cs.length);

  for (let i = 0; i < csLen; ++i) {
    const k = i * 2;

    if (cs[i]) {
      param.lineColors[k] = cs[i];
      param.lineColors[k + 1] = cs[i];
    } else {
      param.lineColors[k] = c;
      param.lineColors[k + 1] = c;
    }
  }

  for (let i = csLen * 2; i < len; ++i) {
    param.lineColors[i] = c;
  }
}

class BoundsFrameEntity extends Line3DEntity_1.Line3DEntity {
  constructor(param) {
    if (!param) param = {};
    param.dashedData = true;

    if (!param.linePositions) {
      buildPosData(param);
    }

    if (!param.lineColors && param.frameColors) {
      buildColorData(param);
    }

    super(param);

    if (param.frameColor) {
      this.color = param.frameColor;
    }
  }

}

exports.BoundsFrameEntity = BoundsFrameEntity;

/***/ }),

/***/ "1eee":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Entity3D_1 = __webpack_require__("551f");

const WGMaterial_1 = __webpack_require__("943f");

const WGRUniformValue_1 = __webpack_require__("7650");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const primitive_vert_wgsl_1 = __importDefault(__webpack_require__("d9d5"));

const primitive_frag_wgsl_1 = __importDefault(__webpack_require__("0d53"));

const primitiveTex_frag_wgsl_1 = __importDefault(__webpack_require__("4ccd"));

const WGGeometry_1 = __webpack_require__("746a");

const Arms_1 = __importDefault(__webpack_require__("cc97"));

class PrimitiveEntity extends Entity3D_1.Entity3D {
  constructor(param) {
    super(param);
    this.mColor = new Color4_1.default();
    this.mArms = new Arms_1.default();
    if (!param) param = {};

    if (!(param.building === false)) {
      this.createGeometry(param);
      this.createMaterial(param);
    }

    this.mDescParam = param;
  }

  clone(param) {
    if (param) {
      if (!param.geometry) param.geometry = this.geometry;
    } else {
      param = this.mDescParam;
      param.materials = this.materials;
      param.geometry = this.geometry;
    }

    let p = new PrimitiveEntity(param);
    p.arm = this.arm;
    p.color = this.color;
    return p;
  }

  setColor(c) {
    return this.setAlbedo(c);
  }

  set color(c) {
    this.setColor(c);
  }

  get color() {
    return this.mColor;
  }

  setAlbedo(c) {
    // console.log("c: ", c);
    // console.log("this.albedoV: ", this.albedoV);
    if (this.albedoV) {
      if (c) {
        this.mColor.setColor(c).toArray4(this.albedoV.data); // console.log("this.mColor: ", this.mColor);

        this.albedoV.version++; // console.log("this.albedoV.data: ", this.albedoV.data);
      }
    }

    return this;
  }

  set albedo(c) {
    this.setAlbedo(c);
  }

  get albedo() {
    return this.mColor;
  }

  setARM(p) {
    this.arm = p;
    return this;
  }

  set arm(p) {
    const t = this.mArms;
    t.setArms(p);

    if (this.armV) {
      t.toArray3(this.armV.data);
      this.armV.version++;
    }
  }

  get arm() {
    return this.mArms;
  }

  getGeometryData(param) {
    return null;
  }

  createGeometry(param) {
    if (param && param.geometry) {
      this.geometry = param.geometry;
    } else {
      const geom = this.getGeometryData(param);

      if (geom) {
        const g = new WGGeometry_1.WGGeometry().addAttribute({
          position: geom.getVS()
        }).addAttribute({
          uv: geom.getUVS()
        }).addAttribute({
          normal: geom.getNVS()
        }).setIndices(geom.getIVS());
        g.bounds = geom.bounds;
        g.drawMode = geom.drawMode;
        g.geometryData = geom;
        this.geometry = g;
      }
    }
  }

  createMaterial(param) {
    if (!param) param = {};

    if (param.materials) {
      this.materials = param.materials;
    } else {
      const texs = param.textures;
      const texTotal = texs ? texs.length : 0;

      if (!param.uniformValues) {
        this.albedoV = Entity3D_1.getUniformValueFromParam("albedo", param, new WGRUniformValue_1.WGRUniformValue({
          data: new Float32Array([0.5, 0.5, 0.5, 1]),
          shdVarName: "albedo"
        }));
        this.armV = Entity3D_1.getUniformValueFromParam("arm", param, new WGRUniformValue_1.WGRUniformValue({
          data: new Float32Array([1, 0.1, 0.1, 1]),
          shdVarName: "arm"
        }));
      }

      let shdSrc = param.shaderSrc ? param.shaderSrc : {
        vertShaderSrc: {
          code: primitive_vert_wgsl_1.default,
          uuid: "primitiveVertShdCode"
        },
        fragShaderSrc: {
          code: texTotal > 0 ? primitiveTex_frag_wgsl_1.default : primitive_frag_wgsl_1.default,
          uuid: texTotal > 0 ? "primitiveTexFragShdCode" : "primitiveFragShdCode"
        }
      };
      let b = param.depthWriteEnabled;
      b = b === false ? false : true;
      let f = param.faceCullMode;
      f = f ? f : "back";
      let bl = param.blendModes;
      bl = bl ? bl : ["solid"];
      let pipelineDefParam = {
        depthWriteEnabled: b,
        faceCullMode: f,
        blendModes: bl
      };
      const material = new WGMaterial_1.WGMaterial({
        shadinguuid: param.shadinguuid !== undefined ? param.shadinguuid : "PrimitiveEntity-material-tex" + texTotal,
        shaderSrc: shdSrc,
        pipelineDefParam
      });
      material.addTextures(texs);

      if (param.instanceCount !== undefined) {
        material.instanceCount = param.instanceCount;
      }

      material.uniformValues = param.uniformValues;

      if (!material.uniformValues) {
        material.uniformValues = [this.albedoV, this.armV];
        this.albedoV = material.uniformValues[0];
        this.armV = material.uniformValues[1];
      }

      this.materials = [material];
    }

    const ms = this.materials;

    if (param.doubleFace !== undefined) {
      let flag = param.doubleFace === true;

      for (let i = 0; i < ms.length; ++i) {
        if (ms[i].doubleFace === undefined && flag) {
          ms[i].doubleFace = flag;
          ms[i].shadinguuid += '-dface';
        }
      }
    }

    if (param.wireframe !== undefined) {
      let flag = param.wireframe === true;

      for (let i = 0; i < ms.length; ++i) {
        if (ms[i].wireframe === undefined && flag) {
          ms[i].wireframe = flag;
          ms[i].shadinguuid += '-wframe';
        }
      }
    } // console.log("param: ", param);
    // console.log("param.albedo: ", param.albedo);


    if (param.albedo) {
      this.albedo = param.albedo;
    }

    if (param.arm) {
      this.arm = param.arm;
    }

    WGMaterial_1.checkMaterialRPasses(this.materials, param.rpasses);
  }

  destroy() {
    this.albedoV = null;
    this.armV = null;
    super.destroy();
  }

}

exports.PrimitiveEntity = PrimitiveEntity;

/***/ }),

/***/ "20e0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Line3DEntity_1 = __webpack_require__("648f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class LineEntityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("LineEntityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rsc = this.mRscene;
    let linePositions = [new Vector3_1.default(), new Vector3_1.default(-100), new Vector3_1.default(-150, -180), new Vector3_1.default(-150, -180, -100)];
    let line = new Line3DEntity_1.Line3DEntity({
      linePositions
    });
    line.setColor([1.0, 0.0, 0.0]);
    rsc.addEntity(line);
    linePositions = [new Vector3_1.default(), new Vector3_1.default(100), new Vector3_1.default(150, 180), new Vector3_1.default(150, 180, 100)];
    let lineColors = [new Color4_1.default(1.0), new Color4_1.default(0.0, 1.0), new Color4_1.default(0.0, 0.0, 1.0), new Color4_1.default(1.0, 0.0, 1.0)];
    let colorLine = new Line3DEntity_1.Line3DEntity({
      linePositions,
      lineColors
    });
    rsc.addEntity(colorLine);
  }

  run() {
    this.mRscene.run();
  }

}

exports.LineEntityTest = LineEntityTest;

/***/ }),

/***/ "213f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseCamDrager_1 = __importDefault(__webpack_require__("949a"));

const MouseCamZoomer_1 = __importDefault(__webpack_require__("9b05"));

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

class MouseInteraction {
  constructor() {
    this.m_rscene = null;
    this.m_autoRun = false;
    this.m_axisType = 0;
    this.drager = new MouseCamDrager_1.default();
    this.zoomer = new MouseCamZoomer_1.default();
    this.zoomMinDistance = 30;
    /**
     * 是否启用摄像机用户控制
     */

    this.cameraCtrlEnabled = true;
  }
  /**
   * @param rscene renderer scene instance
   * @param buttonType the default value is 0, the value contains 0(mouse left button), 1(mouse middle button), 2(mouse right button)
   * @param bgEventEnabled apply background mouse event true or false, the default value is true
   */


  initialize(rscene, buttonType = 0, bgEventEnabled = true, autoRunning = false) {
    if (this.m_rscene == null) {
      this.m_rscene = rscene;
      rscene.enableMouseEvent(true);
      const d = this.drager;
      const z = this.zoomer;
      d.buttonType = buttonType;
      d.bgEventEnabled = bgEventEnabled;
      d.initialize(rscene.getStage3D(), rscene.getCamera());
      z.bindCamera(rscene.getCamera());
      z.initialize(rscene.getStage3D());
      z.setLookAtCtrlEnabled(false);
    }

    this.setAutoRunning(autoRunning);
    return this;
  }

  enableSwing() {
    this.drager.enableSwing();
  }

  isEnabledSwing() {
    return this.isEnabledSwing();
  }

  enableSlide() {
    this.drager.enableSlide();
  }

  setSyncLookAtEnabled(ennabled) {
    this.zoomer.syncLookAt = ennabled;
    return this;
  }

  setLookAtPosition(v) {
    this.zoomer.setLookAtPosition(v);
    return this;
  }
  /**
   * @param enabled enable auto runnning or not
   * @param axisType 0 is y-axis, 1 is z-axis
   */


  setAutoRunning(enabled, axisType = 0) {
    this.m_axisType = axisType;
    this.m_autoRun = enabled;
    const type = EventBase_1.default.ENTER_FRAME;

    if (enabled) {
      this.setSyncLookAtEnabled(true);
      this.m_rscene.addEventListener(type, this.autoRun.bind(this));
    } else {
      this.m_rscene.removeEventListener(type, this.autoRun.bind(this));
    }

    return this;
  }

  autoRun(evt) {
    if (this.cameraCtrlEnabled) {
      this.zoomer.setLookAtPosition(null);
      this.zoomer.run(this.zoomMinDistance);

      switch (this.m_axisType) {
        case 0:
          this.drager.runWithYAxis();
          break;

        case 1:
          this.drager.runWithZAxis();
          break;

        default:
          this.drager.runWithYAxis();
          break;
      }
    }
  }

  run() {
    if (this.cameraCtrlEnabled && !this.m_autoRun) {
      this.zoomer.run(this.zoomMinDistance);
      this.drager.runWithYAxis();
    }
  }

  destroy() {
    if (this.m_rscene != null) {
      this.setAutoRunning(false);
      this.m_rscene = null;
    }
  }

}

exports.MouseInteraction = MouseInteraction;

/***/ }),

/***/ "222c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const BitConst_1 = __importDefault(__webpack_require__("626c"));

class WGRUnitState {
  constructor() {
    this.flag = 0;
    this.rf = 0;
    this.__$rever = 0;
  }

  set __$rendering(v) {
    if (v) {
      this.rf = BitConst_1.default.addBit(this.rf, BitConst_1.default.ONE_0);
    } else {
      this.rf = BitConst_1.default.removeBit(this.rf, BitConst_1.default.ONE_0);
    }
  }

  get __$rendering() {
    return BitConst_1.default.containsBit(this.rf, BitConst_1.default.ONE_0);
  }

  set __$inRenderer(v) {
    if (v) {
      this.rf = BitConst_1.default.addBit(this.rf, BitConst_1.default.ONE_1);
    } else {
      this.rf = BitConst_1.default.removeBit(this.rf, BitConst_1.default.ONE_1);
    } // if(!v) {
    // 	console.log("inRenderer CCCC 0 VVVVVVVV false");
    // }
    // console.log("inRenderer CCCC 0 v: ",v,", this.rf: ", this.rf,);
    // console.log("CCCC 0 Bit.containsBit(this.rf, Bit.ONE_1): ", Bit.containsBit(this.rf, Bit.ONE_1));

  }

  get __$inRenderer() {
    // console.log("inRenderer CCCC 1 this.rf: ", this.rf);
    // console.log("CCCC 1 Bit.containsBit(this.rf, Bit.ONE_1): ", Bit.containsBit(this.rf, Bit.ONE_1));
    return BitConst_1.default.containsBit(this.rf, BitConst_1.default.ONE_1);
  }

  isDrawable() {
    return this.flag < 1;
  }

  set renderable(v) {
    if (v) {
      this.flag = BitConst_1.default.removeBit(this.flag, BitConst_1.default.ONE_2);
    } else {
      this.flag = BitConst_1.default.addBit(this.flag, BitConst_1.default.ONE_2);
    }
  }

  get renderable() {
    return !BitConst_1.default.containsBit(this.flag, BitConst_1.default.ONE_2);
  }

  set camVisible(v) {
    if (v) {
      this.flag = BitConst_1.default.removeBit(this.flag, BitConst_1.default.ONE_1);
    } else {
      this.flag = BitConst_1.default.addBit(this.flag, BitConst_1.default.ONE_1);
    }
  }

  get camVisible() {
    return !BitConst_1.default.containsBit(this.flag, BitConst_1.default.ONE_1);
  }

  set visible(v) {
    if (v) {
      this.flag = BitConst_1.default.removeBit(this.flag, BitConst_1.default.ONE_0);
    } else {
      this.flag = BitConst_1.default.addBit(this.flag, BitConst_1.default.ONE_0);
    }
  }

  get visible() {
    return !BitConst_1.default.containsBit(this.flag, BitConst_1.default.ONE_0);
  }

}

exports.WGRUnitState = WGRUnitState;

/***/ }),

/***/ "2258":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * render pass reference
 */

class WGRPassWrapper {
  get rcommands() {
    if (this.node) {
      return this.node.rcommands;
    }

    return undefined;
  }

  get colorAttachments() {
    if (this.node) {
      return this.node.colorAttachments;
    }

    return undefined;
  }

  addEntity(entity) {
    if (this.node) {
      this.node.addEntity(entity);
    }

    return this;
  }

  setColorAttachmentClearEnabledAt(enabled, index = 0) {
    if (this.node) {
      this.node.setColorAttachmentClearEnabledAt(enabled, index);
    }

    return this;
  }

  render() {
    if (this.node) {
      this.node.render();
      const cmd = this.cmdWrapper;

      if (cmd) {
        //this.rcommands.concat(pass.rcommands);
        cmd.rcommands = cmd.rcommands.concat(this.node.rcommands);
      }
    }
  }

}

exports.WGRPassWrapper = WGRPassWrapper;

/***/ }),

/***/ "245e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const SphereEntity_1 = __webpack_require__("9849");

const BoxEntity_1 = __webpack_require__("5009");

const CylinderEntity_1 = __webpack_require__("76e3");

const CubeEntity_1 = __webpack_require__("0069");

const TorusEntity_1 = __webpack_require__("5118");

const PlaneEntity_1 = __webpack_require__("7e70");

const ConeEntity_1 = __webpack_require__("97f2");

const AxisEntity_1 = __webpack_require__("603e");

class PrimitiveEntityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("PrimitiveEntityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    let axis = new AxisEntity_1.AxisEntity();
    rc.addEntity(axis);
    let entities = [new SphereEntity_1.SphereEntity(), new BoxEntity_1.BoxEntity(), new CylinderEntity_1.CylinderEntity({
      alignYRatio: 0.0
    }), new CubeEntity_1.CubeEntity({
      cubeSize: 130
    }), new TorusEntity_1.TorusEntity({
      radius: 110,
      axisType: 1
    }), new PlaneEntity_1.PlaneEntity({
      axisType: 1,
      extent: [-80, -80, 160, 160],
      doubleFace: true
    }), new ConeEntity_1.ConeEntity({
      alignYRatio: 0.0
    })];
    let ls = entities;
    entities = [];

    for (let i = 0, ln = ls.length; i < ln; ++i) {
      const k = Math.round(Math.random() * 888) % ls.length;
      const t = ls[k];
      entities.push(ls[k]);
      ls.splice(k, 1);
    }

    let radius = 350.0;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length;
      let entity = entities[i].setAlbedo(new Color4_1.default().randomRGB(1.5, 0.1)).setARM([1.1, Math.random() * 0.95 + 0.05, Math.random() * 0.9 + 0.1]);
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]);
      rc.addEntity(entity);
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.PrimitiveEntityTest = PrimitiveEntityTest;

/***/ }),

/***/ "24fe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

function initializeCamera(param, cam) {
  let p = param;
  if (!p) p = {};
  let eye = p.eye ? new Vector3_1.default().toZero().setVector3(p.eye) : new Vector3_1.default(1100.0, 1100.0, 1100.0);
  let up = p.up ? new Vector3_1.default().toZero().setVector3(p.up) : new Vector3_1.default(0, 1, 0);
  let origin = p.origin ? new Vector3_1.default().toZero().setVector3(p.origin) : new Vector3_1.default();
  if (p.fovDegree === undefined) p.fovDegree = 45;
  if (p.near === undefined) p.near = 0.1;
  if (p.far === undefined) p.far = 8000;
  if (p.viewWidth === undefined) p.viewWidth = 512;
  if (p.viewHeight === undefined) p.viewHeight = 512;
  if (p.viewX === undefined) p.viewX = 0;
  if (p.viewY === undefined) p.viewY = 0;
  p.perspective = p.perspective === false || Number(p.perspective) === 0 ? false : true;
  const width = p.viewWidth;
  const height = p.viewHeight;

  if (p.perspective) {
    cam.perspectiveRH(Math.PI * p.fovDegree / 180.0, width / height, p.near, p.far);
  } else {
    cam.inversePerspectiveZ = true;
    cam.orthoRH(p.near, p.far, -0.5 * height, 0.5 * height, -0.5 * width, 0.5 * width);
  }

  cam.lookAtRH(eye, origin, up);
  cam.setViewXY(p.viewX, p.viewY);
  cam.setViewSize(width, height);
  cam.update();
  return cam;
}

exports.initializeCamera = initializeCamera;

/***/ }),

/***/ "25ba":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> param: vec4f;\r\n@group(0) @binding(4) var mySampler0: sampler;\r\n@group(0) @binding(5) var myTexture0: texture_2d<f32>;\r\n@group(0) @binding(6) var mySampler1: sampler;\r\n@group(0) @binding(7) var myTexture1: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n    @location(0) fragUV: vec2<f32>,\r\n    @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n    var color0: vec4<f32>;\r\n    var color1: vec4<f32>;\r\n    color0 = textureSample(myTexture0, mySampler0, fragUV) * fragPosition;\r\n    color1 = textureSample(myTexture1, mySampler1, fragUV) * fragPosition;\r\n    return color0 * (vec4<f32>(1.0) - param) + color1 * param;\r\n}\r\n");

/***/ }),

/***/ "27e9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Entity3DContainer_1 = __webpack_require__("a3fd");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class REntity3DContainerTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {
      console.log("mousedown evt call ...");
    };

    this.mContainers = [];
    this.mRotValue = 0.0;
  }

  initialize() {
    console.log("REntity3DContainerTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texDatas, color, blendModes = ["solid"], faceCullMode = "back") {
    color = color ? color : new Color4_1.default();
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    }); // let ufv = new WGRStorageValue({data: new Float32Array([color.r, color.g, color.b, 1])});

    let ufv = {
      storage: {
        data: new Float32Array([color.r, color.g, color.b, 1])
      }
    };
    material.uniformValues = [ufv];
    material.addTextures(texDatas);
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  createCircle(radius, total, scale, materials, geometry, pv) {
    const rc = this.mRscene;
    pv = pv ? pv : new Vector3_1.default();
    let mContainer = new Entity3DContainer_1.Entity3DContainer();
    mContainer.setPosition(pv);

    for (let i = 0; i < total; ++i) {
      const factor = i / total;
      const rad = Math.PI * 2.0 * factor;
      const px = radius * Math.cos(rad);
      const py = radius * Math.sin(rad);
      let entity = new Entity3D_1.Entity3D();
      entity.materials = materials;
      entity.geometry = geometry;
      entity.transform.setXYZ(px, py, 0);
      entity.transform.setRotationZ(factor * 360.0);
      entity.transform.setScaleAll(scale);
      mContainer.addChild(entity);
    }

    return mContainer;
  }

  initScene() {
    const rc = this.mRscene;
    const geometry = this.createGeom(this.geomData.createCube(80));
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const diffuseMap = {
      diffuse: {
        url: "static/assets/box.jpg"
      }
    };
    let materials0 = [this.createMaterial(shdSrc, [diffuseMap], new Color4_1.default(1.0, 0.0, 0.0))];
    let materials1 = [this.createMaterial(shdSrc, [diffuseMap], new Color4_1.default(0.0, 1.0, 0.0))];
    let materials2 = [this.createMaterial(shdSrc, [diffuseMap], new Color4_1.default(1.0, 0.0, 1.0))];
    const container0 = this.createCircle(100, 10, 0.5, materials0, geometry);
    const container1 = this.createCircle(180, 15, 0.5, materials1, geometry);
    const container2 = this.createCircle(260, 25, 0.5, materials2, geometry);
    let container = new Entity3DContainer_1.Entity3DContainer();
    container.addChild(container0);
    container.addChild(container1);
    container.addChild(container2);
    rc.addEntity(container);
    this.mContainers.push(container0, container1, container2, container);
  }

  run() {
    this.mRotValue += 0.5;
    const ls = this.mContainers;
    ls[0].setRotationZ(this.mRotValue * 1.2);
    ls[1].setRotationZ(this.mRotValue * 0.4 + 15.0);
    ls[2].setRotationZ(this.mRotValue * 0.2 + 30.0);
    ls[3].setRotationY(this.mRotValue * 0.2);
    ls[3].update();
    this.mRscene.run();
  }

}

exports.REntity3DContainerTest = REntity3DContainerTest;

/***/ }),

/***/ "2b0e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GPUMipmapGenerator_1 = __webpack_require__("b3f5");

const CommonUtils_1 = __webpack_require__("fe0b");

const Conversion_1 = __webpack_require__("37f2");

class WebGPUTextureContext {
  constructor(wgCtx) {
    this.mipmapGenerator = new GPUMipmapGenerator_1.GPUMipmapGenerator();

    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  initialize(wgCtx) {
    if (!this.mWGCtx && wgCtx) {
      this.mWGCtx = wgCtx;
      this.mipmapGenerator.initialize(wgCtx.device);
    }
  }

  createFloatRTTTexture(descriptor) {
    if (!descriptor) descriptor = {};

    if (!descriptor.format) {
      descriptor.format = "rgba16float";
    }

    return this.createRTTTexture(descriptor);
  }

  createColorRTTTexture(descriptor) {
    if (!descriptor) descriptor = {};

    if (!descriptor.format) {
      descriptor.format = "bgra8unorm";
    }

    return this.createRTTTexture(descriptor);
  }

  createDepthRTTTexture(descriptor) {
    if (!descriptor) descriptor = {};

    if (!descriptor.format) {
      descriptor.format = "depth24plus";
    }

    return this.createRTTTexture(descriptor);
  }

  createRTTTexture(descriptor) {
    if (!descriptor) descriptor = {};
    const ctx = this.mWGCtx;

    if (descriptor.size === undefined) {
      descriptor.size = [ctx.canvasWidth, ctx.canvasHeight];
    }

    if (!descriptor.format) {
      descriptor.format = ctx.presentationFormat;
    }

    if (descriptor.usage === undefined) {
      descriptor.usage = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING;
    }

    return this.createTexture(descriptor);
  }

  async createTex2DByUrl(url, generateMipmaps = true, flipY = false, format = "rgba8unorm") {
    const response = await fetch(url);
    let imageBitmap;

    try {
      imageBitmap = await createImageBitmap(await response.blob());
    } catch (e) {
      console.error("createMaterialTexture(), error url: ", url);
      return null;
    }

    const tex = this.createTex2DByImage(imageBitmap, generateMipmaps, flipY, format, url);
    tex.url = url;
    return tex;
  }

  createTexture(descriptor) {
    const device = this.mWGCtx.device;
    let tex = device.createTexture(descriptor);
    tex.uid = WebGPUTextureContext.sUid++;
    return tex;
  }

  checkTexDesc(descriptor, generateMipmaps) {
    if (descriptor.usage === undefined) descriptor.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    if (descriptor.mipLevelCount < 1) descriptor.mipLevelCount = 1;
    generateMipmaps = generateMipmaps && descriptor.mipLevelCount > 1;

    if (generateMipmaps) {
      descriptor.usage = descriptor.usage | GPUTextureUsage.RENDER_ATTACHMENT;
    }

    return generateMipmaps;
  }

  createTex2DByImage(image, generateMipmaps = true, flipY = false, format = "rgba8unorm", label) {
    const device = this.mWGCtx.device;
    const mipmapG = this.mipmapGenerator;
    let mipLevelCount = generateMipmaps ? GPUMipmapGenerator_1.calculateMipLevels(image.width, image.height) : 1;
    const descriptor = {
      dimension: "2d",
      size: {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      },
      format,
      mipLevelCount
    };
    generateMipmaps = this.checkTexDesc(descriptor, generateMipmaps);
    let tex = this.createTexture(descriptor);
    device.queue.copyExternalImageToTexture({
      source: image,
      flipY
    }, {
      texture: tex
    }, [image.width, image.height]);

    if (generateMipmaps) {
      tex = mipmapG.generateMipmap(tex, descriptor);
    }

    return tex;
  }

  async createTexCubeByUrls(urls, generateMipmaps = true, flipY = false, format = "rgba8unorm") {
    const promises = urls.map(async src => {
      const response = await fetch(src);
      return createImageBitmap(await response.blob());
    });
    const images = await Promise.all(promises);
    const tex = this.createTexCubeByImages(images, generateMipmaps, flipY, format = "rgba8unorm");
    tex.url = urls[0];
    return tex;
  }

  createTexCubeByImages(images, generateMipmaps = true, flipY = false, format = "rgba8unorm", label) {
    let image = images[0];
    const queue = this.mWGCtx.queue;
    let mipLevelCount = generateMipmaps ? GPUMipmapGenerator_1.calculateMipLevels(image.width, image.height) : 1;
    const descriptor = {
      dimension: "2d",
      size: {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 6
      },
      format,
      mipLevelCount
    };
    generateMipmaps = this.checkTexDesc(descriptor, generateMipmaps);
    console.log("createTexCubeByImages(), descriptor: ", descriptor);
    let tex = this.createTexture(descriptor);

    for (let i = 0; i < images.length; ++i) {
      image = images[i];
      queue.copyExternalImageToTexture({
        source: image,
        flipY
      }, {
        texture: tex,
        origin: [0, 0, i]
      }, [image.width, image.height]);
    }

    if (generateMipmaps) {
      tex = this.mipmapGenerator.generateMipmap(tex, descriptor);
    }

    return tex;
  }

  createDataTexture(srcDatas, width, height, descriptor, generateMipmaps = false) {
    if (!descriptor) descriptor = {};

    if (!descriptor.format) {
      descriptor.format = "rgba8unorm";
    }

    console.log("descriptor.format: ", descriptor.format);

    switch (descriptor.format) {
      case "rgba16float":
        return this.create64BitsTexture(srcDatas, width, height, descriptor, generateMipmaps);
        break;

      case "bgra8unorm":
      case "rgba8unorm":
      case "rgb9e5ufloat":
        return this.create32BitsTexture(srcDatas, width, height, descriptor, generateMipmaps);

      default:
        break;
    }

    throw Error("Illegal operation !!!");
  }

  create32BitsTexture(srcDatas, width, height, descriptor, generateMipmaps = false) {
    generateMipmaps = generateMipmaps === true ? true : false;
    if (!descriptor) descriptor = {};

    if (!descriptor.format) {
      descriptor.format = "rgba8unorm";
    }

    let wgctx = this.mWGCtx;
    let datas = new Array(srcDatas.length);
    if (!descriptor) descriptor = {};

    if (!descriptor.usage) {
      descriptor.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    }

    if (!descriptor.size) {
      descriptor.size = [width, height];
    }

    console.log("this.create32BitsTexture(), descriptor.format: ", descriptor.format);

    switch (descriptor.format) {
      case "rgb9e5ufloat":
        generateMipmaps = false;

        for (let i = 0; i < srcDatas.length; ++i) {
          let rd = srcDatas[i];
          let tot = rd.length / 3;
          let k = 0;
          let data = new Int32Array(tot);

          for (let j = 0; j < tot; ++j) {
            data[j] = Conversion_1.packRGB9E5UFloat(rd[k], rd[k + 1], rd[k + 2]);
            k += 3;
          }

          datas[i] = data;
        }

        break;

      default:
        for (let i = 0; i < srcDatas.length; ++i) {
          let data = srcDatas[i]; // console.log('data instanceof Uint8Array: ', data instanceof Uint8Array, ', data.BYTES_PER_ELEMENT: ', data.BYTES_PER_ELEMENT);

          if (data.byteLength === undefined || data.BYTES_PER_ELEMENT != 1) {
            data = new Uint8Array(srcDatas[i]);
          }

          datas[i] = data;
        }

        break;
    }

    descriptor.mipLevelCount = generateMipmaps || datas.length > 1 ? GPUMipmapGenerator_1.calculateMipLevels(width, height) : 1;
    generateMipmaps = this.checkTexDesc(descriptor, generateMipmaps);
    let texture;

    if (descriptor.viewDimension === "cube") {
      descriptor.size = {
        width,
        height,
        depthOrArrayLayers: 6
      };
      texture = wgctx.device.createTexture(descriptor);
      let k = 0;

      for (let i = 0; i < descriptor.mipLevelCount; i++) {
        let bytesPerRow = width * 4;
        let rowsPerImage = height;

        for (let j = 0; j < 6; j++) {
          wgctx.device.queue.writeTexture({
            texture,
            mipLevel: i,
            origin: [0, 0, j]
          }, datas[k++], {
            bytesPerRow,
            rowsPerImage
          }, {
            width,
            height
          });
        }

        width >>= 1;
        height >>= 1;
      }
    } else {
      let rowsPerImage = height;
      texture = wgctx.device.createTexture(descriptor);

      for (let i = 0; i < datas.length; ++i) {
        let bytesPerRow = width * 4;
        wgctx.device.queue.writeTexture({
          texture,
          mipLevel: i,
          origin: [0, 0]
        }, datas[i], {
          bytesPerRow,
          rowsPerImage
        }, {
          width,
          height
        });
        width >>= 1;
        height >>= 1;
      }
    } // console.log("this.create32BitsTexture(), mipmapGenerator: ", generateMipmaps);


    if (generateMipmaps) {
      texture = this.mipmapGenerator.generateMipmap(texture, descriptor);
    }

    return texture;
  }

  create64BitsTexture(srcDatas, width, height, descriptor, generateMipmaps = false) {
    generateMipmaps = generateMipmaps === true ? true : false;

    if (!descriptor.format) {
      descriptor.format = "rgba16float";
    }

    let wgctx = this.mWGCtx;
    let datas = new Array(srcDatas.length);

    switch (descriptor.format) {
      case "rgba16float":
        for (let i = 0; i < srcDatas.length; i++) {
          let sd = srcDatas[i];
          let data = new Uint16Array(sd.length);

          for (let j = 0; j < sd.length; ++j) {
            data[j] = CommonUtils_1.toFloat16(sd[j]);
          }

          datas[i] = data;
        }

        break;

      default:
        break;
    }

    if (!descriptor) descriptor = {};

    if (!descriptor.size) {
      descriptor.size = [width, height];
    }

    descriptor.mipLevelCount = generateMipmaps ? GPUMipmapGenerator_1.calculateMipLevels(width, height) : 1;
    generateMipmaps = this.checkTexDesc(descriptor, generateMipmaps);
    let texture;

    if (descriptor.viewDimension === "cube") {
      descriptor.size = {
        width,
        height,
        depthOrArrayLayers: 6
      };
      texture = wgctx.device.createTexture(descriptor);
      let k = 0;

      for (let i = 0; i < descriptor.mipLevelCount; i++) {
        let bytesPerRow = width * 8;
        let rowsPerImage = height;

        for (let j = 0; j < 6; j++) {
          wgctx.device.queue.writeTexture({
            texture,
            mipLevel: i,
            origin: [0, 0, j]
          }, datas[k++], {
            bytesPerRow,
            rowsPerImage
          }, {
            width,
            height
          });
        }

        width >>= 1;
        height >>= 1;
      }
    } else {
      texture = wgctx.device.createTexture(descriptor);

      for (let i = 0; i < datas.length; i++) {
        let bytesPerRow = width * 8;
        wgctx.device.queue.writeTexture({
          texture,
          mipLevel: i
        }, datas[i], {
          bytesPerRow,
          rowsPerImage: height
        }, {
          width,
          height
        });
        width >>= 1;
        height >>= 1;
      }
    }

    if (generateMipmaps) {
      texture = this.mipmapGenerator.generateMipmap(texture, descriptor);
    }

    return texture;
  }

}

WebGPUTextureContext.sUid = 0;
exports.WebGPUTextureContext = WebGPUTextureContext;

/***/ }),

/***/ "2b4f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const HttpFileLoader_1 = __webpack_require__("2fc9");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const fixScreenPlaneBrn4BytesTex_frag_wgsl_1 = __importDefault(__webpack_require__("afaf"));

const vertEntityOnlyVtx_vert_wgsl_1 = __importDefault(__webpack_require__("4ca8"));

const cubemap_frag_wgsl_1 = __importDefault(__webpack_require__("1a9d"));

const cubemapBrn_frag_wgsl_1 = __importDefault(__webpack_require__("0f15"));

const WGMaterial_1 = __webpack_require__("943f");

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const Entity3D_1 = __webpack_require__("551f");

const WGGeometry_1 = __webpack_require__("746a");

const SpecularBrnTexture_1 = __webpack_require__("6cb1");

const SpecularEnvBrnTexture_1 = __webpack_require__("0c34");

class Set32BitsTexMipmapData {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("Set32BitsTexMipmapData::initialize() ...");

    let callback = () => {
      // this.initScene();
      // this.initAssets();
      this.initBrnTexEnvMap();
      this.initEvent();
    };

    this.mRscene.initialize({
      callback
    });
  }

  initBrnTexEnvMap() {
    let shaderSrc = {
      vert: {
        code: vertEntityOnlyVtx_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: cubemapBrn_frag_wgsl_1.default,
        uuid: "brnCubeFrag"
      }
    };
    let envMapUrl = "static/bytes/spb.bin";
    let tex = new SpecularEnvBrnTexture_1.SpecularEnvBrnTexture().load(envMapUrl);
    const material = this.createMaterial(shaderSrc, tex);
    this.createCubeMapEntity([material]);
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initAssets() {
    let hdrBrnEnabled = true;
    let envMapUrl = "static/bytes/spb.bin";
    new HttpFileLoader_1.HttpFileLoader().load(envMapUrl, (buf, url) => {
      console.log("buf: ", buf);
      this.buildFloatTex(hdrBrnEnabled, buf);
      this.initializeImgCubeMap();
    });
  }

  buildFloatTex(hdrBrnEnabled, buf) {
    this.parseMultiHdrBrn(buf); // this.parseCubeHdrBrn(buf);
  }

  parseMultiHdrBrn(buffer) {
    let data16 = new Uint16Array(buffer);
    let currBytes = new Uint8Array(buffer);
    let begin = 0;
    let width = data16[4];
    let height = data16[5];
    let mipMapMaxLv = data16[6];
    console.log("parseMultiHdrBrn, width: ", width, "height: ", height, "mipMapMaxLv: ", mipMapMaxLv);
    let size = 0;
    let bytes = currBytes.subarray(32);
    let dataU8;
    let datas = [];
    let dstI = 0;
    let currW = width;
    let currH = height;

    for (let j = 0; j < mipMapMaxLv; j++) {
      for (let i = 0; i < 6; i++) {
        size = currW * currW * 4;

        if (i == dstI) {
          // console.log("parseMultiHdrBrn, j: ", j, ", currW: ", currW, ", currH: ", currH);
          dataU8 = bytes.subarray(begin, begin + size);
          datas.push(dataU8);
        }

        begin += size;
      }

      currW >>= 1;
      currH >>= 1;
    }

    let rc = this.mRscene;
    let tb = rc.getWGCtx().texture; // let texture = tb.create32BitsTexture(datas, width, height, { format: "rgba8unorm" }, false);
    // let tex = {
    // 	// diffuse: { uuid: "texBrn", dataTexture: { data: dataU8, width, height }, format: "rgba8unorm", generateMipmaps: false }
    // 	diffuse: { uuid: "texMultiBrn", dataTexture: { texture }, format: "rgba8unorm", generateMipmaps: false }
    // };

    let tex = new SpecularBrnTexture_1.SpecularBrnTexture(datas, width, height);
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: fixScreenPlaneBrn4BytesTex_frag_wgsl_1.default,
        uuid: "br4BytesFrag"
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shadinguuid: "texMultiBrnM",
      shaderSrc,
      extent: [0.0, 0.0, 0.8, 0.8],
      textures: [tex]
    });
    entity.color = [1.0, 1.0, 1.0, 4.0];
    rc.addEntity(entity);
  }

  parseCubeHdrBrn(buffer) {
    let data16 = new Uint16Array(buffer);
    let currBytes = new Uint8Array(buffer);
    let begin = 0;
    let width = data16[4];
    let height = data16[5];
    let mipMapMaxLv = data16[6];
    console.log("parseCubeHdrBrn, width: ", width, "height: ", height, "mipMapMaxLv: ", mipMapMaxLv);
    let size = 0;
    let bytes = currBytes.subarray(32);
    let dataU8;
    let datas = [];
    let currW = width;
    let currH = height;

    for (let j = 0; j < mipMapMaxLv; j++) {
      for (let i = 0; i < 6; i++) {
        size = currW * currW * 4; // console.log("parseMultiHdrBrn, j: ", j, ", currW: ", currW, ", currH: ", currH);

        dataU8 = bytes.subarray(begin, begin + size);
        datas.push(dataU8);
        begin += size;
      }

      currW >>= 1;
      currH >>= 1;
    }

    let rc = this.mRscene;
    let tb = rc.getWGCtx().texture; // let texture = tb.create32BitsTexture(datas, width, height, { viewDimension: 'cube', dimension: "2d", format: "rgba8unorm", size: { width, height, depthOrArrayLayers: 6} }, false);

    let tex = {
      diffuse: {
        uuid: "cubeTexBrn",
        dataTexture: {
          datas: datas,
          width,
          height
        },
        viewDimension: "cube",
        format: "rgba8unorm",
        generateMipmaps: false
      } // diffuse: { uuid: "texCubeBrn", viewDimension: "cube", dataTexture: { texture }, format: "rgba8unorm", generateMipmaps: false }

    };
    let shaderSrc = {
      vert: {
        code: vertEntityOnlyVtx_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: cubemapBrn_frag_wgsl_1.default,
        uuid: "brnCubeFrag"
      }
    }; // let entity = new FixScreenPlaneEntity({ shadinguuid: "texCubeBrnM", shaderSrc, extent: [0.0, 0.0, 0.8, 0.8], textures: [tex] });
    // entity.color = [1.0, 1.0, 1.0, 4.0];
    // rc.addEntity(entity);

    const material = this.createMaterial(shaderSrc, tex);
    this.createCubeMapEntity([material]);
  }

  initializeImgCubeMap() {
    console.log("ImgCubeMap::initialize() ...");
    let urls = ["static/assets/hw_morning/morning_ft.jpg", "static/assets/hw_morning/morning_bk.jpg", "static/assets/hw_morning/morning_up.jpg", "static/assets/hw_morning/morning_dn.jpg", "static/assets/hw_morning/morning_rt.jpg", "static/assets/hw_morning/morning_lf.jpg"]; // // const diffuseTex = { diffuse: { url: "static/assets/default.jpg", flipY: true } };

    const diffuseTex = {
      diffuse: {
        uuid: "imgCubeTex",
        urls,
        viewDimension: "cube"
      }
    };
    const shaderSrc = {
      vert: {
        code: vertEntityOnlyVtx_vert_wgsl_1.default,
        uuid: "vertCubeShdCode"
      },
      frag: {
        code: cubemap_frag_wgsl_1.default,
        uuid: "fragCubeShdCode"
      }
    }; // const material = this.createMaterial(shaderSrc, diffuseTex );
    // this.createCubeMapEntity([material]);
  }

  createMaterial(shaderSrc, tex) {
    // // let texDataList = [new WGImageCubeTextureData(urls)];
    const texTotal = 1;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "cube-base-material-tex" + texTotal,
      shaderSrc
    }).addTextures([tex]);
    return material; // return new WGMaterial();
  }

  createCubeMapEntity(materials) {
    let rc = this.mRscene;
    const rgd = this.geomData.createCube(200);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).setIndices(rgd.ivs);
    const entity = new Entity3D_1.Entity3D({
      materials,
      geometry
    });
    rc.addEntity(entity);
    return entity;
  }

  applyRGBA8Tex() {
    let rc = this.mRscene;
    let width = 256;
    let height = 256;
    let stride = 4;
    let dataU8 = new Uint8Array(width * height * stride);
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * 4;
        dataU8[k] = j / width * 255 | 0;
        dataU8[k + 1] = (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width))) * 255 | 0;
        dataU8[k + 2] = (1.0 - i * j / (width * height)) * 255 | 0;
        dataU8[k + 3] = 255;
      }
    }

    let tex = {
      diffuse: {
        uuid: "texRGBA8Tex",
        dataTexture: {
          data: dataU8,
          width,
          height
        },
        format: "rgba8unorm",
        generateMipmaps: false
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shadinguuid: "texRGBA8",
      extent: [-0.3, -0.3, 0.8, 0.8],
      textures: [tex]
    });
    rc.addEntity(entity);
  }

  initScene() {// this.applyRGBA8Tex();
  }

  run() {
    this.mRscene.run();
  }

}

exports.Set32BitsTexMipmapData = Set32BitsTexMipmapData;

/***/ }),

/***/ "2c77":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
const __$mcv = 1e-5;

function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}

function euclideanModulo(n, m) {
  return (n % m + m) % m;
}

function clamp(value, min, max) {
  return Math.max(Math.min(value, max), min);
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function srgbToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function linearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

function getHexStr(v) {
  let t = Math.floor(v * 255.0);

  if (t > 0) {
    if (t < 0xf) {
      return "0" + t.toString(16);
    } else {
      return "" + t.toString(16);
    }
  } else {
    return '00';
  }
}

class Color4 {
  constructor(pr = 1.0, pg = 1.0, pb = 1.0, pa = 1.0) {
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this.v = 0;
    this.c = 0;
    this.m = 0;
    this.y = 0;
    this.k = 0;
    this.r = pr;
    this.g = pg;
    this.b = pb;
    this.a = pa;
  }

  clone() {
    return new Color4(this.r, this.g, this.b, this.a);
  }

  setColor(color) {
    let v = color;

    if (v) {
      const c = this;
      const vs = v;

      if (vs.length !== undefined) {
        const len = vs.length;
        if (len > 0) c.r = vs[0];
        if (len > 1) c.g = vs[1];
        if (len > 2) c.b = vs[2];
        if (len > 3) c.a = vs[3];
      } else {
        const vo = v;
        if (vo.r !== undefined) c.r = vo.r;
        if (vo.g !== undefined) c.g = vo.g;
        if (vo.b !== undefined) c.b = vo.b;
        if (vo.a !== undefined) c.a = vo.a;
      }
    }

    return this;
  }

  toBlack(brn = 0) {
    this.r = this.g = this.b = brn;
    return this;
  }

  toWhite(brn = 1.0) {
    this.r = this.g = this.b = brn;
    return this;
  }

  gammaCorrect() {
    const f = 1.0 / 2.2;
    this.r = Math.pow(this.r, f);
    this.g = Math.pow(this.g, f);
    this.b = Math.pow(this.b, f);
    return this;
  }

  fromArray4(arr, offset = 0) {
    this.r = arr[offset];
    this.g = arr[offset + 1];
    this.b = arr[offset + 2];
    this.a = arr[offset + 3];
    return this;
  }

  toArray4(arr, offset = 0) {
    arr[offset] = this.r;
    arr[offset + 1] = this.g;
    arr[offset + 2] = this.b;
    arr[offset + 3] = this.a;
    return this;
  }

  getArray4() {
    let arr = new Array(4);
    this.toArray4(arr);
    return arr;
  }

  getArray3() {
    let arr = new Array(3);
    this.toArray3(arr);
    return arr;
  }

  fromArray3(arr, offset = 0) {
    this.r = arr[offset];
    this.g = arr[offset + 1];
    this.b = arr[offset + 2];
    return this;
  }

  toArray3(arr, offset = 0) {
    arr[offset] = this.r;
    arr[offset + 1] = this.g;
    arr[offset + 2] = this.b;
    return this;
  }

  fromBytesArray3(arr, offset = 0) {
    this.setRGB3Bytes(arr[offset], arr[offset + 1], arr[offset + 2]);
    return this;
  }

  toBytesArray3(arr, offset = 0) {
    arr[offset] = Math.round(this.r * 255);
    arr[offset + 1] = Math.round(this.g * 255);
    arr[offset + 2] = Math.round(this.b * 255);
    return this;
  }

  setRGB3f(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }

  setRGB3Bytes(uint8R, uint8G, uint8B) {
    const k = 1.0 / 255.0;
    this.r = uint8R * k;
    this.g = uint8G * k;
    this.b = uint8B * k;
    return this; // return this.setRGB3Bytes(r,g,b);
  }

  setRGBUint24(rgbUint24) {
    const bit = 0xff;
    this.r = (rgbUint24 >> 16 & bit) / 255.0;
    this.g = (rgbUint24 >> 8 & bit) / 255.0;
    this.b = (rgbUint24 & bit) / 255.0;
    return this;
  }

  getRGBUint24() {
    return (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
  }

  clamp() {
    if (this.r > 1.0) this.r = 1.0;else if (this.r < 0.0) this.r = 0.0;
    if (this.g > 1.0) this.g = 1.0;else if (this.g < 0.0) this.g = 0.0;
    if (this.b > 1.0) this.b = 1.0;else if (this.b < 0.0) this.b = 0.0;
    return this;
  }

  ceil() {
    let s = Math.max(Math.max(this.r, this.g), this.b); // console.log("a0 s: ", s);

    s = 1.0 / (s + 0.000001); // console.log("a1 s: ", s);

    if (s < 1.0) {
      s = 1.0;
    } // console.log("b0 s: ", s);


    return this.scaleBy(s);
  }
  /**
   * @param argbUint32 example: 0xFFFF88cc
   */


  setARGBUint32(argbUint32) {
    const bit = 0xff;
    this.r = (argbUint32 >> 16 & bit) / 255.0;
    this.g = (argbUint32 >> 8 & bit) / 255.0;
    this.b = (argbUint32 & bit) / 255.0;
    this.a = (argbUint32 >> 24 & bit) / 255.0;
    return this;
  }

  getARGBUint32() {
    return (Math.round(this.a * 255) << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
  }

  setRGBA4f(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }

  setAlpha(a) {
    this.a = a;
    return this;
  }
  /**
   *
   * @param contrast its value range is [-50.0, 100.0]
   */


  setContrast(contrast) {
    /*
        //限制参数p;
        if(p>0){p=p+1;}//当p>0时,函数图像无限趋近于垂直
        else{p=1/(1-p);}//当p<0时,函数图像无限趋近于水平
        //使函数图像绕(0.5,0.5)为中心旋转;
        x=p*(x-0.5)+0.5;
        //返回x限制在0-1之间的值;
        return clamp(x, 0.0, 1.0);
    */

    /*
        //限制参数p;
        if(p>0){p=p+1;}//当p>0时,函数图像无限趋近于垂直
        else{p=1/(1-p);}//当p<0时,函数图像无限趋近于水平
        //R通道运算;
        if(x.x>0.5){x.x=1-pow((2-x.x*2),p)/2;}
        else{x.x=pow((x.x*2),p)/2;}
        //G通道运算;
        if(x.y>0.5){x.y=1-pow((2-2*x.y),p)/2;}
        else{x.y=pow((2*x.y),p)/2;}
        //B通道运算;
        if(x.z>0.5){x.z=1-pow((2-2*x.z),p)/2;}
        else{x.z=pow((2*x.z),p)/2;}
        //返回值;
        return x;
        // thanks: https://zhuanlan.zhihu.com/p/415198746
    */
    const factor = 259.0 * (contrast + 255.0) / (255.0 * (259.0 - contrast));
    const pr = 255.0 * this.r;
    const pg = 255.0 * this.g;
    const pb = 255.0 * this.b;
    this.r = clamp(factor * (pr - 128.0) + 128.0, 0.0, 255.0) / 255.0;
    this.g = clamp(factor * (pg - 128.0) + 128.0, 0.0, 255.0) / 255.0;
    this.b = clamp(factor * (pb - 128.0) + 128.0, 0.0, 255.0) / 255.0;
    return this;
  }

  toGray() {
    this.r *= 0.2126;
    this.g *= 0.7152;
    this.b *= 0.0722;
    return this;
  }

  setHSL(h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);

    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }

    return this;
  }

  getHSL(target = null) {
    // h,s,l ranges are in 0.0 - 1.0
    if (!target) {
      target = new Color4();
    }

    const r = this.r,
          g = this.g,
          b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }

  lerp(color, factor) {
    this.r += (color.r - this.r) * factor;
    this.g += (color.g - this.g) * factor;
    this.b += (color.b - this.b) * factor;
    return this;
  }

  lerpColors(color1, color2, factor) {
    this.r = color1.r + (color2.r - color1.r) * factor;
    this.g = color1.g + (color2.g - color1.g) * factor;
    this.b = color1.b + (color2.b - color1.b) * factor;
    return this;
  }

  lerpHSL(color, factor) {
    const c0 = Color4.sC0;
    const c1 = Color4.aC1;
    this.getHSL(c0);
    color.getHSL(c1);
    const h = lerp(c0.h, c1.h, factor);
    const s = lerp(c0.s, c1.s, factor);
    const l = lerp(c0.l, c1.l, factor);
    this.setHSL(h, s, l);
    return this;
  }

  copyFrom(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }

  copyFromRGB(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    return this;
  }

  scaleBy(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }

  inverseRGB() {
    this.r = 1.0 - this.r;
    this.g = 1.0 - this.g;
    this.b = 1.0 - this.b;
    return this;
  }

  randomRGB(density = 1.0, bias = 0.0) {
    this.r = Math.random() * density + bias;
    this.g = Math.random() * density + bias;
    this.b = Math.random() * density + bias;
    return this;
  }

  rotate() {
    // let arr = [this.g, this.b, this.r];
    return this.setColor([this.g, this.b, this.r]);
  }

  normalizeRandom(density = 1.0, bias = 0.0) {
    this.r = Math.random();
    this.g = Math.random();
    this.b = Math.random();
    let d = Math.sqrt(this.r * this.r + this.g * this.g + this.b * this.b);

    if (d > __$mcv) {
      this.r = density * this.r / d;
      this.g = density * this.g / d;
      this.b = density * this.b / d;
    }

    this.r += bias;
    this.g += bias;
    this.b += bias;
    return this;
  }

  normalize(density) {
    if (density == undefined) density = 1.0;
    let d = Math.sqrt(this.r * this.r + this.g * this.g + this.b * this.b);

    if (d > __$mcv) {
      this.r = density * this.r / d;
      this.g = density * this.g / d;
      this.b = density * this.b / d;
    }

    return this;
  }

  rgbSizeTo(size) {
    let d = Math.sqrt(this.r * this.r + this.g * this.g + this.b * this.b);
    d = size / d;
    this.r *= d;
    this.g *= d;
    this.b *= d;
    return this;
  }

  copySRGBToLinear(color) {
    this.r = srgbToLinear(color.r);
    this.g = srgbToLinear(color.g);
    this.b = srgbToLinear(color.b);
    return this;
  }

  copyLinearToSRGB(color) {
    this.r = linearToSRGB(color.r);
    this.g = linearToSRGB(color.g);
    this.b = linearToSRGB(color.b);
    return this;
  }

  convertSRGBToLinear() {
    return this.copySRGBToLinear(this);
  }

  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this);
  }
  /**
   * @returns for example: rgba(255,255,255,1.0)
   */


  getCSSDecRGBAColor() {
    let pr = Math.floor(this.r * 255.0);
    let pg = Math.floor(this.g * 255.0);
    let pb = Math.floor(this.b * 255.0);
    let pa = this.a;
    return "rgba(" + pr + "," + pg + "," + pb + "," + pa + ")";
  }
  /**
   * @returns for example: #350b7e
   */


  getCSSHeXRGBColor(keyStr = "#") {
    let str = keyStr;
    str += getHexStr(this.r);
    str += getHexStr(this.g);
    str += getHexStr(this.b);
    return str;
  }

}

Color4.sC0 = new Color4();
Color4.aC1 = new Color4();
exports.default = Color4;

/***/ }),

/***/ "2c8d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n\r\n    var result = textureSample(texture0, sampler0, uv) * param;\r\n\tresult = vec4f(result.xyz, 1.0);\r\n\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "2d03":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const floatRTTCalc_frag_wgsl_1 = __importDefault(__webpack_require__("74d8"));

const floatRTTRead_frag_wgsl_1 = __importDefault(__webpack_require__("cb24"));

const floatRTT = {
  diffuse: {
    uuid: "rtt0",
    rttTexture: {},
    format: 'rgba16float'
  }
};

class FloatRTT {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("FloatRTT::initialize() ...");
    let multisampleEnabled = true;
    let depthTestEnabled = false;
    let rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam
    });
    this.initScene();
  }

  applyRTTPass(extent) {
    let rs = this.mRscene;
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: floatRTTCalc_frag_wgsl_1.default,
        uuid: "calcFrag"
      }
    };
    const attachment = {
      texture: floatRTT,
      clearValue: [0.1, 0.1, 0.1, 1.0]
    };
    const colorAttachments = [attachment];
    let rPass = rs.createRenderPass({
      separate: true,
      colorAttachments
    });
    const diffuseTex = {
      diffuse: {
        url: "static/assets/huluwa.jpg",
        flipY: true
      }
    };
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-1, -1, 2, 2],
      textures: [diffuseTex],
      shaderSrc,
      shadinguuid: "floatRTT"
    });
    rPass.addEntity(rttEntity);
    shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: floatRTTRead_frag_wgsl_1.default,
        uuid: "readFrag"
      }
    }; // display float rtt rendering result

    extent = [-0.8, -0.8, 1.6, 1.6];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [floatRTT],
      shaderSrc,
      shadinguuid: "calcColor"
    });
    rs.addEntity(entity); // display origin image

    extent = [-0.95, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: false,
      textures: [diffuseTex]
    });
    rs.addEntity(entity);
  }

  initScene() {
    this.applyRTTPass([-1, -1, 2, 2]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.FloatRTT = FloatRTT;

/***/ }),

/***/ "2d6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const BitConst_1 = __importDefault(__webpack_require__("626c"));

const WGRBufferView_1 = __webpack_require__("dfa8");

const WGRBufferValueParam_1 = __webpack_require__("b512");

exports.WGRBufferData = WGRBufferValueParam_1.WGRBufferData;
exports.WGRBufferValueParam = WGRBufferValueParam_1.WGRBufferValueParam;

const WGRBufferVisibility_1 = __webpack_require__("dc4d");

class WGRBufferValue extends WGRBufferView_1.WGRBufferView {
  constructor(param) {
    super();
    WGRBufferValueParam_1.applyParamToBufferData(this, param);
    this.upate();
  }

  toShared() {
    this.shared = true;
    return this;
  }

  toVisibleAll() {
    this.visibility.toVisibleAll();
    return this;
  }

  toVisibleVertComp() {
    this.visibility.toVisibleVertComp();
    return this;
  }

  toVisibleComp() {
    this.visibility.toVisibleComp();
    return this;
  }

  toBufferForStorage() {
    this.visibility.toBufferForStorage();
    return this;
  }

  toBufferForReadOnlyStorage() {
    this.visibility.toBufferForReadOnlyStorage();
    return this;
  }

  toUniform() {
    this.usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
    return this;
  }

  toStorage() {
    this.usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
  }

  toVertex() {
    this.usage = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST;
  }

  isUniform() {
    return BitConst_1.default.containsBit(this.usage, GPUBufferUsage.UNIFORM);
  }

  isStorage() {
    return BitConst_1.default.containsBit(this.usage, GPUBufferUsage.STORAGE);
  }

  isVertex() {
    return BitConst_1.default.containsBit(this.usage, GPUBufferUsage.VERTEX);
  }

  upate() {
    this.version++;
  }

  clone(data) {
    const u = new WGRBufferValue({
      data: data
    });
    u.name = this.name;
    u.byteOffset = this.byteOffset;
    u.arrayStride = this.arrayStride;
    u.usage = this.usage;
    return u;
  }

  destroy() {
    this.data = null;
    this.bufData = null;
    this.shared = null;
    this.visibility = null;

    if (this.buffer) {
      this.buffer = null;
    }
  }

}

exports.WGRBufferValue = WGRBufferValue;

const __$ubv = new WGRBufferValue({
  data: new Float32Array(4)
});

function getVisibility(str, value) {
  switch (str) {
    case 'vert':
    case 'vertex':
      // console.log("getVisibility() XXXX Vert");
      return value | GPUShaderStage.VERTEX;
      break;

    case 'frag':
    case 'fragment':
      // console.log("getVisibility() XXXX Frag");
      return value | GPUShaderStage.FRAGMENT;
      break;

    case 'comp':
    case 'compute':
      console.log("getVisibility() XXXX Comp");
      return value | GPUShaderStage.COMPUTE;
      break;

    default:
      break;
  }

  return value;
}

function applyLayout(layout, vi, type) {
  let visi = layout.visibility !== undefined ? layout.visibility : 'vert_frag';
  let vs = visi.split('_');
  let v = 0;
  let bv = __$ubv.visibility;

  for (let i = 0; i < vs.length; ++i) {
    if (vs[i] === 'all') {
      bv.toVisibleAll();
      v = bv.visibility;
      break;
    }

    v = v | getVisibility(vs[i], v);
  }

  if (vs.length < 1) {
    bv.toVisibleVertFrag();
    v = bv.visibility;
  }

  if (v < 1) {
    throw 'Illegal operation !!!';
  }

  vi.visibility = v;
  let acc = layout.access !== undefined ? layout.access : '';

  switch (type) {
    case 'uniform':
      vi.toBufferForUniform();
      break;

    case 'storage':
      if (acc === 'read_write') {
        vi.toBufferForStorage();
      } else {
        vi.toBufferForReadOnlyStorage();
      }

      break;

    default:
      break;
  }
}

function bufferDataFilter(d) {
  if (!d) {
    return d;
  }

  const v = __$ubv;
  let rd = d;
  let vi = rd.visibility;
  let layout = rd.layout;

  if (d.storage) {
    rd = d.storage;
    v.toStorage();
    rd.usage = v.usage;
    let flag = !rd.visibility;

    if (flag) {
      rd.visibility = new WGRBufferVisibility_1.WGRBufferVisibility();
    }

    vi = rd.visibility;
    if (!layout) layout = rd.layout;

    if (flag && layout !== undefined) {
      applyLayout(layout, vi, 'storage');
    } else {
      let b = vi.buffer; // console.log("dfdfdfd AAA b: ", b, (!b));

      if (!b || b.type.indexOf('storage') < 0) {
        vi.toBufferForReadOnlyStorage();
        b = vi.buffer;
      }
    } // console.log("dfdfdfd BBB b: ", b, (!b));

  }

  if (d.vertex) {
    rd = d.vertex;
    v.toVertex();
    rd.usage = v.usage;
  }

  if (rd.usage === undefined || d.uniform) {
    if (d.uniform) {
      rd = d.uniform;
    }

    v.toUniform();
    rd.usage = v.usage;
    let flag = !rd.visibility;

    if (flag) {
      rd.visibility = new WGRBufferVisibility_1.WGRBufferVisibility();
    }

    vi = rd.visibility;
    if (!layout) layout = rd.layout;

    if (flag && layout !== undefined) {
      applyLayout(layout, vi, 'uniform');
    } else {
      let b = vi.buffer;

      if (!b || b.type.indexOf('uniform') < 1) {
        vi.toBufferForUniform();
        b = vi.buffer;
      }
    } // console.log("dfdfdfd AAA111 b: ", b, (!b), ", vi: ", vi);

  }

  if (rd.byteOffset === undefined) rd.byteOffset = 0;
  if (rd.version === undefined) rd.version = -1;
  return rd;
}

function checkBufferData(bufData) {
  let isBV = bufData instanceof WGRBufferValue; // console.log("checkBufferData(), isBV: ", isBV);

  if (!isBV) {
    // console.log("checkBufferData(), building data ...");
    bufData = bufferDataFilter(bufData);
    bufData.shared = bufData.shared === true ? true : false;
    WGRBufferValueParam_1.applyParamToBufferData(bufData, bufData);
    bufData.byteLength = bufData.data.byteLength; // console.log("checkBufferData(), XXXXXXXX bufDatd: ", bufData);
  }

  return bufData;
}

exports.checkBufferData = checkBufferData;

/***/ }),

/***/ "2fc9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class HttpFileLoader {
  constructor() {
    this.crossOrigin = 'anonymous';
  }

  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
  }

  loadText(url, onLoad,
  /**
   * @param progress its value is 0.0 -> 1.0
   */
  onProgress = null, onError = null, responseType = "text", headRange = "") {
    return this.load(url, onLoad, onProgress, onError, responseType, headRange);
  }

  loadJson(url, onLoad,
  /**
   * @param progress its value is 0.0 -> 1.0
   */
  onProgress = null, onError = null, responseType = "json", headRange = "") {
    return this.load(url, onLoad, onProgress, onError, responseType, headRange);
  }

  load(url, onLoad,
  /**
   * @param progress its value is 0.0 -> 1.0
   */
  onProgress = null, onError = null, responseType = "blob", headRange = "") {
    // console.log("HttpFileLoader::load(), A url: ", url);
    // console.log("loadBinBuffer, headRange != '': ", headRange != "");
    if (onLoad == null) {
      throw Error("onload == null !!!");
    }

    const reader = new FileReader();

    reader.onload = e => {
      if (onLoad) onLoad(reader.result, url);
    };

    const request = new XMLHttpRequest();
    request.open("GET", url, true);

    if (headRange != "") {
      request.setRequestHeader("Range", headRange);
    }

    request.responseType = responseType;

    request.onload = e => {
      // console.log("loaded binary buffer request.status: ", request.status, e);
      // console.log("HttpFileLoader::load(), B url: ", url);
      if (request.status <= 206) {
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            reader.readAsArrayBuffer(request.response);
            break;

          case "json":
            if (onLoad) onLoad(request.response, url);
            break;

          case "text":
            if (onLoad) onLoad(request.response, url);
            break;

          default:
            if (onLoad) onLoad(request.response, url);
            break;
        } // if(responseType == "blob" || responseType == "arraybuffer") {
        // 	reader.readAsArrayBuffer(request.response);
        // }else {
        // 	if(onLoad) onLoad(<string>request.response, url);
        // }

      } else if (onError) {
        onError(request.status, url);
      }
    };

    if (onProgress != null) {
      request.onprogress = evt => {
        // console.log("progress evt: ", evt);
        // console.log("progress total: ", evt.total, ", loaded: ", evt.loaded);
        let k = 0.0;

        if (evt.total > 0 || evt.lengthComputable) {
          k = Math.min(1.0, evt.loaded / evt.total);
        } else {
          let content_length = parseInt(request.getResponseHeader("content-length")); // var encoding = req.getResponseHeader("content-encoding");
          // if (total && encoding && encoding.indexOf("gzip") > -1) {

          if (content_length > 0) {
            // assuming average gzip compression ratio to be 25%
            content_length *= 4; // original size / compressed size

            k = Math.min(1.0, evt.loaded / content_length);
          } else {
            console.warn("lengthComputable failed");
          }
        } //let progressInfo = k + "%";
        //console.log("progress progressInfo: ", progressInfo);


        onProgress(k, url);
      };
    }

    if (onError != null) {
      request.onerror = e => {
        console.error("load error, request.status: ", request.status, ", url: ", url);
        onError(request.status, url);
      };
    }

    request.send(null);
    return this;
  }

}

exports.HttpFileLoader = HttpFileLoader;

/***/ }),

/***/ "3247":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class URLFilter {
  static getDomain(url) {
    var urlReg = /http:\/\/([^\/]+)/i;
    let domain = url.match(urlReg);
    return domain != null && domain.length > 0 ? domain[0] : "";
  }

  static getHostUrl(port, end = "/") {
    let host = location.href;
    let domain = URLFilter.getDomain(host);
    let nsList = domain.split(":");
    host = nsList[0] + ":" + nsList[1];
    return port ? host + ":" + port + "/" : domain + end;
  }

  static isEnabled() {
    let hostUrl = window.location.href;
    return hostUrl.indexOf(".artvily.com") > 0;
  }

  static filterUrl(url) {
    if (url.indexOf("blob:") < 0) {
      let hostUrl = window.location.href;

      if (hostUrl.indexOf(".artvily.") > 0) {
        hostUrl = "http://www.artvily.com:9090/";
        url = hostUrl + url;
      }
    }

    return url;
  }

  static getFileName(url, lowerCase = false, force = false) {
    if (url.indexOf("blob:") < 0 || force) {
      let i = url.lastIndexOf("/");

      if (i < 0) {
        return "";
      }

      let j = url.lastIndexOf(".", url.length);

      if (j < 0) {
        return "";
      }

      if (i + 2 < j) {
        let str = url.slice(i + 1, j);

        if (lowerCase) {
          return str.toLocaleLowerCase();
        }

        return str;
      }
    }

    return "";
  }

  static getFileNameAndSuffixName(url, lowerCase = false, force = false) {
    if (url.indexOf("blob:") < 0 || force) {
      let i = url.lastIndexOf("/");
      let j = url.lastIndexOf(".", url.length);

      if (j < 0) {
        return "";
      }

      let str = url.slice(i + 1);

      if (lowerCase) {
        return str.toLocaleLowerCase();
      }

      return str;
    }

    return "";
  }

  static getFileSuffixName(url, lowerCase = false, force = false) {
    if (url.indexOf("blob:") < 0 || force) {
      let j = url.lastIndexOf(".", url.length);

      if (j < 0) {
        return "";
      }

      let str = url.slice(j + 1);

      if (lowerCase) {
        return str.toLocaleLowerCase();
      }

      return str;
    }

    return "";
  }

}

exports.default = URLFilter;

/***/ }),

/***/ "32d5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("struct VertexInput {\r\n\t@location(0) pos: vec3f,\r\n\t@builtin(instance_index) instance: u32,\r\n};\r\n\r\nstruct VertexOutput {\r\n\t@builtin(position) pos: vec4f,\r\n\t@location(0) cell: vec2f,\r\n};\r\n@group(0) @binding(0) var<uniform> grid: vec2f;\r\n@group(0) @binding(1) var<storage> cellState: array<u32>;\r\n@vertex\r\nfn vertMain(input: VertexInput) -> VertexOutput {\r\n    let i = f32(input.instance);\r\n    let cell = vec2f(i % grid.x, floor(i / grid.x));\r\n    let cellOffset = cell / grid * 2.0;\r\n\r\n    var state = f32(cellState[input.instance]);\r\n    let gridPos = (input.pos.xy * state + 1.0) / grid - 1.0 + cellOffset;\r\n\r\n    var output: VertexOutput;\r\n    output.pos = vec4f(gridPos, 0.0, 1.0);\r\n    output.cell = cell;\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fragMain(input: VertexOutput) -> @location(0) vec4f {\r\n    let c = input.cell / grid;\r\n    return vec4f(c, 1.0 - c.x, 1.0);\r\n}");

/***/ }),

/***/ "3341":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * See: https://gpuweb.github.io/gpuweb/#enumdef-gputextureformat
 */

var GPUTextureFormat;

(function (GPUTextureFormat) {
  // 8-bit formats
  GPUTextureFormat[GPUTextureFormat["r8unorm"] = 0] = "r8unorm";
  GPUTextureFormat[GPUTextureFormat["r8snorm"] = 1] = "r8snorm";
  GPUTextureFormat[GPUTextureFormat["r8uint"] = 2] = "r8uint";
  GPUTextureFormat[GPUTextureFormat["r8sint"] = 3] = "r8sint"; // 16-bit formats

  GPUTextureFormat[GPUTextureFormat["r16uint"] = 4] = "r16uint";
  GPUTextureFormat[GPUTextureFormat["r16sint"] = 5] = "r16sint";
  GPUTextureFormat[GPUTextureFormat["r16float"] = 6] = "r16float";
  GPUTextureFormat[GPUTextureFormat["rg8unorm"] = 7] = "rg8unorm";
  GPUTextureFormat[GPUTextureFormat["rg8snorm"] = 8] = "rg8snorm";
  GPUTextureFormat[GPUTextureFormat["rg8uint"] = 9] = "rg8uint";
  GPUTextureFormat[GPUTextureFormat["rg8sint"] = 10] = "rg8sint"; // 32-bit formats

  GPUTextureFormat[GPUTextureFormat["r32uint"] = 11] = "r32uint";
  GPUTextureFormat[GPUTextureFormat["r32sint"] = 12] = "r32sint";
  GPUTextureFormat[GPUTextureFormat["r32float"] = 13] = "r32float";
  GPUTextureFormat[GPUTextureFormat["rg16uint"] = 14] = "rg16uint";
  GPUTextureFormat[GPUTextureFormat["rg16sint"] = 15] = "rg16sint";
  GPUTextureFormat[GPUTextureFormat["rg16float"] = 16] = "rg16float";
  GPUTextureFormat[GPUTextureFormat["rgba8unorm"] = 17] = "rgba8unorm";
  GPUTextureFormat[GPUTextureFormat["rgba8unorm-srgb"] = 18] = "rgba8unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["rgba8snorm"] = 19] = "rgba8snorm";
  GPUTextureFormat[GPUTextureFormat["rgba8uint"] = 20] = "rgba8uint";
  GPUTextureFormat[GPUTextureFormat["rgba8sint"] = 21] = "rgba8sint";
  GPUTextureFormat[GPUTextureFormat["bgra8unorm"] = 22] = "bgra8unorm";
  GPUTextureFormat[GPUTextureFormat["bgra8unorm-srgb"] = 23] = "bgra8unorm-srgb"; // Packed 32-bit formats

  GPUTextureFormat[GPUTextureFormat["rgb9e5ufloat"] = 24] = "rgb9e5ufloat";
  GPUTextureFormat[GPUTextureFormat["rgb10a2uint"] = 25] = "rgb10a2uint";
  GPUTextureFormat[GPUTextureFormat["rgb10a2unorm"] = 26] = "rgb10a2unorm";
  GPUTextureFormat[GPUTextureFormat["rg11b10ufloat"] = 27] = "rg11b10ufloat"; // 64-bit formats

  GPUTextureFormat[GPUTextureFormat["rg32uint"] = 28] = "rg32uint";
  GPUTextureFormat[GPUTextureFormat["rg32sint"] = 29] = "rg32sint";
  GPUTextureFormat[GPUTextureFormat["rg32float"] = 30] = "rg32float";
  GPUTextureFormat[GPUTextureFormat["rgba16uint"] = 31] = "rgba16uint";
  GPUTextureFormat[GPUTextureFormat["rgba16sint"] = 32] = "rgba16sint";
  GPUTextureFormat[GPUTextureFormat["rgba16float"] = 33] = "rgba16float"; // 128-bit formats

  GPUTextureFormat[GPUTextureFormat["rgba32uint"] = 34] = "rgba32uint";
  GPUTextureFormat[GPUTextureFormat["rgba32sint"] = 35] = "rgba32sint";
  GPUTextureFormat[GPUTextureFormat["rgba32float"] = 36] = "rgba32float"; // Depth/stencil formats

  GPUTextureFormat[GPUTextureFormat["stencil8"] = 37] = "stencil8";
  GPUTextureFormat[GPUTextureFormat["depth16unorm"] = 38] = "depth16unorm";
  GPUTextureFormat[GPUTextureFormat["depth24plus"] = 39] = "depth24plus";
  GPUTextureFormat[GPUTextureFormat["depth24plus-stencil8"] = 40] = "depth24plus-stencil8";
  GPUTextureFormat[GPUTextureFormat["depth32float"] = 41] = "depth32float"; // "depth32float-stencil8" feature

  GPUTextureFormat[GPUTextureFormat["depth32float-stencil8"] = 42] = "depth32float-stencil8"; // BC compressed formats usable if "texture-compression-bc" is both
  // supported by the device/user agent and enabled in requestDevice.

  GPUTextureFormat[GPUTextureFormat["bc1-rgba-unorm"] = 43] = "bc1-rgba-unorm";
  GPUTextureFormat[GPUTextureFormat["bc1-rgba-unorm-srgb"] = 44] = "bc1-rgba-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["bc2-rgba-unorm"] = 45] = "bc2-rgba-unorm";
  GPUTextureFormat[GPUTextureFormat["bc2-rgba-unorm-srgb"] = 46] = "bc2-rgba-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["bc3-rgba-unorm"] = 47] = "bc3-rgba-unorm";
  GPUTextureFormat[GPUTextureFormat["bc3-rgba-unorm-srgb"] = 48] = "bc3-rgba-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["bc4-r-unorm"] = 49] = "bc4-r-unorm";
  GPUTextureFormat[GPUTextureFormat["bc4-r-snorm"] = 50] = "bc4-r-snorm";
  GPUTextureFormat[GPUTextureFormat["bc5-rg-unorm"] = 51] = "bc5-rg-unorm";
  GPUTextureFormat[GPUTextureFormat["bc5-rg-snorm"] = 52] = "bc5-rg-snorm";
  GPUTextureFormat[GPUTextureFormat["bc6h-rgb-ufloat"] = 53] = "bc6h-rgb-ufloat";
  GPUTextureFormat[GPUTextureFormat["bc6h-rgb-float"] = 54] = "bc6h-rgb-float";
  GPUTextureFormat[GPUTextureFormat["bc7-rgba-unorm"] = 55] = "bc7-rgba-unorm";
  GPUTextureFormat[GPUTextureFormat["bc7-rgba-unorm-srgb"] = 56] = "bc7-rgba-unorm-srgb"; // ETC2 compressed formats usable if "texture-compression-etc2" is both
  // supported by the device/user agent and enabled in requestDevice.

  GPUTextureFormat[GPUTextureFormat["etc2-rgb8unorm"] = 57] = "etc2-rgb8unorm";
  GPUTextureFormat[GPUTextureFormat["etc2-rgb8unorm-srgb"] = 58] = "etc2-rgb8unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["etc2-rgb8a1unorm"] = 59] = "etc2-rgb8a1unorm";
  GPUTextureFormat[GPUTextureFormat["etc2-rgb8a1unorm-srgb"] = 60] = "etc2-rgb8a1unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["etc2-rgba8unorm"] = 61] = "etc2-rgba8unorm";
  GPUTextureFormat[GPUTextureFormat["etc2-rgba8unorm-srgb"] = 62] = "etc2-rgba8unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["eac-r11unorm"] = 63] = "eac-r11unorm";
  GPUTextureFormat[GPUTextureFormat["eac-r11snorm"] = 64] = "eac-r11snorm";
  GPUTextureFormat[GPUTextureFormat["eac-rg11unorm"] = 65] = "eac-rg11unorm";
  GPUTextureFormat[GPUTextureFormat["eac-rg11snorm"] = 66] = "eac-rg11snorm"; // ASTC compressed formats usable if "texture-compression-astc" is both
  // supported by the device/user agent and enabled in requestDevice.

  GPUTextureFormat[GPUTextureFormat["astc-4x4-unorm"] = 67] = "astc-4x4-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-4x4-unorm-srgb"] = 68] = "astc-4x4-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-5x4-unorm"] = 69] = "astc-5x4-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-5x4-unorm-srgb"] = 70] = "astc-5x4-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-5x5-unorm"] = 71] = "astc-5x5-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-5x5-unorm-srgb"] = 72] = "astc-5x5-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-6x5-unorm"] = 73] = "astc-6x5-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-6x5-unorm-srgb"] = 74] = "astc-6x5-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-6x6-unorm"] = 75] = "astc-6x6-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-6x6-unorm-srgb"] = 76] = "astc-6x6-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-8x5-unorm"] = 77] = "astc-8x5-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-8x5-unorm-srgb"] = 78] = "astc-8x5-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-8x6-unorm"] = 79] = "astc-8x6-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-8x6-unorm-srgb"] = 80] = "astc-8x6-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-8x8-unorm"] = 81] = "astc-8x8-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-8x8-unorm-srgb"] = 82] = "astc-8x8-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-10x5-unorm"] = 83] = "astc-10x5-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-10x5-unorm-srgb"] = 84] = "astc-10x5-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-10x6-unorm"] = 85] = "astc-10x6-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-10x6-unorm-srgb"] = 86] = "astc-10x6-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-10x8-unorm"] = 87] = "astc-10x8-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-10x8-unorm-srgb"] = 88] = "astc-10x8-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-10x10-unorm"] = 89] = "astc-10x10-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-10x10-unorm-srgb"] = 90] = "astc-10x10-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-12x10-unorm"] = 91] = "astc-12x10-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-12x10-unorm-srgb"] = 92] = "astc-12x10-unorm-srgb";
  GPUTextureFormat[GPUTextureFormat["astc-12x12-unorm"] = 93] = "astc-12x12-unorm";
  GPUTextureFormat[GPUTextureFormat["astc-12x12-unorm-srgb"] = 94] = "astc-12x12-unorm-srgb";
})(GPUTextureFormat || (GPUTextureFormat = {}));

exports.GPUTextureFormat = GPUTextureFormat;
;
const __$WGTFMap = GPUTextureFormat;

function checkGPUTextureFormat(format, error = true) {
  const flag = __$WGTFMap.hasOwnProperty(format);

  if (!flag && error) {
    console.error(`Error: invalid gpu texture format "${format}"`);
  }

  return flag;
}

exports.checkGPUTextureFormat = checkGPUTextureFormat;

/***/ }),

/***/ "348f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Define_1 = __webpack_require__("af1b");

class GeometryBase {
  constructor() {
    this.mPolyhedral = true;
    /**
     * 强制更新 vertex indices buffer 数据, 默认值为false
     */

    this.forceUpdateIVS = false;
    /**
     * 是否启用形状模式数据, 默认值为true
     */

    this.shape = true;
    this.normalType = 0;
    this.normalScale = 1.0;
    this.vtxTotal = 0;
    this.trisNumber = 0; //  vtx postion in data stream used count

    this.vtCount = 0;
    this.drawMode = Define_1.WGRDrawMode.TRIANGLES;
  }

  setTransformMatrix(matrix) {
    this.mTransMatrix = matrix;
  }

  getTransformMatrix() {
    return this.mTransMatrix;
  }
  /**
   * @return 返回true是则表示这是基于三角面的可渲染多面体, 返回false则是一个数学方程描述的几何体(例如球体).
   *         如果是多面体实体,则可以进行三角面的相关计算等操作, 如果不是则需要进行相关的几何算法计算.
   */


  isPolyhedral() {
    return this.mPolyhedral;
  } // 设置自身是否是多面体实体，根据实际需要改变相关的状态值


  setPolyhedral(polyhedral) {
    this.mPolyhedral = polyhedral;
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    return -1;
  } // isGeomDynamic(): boolean {
  //     return true;
  // }


  getVSStride() {
    return 3;
  }

  getUVSStride() {
    return 2;
  }

  getNVSStride() {
    return 3;
  }
  /**
   * @returns vertex position buffer Float32Array
   */


  getVS() {
    return null;
  }
  /**
   * @returns vertex uv buffer Float32Array
   */


  getUVS() {
    return null;
  }
  /**
   * @returns vertex normal buffer Float32Array
   */


  getNVS() {
    return null;
  }
  /**
   * @returns vertex vtx color(r,g,b) buffer Float32Array
   */


  getCVS() {
    return null;
  }
  /**
   * @returns vertex indices buffer Uint16Array or Uint32Array
   */


  getIVS() {
    return this.mivs;
  }
  /**
   * @param layoutBit vertex shader vertex attributes layout bit status.
   *                  the value of layoutBit comes from the material shdder program.
   */


  setBufSortFormat(layoutBit) {
    if (layoutBit < 1) {
      console.error("vertex layoutBit is the error value(0x" + layoutBit.toString(16) + ") in GeometryBase::setBufSortFormat(), the material instance must initialize.");
    } // this.m_layoutBit = layoutBit;

  }
  /**
   * really destroy this instance all data
   */


  __$destroy() {
    if (this.mivs) {
      //console.log("GeometryBase::__$destroy()... this.m_attachCount: "+this.m_attachCount);
      this.mivs = null;
      this.trisNumber = 0;
      this.mTransMatrix = null;
    }
  }

}

exports.default = GeometryBase;

/***/ }),

/***/ "3590":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRUniform_1 = __webpack_require__("005f");

const WGRPipelineContextImpl_1 = __webpack_require__("374c");

exports.BufDataParamType = WGRPipelineContextImpl_1.BufDataParamType;

const IWGRUniformContext_1 = __webpack_require__("9069");

exports.WGRUniformParam = IWGRUniformContext_1.WGRUniformParam;

const WGHBufferStore_1 = __webpack_require__("5151");

const WGRBufferVisibility_1 = __webpack_require__("dc4d");

const WGRBufferView_1 = __webpack_require__("dfa8");

class SharedUniformObj {
  constructor() {
    this.map = new Map();
  }

}

exports.SharedUniformObj = SharedUniformObj;

class WGRUniformCtxInstance {
  constructor() {
    this.mUid = WGRUniformCtxInstance.sUid++;
    this.mList = [];
    this.mBuildTotal = 0;
    this.mBufObj = new IWGRUniformContext_1.WGRUniformBufObj();
    this.mFreeIds = [];
    this.ready = false;
    this.layoutAuto = true;
  }

  getFreeIndex() {
    if (this.mFreeIds.length > 0) return this.mFreeIds.pop();
    return -1;
  }

  getWGCtx() {
    return this.mBindGCtx.getWGCtx();
  }

  initialize(bindGCtx) {
    this.mBindGCtx = bindGCtx;
  }

  isEnabled() {
    return this.mBuildTotal > 0;
  }

  getBindGroupLayout(multisampled) {
    const ls = this.mList;
    const wp = ls[0];
    const ets = [];

    if (wp.bufDataParams) {
      const dps = wp.bufDataParams;

      for (let i = 0; i < dps.length; ++i) {
        const p = dps[i];
        p.visibility.binding = ets.length;

        if (!p.visibility.buffer) {
          p.visibility.toBufferForUniform();
        }

        ets.push(p.visibility);
      }
    }

    if (wp.texParams) {
      const tps = wp.texParams;

      for (let i = 0; i < tps.length; ++i) {
        const p = tps[i];
        let v = new WGRBufferVisibility_1.WGRBufferVisibility().toSamplerFiltering();
        v.binding = ets.length;
        ets.push(v);
        v = new WGRBufferVisibility_1.WGRBufferVisibility().toTextureFloat(p.texView.dimension);
        v.texture.multisampled = multisampled === true ? true : false;
        v.binding = ets.length;
        ets.push(v);
      }
    }

    if (ets.length < 1) {
      return undefined;
    } // console.log("WGRUniformCtxInstance:: getBindGroupLayout(), CCCCCCC ets: ", ets);


    const desc = {
      label: "(BindGroupLayout)WGRUniformCtxInstance" + this.mUid,
      entries: ets
    };
    this.mBindGroupLayout = this.mBindGCtx.createBindGroupLayout(desc);
    return this.mBindGroupLayout;
  }

  runBegin() {
    const ls = this.mList;

    if (this.ready && this.mBuildTotal < ls.length) {
      this.mBuildTotal = ls.length; // console.log("WGRUniformCtxInstance::runBegin(), XXX XXX XXX runBegin(), this.mList.length: ", this.mList.length);

      if (ls.length > 0) {
        this.mBindGroupDesc = null;
        this.mBufDataDescs = null;
        const wp = ls[0];

        if (!wp.uniformAppend && !wp.bufObj) {
          wp.bufObj = new IWGRUniformContext_1.WGRUniformBufObj();
        }

        const bo = wp.uniformAppend ? this.mBufObj : wp.bufObj;
        wp.bufObj = bo;
        const bufs = bo.oldBufs;

        if (bufs) {
          for (let i = 0; i < bufs.length; ++i) {
            bufs[i].destroy(); // console.log("0 destroy a private separate gpu buffer...");
          }
        }

        bo.buffers = [];
        bo.oldBufs = []; // console.log("WGRUniformCtxInstance::runBegin(), XXX wp.uniformAppend: ", wp.uniformAppend);
        // console.log("WGRUniformCtxInstance::runBegin(), XXX wp.bufObj: ", wp.bufObj);

        if (wp.uniformAppend) {
          for (let i = 1; i < ls.length; ++i) {
            ls[i].bufObj = wp.bufObj;
          }

          this.buildBufs(wp);
        } else {
          this.buildBufs(wp);

          for (let i = 1; i < ls.length; ++i) {
            let tbo = ls[i].bufObj;

            if (tbo) {
              const bufs = tbo.oldBufs;

              if (bufs) {
                for (let j = 0; j < bufs.length; ++j) {
                  bufs[j].destroy(); // console.log("1 destroy a private separate gpu buffer...");
                }
              }
            } else {
              tbo = ls[i].bufObj = new IWGRUniformContext_1.WGRUniformBufObj();
            }

            tbo.buffers = [];
            tbo.oldBufs = [];
            this.buildBufs(ls[i]);
          }
        } // console.log("XXX XXX bo.buffers: ", bo.buffers);


        for (let i = 0; i < ls.length; ++i) {
          this.createUniformWithWP(ls[i], i, true);
        }
      }
    }
  }

  buildBufs(wp) {
    if (wp.bufDataParams) {
      const bo = wp.bufObj;
      const ls = this.mList;
      const wgctx = this.mBindGCtx.getWGCtx();
      const store = WGHBufferStore_1.WGHBufferStore.getStore(wgctx);
      const append = wp.uniformAppend;
      const dps = wp.bufDataParams;

      for (let i = 0; i < dps.length; ++i) {
        const dp = dps[i];
        dp.visibility.binding = i;
        const sizes = new Array(dp.shared || !append ? 1 : ls.length);
        const uniformParam = {
          sizes,
          usage: dp.usage,
          arrayStride: dp.arrayStride
        };
        const ufv = dp.ufvalue;
        let buf = ufv.buffer;
        const bufData = ufv.bufData;

        if (!buf && bufData) {
          buf = bufData.buffer;
        }

        if (!buf) {
          let bufDataShared = bufData !== undefined && bufData.shared === true; // console.log("VVVVVVVVVVVV bufDataShared: ", bufDataShared, ", dp.shared: ", dp.shared);

          if (ufv.shared || bufDataShared) {
            let bufuid = bufDataShared && bufData.uid !== undefined ? bufData.uid : -1;
            let vuid = ufv.shared ? ufv.uid : bufuid; // console.log("VVVVVVVVVVVV shared: ", dp.shared,", vuid: ", vuid, ", bufuid: ", bufuid, ", byteLength: ", ufv.byteLength);

            if (store.hasWithUid(vuid)) {
              buf = store.getBufWithUid(vuid); // console.log("apply old shared uniform gpu buffer..., bufDataShared: ", bufDataShared, buf);
            } else {
              if (store.hasWithUid(bufuid)) {
                buf = store.getBufWithUid(bufuid);
              } else {
                // console.log("create new shared uniform gpu buffer...");
                uniformParam.sizes[0] = ls[0].bufDataParams[i].size;
                buf = this.mBindGCtx.createUniformsBuffer(uniformParam);
              }

              if (vuid < 0 || bufDataShared && !store.hasWithUid(bufuid)) {
                // console.log("bufData.uuid: ", bufData.uuid, ", create a new shared uniform gpu buffer and buf a view object...");
                const bufView = new WGRBufferView_1.WGRBufferView().setParam(bufData);
                bufView.buffer = buf;
                ufv.bufData = bufView;
                bufData.uid = bufView.uid;
                store.addWithUid(bufView.uid, bufView);
              }

              if (ufv.shared) {
                ufv.buffer = buf;

                if (bufData && bufData.uid === undefined) {
                  bufData.uid = ufv.uid;
                }

                store.addWithUid(ufv.uid, ufv);
              }
            }

            buf.shared = true;
          } else {
            if (append) {
              for (let j = 0; j < ls.length; ++j) {
                uniformParam.sizes[j] = ls[j].bufDataParams[i].size;
              }

              buf = this.mBindGCtx.createUniformsBuffer(uniformParam);
            } else {
              uniformParam.sizes[0] = ls[i].bufDataParams[i].size;
              buf = this.mBindGCtx.createUniformsBuffer(uniformParam);
            }
          }
        }

        if (!dp.shared && (!bufData || !(bufData.shared === true))) {
          bo.oldBufs.push(buf);
        }

        if (bufData && !bufData.buffer) {
          // console.log("XXXXX A-3 buf: ", buf);
          bufData.buffer = buf;
        }

        bo.buffers.push(buf); // console.log("PPP PPP PPP ,i: ",i," buf.size: ", buf.size);
      }
    }
  }

  createVers(wp) {
    const dps = wp.bufDataParams;
    const map = this.shdUniform.map;
    let versions = new Array(dps.length);

    for (let i = 0; i < dps.length; ++i) {
      const ufv = dps[i].ufvalue;

      if (ufv.shared === true) {
        const vid = ufv.uid;

        if (!map.has(vid)) {
          map.set(vid, {
            vid: ufv.uid,
            ver: -9,
            shared: true,
            shdVarName: ufv.shdVarName
          });
        }

        versions[i] = map.get(vid);
      } else {
        versions[i] = {
          vid: ufv.uid,
          ver: -9,
          shared: false,
          shdVarName: ufv.shdVarName
        };
      }
    }

    return versions;
  }

  createUvfs(wp) {
    const dps = wp.bufDataParams;
    let uvfs = new Array(dps.length);

    for (let i = 0; i < dps.length; ++i) {
      uvfs[i] = dps[i].ufvalue;
    }

    return uvfs;
  }

  createUniformWithWP(wp, index, force = false) {
    // console.log("createUniformWithWP(), wp.groupIndex: ", wp.groupIndex);
    const uf = wp.uniform;

    if (uf && (!uf.bindGroup || force)) {
      uf.buffers = wp.bufObj.buffers.slice(0);
      uf.versions = this.createVers(wp);
      uf.uvfs = this.createUvfs(wp); // console.log("uf.versions: ", uf.versions);

      let ivs = new Array(uf.uvfs.length);

      for (let i = 0; i < ivs.length; ++i) {
        ivs[i] = uf.uvfs[i].shared || !wp.uniformAppend ? 0 : uf.index;
      }

      uf.ivs = ivs;
      const dps = wp.bufDataParams;

      if (dps) {
        let desc = this.mBindGroupDesc;
        let ps = this.mBufDataDescs;

        if (!desc || !wp.uniformAppend) {
          if (!ps || !wp.uniformAppend) {
            ps = new Array(dps.length);

            for (let j = 0; j < dps.length; ++j) {
              const dp = dps[j];
              ps[j] = {
                index: index,
                buffer: uf.buffers[j],
                bufferSize: dp.size,
                shared: dp.shared
              };
            }

            this.mBufDataDescs = ps;
          }

          if (wp.uniformAppend) {
            for (let j = 0; j < ps.length; ++j) {
              ps[j].index = index;
            }
          }

          const layout = this.layoutAuto ? null : this.mBindGroupLayout;
          desc = this.mBindGCtx.createBindGroupDesc(wp.groupIndex, ps, wp.texParams, 0, layout);
          this.mBindGroupDesc = desc;
        }

        this.mBindGCtx.bindGroupDescUpdate(desc, ps, wp.texParams, index, wp.uniformAppend);
        uf.bindGroup = this.mBindGCtx.createBindGroupWithDesc(desc);
      } else {
        uf.bindGroup = this.mBindGCtx.createBindGroup(wp.groupIndex, null, wp.texParams);
      } // console.log("XXX XXX createUniformWithWP(), create a bindGroup: ", uf.bindGroup);


      uf.__$$updateSubUniforms();
    }
  }

  runEnd() {}

  createUniform(layoutName, groupIndex, bufDataParams, texParams, uniformAppend) {
    if (!(bufDataParams && bufDataParams.length || texParams && texParams.length)) {
      throw Error("Illegal operation !!!");
    }

    const index = this.getFreeIndex(); // console.log("WGRUniformCtxInstance::createUniform(), index: ", index, ", mUid: ", this.mUid);

    const u = new WGRUniform_1.WGRUniform(this);
    u.layoutName = layoutName;
    u.groupIndex = groupIndex;
    let wp;

    if (index >= 0) {
      wp = this.mList[index];
      u.index = index;
    } else {
      wp = new IWGRUniformContext_1.WGRUniformWrapper();
      u.index = this.mList.length;
      this.mList.push(wp);
    }

    wp.uniformAppend = uniformAppend === false ? false : true;
    wp.texParams = texParams;
    wp.bufDataParams = bufDataParams;
    wp.uniform = u;
    wp.enabled = true;

    if (index >= 0) {
      if (wp.uniformAppend) {
        const bo = wp.uniformAppend ? this.mBufObj : wp.bufObj;
        wp.bufObj = bo;
        this.createUniformWithWP(wp, index);
      } else {
        this.mBuildTotal = 0;
      }
    } // console.log("WGRUniformCtxInstance::createUniform(), this.mList.length: ", this.mList.length);


    return u;
  }

  updateUniformTextureView(u, texParams) {
    if (u && u.index >= 0 && this.mList[u.index]) {
      const wp = this.mList[u.index];
      const uf = wp.uniform;

      if (uf) {
        uf.bindGroup = this.mBindGCtx.createBindGroup(wp.groupIndex, wp.bufDataDescs, texParams);
      }
    }
  }

  removeUniform(u) {
    if (u && u.index >= 0 && this.mList[u.index]) {
      const wp = this.mList[u.index];

      if (wp.enabled) {
        // 注: remove 不一定是destroy，目前暂且这么处理，后续资源管理机制梳理的时候再调整。
        this.mFreeIds.push(u.index);
        wp.uniform = null;
        wp.bufObj = null;
        wp.texParams = null;
        wp.enabled = false;

        u.__$$destroy();

        console.log("WGRUniformCtxInstance::removeUniform(), clear an uniform wp instance.");
      }
    }
  }

  destroy() {
    if (this.mBindGCtx) {
      this.shdUniform = null;

      if (this.mBufObj) {
        this.mBufObj.destroy();
        this.mBufObj = null;
      }

      this.mBindGCtx = null;
      let ls = this.mList;

      for (let i = 0; i < ls.length; ++i) {
        if (this.mList[i]) {
          this.removeUniform(this.mList[i].uniform);
        }
      }
    }
  }

}

WGRUniformCtxInstance.sUid = 0;
exports.WGRUniformCtxInstance = WGRUniformCtxInstance;

/***/ }),

/***/ "3645":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const WGRPassNodeGraph_1 = __webpack_require__("f083");

const WGMaterial_1 = __webpack_require__("943f");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const blurHTex_frag_wgsl_1 = __importDefault(__webpack_require__("d3d0"));

const blurVTex_frag_wgsl_1 = __importDefault(__webpack_require__("5dcd"));

const rttTex0 = {
  diffuse: {
    uuid: "rtt0",
    rttTexture: {}
  }
};
const rttTex1 = {
  diffuse: {
    uuid: "rtt1",
    rttTexture: {}
  }
};
const rtts = [rttTex0, rttTex1];
const attachment = {
  texture: rttTex0,
  clearValue: [],
  loadOp: "clear",
  storeOp: "store"
};
const colorAttachments = [attachment];

class PassGraph extends WGRPassNodeGraph_1.WGRPassNodeGraph {
  constructor() {
    super();
  }

  run() {
    let pass = this.passes[0];
    const srcEntity = this.srcEntity;
    const entity = this.blurEntity;
    let ms = entity.materials;

    for (let i = 0; i < 9; ++i) {
      const ia = i % 2;
      const ib = (i + 1) % 2;
      srcEntity.visible = i < 1;
      entity.visible = !srcEntity.visible;
      pass.colorAttachments[0].clearEnabled = i < 1;
      attachment.texture = rtts[ia];
      ms[ia].visible = false;
      ms[ib].visible = !ms[ia].visible;
      pass.render();
    }
  }

}

class PingpongBlur {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mGraph = new PassGraph();
    this.mBlurDensity = 2.0;
    this.uniformValues = [{
      data: new Float32Array([512, 512, this.mBlurDensity, 0])
    }];
  }

  initialize() {
    console.log("PingpongBlur::initialize() ...");
    const multisampleEnabled = true;
    const depthTestEnabled = false;
    const rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam
    });
    this.initScene();
  }

  createMaterial(shadinguuid, textures, type) {
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: type > 0 ? blurVTex_frag_wgsl_1.default : blurHTex_frag_wgsl_1.default,
        uuid: "frag"
      }
    };
    shadinguuid += "-" + type;
    let pipelineDefParam = {
      depthWriteEnabled: false
    };
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid,
      shaderSrc,
      pipelineDefParam
    });
    material.uniformValues = this.uniformValues;
    material.addTextures(textures);
    return material;
  }

  applyBlurPass(clearColor, extent) {
    let rs = this.mRscene;
    const graph = this.mGraph;
    attachment.clearValue = clearColor;
    let rPass = rs.createRenderPass({
      separate: true,
      colorAttachments
    });
    graph.passes = [rPass];
    const diffuseTex = {
      diffuse: {
        url: "static/assets/huluwa.jpg",
        flipY: true
      }
    };
    let materials = [this.createMaterial("shd-00", [rttTex0], 0), this.createMaterial("shd-01", [rttTex1], 1)];
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-1, -1, 2, 2],
      textures: [diffuseTex]
    });
    rPass.addEntity(rttEntity);
    graph.srcEntity = rttEntity;
    rs.setPassNodeGraph(graph);
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      materials
    });
    entity.materials[0].visible = false;
    entity.uuid = "blur-entity";
    rPass.addEntity(entity);
    graph.blurEntity = entity; // display blur rendering result

    extent = [-0.8, -0.8, 1.6, 1.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [rttTex0]
    });
    entity.uuid = "blur-big-img";
    rs.addEntity(entity); // display origin image

    extent = [-0.95, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: false,
      textures: [diffuseTex]
    });
    rs.addEntity(entity);
  }

  initScene() {
    this.applyBlurPass([0.1, 0.1, 0.1, 1.0], [-1, -1, 2, 2]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.PingpongBlur = PingpongBlur;

/***/ }),

/***/ "36ce":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GPURenderPipelineEmpty_1 = __webpack_require__("c812");

const WGRPipelineContextImpl_1 = __webpack_require__("374c");

exports.BufDataParamType = WGRPipelineContextImpl_1.BufDataParamType;
exports.VtxPipelinDescParam = WGRPipelineContextImpl_1.VtxPipelinDescParam;

const WGRPipelineShader_1 = __webpack_require__("70bd");

const WGRUniformContext_1 = __webpack_require__("b2fd");

exports.WGRUniformParam = WGRUniformContext_1.WGRUniformParam;

const WGRBindGroupContext_1 = __webpack_require__("8a88");

const Define_1 = __webpack_require__("af1b");
/**
 * one type shading shader, one WGRPipelineContext instance
 */


class WGRPipelineContext {
  constructor(wgCtx) {
    this.mUid = WGRPipelineContext.sUid++;
    this.mInit = true;
    this.mShader = new WGRPipelineShader_1.WGRPipelineShader();
    this.bindGroupCtx = new WGRBindGroupContext_1.WGRBindGroupContext();
    this.type = "render";
    this.pipeline = new GPURenderPipelineEmpty_1.GPURenderPipelineEmpty();
    this.shadinguuid = "";
    this.name = "PipelineContext";
    this.uniformCtx = new WGRUniformContext_1.WGRUniformContext(false);
    console.log("WGRPipelineContext::constructor() ...");

    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  init() {
    if (this.mInit) {
      this.mInit = false;
      const ctx = this.mWGCtx;
      const p = this.mPipelineParams;

      if (p) {
        this.mShader.build(p, this.rpass); // console.log("WGRPipelineContext::init(), param:\n", p);

        let pipeGLayout;

        if (!this.uniformCtx.isLayoutAuto()) {
          const bindGLayout = this.uniformCtx.getBindGroupLayout(p.multisampleEnabled);
          const bindGroupLayouts = bindGLayout ? [bindGLayout] : [];
          pipeGLayout = ctx.device.createPipelineLayout({
            label: p.label,
            bindGroupLayouts
          }); // console.log("CCCCCCCCCC 01 bindGLayout: ", bindGLayout);
          // console.log("CCCCCCCCCC 02 pipeGLayout: ", pipeGLayout);
          // console.log("CCCCCCCCCC 03 pipeline use spec layout !!!");
        } else {
          pipeGLayout = ctx.device.createPipelineLayout({
            label: p.label,
            bindGroupLayouts: []
          });
        }

        this.bindGroupCtx.rpass = this.rpass;

        if (p.compShaderSrc) {
          const desc = {
            label: this.shadinguuid + "-comp-pl-" + this.mUid,
            layout: pipeGLayout,
            compute: p.compute
          }; // console.log("GPUShaderStage.COMPUTE: ", GPUShaderStage.COMPUTE);

          console.log("WGRPipelineContext::init(), create compute pieline desc: ", desc);
          this.comppipeline = ctx.device.createComputePipeline(desc);
          this.type = "compute";
          this.bindGroupCtx.comppipeline = this.comppipeline;
        } else {
          p.layout = pipeGLayout;
          p.label = this.shadinguuid + "-pl-" + this.mUid;
          console.log("WGRPipelineContext::init(), create rendering pieline desc: ", p);
          this.pipeline = ctx.device.createRenderPipeline(p);
          this.bindGroupCtx.pipeline = this.pipeline;
        }
      }
    }
  }

  destroy() {
    if (this.mWGCtx) {
      this.mWGCtx = null;
    }
  }

  runBegin() {
    this.init();
    this.uniformCtx.runBegin();
  }

  runEnd() {
    this.uniformCtx.runEnd();
  }

  initialize(wgCtx) {
    if (wgCtx && !this.mWGCtx) {
      this.mWGCtx = wgCtx;
      this.queue = wgCtx.queue;
      this.bindGroupCtx.initialize(wgCtx);
      this.uniformCtx.initialize(this.bindGroupCtx);
      this.mShader.initialize(wgCtx);
    }
  }

  getWGCtx() {
    return this.mWGCtx;
  }

  createRenderingPipeline(pipelineParams, descParams, vtxDesc) {
    const ctx = this.mWGCtx;

    if (descParams) {
      // if(!pipelineParams.compShaderSrc) {
      let location = 0;

      for (let k = 0; k < descParams.length; ++k) {
        const vtx = descParams[k].vertex;
        pipelineParams.addVertexBufferLayout({
          arrayStride: vtx.arrayStride,
          attributes: [],
          stepMode: "vertex"
        });
        const params = vtx.params;

        for (let i = 0; i < params.length; ++i) {
          const p = params[i];
          pipelineParams.addVertexBufferAttribute({
            shaderLocation: location++,
            offset: p.offset,
            format: p.format
          }, k);
        }
      }

      if (vtxDesc) {
        const primitive = pipelineParams.primitive;

        if (primitive && vtxDesc.vertex) {
          // console.log("vtxDesc.vertex.drawMode: ", vtxDesc.vertex.drawMode);
          switch (vtxDesc.vertex.drawMode) {
            case Define_1.WGRDrawMode.LINES:
              primitive.topology = "line-list";
              break;

            default:
              break;
          }
        }
      } // }

    }

    return this.createRenderPipeline(pipelineParams);
    /*
    if (pipelineParams.buildDeferred) {
        this.mPipelineParams = pipelineParams;
    } else {
        this.mShader.build(pipelineParams, this.rpass);
    }
    // console.log("createRenderPipeline(), pipelineParams:\n", pipelineParams);
    if (!this.mPipelineParams) {
        this.pipeline = ctx.device.createRenderPipeline(pipelineParams);
    }
    return this.pipeline;
    //*/
  }

  createRenderPipeline(pipelineParams) {
    const ctx = this.mWGCtx;

    if (pipelineParams.buildDeferred) {
      this.mPipelineParams = pipelineParams;
    } else {
      this.mShader.build(pipelineParams, this.rpass);
    } // console.log("createRenderPipeline(), pipelineParams:\n", pipelineParams);


    if (!this.mPipelineParams) {
      this.pipeline = ctx.device.createRenderPipeline(pipelineParams);
    }

    return this.pipeline;
  }

  createRenderPipelineWithBuf(pipelineParams, vtxDesc) {
    if (pipelineParams.compShaderSrc) {
      return this.createRenderPipeline(pipelineParams);
    } else {
      if (vtxDesc) {
        const vtx = vtxDesc.vertex;
        const vtxDescParams = vtx ? this.createRenderPipelineVtxParams(vtx.buffers, vtx.attributeIndicesArray) : [{}]; // console.log("vtxDescParams: ", vtxDescParams);

        return this.createRenderingPipeline(pipelineParams, vtxDescParams, vtxDesc);
      } else {
        return this.createRenderingPipeline(pipelineParams, [{}]);
      }
    }
  }

  createRenderPipelineVtxParam(vtxBuf, attributeIndices) {
    const p = {
      vertex: {
        arrayStride: vtxBuf.arrayStride,
        params: []
      }
    };
    const params = p.vertex.params;
    const ls = attributeIndices;

    for (let i = 0; i < attributeIndices.length; ++i) {
      params.push({
        offset: vtxBuf.vectorOffsets[ls[i]],
        format: vtxBuf.vectorFormats[ls[i]]
      });
    }

    return p;
  }

  createRenderPipelineVtxParams(vtxBufs, attributeIndicesArray) {
    const ls = new Array(attributeIndicesArray.length);

    for (let i = 0; i < attributeIndicesArray.length; ++i) {
      ls[i] = this.createRenderPipelineVtxParam(vtxBufs[i], attributeIndicesArray[i]);
    }

    return ls;
  }

}

WGRPipelineContext.sUid = 0;
exports.WGRPipelineContext = WGRPipelineContext;

/***/ }),

/***/ "374c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
;

/***/ }),

/***/ "37b8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function texDescriptorFilter(d) {
  if (!d) {
    return d;
  }

  let rd = d;

  if (d.diffuse) {
    rd = d.diffuse;
    rd.shdVarName = "diffuse";
  }

  if (d.color) {
    rd = d.color;
    rd.shdVarName = "color";
  }

  if (d.albedo) {
    rd = d.albedo;
    rd.shdVarName = "albedo";
  }

  if (d.normal) {
    rd = d.normal;
    rd.shdVarName = "normal";
  }

  if (d.ao) {
    rd = d.ao;
    rd.shdVarName = "ao";
  }

  if (d.metallic) {
    rd = d.metallic;
    rd.shdVarName = "metallic";
  }

  if (d.roughness) {
    rd = d.roughness;
    rd.shdVarName = "roughness";
  }

  if (d.specularEnv) {
    rd = d.specularEnv;
    rd.shdVarName = "specularEnv";
  }

  if (d.arm) {
    rd = d.arm;
    rd.shdVarName = "arm";
  }

  if (d.parallax) {
    rd = d.parallax;
    rd.shdVarName = "parallax";
  } // if (d.height) {
  // 	rd = d.height;
  // 	rd.shdVarName = "height";
  // }


  if (d.displacement) {
    rd = d.displacement;
    rd.shdVarName = "displacement";
  }

  if (d.specular) {
    rd = d.specular;
    rd.shdVarName = "specular";
  }

  return rd;
}

exports.texDescriptorFilter = texDescriptorFilter;

/***/ }),

/***/ "37f2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__("660c");

const math_1 = __webpack_require__("89ff"); // thanks: https://github.com/vilyLei/cts/blob/main/src/webgpu/util/conversion.ts

/**
 * Encodes three JS `number` values into RGB9E5, returned as an integer-valued JS `number`.
 *
 * RGB9E5 represents three partial-precision floating-point numbers encoded into a single 32-bit
 * value all sharing the same 5-bit exponent.
 * There is no sign bit, and there is a shared 5-bit biased (15) exponent and a 9-bit
 * mantissa for each channel. The mantissa does NOT have an implicit leading "1.",
 * and instead has an implicit leading "0.".
 *
 * @see https://registry.khronos.org/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt
 */


function packRGB9E5UFloat(r, g, b) {
  const N = 9; // number of mantissa bits

  const Emax = 31; // max exponent

  const B = 15; // exponent bias

  const sharedexp_max = ((1 << N) - 1) / (1 << N) * 2 ** (Emax - B);
  const red_c = math_1.clamp(r, {
    min: 0,
    max: sharedexp_max
  });
  const green_c = math_1.clamp(g, {
    min: 0,
    max: sharedexp_max
  });
  const blue_c = math_1.clamp(b, {
    min: 0,
    max: sharedexp_max
  });
  const max_c = Math.max(red_c, green_c, blue_c);
  const exp_shared_p = Math.max(-B - 1, Math.floor(Math.log2(max_c))) + 1 + B;
  const max_s = Math.floor(max_c / 2 ** (exp_shared_p - B - N) + 0.5);
  const exp_shared = max_s === 1 << N ? exp_shared_p + 1 : exp_shared_p;
  const scalar = 1 / 2 ** (exp_shared - B - N);
  const red_s = Math.floor(red_c * scalar + 0.5);
  const green_s = Math.floor(green_c * scalar + 0.5);
  const blue_s = Math.floor(blue_c * scalar + 0.5);
  util_1.assert(red_s >= 0 && red_s <= 0b111111111);
  util_1.assert(green_s >= 0 && green_s <= 0b111111111);
  util_1.assert(blue_s >= 0 && blue_s <= 0b111111111);
  util_1.assert(exp_shared >= 0 && exp_shared <= 0b11111);
  return (exp_shared << 27 | blue_s << 18 | green_s << 9 | red_s) >>> 0;
}

exports.packRGB9E5UFloat = packRGB9E5UFloat;

/***/ }),

/***/ "381c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

class FixScreenPlaneTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("FixScreenPlaneTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity().setColor([0.2, 0.5, 0.7]);
    rc.addEntity(entity);
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, 0.1, 0.5, 0.5]
    }).setColor([0.2, 0.8, 0.3]);
    rc.addEntity(entity);
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 0.8, 0.8],
      textures: [diffuseTex]
    });
    entity.setColor([0.1, 0.3, 0.9]);
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.FixScreenPlaneTest = FixScreenPlaneTest;

/***/ }),

/***/ "3850":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function checkMaterialRPasses(ms, rpasses) {
  // const rpasses = param.rpasses;
  if (rpasses) {
    const ms = this.materials; // 这里的实现需要优化, 因为一个material实际上可以加入到多个rpass中去

    let len = Math.min(rpasses.length, ms.length);

    for (let i = 0; i < len; ++i) {
      const rpass = ms[i].rpass;

      if (!rpass || !rpass.rpass.node) {
        ms[i].rpass = rpasses[i];
      }
    }
  }
}

exports.checkMaterialRPasses = checkMaterialRPasses;

/***/ }),

/***/ "395b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\r\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>\r\n}\r\n\r\nfn inverseM33(m: mat3x3<f32>)-> mat3x3<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2];\r\n    let b01 = a22 * a11 - a12 * a21;\r\n    let b11 = -a22 * a10 + a12 * a20;\r\n    let b21 = a21 * a10 - a11 * a20;\r\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3x3<f32>(\r\n\t\tvec3<f32>(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11)) / det,\r\n                vec3<f32>(b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det,\r\n                vec3<f32>(b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det);\r\n}\r\nfn m44ToM33(m: mat4x4<f32>) -> mat3x3<f32> {\r\n\treturn mat3x3(m[0].xyz, m[1].xyz, m[2].xyz);\r\n}\r\n\r\nfn inverseM44(m: mat4x4<f32>)-> mat4x4<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\r\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\r\n    let b00 = a00 * a11 - a01 * a10;\r\n    let b01 = a00 * a12 - a02 * a10;\r\n    let b02 = a00 * a13 - a03 * a10;\r\n    let b03 = a01 * a12 - a02 * a11;\r\n    let b04 = a01 * a13 - a03 * a11;\r\n    let b05 = a02 * a13 - a03 * a12;\r\n    let b06 = a20 * a31 - a21 * a30;\r\n    let b07 = a20 * a32 - a22 * a30;\r\n    let b08 = a20 * a33 - a23 * a30;\r\n    let b09 = a21 * a32 - a22 * a31;\r\n    let b10 = a21 * a33 - a23 * a31;\r\n    let b11 = a22 * a33 - a23 * a32;\r\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\treturn mat4x4<f32>(\r\n\t\tvec4<f32>(a11 * b11 - a12 * b10 + a13 * b09,\r\n\t\ta02 * b10 - a01 * b11 - a03 * b09,\r\n\t\ta31 * b05 - a32 * b04 + a33 * b03,\r\n\t\ta22 * b04 - a21 * b05 - a23 * b03) / det,\r\n\t\t\tvec4<f32>(a12 * b08 - a10 * b11 - a13 * b07,\r\n\t\ta00 * b11 - a02 * b08 + a03 * b07,\r\n\t\ta32 * b02 - a30 * b05 - a33 * b01,\r\n\t\ta20 * b05 - a22 * b02 + a23 * b01) / det,\r\n\t\tvec4<f32>(a10 * b10 - a11 * b08 + a13 * b06,\r\n\t\ta01 * b08 - a00 * b10 - a03 * b06,\r\n\t\ta30 * b04 - a31 * b02 + a33 * b00,\r\n\t\ta21 * b02 - a20 * b04 - a23 * b00) / det,\r\n\t\tvec4<f32>(a11 * b07 - a10 * b09 - a12 * b06,\r\n\t\ta00 * b09 - a01 * b07 + a02 * b06,\r\n\t\ta31 * b01 - a30 * b03 - a32 * b00,\r\n\t\ta20 * b03 - a21 * b01 + a22 * b00) / det);\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>\r\n) -> VertexOutput {\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * objMat * vec4(position.xyz, 1.0);\r\n  output.uv = uv;\r\n\r\n  let invMat33 = inverseM33( m44ToM33( objMat ) );\r\n  output.normal = normalize( normal * invMat33 );\r\n\r\n  var pv: vec4<f32>;\r\n  pv = vec4<f32>(position, 1.0);\r\n  output.pos = pv;\r\n  return output;\r\n}\r\n");

/***/ }),

/***/ "3963":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RViewElement_1 = __importDefault(__webpack_require__("a5b0"));

const ContextMouseEvtDispatcher_1 = __importDefault(__webpack_require__("0f9f"));

class RAdapterContext {
  constructor() {
    this.mSysEvt = new ContextMouseEvtDispatcher_1.default();
    this.mDiv = null;
    this.mCanvas = null;
    this.m_offcanvas = null;
    this.mStage = null;
    this.m_dpr = 1.0;
    this.m_viewEle = new RViewElement_1.default();
    this.m_resizeFlag = true;
  }

  getDiv() {
    return this.mDiv;
  }

  getCanvas() {
    return this.m_offcanvas ? this.m_offcanvas : this.mCanvas;
  }

  setDivStyleLeftAndTop(px, py) {
    this.m_viewEle.setDivStyleLeftAndTop(px, py);
  }

  setDivStyleSize(pw, ph) {
    this.m_viewEle.setDivStyleSize(pw, ph);
  }

  initialize(param) {
    this.mStage = param.stage;
    this.mDiv = param.div;
    this.m_viewEle.setDiv(param.div);
    this.setCanvas(param.canvas);
  }

  setCanvas(canvas) {
    let c0 = this.mCanvas;
    this.m_viewEle.setCanvas(canvas);
    let c1 = this.m_viewEle.getCanvas();

    if (c0 != c1) {
      this.m_offcanvas = null;
      this.mCanvas = c1;
      this.initEvt();
    }

    return c0 != c1;
  }

  initEvt() {
    this.mSysEvt.initialize(this.mCanvas, this.mDiv, this.mStage);
  }

  getStage() {
    return this.mStage;
  }

  getStageWidth() {
    return this.mStage.stageWidth;
  }

  getStageHeight() {
    return this.mStage.stageHeight;
  }

}

exports.RAdapterContext = RAdapterContext;

/***/ }),

/***/ "3cf9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const KeyboardEvent_1 = __importDefault(__webpack_require__("bcc5"));

class Keyboard {
  static KeyDown(evt) {
    var len = Keyboard.m_down_listener.length; //console.log("KeyDown(), m_down_listener.length: ",len);

    for (var i = 0; i < len; ++i) {
      Keyboard.m_down_listener[i].call(Keyboard.m_down_ers[i], evt);
    }
  }

  static KeyUp(evt) {
    let len = Keyboard.m_up_listener.length; //console.log("KeyUp(), m_up_listener.length: ",len);

    for (let i = 0; i < len; ++i) {
      Keyboard.m_up_listener[i].call(Keyboard.m_up_ers[i], evt);
    }
  }

  static AddEventListener(type, target, func) {
    if (func != null) {
      let i = 0;

      switch (type) {
        case KeyboardEvent_1.default.KEY_DOWN:
          for (i = Keyboard.m_down_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_down_listener[i]) {
              break;
            }
          }

          if (i < 0) {
            Keyboard.m_down_ers.push(target);
            Keyboard.m_down_listener.push(func);
          }

          break;

        case KeyboardEvent_1.default.KEY_UP:
          for (i = Keyboard.m_up_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_up_listener[i]) {
              break;
            }
          }

          if (i < 0) {
            Keyboard.m_up_ers.push(target);
            Keyboard.m_up_listener.push(func);
          }

          break;

        default:
          break;
      }
    }
  }

  static RemoveEventListener(type, func) {
    if (func != null) {
      let i;

      switch (type) {
        case KeyboardEvent_1.default.KEY_DOWN:
          for (i = Keyboard.m_down_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_down_listener[i]) {
              Keyboard.m_down_ers.splice(i, 1);
              Keyboard.m_down_listener.splice(i, 1);
              break;
            }
          }

          break;

        case KeyboardEvent_1.default.KEY_UP:
          for (i = Keyboard.m_up_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_up_listener[i]) {
              Keyboard.m_up_ers.splice(i, 1);
              Keyboard.m_up_listener.splice(i, 1);
              break;
            }
          }

          break;

        default:
          break;
      }
    }
  }

}

Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.ESC = 27;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.m_down_ers = [];
Keyboard.m_down_listener = [];
Keyboard.m_up_ers = [];
Keyboard.m_up_listener = [];
exports.default = Keyboard;

/***/ }),

/***/ "3e26":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const RadialLine_1 = __importDefault(__webpack_require__("c3d6"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const Define_1 = __webpack_require__("af1b");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const __$v3 = new Vector3_1.default();

const __$c4 = new Color4_1.default();

class DashedLineGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.mLSTotal = 0;
    this.dashedData = false;
    /**
     * line thinkness radius
     */

    this.lineRadius = 2.0;
    this.mPolyhedral = false;
    this.drawMode = Define_1.WGRDrawMode.LINES;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getCVS() {
    return this.mcvs;
  }

  getIVS() {
    return this.mivs;
  }

  initialize(positions, colors) {
    const v3 = new Vector3_1.default();
    const c4 = new Color4_1.default();
    let j = 0;

    if (this.dashedData) {
      this.mvs = new Float32Array(positions.length * 3);

      for (let i = 0; i < positions.length; ++i) {
        if (positions[i]) {
          v3.setVector3(positions[i]).toArray3(this.mvs, j++ * 3);
        }
      }
    } else {
      this.mvs = new Float32Array(positions.length > 2 ? ((positions.length - 2) * 2 + 2) * 3 : positions.length * 3);

      for (let i = 0; i < positions.length; ++i) {
        if (positions[i]) {
          v3.setVector3(positions[i]).toArray3(this.mvs, j++ * 3);

          if (i > 0 && i < positions.length - 1) {
            v3.setVector3(positions[i]).toArray3(this.mvs, j++ * 3);
          }
        }
      }
    }

    if (colors) {
      j = 0;

      if (this.dashedData) {
        this.mcvs = new Float32Array(colors.length * 3);

        for (let i = 0; i < colors.length; ++i) {
          if (colors[i]) {
            c4.setColor(colors[i]).toArray3(this.mcvs, j++ * 3);
          }
        }
      } else {
        this.mcvs = new Float32Array(colors.length > 2 ? ((colors.length - 2) * 2 + 2) * 3 : colors.length * 3);

        for (let i = 0; i < colors.length; ++i) {
          if (colors[i]) {
            c4.setColor(colors[i]).toArray3(this.mcvs, j++ * 3);

            if (i > 0 && i < colors.length - 1) {
              c4.setColor(colors[i]).toArray3(this.mcvs, j++ * 3);
            }
          }
        }
      }
    } // console.log("this.mvs: ", this.mvs);
    // console.log(this.mcvs);


    if (!this.bounds) this.bounds = new AABB_1.default();
    this.bounds.addFloat32Arr(this.mvs);
    this.bounds.updateFast();
    this.trisNumber = 0;
    this.vtCount = Math.floor(this.mvs.length / 3);
    this.mLSTotal = Math.floor(this.vtCount / 2);
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mcvs = null;

      super.__$destroy();
    }
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    const DL = DashedLineGeometry;
    let j = 0;
    const vs = this.mvs;
    let flag = 0;
    const radius = this.lineRadius;
    const pv0 = DL.sPv0;
    const pv1 = DL.sPv1;

    for (let i = 0; i < this.mLSTotal; ++i) {
      pv0.setXYZ(vs[j], vs[j + 1], vs[j + 2]);
      pv1.setXYZ(vs[j + 3], vs[j + 4], vs[j + 5]);
      flag = RadialLine_1.default.IntersectionLS(rlpv, rltv, pv0, pv1, outV, radius);

      if (flag > 0) {
        return 1;
      }

      j += 6;
    }

    return 0;
  }

}

DashedLineGeometry.sPv0 = new Vector3_1.default();
DashedLineGeometry.sPv1 = new Vector3_1.default();
exports.default = DashedLineGeometry;

/***/ }),

/***/ "3e2f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "3e40":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class AABB {
  constructor() {
    this.m_long = 100.0;
    this.m_width = 100.0;
    this.m_height = 100.0;
    this.m_halfLong = 50.0;
    this.m_halfWidth = 50.0;
    this.m_halfHeight = 50.0;
    this.m_tempV = new Vector3_1.default();
    this.version = -1;
    this.radius = 50;
    this.radius2 = 2500;
    this.min = new Vector3_1.default();
    this.max = new Vector3_1.default();
    this.center = new Vector3_1.default();
    this.reset();
  }

  getLong() {
    return this.m_long;
  }

  getWidth() {
    return this.m_width;
  }

  getHeight() {
    return this.m_height;
  }

  reset() {
    const v0 = this.min;
    const v1 = this.max;
    v0.x = v0.y = v0.z = MathConst_1.default.MATH_MAX_POSITIVE;
    v1.x = v1.y = v1.z = MathConst_1.default.MATH_MIN_NEGATIVE;
  }

  equals(ab) {
    return this.min.equalsXYZ(ab.min) && this.max.equalsXYZ(ab.max);
  }

  setVolume(width, height, long) {
    this.m_width = width;
    this.m_height = height;
    this.m_long = long;
    this.m_halfLong = 0.5 * this.m_long;
    this.m_halfWidth = 0.5 * this.m_width;
    this.m_halfHeight = 0.5 * this.m_height;
    this.max.x = this.center.x + this.m_halfWidth;
    this.max.y = this.center.y + this.m_halfHeight;
    this.max.z = this.center.z + this.m_halfLong;
    this.min.x = this.center.x - this.m_halfWidth;
    this.min.y = this.center.y - this.m_halfHeight;
    this.min.z = this.center.z - this.m_halfLong;
    this.radius2 = this.m_halfWidth * this.m_halfWidth + this.m_halfHeight * this.m_halfHeight + this.m_halfLong * this.m_halfLong;
    this.radius = Math.sqrt(this.radius2);
  }

  union(ab) {
    this.addPosition(ab.min);
    this.addPosition(ab.max);
    return this;
  }

  addPosition(pv) {
    this.addXYZ(pv.x, pv.y, pv.z);
    return this;
  }

  addXYZ(pvx, pvy, pvz) {
    const min = this.min;
    const max = this.max;
    if (min.x > pvx) min.x = pvx;
    if (max.x < pvx) max.x = pvx;
    if (min.y > pvy) min.y = pvy;
    if (max.y < pvy) max.y = pvy;
    if (min.z > pvz) min.z = pvz;
    if (max.z < pvz) max.z = pvz;
  }

  addFloat32Arr(vs, step = 3) {
    let len = vs.length;

    if (step >= 3) {
      for (let i = 0; i < len;) {
        this.addXYZ(vs[i], vs[i + 1], vs[i + 2]);
        i += step;
      }
    }

    if (step == 2) {
      for (let i = 0; i < len;) {
        this.addXYZ(vs[i], vs[i + 1], 0.0);
        i += step;
      }
    }
  }

  addFloat32AndIndices(vs, indices, step = 3) {
    let len = indices.length;
    let i;

    if (step >= 3) {
      for (let k = 0; k < len; k++) {
        i = indices[k] * step;
        this.addXYZ(vs[i++], vs[i++], vs[i]);
      }
    } else if (step == 2) {
      for (let k = 0; k < len; k++) {
        i = indices[k] * step;
        this.addXYZ(vs[i++], vs[i], 0.0);
      }
    }
  }

  getClosePosition(in_pos, out_pos, bias = 0.0) {
    const min = this.min;
    const max = this.max;
    out_pos.copyFrom(in_pos);

    if (out_pos.x < min.x) {
      out_pos.x = min.x + bias;
    } else if (out_pos.x > max.x) {
      out_pos.x = max.x - bias;
    }

    if (out_pos.y < min.y) {
      out_pos.y = min.y + bias;
    } else if (out_pos.y > max.y) {
      out_pos.y = max.y - bias;
    }

    if (out_pos.z < min.z) {
      out_pos.z = min.z + bias;
    } else if (out_pos.z > max.z) {
      out_pos.z = max.z - bias;
    }
  } // @param	v	Vector3 instance


  containsV(v) {
    if (v.x < this.min.x || v.x > this.max.x) return false;
    if (v.y < this.min.y || v.y > this.max.y) return false;
    if (v.z < this.min.z || v.z > this.max.z) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsXY(vx, vy) {
    if (vx < this.min.x || vx > this.max.x) return false;
    if (vy < this.min.y || vy > this.max.y) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsXZ(vx, vz) {
    if (vx < this.min.x || vx > this.max.x) return false;
    if (vz < this.min.z || vz > this.max.z) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsYZ(vy, vz) {
    if (vy < this.min.y || vy > this.max.y) return false;
    if (vz < this.min.z || vz > this.max.z) return false;
    return true;
  }

  copyFrom(ab) {
    //this.setRadius(ab.getRadius());
    this.radius = ab.radius;
    this.radius2 = ab.radius2; //this.setRadiusSquared(ab.getRadiusSquared());

    this.min.copyFrom(ab.min);
    this.max.copyFrom(ab.max); //this.getOCenter().copyFrom(ab.getOCenter());

    this.center.copyFrom(ab.center);
    this.updateVolume();
    this.version = ab.version;
    return this;
  }

  expand(bias) {
    this.min.subtractBy(bias);
    this.max.addBy(bias);
    return this;
  }

  updateVolume() {
    this.m_width = this.max.x - this.min.x;
    this.m_height = this.max.y - this.min.y;
    this.m_long = this.max.z - this.min.z;
    this.m_halfLong = 0.5 * this.m_long;
    this.m_halfWidth = 0.5 * this.m_width;
    this.m_halfHeight = 0.5 * this.m_height;
    ++this.version;
    return this;
  }

  updateThis() {
    this.center.x = 0.5 * this.m_width;
    this.center.y = 0.5 * this.m_height;
    this.center.z = 0.5 * this.m_long;
    this.m_halfLong = this.center.z;
    this.m_halfWidth = this.center.x;
    this.m_halfHeight = this.center.y;
    this.radius2 = this.m_halfWidth * this.m_halfWidth + this.m_halfHeight * this.m_halfHeight + this.m_halfLong * this.m_halfLong;
    this.radius = Math.sqrt(this.radius2);
    this.center.addBy(this.min);
    ++this.version;
  }

  update() {
    // x
    this.m_width = this.max.x;

    if (this.min.x > this.max.x) {
      this.max.x = this.min.x;
      this.min.x = this.m_width;
    }

    this.m_width = this.max.x - this.min.x; // y

    this.m_height = this.max.y;

    if (this.min.y > this.max.y) {
      this.max.y = this.min.y;
      this.min.y = this.m_height;
    }

    this.m_height = this.max.y - this.min.y; // z

    this.m_long = this.max.z;

    if (this.min.z > this.max.z) {
      this.max.z = this.min.z;
      this.min.z = this.m_long;
    }

    this.m_long = this.max.z - this.min.z;
    this.updateThis();
  }

  updateFast() {
    this.m_width = this.max.x - this.min.x;
    this.m_height = this.max.y - this.min.y;
    this.m_long = this.max.z - this.min.z;
    this.updateThis();
  }

  toString() {
    return "[AABB(min->" + this.min + ",size(" + this.m_width + "," + this.m_height + "," + this.m_long + "))]";
  } // max vecs sphere range intersect calc


  sphereIntersect(centerV, radius) {
    this.m_tempV.x = this.center.x - centerV.x;
    this.m_tempV.y = this.center.y - centerV.y;
    this.m_tempV.z = this.center.z - centerV.z;
    let dis = this.m_tempV.getLengthSquared();

    if (dis < this.radius2) {
      return true;
    }

    radius += this.radius;
    radius *= radius;
    return radius >= dis;
  }

}

exports.default = AABB;

/***/ }),

/***/ "3f99":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var mySampler: sampler;\r\n@group(0) @binding(4) var myTexture: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragUV: vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  return textureSample(myTexture, mySampler, fragUV) * fragPosition;\r\n}\r\n");

/***/ }),

/***/ "406a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const IdentityMat4Data = new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);
exports.IdentityMat4Data = IdentityMat4Data;

/***/ }),

/***/ "4145":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRUnitState_1 = __webpack_require__("222c");

class WGREntityNode {
  constructor() {
    this.blockid = -1;
    this.entityid = -1;
    this.rstate = new WGRUnitState_1.WGRUnitState();
  }

}

exports.WGREntityNode = WGREntityNode;

/***/ }),

/***/ "4173":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const WGRPassNodeGraph_1 = __webpack_require__("f083");

const rttTex0 = {
  diffuse: {
    uuid: 'rtt0',
    rttTexture: {}
  }
};
const rttTex1 = {
  diffuse: {
    uuid: 'rtt1',
    rttTexture: {}
  }
};
const attachment0 = {
  texture: rttTex0,
  clearValue: [],
  loadOp: "clear",
  storeOp: "store"
};
const attachment1 = {
  texture: rttTex1,
  clearValue: []
};
const colorAttachments = [attachment0];

class PassGraph extends WGRPassNodeGraph_1.WGRPassNodeGraph {
  constructor() {
    super();
    this.mTimes = 0;
  }

  runBegin() {
    super.runBegin();
  }

  run() {
    this.mTimes++;

    if (this.mTimes == 50) {
      const replaceColorAttachment = true;

      if (replaceColorAttachment) {
        // replace color attachment
        attachment1.clearValue = [0.2, 0.5, 0.2];
        colorAttachments[0] = attachment1;
      } else {
        // replace texture
        colorAttachments[0].texture = rttTex1;
      }
    }

    let pass = this.passes[0];

    for (let i = 0; i < 1; ++i) {
      pass.colorAttachments[0].clearEnabled = i < 1;
      pass.render();
    }
  }

}

class ColorAttachmentReplace {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mGraph = new PassGraph();
  }

  initialize() {
    console.log("ColorAttachmentReplace::initialize() ...");
    let multisampleEnabled = true;
    let depthTestEnabled = false;
    let rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam
    });
    this.initEvent();
    this.initScene();
  }

  applyRTTPass(clearColor, extent = [0.4, 0.3, 0.5, 0.5]) {
    let rs = this.mRscene;
    const graph = this.mGraph;
    attachment0.clearValue = clearColor;
    attachment1.clearValue = clearColor;
    let rPass = rs.renderer.appendRenderPass({
      separate: true,
      colorAttachments
    });
    const diffuseTex = {
      diffuse: {
        url: "static/assets/huluwa.jpg",
        flipY: true
      }
    };
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 1.6, 1.6],
      textures: [diffuseTex]
    });
    rPass.addEntity(rttEntity);
    graph.passes = [rPass];
    rs.setPassNodeGraph(graph);
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [rttTex0]
    });
    rs.addEntity(entity);
    extent = [-0.9, -0.9, 1.2, 1.2];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [rttTex1]
    });
    rs.addEntity(entity);
  }

  initEvent() {
    const rs = this.mRscene;
    new MouseInteraction_1.MouseInteraction().initialize(rs, 0, false).setAutoRunning(true);
  }

  initScene() {
    this.applyRTTPass([0.1, 0.1, 0.1, 1.0], [-0.8, -0.8, 1.6, 1.6]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.ColorAttachmentReplace = ColorAttachmentReplace;

/***/ }),

/***/ "4255":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const SurfaceNormalCalc_1 = __importDefault(__webpack_require__("e38f"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const GeometryVertex_1 = __importDefault(__webpack_require__("98bb"));

class CylinderGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
    this.inverseUV = false;
    this.uScale = 1.0;
    this.vScale = 1.0;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getNVS() {
    return this.mnvs;
  }

  getIVS() {
    return this.mivs;
  }

  initialize(radius, height, longitudeNumSegments, latitudeNumSegments, uvType = 1, alignYRatio = -0.5) {
    if (this.vtxTotal < 1) {
      if (radius < 0.01) return;
      if (longitudeNumSegments < 2) longitudeNumSegments = 2;
      latitudeNumSegments = 3;
      let mRadius = Math.abs(radius);
      let m_height = Math.abs(height);
      let plongitudeNumSegments = longitudeNumSegments;
      let platitudeNumSegments = latitudeNumSegments;
      let i = 1;
      let j = 0;
      let trisTot = 0;
      let yRad = 0;
      let px = 0;
      let py = 0;
      let minY = alignYRatio * m_height;
      this.bounds = new AABB_1.default();
      this.bounds.min.setXYZ(-radius, minY, -radius);
      this.bounds.max.setXYZ(radius, minY + m_height, radius);
      this.bounds.updateFast();
      let vtx = new GeometryVertex_1.default();
      vtx.y = minY; // two independent circles and a cylinder wall

      let vtxVec = [];
      let vtxRows = [];
      vtxRows.push([]);
      let vtxRow = vtxRows[0];
      vtx.u = 0.5;
      vtx.v = 0.5;
      vtx.nx = 0.0;
      vtx.ny = -1.0;
      vtx.nz = 0.0;
      vtxRow.push(vtx.cloneVertex());
      vtxVec.push(vtxRow[0]);

      for (; i < platitudeNumSegments; ++i) {
        vtx.y = minY + m_height * (i - 1);
        vtxRows.push([]);
        let row = vtxRows[i];

        for (j = 0; j < plongitudeNumSegments; ++j) {
          yRad = Math.PI * 2 * j / plongitudeNumSegments;
          ++trisTot;
          px = Math.sin(yRad);
          py = Math.cos(yRad);
          vtx.x = px * mRadius;
          vtx.z = py * mRadius;
          vtx.index = trisTot; // calc uv

          px *= 0.495;
          py *= 0.495;
          vtx.u = 0.5 + px;
          vtx.v = 0.5 + py;

          if (i < 2) {
            vtx.nx = 0.0;
            vtx.ny = -1.0;
            vtx.nz = 0.0;
          } else {
            vtx.nx = 0.0;
            vtx.ny = 1.0;
            vtx.nz = 0.0;
          }

          row.push(vtx.cloneVertex());
          vtxVec.push(row[j]);
        }

        row.push(row[0]);
      }

      ++trisTot;
      vtx.index = trisTot;
      vtx.x = 0;
      vtx.y = minY + m_height;
      vtx.z = 0.0;
      vtx.u = 0.5;
      vtx.v = 0.5;
      vtx.nx = 0.0;
      vtx.ny = 1.0;
      vtx.nz = 0.0;
      vtxRows.push([]);
      let lastRow = vtxRows[3];
      lastRow.push(vtx.cloneVertex());
      vtxVec.push(lastRow[0]); // two circles's vertexes calc end;
      // calc cylinder wall vertexes

      let f = 1.0 / mRadius;

      for (i = 0; i < 2; ++i) {
        let preRow = vtxRows[i + 1];
        vtxRows.push([]);
        let row = vtxRows[vtxRows.length - 1];

        for (j = 0; j <= plongitudeNumSegments; ++j) {
          ++trisTot;
          vtx.copyFrom(preRow[j]);
          vtx.index = trisTot;

          if (uvType < 1) {
            if (i < 1) {
              vtx.v = 0.0;
            } else {
              vtx.v = this.vScale;
            }

            vtx.u = this.uScale * (j / plongitudeNumSegments);
          } else {
            if (i < 1) {
              vtx.u = 0.0;
            } else {
              vtx.u = this.uScale;
            }

            vtx.v = this.vScale * (j / plongitudeNumSegments);
          }

          vtx.ny = 0.0;
          vtx.nx = vtx.x * f;
          vtx.nz = vtx.z * f;
          row.push(vtx.cloneVertex());
          vtxVec.push(row[j]);
        }
      }

      let pvtx = null;
      let pivs = [];
      i = 1;
      let rowa = null;
      let rowb = null;

      for (; i <= platitudeNumSegments; ++i) {
        rowa = vtxRows[i - 1];
        rowb = vtxRows[i];

        for (j = 1; j <= plongitudeNumSegments; ++j) {
          if (i == 1) {
            pivs.push(rowa[0].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          } else if (i == platitudeNumSegments) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[0].index);
            pivs.push(rowa[j - 1].index);
          }
        }
      } // create cylinder wall triangles


      rowa = vtxRows[vtxRows.length - 2];
      rowb = vtxRows[vtxRows.length - 1];

      for (j = 1; j <= plongitudeNumSegments; ++j) {
        pivs.push(rowa[j].index);
        pivs.push(rowb[j - 1].index);
        pivs.push(rowa[j - 1].index);
        pivs.push(rowa[j].index);
        pivs.push(rowb[j].index);
        pivs.push(rowb[j - 1].index);
      }

      this.vtxTotal = vtxVec.length;
      this.mvs = new Float32Array(this.vtxTotal * 3);
      i = 0;

      for (j = 0; j < this.vtxTotal; ++j) {
        pvtx = vtxVec[j];
        this.mvs[i] = pvtx.x;
        this.mvs[i + 1] = pvtx.y;
        this.mvs[i + 2] = pvtx.z;
        i += 3;
      }

      if (this.mTransMatrix != null) {
        this.mTransMatrix.transformVectorsSelf(this.mvs, this.mvs.length);
        this.bounds.addFloat32Arr(this.mvs);
        this.bounds.updateFast();
      }

      this.mivs = new Uint16Array(pivs);
      this.vtCount = this.mivs.length;
      this.trisNumber = this.vtCount / 3;

      if (true) {
        this.muvs = new Float32Array(this.vtxTotal * 2);
        i = 0;

        for (j = 0; j < this.vtxTotal; ++j) {
          pvtx = vtxVec[j];
          this.muvs[i] = pvtx.u;
          this.muvs[i + 1] = pvtx.v;
          i += 2;
        }
      }

      if (true) {
        this.mnvs = new Float32Array(this.vtxTotal * 3);

        if (this.mTransMatrix != null) {
          SurfaceNormalCalc_1.default.ClacTrisNormal(this.mvs, this.mvs.length, this.trisNumber, this.mivs, this.mnvs);
        } else {
          i = 0;

          for (j = 0; j < this.vtxTotal; ++j) {
            pvtx = vtxVec[j];
            this.mnvs[i] = pvtx.nx;
            this.mnvs[i + 1] = pvtx.ny;
            this.mnvs[i + 2] = pvtx.nz;
            i += 3;
          }
        }
      }

      this.vtCount = this.mivs.length;
      this.trisNumber = this.vtCount / 3;
    }
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;

      super.__$destroy();
    }
  }

}

exports.default = CylinderGeometry;

/***/ }),

/***/ "425a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseInteraction_1 = __webpack_require__("213f");

const DataDrivenRScene_1 = __webpack_require__("56f9");

const HttpFileLoader_1 = __webpack_require__("2fc9");

class DataDrivenTest {
  constructor() {
    this.mScene = new DataDrivenRScene_1.DataDrivenRScene();
  }

  initialize() {
    console.log("DataDrivenTest::initialize() ...");
    let url = "static/assets/scene/sceneData01.json";
    new HttpFileLoader_1.HttpFileLoader().loadJson(url, (json, url) => {
      console.log("json: ", json);
      this.initScene(json);
    });
  }

  initScene(json) {
    this.mScene.initialize(json);
    this.initEvent();
  }

  initEvent() {
    const rc = this.mScene;
    new MouseInteraction_1.MouseInteraction().initialize(rc.rscene, 0, false).setAutoRunning(true);
  }

  run() {
    this.mScene.run();
  }

}

exports.DataDrivenTest = DataDrivenTest;

/***/ }),

/***/ "46a3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

class RTTTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("RTTTest::initialize() ...");
    this.applyRTT();
    this.initScene();
  }

  applyRTT() {
    let rc = this.mRscene; // rtt texture proxy descriptor

    let rttTex = {
      uuid: "rtt0",
      rttTexture: {}
    }; // define a rtt pass color colorAttachment0

    let colorAttachments = [{
      texture: rttTex,
      // green clear background color
      clearValue: {
        r: 0.1,
        g: 0.9,
        b: 0.1,
        a: 1.0
      },
      loadOp: "clear",
      storeOp: "store"
    }]; // create a separate rtt rendering pass

    let rPass = rc.createRTTPass({
      colorAttachments
    });
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let extent = [-0.5, -0.5, 0.8, 0.8];
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [diffuseTex]
    }).setColor([1.0, 0.0, 0.0]); // 往pass中添加可渲染对象

    rPass.addEntity(rttEntity); // 使用rtt纹理

    extent = [0.3, 0.3, 0.6, 0.6];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [{
        diffuse: rttTex
      }]
    });
    rc.addEntity(entity);
  }

  initScene() {
    const rc = this.mRscene;
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let extent = [-0.9, 0.0, 0.5, 0.5];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent
    }).setColor([0.2, 0.5, 0.7]);
    rc.addEntity(entity);
    extent = [-0.8, -0.8, 0.8, 0.8];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [diffuseTex]
    }).setColor([0.1, 0.3, 0.9]);
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.RTTTest = RTTTest;

/***/ }),

/***/ "4942":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const Plane_1 = __importDefault(__webpack_require__("7a70"));

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const minv = MathConst_1.default.MATH_MIN_POSITIVE;
const maxv = MathConst_1.default.MATH_MAX_NEGATIVE;

class Frustum {
  constructor() {
    this.mTempV = new Vector3_1.default();
    this.mTempV1 = new Vector3_1.default();
    this.mFpns = [new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default()];
    this.mFpds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    this.near = 0.1;
    this.far = 5000;
    this.aspect = 1;
    /**
     * fov radian value
     */

    this.fov = Math.PI * 0.25;
    this.perspective = true;
    this.viewWidth = 800;
    this.viewHeight = 600;
    this.viewHalfWidth = 400;
    this.viewHalfHeight = 300;
    this.bounds = new AABB_1.default();
    this.nearHalfWidth = 0.5;
    this.nearHalfHeight = 0.5;
    this.nearWidth = 1;
    this.nearHeight = 1;
    this.worldDirec = new Vector3_1.default();
    this.nearWorldCenter = new Vector3_1.default();
    this.farWorldCenter = new Vector3_1.default();
    /**
     * eight vertices: 4 far points, 4 near points
     */

    this.vertices = [new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default()]; // world space front,back ->(view space -z,z), world space left,right ->(view space -x,x),world space top,bottm ->(view space y,-y)

    this.planes = [new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default()];
  }

  setParam(fov, near, far, aspect) {
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.aspect = aspect;
  }

  setViewSize(pw, ph) {
    this.viewWidth = pw;
    this.viewHeight = ph;
    this.viewHalfWidth = pw * 0.5;
    this.viewHalfHeight = ph * 0.5;
  }

  update(invViewMat) {
    this.calcParam(invViewMat);
  }
  /**
   * @param w_cv 世界坐标位置
   * @param radius 球体半径
   * @returns 0表示完全不会再近平面内, 1表示完全在近平面内, 2表示和近平面相交
   */


  visiTestNearPlaneWithSphere(w_cv, radius) {
    const ps = this.mFpns;
    const v = ps[1].dot(w_cv) - this.mFpds[1];

    if (v - radius > minv) {
      // 表示完全在近平面之外，也就是前面
      return 0;
    } else if (v + radius < maxv) {
      // 表示完全在近平面内, 也就是后面
      return 1;
    } // 表示和近平面相交


    return 2;
  }

  visiTestSphere2(w_cv, radius) {
    const ps = this.mFpns;
    let boo = ps[0].dot(w_cv) - this.mFpds[0] - radius > minv;
    if (boo) return false;
    boo = ps[1].dot(w_cv) - this.mFpds[1] - radius > minv;
    if (boo) return false;
    boo = ps[2].dot(w_cv) - this.mFpds[2] - radius > minv;
    if (boo) return false;
    boo = ps[3].dot(w_cv) - this.mFpds[3] - radius > minv;
    if (boo) return false;
    boo = ps[4].dot(w_cv) - this.mFpds[4] - radius > minv;
    if (boo) return false;
    boo = ps[5].dot(w_cv) - this.mFpds[5] - radius > minv;
    if (boo) return false;
    return true;
  }

  visiTestSphere3(w_cv, radius, farROffset) {
    const ps = this.mFpns;
    let boo = ps[0].dot(w_cv) - this.mFpds[0] + farROffset - radius > minv;
    if (boo) return false;
    boo = ps[1].dot(w_cv) - this.mFpds[1] - radius > minv;
    if (boo) return false;
    boo = ps[2].dot(w_cv) - this.mFpds[2] - radius > minv;
    if (boo) return false;
    boo = ps[3].dot(w_cv) - this.mFpds[3] - radius > minv;
    if (boo) return false;
    boo = ps[4].dot(w_cv) - this.mFpds[4] - radius > minv;
    if (boo) return false;
    boo = ps[5].dot(w_cv) - this.mFpds[5] - radius > minv;
    if (boo) return false;
    return true;
  }

  visiTestPosition(pv) {
    const ps = this.mFpns;
    let boo = ps[0].dot(pv) - this.mFpds[0] > minv;
    if (boo) return false;
    boo = ps[1].dot(pv) - this.mFpds[1] > minv;
    if (boo) return false;
    boo = ps[2].dot(pv) - this.mFpds[2] > minv;
    if (boo) return false;
    boo = ps[3].dot(pv) - this.mFpds[3] > minv;
    if (boo) return false;
    boo = ps[4].dot(pv) - this.mFpds[4] > minv;
    if (boo) return false;
    boo = ps[5].dot(pv) - this.mFpds[5] > minv;
    if (boo) return false;
    return true;
  }

  visiTestPlane(nv, distance) {
    const ls = this.planes;
    let f0 = nv.dot(ls[0].position) - distance;
    let f1 = f0 * (nv.dot(ls[1].position) - distance);
    if (f1 < minv) return true;
    f1 = f0 * (nv.dot(ls[2].position) - distance);
    if (f1 < minv) return true;
    f1 = f0 * (nv.dot(ls[3].position) - distance);
    if (f1 < minv) return true;
    f1 = f0 * (nv.dot(ls[4].position) - distance);
    if (f1 < minv) return true;
    f1 = f0 * (nv.dot(ls[5].position) - distance);
    if (f1 < minv) return true;
    return false;
  } // frustum intersect sphere in wrod space


  visiTestSphere(w_cv, radius) {
    const ls = this.planes;
    let boo = this.bounds.sphereIntersect(w_cv, radius);

    if (boo) {
      let pf0 = ls[0].intersectSphere(w_cv, radius);
      let pf1 = ls[1].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[0].intersectBoo || ls[1].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = ls[2].intersectSphere(w_cv, radius);
      pf1 = ls[3].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[2].intersectBoo || ls[3].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = ls[4].intersectSphere(w_cv, radius);
      pf1 = ls[5].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[4].intersectBoo || ls[5].intersectBoo) {} else {
          return false;
        }
      }

      return true;
    }

    return false;
  } // visibility test
  // 可见性检测这边可以做的更精细，例如上一帧检测过的对象如果摄像机没有移动而且它自身也没有位置等变化，就可以不用检测
  // 例如精细检测可以分类: 圆球，圆柱体，长方体 等不同的检测模型计算方式会有区别


  visiTestAABB(ab) {
    let w_cv = ab.center;
    let radius = ab.radius;
    let boo = this.bounds.sphereIntersect(w_cv, radius);
    const ls = this.planes;

    if (boo) {
      let pf0 = ls[0].intersectSphere(w_cv, radius);
      let pf1 = ls[1].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[0].intersectBoo || ls[1].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = ls[2].intersectSphere(w_cv, radius);
      pf1 = ls[3].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[2].intersectBoo || ls[3].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = ls[4].intersectSphere(w_cv, radius);
      pf1 = ls[5].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (ls[4].intersectBoo || ls[5].intersectBoo) {} else {
          return false;
        }
      }

      return true;
    }

    return false;
  }

  calcParam(invViewMat) {
    let plane;
    let halfMinH = this.viewHalfHeight;
    let halfMinW = this.viewHalfWidth;
    let halfMaxH = halfMinH;
    let halfMaxW = halfMinW;

    if (this.perspective) {
      const tanv = Math.tan(this.fov * 0.5);
      halfMinH = this.near * tanv;
      halfMinW = halfMinH * this.aspect;
      halfMaxH = this.far * tanv;
      halfMaxW = halfMaxH * this.aspect;
    }

    const frustumPositions = this.vertices;
    const frustumPlanes = this.planes;
    this.nearHalfWidth = halfMinW;
    this.nearHalfHeight = halfMinH;
    this.nearWidth = 2.0 * halfMinW;
    this.nearHeight = 2.0 * halfMinH; // inner view space

    this.nearWorldCenter.setXYZ(0, 0, -this.near);
    this.farWorldCenter.setXYZ(0, 0, -this.far);
    invViewMat.transformVectorSelf(this.nearWorldCenter);
    invViewMat.transformVectorSelf(this.farWorldCenter);
    const direc = this.worldDirec.subVecsTo(this.farWorldCenter, this.nearWorldCenter);
    direc.normalize(); // front face, far plane

    plane = frustumPlanes[0];
    plane.nv.copyFrom(direc);
    plane.distance = plane.nv.dot(this.farWorldCenter);
    plane.position.copyFrom(this.farWorldCenter); // back face, near face

    plane = frustumPlanes[1];
    plane.nv.copyFrom(frustumPlanes[0].nv);
    plane.distance = plane.nv.dot(this.nearWorldCenter);
    plane.position.copyFrom(this.nearWorldCenter); // far face

    frustumPositions[0].setXYZ(-halfMaxW, -halfMaxH, -this.far);
    frustumPositions[1].setXYZ(halfMaxW, -halfMaxH, -this.far);
    frustumPositions[2].setXYZ(halfMaxW, halfMaxH, -this.far);
    frustumPositions[3].setXYZ(-halfMaxW, halfMaxH, -this.far); // near face

    frustumPositions[4].setXYZ(-halfMinW, -halfMinH, -this.near);
    frustumPositions[5].setXYZ(halfMinW, -halfMinH, -this.near);
    frustumPositions[6].setXYZ(halfMinW, halfMinH, -this.near);
    frustumPositions[7].setXYZ(-halfMinW, halfMinH, -this.near);
    const invM = invViewMat;
    invM.transformVectorSelf(frustumPositions[0]);
    invM.transformVectorSelf(frustumPositions[1]);
    invM.transformVectorSelf(frustumPositions[2]);
    invM.transformVectorSelf(frustumPositions[3]);
    invM.transformVectorSelf(frustumPositions[4]);
    invM.transformVectorSelf(frustumPositions[5]);
    invM.transformVectorSelf(frustumPositions[6]);
    invM.transformVectorSelf(frustumPositions[7]);
    this.bounds.reset();

    for (let i = 0; i < 8; ++i) {
      this.bounds.addPosition(frustumPositions[i]);
    }

    this.bounds.updateFast();
    const cross = Vector3_1.default.Cross; // bottom

    this.mTempV.subVecsTo(frustumPositions[0], frustumPositions[4]);
    let v0 = frustumPositions[1];
    this.mTempV1.subVecsTo(frustumPositions[1], frustumPositions[5]);
    plane = frustumPlanes[3];
    cross(this.mTempV1, this.mTempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // top

    this.mTempV.subVecsTo(frustumPositions[3], frustumPositions[7]);
    v0 = frustumPositions[2];
    this.mTempV1.subVecsTo(frustumPositions[2], frustumPositions[6]);
    plane = frustumPlanes[2];
    cross(this.mTempV1, this.mTempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // left

    this.mTempV.subVecsTo(frustumPositions[0], frustumPositions[4]);
    v0 = frustumPositions[3];
    this.mTempV1.subVecsTo(frustumPositions[3], frustumPositions[7]);
    plane = frustumPlanes[4];
    cross(this.mTempV, this.mTempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // right

    this.mTempV.subVecsTo(frustumPositions[1], frustumPositions[5]);
    v0 = frustumPositions[2];
    this.mTempV1.subVecsTo(frustumPositions[2], frustumPositions[6]);
    plane = frustumPlanes[5];
    cross(this.mTempV, this.mTempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    const fpna = this.mFpns;
    fpna[0].copyFrom(frustumPlanes[0].nv);
    fpna[1].copyFrom(frustumPlanes[1].nv);
    fpna[1].scaleBy(-1.0);
    fpna[2].copyFrom(frustumPlanes[2].nv);
    fpna[3].copyFrom(frustumPlanes[3].nv);
    fpna[3].scaleBy(-1.0);
    fpna[4].copyFrom(frustumPlanes[4].nv);
    fpna[4].scaleBy(-1.0);
    fpna[5].copyFrom(frustumPlanes[5].nv);
    const fpda = this.mFpds;
    fpda[0] = frustumPlanes[0].distance;
    fpda[1] = -frustumPlanes[1].distance;
    fpda[2] = frustumPlanes[2].distance;
    fpda[3] = -frustumPlanes[3].distance;
    fpda[4] = -frustumPlanes[4].distance;
    fpda[5] = frustumPlanes[5].distance;
  }

}

exports.Frustum = Frustum;

/***/ }),

/***/ "4a64":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class TransObject {
  constructor() {
    this.position = new Vector3_1.default();
    this.scale = new Vector3_1.default(1.0, 1.0, 1.0);
    this.rotation = new Vector3_1.default();
    this.rotationSpdv = new Vector3_1.default(0.1, 1.0);
  }

  initialize(range = 1000) {
    let rangeHalf = 0.5 * range;
    const pos = this.position;
    pos.setXYZ(Math.random() * range - rangeHalf, Math.random() * range - rangeHalf, Math.random() * range - rangeHalf);
  }

  run() {
    const et = this.entity;

    if (et) {
      const trans = et.transform;
      trans.setPosition(this.position);
      trans.setScale(this.scale);
      trans.setRotation(this.rotation);

      if (this.rotationSpdv) {
        this.rotation.addBy(this.rotationSpdv);
      }

      et.update();
    }
  }

}

exports.TransObject = TransObject;

/***/ }),

/***/ "4ad2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RAdapterContext_1 = __webpack_require__("3963");

const Stage3D_1 = __importDefault(__webpack_require__("19e8"));

const WGRendererParam_1 = __webpack_require__("f5fb");

const WGRenderer_1 = __webpack_require__("cae9");

class RendererScene {
  constructor(uidBase = 0) {
    this.mUid = 0;
    this.mInit = true;
    this.mContainers = [];
    this.enabled = true;
    this.mUid = uidBase + RendererScene.sUid++;
  }

  get renderer() {
    return this.mRenderer;
  }

  get uid() {
    return this.mUid;
  }

  initialize(config) {
    if (this.mInit) {
      this.mInit = false;
      const renderer = new WGRenderer_1.WGRenderer();
      config = WGRendererParam_1.checkConfig(config);
      this.mStage = new Stage3D_1.default(this.uid, document);
      this.racontext = new RAdapterContext_1.RAdapterContext();
      this.racontext.initialize({
        stage: this.mStage,
        canvas: config.canvas,
        div: config.div
      });
      renderer.initialize(config);
      this.mRenderer = renderer;
      this.camera = renderer.camera;
    }
  }

  setPassNodeGraph(graph, blockIndex = 0) {
    this.initialize();
    this.mRenderer.setPassNodeGraph(graph, blockIndex);
  }

  createRTTPass(param, blockIndex = 0) {
    this.initialize();
    if (!param) param = {};
    param.separate = true;
    return this.renderer.appendRenderPass(param, blockIndex);
  }

  createRenderPass(param, blockIndex = 0) {
    this.initialize();
    return this.renderer.appendRenderPass(param, blockIndex);
  }

  getWGCtx() {
    return this.renderer.getWGCtx();
  }

  getStage3D() {
    return this.racontext.getStage();
  }

  getCamera() {
    return this.camera;
  }

  enableMouseEvent(enabled = true) {}

  addContainer(container, processid = 0) {
    if (container.isContainer()) {
      this.initialize();

      if (container.__$wuid < 0 && container.__$contId < 1) {
        let i = 0;

        for (; i < this.mContainers.length; ++i) {
          if (this.mContainers[i] == container) {
            break;
          }
        }

        if (i >= this.mContainers.length) {
          container.__$wuid = this.mUid;
          container.__$wprocuid = processid;

          container.__$setRenderer(this);

          this.mContainers.push(container);
          container.update();
        }
      }
    } else {
      throw Error("illegal operation !!!");
    }
  }

  addEntity(entity, processIndex = 0) {
    if (entity) {
      this.initialize();

      if (entity.isContainer()) {
        this.addContainer(entity, processIndex);
      } else {
        this.mRenderer.addEntity(entity, processIndex);
      }
    }

    return this;
  }

  removeEntity(entity) {
    if (entity.isContainer()) {} else {
      this.mRenderer.removeEntity(entity);
    }
  }
  /**
   * @param type event type
   * @param func event listerner callback function
   * @param captureEnabled the default value is true
   * @param bubbleEnabled the default value is false
   */


  addEventListener(type, func, captureEnabled = true, bubbleEnabled = true) {
    this.initialize();
    const st = this.racontext.getStage();
    st.addEventListener(type, func, captureEnabled, bubbleEnabled);
  }
  /**
   * @param type event type
   * @param func event listerner callback function
   */


  removeEventListener(type, func) {
    const st = this.racontext.getStage();
    st.removeEventListener(type, func);
  }

  run(rendering = true) {
    const r = this.mRenderer;

    if (this.enabled && r && r.isEnabled()) {
      this.camera.update();
      const st = this.racontext.getStage();
      st.enterFrame();
      r.run(rendering);
    }
  }

  destroy() {}

}

RendererScene.sUid = 0;
exports.RendererScene = RendererScene;

/***/ }),

/***/ "4c75":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = vec4f(textureSample(texture0, sampler0, uv).xyz, 1.0) * color;\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "4ca8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\r\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragPosition: vec4<f32>,\r\n}\r\nfn invertedColor( color : vec4<f32>) -> vec4<f32> {\r\n   return vec4( 1.0 - color.rgb, color.a );\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>\r\n) -> VertexOutput {\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * objMat * vec4(position.xyz, 1.0);\r\n  var pv: vec4<f32>;\r\n  pv = 0.5 * (vec4<f32>(normalize(position.xyz) * 2.0, 1.0) + vec4<f32>(1.0, 1.0, 1.0, 1.0));\r\n  output.fragPosition = pv;\r\n  return output;\r\n}\r\n");

/***/ }),

/***/ "4ccd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = textureSample(texture0, sampler0, uv) * color;\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "4dc1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const MouseInteraction_1 = __webpack_require__("213f");

const gameOfLifeSphere_wgsl_1 = __importDefault(__webpack_require__("f73a"));

const WGRUniformValue_1 = __webpack_require__("7650");

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGCompMaterial_1 = __webpack_require__("19f9");

const WGMaterial_1 = __webpack_require__("943f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const SphereEntity_1 = __webpack_require__("9849");

const RenderStatusDisplay_1 = __importDefault(__webpack_require__("e58d"));

const gridSize = 256;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;
@group(0) @binding(3) var<storage, read_write> lifeState: array<f32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, 		cell.y+1) +
							cellActive(cell.x+1, 	cell.y) +
							cellActive(cell.x+1, 	cell.y-1) +
							cellActive(cell.x, 		cell.y-1) +
							cellActive(cell.x-1, 	cell.y-1) +
							cellActive(cell.x-1, 	cell.y) +
							cellActive(cell.x-1, 	cell.y+1) +
							cellActive(cell.x, 		cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
			if(cellStateOut[i] > 0) {
				lifeState[i] += 0.5;
			} else {
				lifeState[i] -= 0.5;
			}
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
			lifeState[i] += 0.5;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
			lifeState[i] = 0.01;
		}
	}
	if(lifeState[i] < 0.01) { lifeState[i] = 0.01; }
}`;

class GameOfLifeSphere {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mFlag = 6;

    this.mouseDown = evt => {
      this.mFlag = 1;
    };

    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLifeSphere::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new RenderStatusDisplay_1.default(this.mRscene, true);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.6 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    const lifeStateArray3 = new Float32Array(gridSize * gridSize);

    for (let i = 0; i < lifeStateArray3.length; i++) {
      lifeStateArray3[i] = 0.01;
    }

    const posisitonArray4 = new Float32Array(gridSize * gridSize * 4);
    let sizeV = new Vector3_1.default(40, 1, 40);
    let posV = new Vector3_1.default().copyFrom(sizeV);
    posV.scaleBy(gridSize);
    posV.scaleBy(-0.5);
    let k = 0;

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        let pv = new Vector3_1.default(j * sizeV.x, 0, i * sizeV.z).addBy(posV);
        posisitonArray4[k] = pv.x;
        posisitonArray4[k + 1] = pv.y;
        posisitonArray4[k + 2] = pv.z;
        k += 4;
      }
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0,
      shared
    };
    let sharedData1 = {
      data: cellStateArray1,
      shared
    };
    let sharedData3 = {
      data: lifeStateArray3,
      shared
    };
    let sharedData4 = {
      data: posisitonArray4,
      shared
    };
    const v0 = new WGRUniformValue_1.WGRUniformValue({
      data: gridsSizesArray,
      stride: 2,
      shared,
      shdVarName: 'v0'
    }).toVisibleAll(); // build rendering uniforms

    const va1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'va1'
    }).toVisibleVertComp();
    const vb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'vb1'
    }).toVisibleVertComp();
    const vc1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared,
      shdVarName: 'vc1'
    }).toVisibleAll();
    const v4 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData4,
      stride: 3,
      shared,
      shdVarName: 'v4'
    }).toVisibleVertComp(); // build computing uniforms

    const compva1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'compva1'
    }).toVisibleVertComp();
    const compva2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'compva2'
    }).toVisibleComp();
    compva2.toBufferForStorage();
    const compvb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'compvb1'
    }).toVisibleVertComp();
    const compvb2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'compvb2'
    }).toVisibleComp();
    compvb2.toBufferForStorage();
    const compv3 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared,
      shdVarName: 'compv3'
    }).toVisibleComp();
    compv3.toBufferForStorage();
    return [{
      ufvs0: [v0, va1, vc1, v4],
      ufvs1: [v0, vb1, vc1, v4]
    }, {
      ufvs0: [v0, compva1, compva2, compv3],
      ufvs1: [v0, compvb1, compvb2, compv3]
    }];
  }

  createMaterial(shaderSrc, uniformValues, shadinguuid, instanceCount) {
    return new WGMaterial_1.WGMaterial({
      shadinguuid,
      shaderSrc,
      instanceCount,
      uniformValues
    });
  }

  createCompMaterial(shaderSrc, uniformValues, shadinguuid, workgroupCount = 2) {
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid,
      shaderSrc,
      uniformValues
    }).setWorkcounts(workgroupCount, workgroupCount);
  }

  initScene() {
    const rc = this.mRscene;
    const ufvsObjs = this.createUniformValues();
    const instanceCount = gridSize * gridSize;
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    let shaderSrc = {
      code: gameOfLifeSphere_wgsl_1.default,
      uuid: "shader-gameOfLife"
    };
    let compShaderSrc = {
      code: compShdCode,
      uuid: "shader-computing"
    };
    const materials = [// build ping-pong rendering process
    this.createMaterial(shaderSrc, ufvsObjs[0].ufvs0, "rshd0", instanceCount), this.createMaterial(shaderSrc, ufvsObjs[0].ufvs1, "rshd1", instanceCount), // // // build ping-pong computing process
    this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs1, "compshd0", workgroupCount), this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs0, "compshd1", workgroupCount)];
    let entity = new SphereEntity_1.SphereEntity({
      transufvShared: true,
      radius: 20,
      longitudeNumSegments: 10,
      latitudeNumSegments: 10,
      materials
    });
    rc.addEntity(entity);
    this.mEntity = entity;
  }

  run() {
    let flag = this.mEntity.isRendering();
    const ms = this.mEntity.materials;

    if (flag) {
      for (let i = 0; i < ms.length; i++) {
        ms[i].visible = (this.mStep % 2 + i) % 2 == 0;
      }

      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        flag = false;
      } else {
        this.mFrameDelay = 3;
        this.mStep++;
      }
    }

    if (!flag) {
      ms[2].visible = false;
      ms[3].visible = false;
    }

    this.mRscene.run();
  }

}

exports.GameOfLifeSphere = GameOfLifeSphere;

/***/ }),

/***/ "4e74":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Matrix4_1 = __importDefault(__webpack_require__("c6d1"));

class Matrix4Pool {
  static GetMatTotal() {
    return Matrix4Pool.s_mtotal;
  }

  static GetFS32Arr() {
    return Matrix4Pool.s_mfs32Arr;
  }

  static SetFS32Arr(fs32) {
    Matrix4Pool.s_mfs32Arr = fs32;
    let total = Matrix4Pool.s_mtotal;
    let list = Matrix4Pool.s_matList;

    for (let i = 0; i < total; ++i) {
      list[i].setF32Arr(fs32);
    }
  }

  static GetFreeId() {
    if (Matrix4Pool.m_freeIdList.length > 0) {
      return Matrix4Pool.m_freeIdList.pop();
    }

    return -1;
  }

  static Allocate(total) {
    if (total < 1024) {
      total = 1024;
    }

    if (Matrix4Pool.s_mtotal < 1) {
      console.log("Matrix4Pool::Allocate(), Matrix total: " + total);
      Matrix4Pool.s_mtotal = total;
      Matrix4Pool.s_mfs32Arr = new Float32Array(total * 16);
      let i = 0;
      let mat = new Matrix4_1.default(Matrix4Pool.s_mfs32Arr, i * 16);
      let uid = mat.getUid();
      Matrix4Pool.s_baseUid = uid;
      Matrix4Pool.s_maxUid = uid + total;

      for (; i < uid; ++i) {
        Matrix4Pool.s_matList.push(null);
        Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
      }

      Matrix4Pool.s_matList.push(mat);
      Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
      Matrix4Pool.m_freeIdList.push(mat.getUid());

      for (i = 1; i < total; ++i) {
        mat = new Matrix4_1.default(Matrix4Pool.s_mfs32Arr, i * 16);
        Matrix4Pool.s_matList.push(mat);
        Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
        Matrix4Pool.m_freeIdList.push(mat.getUid());
      }
    }
  }

  static GetMatrix() {
    let mat = null;
    let index = Matrix4Pool.GetFreeId() - Matrix4Pool.s_baseUid;

    if (index >= 0) {
      mat = Matrix4Pool.s_matList[index];
      mat.identity();
      Matrix4Pool.s_matFlagList[index] = Matrix4Pool.s_FLAG_BUSY; //console.log("Get a free Matrix !!!");
    } else {
      //console.error("Matrix4Pool::GetMatrix(), Error Matrix4Pool is empty !!!");
      mat = new Matrix4_1.default();
    }

    return mat;
  }

  static RetrieveMatrix(mat) {
    if (mat != null) {
      let uid = mat.getUid();

      if (uid >= Matrix4Pool.s_baseUid && uid < Matrix4Pool.s_maxUid) {
        if (Matrix4Pool.s_matFlagList[uid - Matrix4Pool.s_baseUid] == Matrix4Pool.s_FLAG_BUSY) {
          Matrix4Pool.m_freeIdList.push(uid);
          Matrix4Pool.s_matFlagList[uid - Matrix4Pool.s_baseUid] = Matrix4Pool.s_FLAG_FREE;
        }
      }
    }
  }

}

Matrix4Pool.s_FLAG_BUSY = 1;
Matrix4Pool.s_FLAG_FREE = 0;
Matrix4Pool.s_matList = [];
Matrix4Pool.s_matFlagList = [];
Matrix4Pool.m_freeIdList = [];
Matrix4Pool.s_mfs32Arr = null;
Matrix4Pool.s_baseUid = 0;
Matrix4Pool.s_maxUid = 0;
Matrix4Pool.s_mtotal = 0;
exports.default = Matrix4Pool;

/***/ }),

/***/ "5009":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const BoxGeometry_1 = __importDefault(__webpack_require__("a229"));

class BoxEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {};
    if (param.minPos === undefined) param.minPos = [-50, -50, -50];
    if (param.maxPos === undefined) param.maxPos = [50, 50, 50];
    return new BoxGeometry_1.default().initialize(param.minPos, param.maxPos);
  }

}

exports.BoxEntity = BoxEntity;

/***/ }),

/***/ "5118":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const TorusGeometry_1 = __importDefault(__webpack_require__("bd36"));

class TorusEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {};
    if (param.radius === undefined) param.radius = 100.0;
    if (param.axisRadius === undefined) param.axisRadius = 30.0;
    if (param.longitudeNumSegments === undefined) param.longitudeNumSegments = 10;
    if (param.latitudeNumSegments === undefined) param.latitudeNumSegments = 20;
    if (param.axisType === undefined) param.axisType = 0;
    let g = new TorusGeometry_1.default();
    g.axisType = param.axisType;
    g.initialize(param.radius, param.axisRadius, param.longitudeNumSegments, param.latitudeNumSegments);
    return g;
  }

}

exports.TorusEntity = TorusEntity;

/***/ }),

/***/ "5150":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const SphereEntity_1 = __webpack_require__("9849");

const BoxEntity_1 = __webpack_require__("5009");

const CylinderEntity_1 = __webpack_require__("76e3");

const CubeEntity_1 = __webpack_require__("0069");

const TorusEntity_1 = __webpack_require__("5118");

const PlaneEntity_1 = __webpack_require__("7e70");

const ConeEntity_1 = __webpack_require__("97f2");

const AxisEntity_1 = __webpack_require__("603e");

class WireframeEntityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("WireframeEntityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    let axis = new AxisEntity_1.AxisEntity();
    rc.addEntity(axis);
    let entities = [new SphereEntity_1.SphereEntity(), new BoxEntity_1.BoxEntity(), new CylinderEntity_1.CylinderEntity({
      alignYRatio: 0.0
    }), new CubeEntity_1.CubeEntity({
      cubeSize: 130
    }), new TorusEntity_1.TorusEntity({
      radius: 110,
      axisType: 1
    }), new PlaneEntity_1.PlaneEntity({
      axisType: 1,
      extent: [-80, -80, 160, 160],
      doubleFace: true
    }), new ConeEntity_1.ConeEntity({
      alignYRatio: 0.0
    })];
    let ls = entities;
    entities = []; // random sorting

    for (let i = 0, ln = ls.length; i < ln; ++i) {
      const k = Math.round(Math.random() * 888) % ls.length;
      entities.push(ls[k]);
      ls.splice(k, 1);
    }

    let radius = 300.0;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length;
      let entity = entities[i].setAlbedo(new Color4_1.default().randomRGB(1.5, 0.1));
      entity.arm = [1.1, Math.random() * 0.95 + 0.05, Math.random() * 0.9 + 0.1];
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]);
      rc.addEntity(entity);
    }

    radius += 230;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length + 0.5;
      let entity = entities[i].clone({
        geometry: entities[i].geometry,
        doubleFace: true,
        wireframe: true
      });
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]);
      rc.addEntity(entity);
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.WireframeEntityTest = WireframeEntityTest;

/***/ }),

/***/ "5151":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 用于统一的gpu端buf资源管理
 * WGH(Web GPU Hardware)
 */

class WGHBufferStoreIns {
  constructor() {
    this.mBufMap = new Map();
  }

  addWithUid(uid, buf) {
    if (buf) {
      const map = this.mBufMap;

      if (!map.has(uid)) {
        map.set(uid, buf);
      }
    }
  }

  removeWithUid(uid) {
    const map = this.mBufMap;

    if (map.has(uid)) {
      map.delete(uid);
    }
  }

  getWithUid(uid) {
    return this.mBufMap.get(uid);
  }

  getBufWithUid(uid) {
    if (this.mBufMap.has(uid)) {
      return this.mBufMap.get(uid).buffer;
    }

    return null;
  }

  hasWithUid(uid) {
    const map = this.mBufMap;
    return map.has(uid);
  }

}

class WGHBufferStore {
  static getStore(ctx) {
    const i = ctx.uid;
    const sts = WGHBufferStore.sStores;

    if (!sts[i]) {
      sts[i] = new WGHBufferStoreIns();
    }

    return sts[i];
  }

}

WGHBufferStore.sStores = new Array(1024);
exports.WGHBufferStore = WGHBufferStore;

/***/ }),

/***/ "5326":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const vertEntityOnlyVtx_vert_wgsl_1 = __importDefault(__webpack_require__("4ca8"));

const cubemap_frag_wgsl_1 = __importDefault(__webpack_require__("1a9d"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

class ImgCubeMap {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    console.log("ImgCubeMap::initialize() ...");
    const material = this.createMaterial();
    this.createEntity([material]);
  }

  createMaterial() {
    let urls = ["static/assets/hw_morning/morning_ft.jpg", "static/assets/hw_morning/morning_bk.jpg", "static/assets/hw_morning/morning_up.jpg", "static/assets/hw_morning/morning_dn.jpg", "static/assets/hw_morning/morning_rt.jpg", "static/assets/hw_morning/morning_lf.jpg"];
    let texDataList = [new WGTextureWrapper_1.WGImageCubeTextureData(urls)];
    const shaderSrc = {
      vert: {
        code: vertEntityOnlyVtx_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: cubemap_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const texTotal = texDataList ? texDataList.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc
    }).addTextureWithDatas(texDataList);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createCube(200);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).setIndices(rgd.ivs);
    const entity = new Entity3D_1.Entity3D({
      materials,
      geometry
    });
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.renderer.run();
  }

}

exports.ImgCubeMap = ImgCubeMap;

/***/ }),

/***/ "541b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const AABB_1 = __importDefault(__webpack_require__("3e40"));

class GeometryData {
  constructor() {
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
    this.mivs = null;
    this.bounds = new AABB_1.default();
    this.vtxTotal = 0;
    this.trisNumber = 0;
    this.vtCount = 0;
    /**
     * axisType = 0 is XOY plane,
     * axisType = 1 is XOZ plane,
     * axisType = 2 is YOZ plane
     */

    this.axisType = 0;
  }

  clone() {
    let geometry = new GeometryData();
    geometry.copyFrom(this);
    return geometry;
  }

  copyFrom(src) {
    let geometry = new GeometryData();

    if (src.mvs != null) {
      if (this.mvs != null) this.mvs.set(src.mvs);else this.mvs = src.mvs.slice(0);
    }

    if (src.muvs != null) {
      if (this.muvs != null) this.muvs.set(src.muvs);else this.muvs = src.muvs.slice(0);
    }

    if (src.mnvs != null) {
      if (this.mnvs != null) this.mnvs.set(src.mnvs);else this.mnvs = src.mnvs.slice(0);
    }

    if (src.mivs != null) {
      if (this.mivs != null) this.mivs.set(src.mivs);else this.mivs = src.mivs.slice(0);
    }

    geometry.vtxTotal = this.vtxTotal;
    geometry.trisNumber = this.trisNumber;
    geometry.vtCount = this.vtCount;
    geometry.bounds.copyFrom(this.bounds);
  }

  getCenterAt(i, outV) {}

  transformAt(i, mat4) {}

  getVSSegAt(i) {
    return null;
  }
  /**
   * @returns vertex position buffer Float32Array
   */


  getVS() {
    return this.mvs;
  }
  /**
   * @returns vertex uv buffer Float32Array
   */


  getUVS() {
    return this.muvs;
  }
  /**
   * @returns vertex normal buffer Float32Array
   */


  getNVS() {
    return this.mnvs;
  }
  /**
   * @returns vertex indices buffer Uint16Array or Uint32Array
   */


  getIVS() {
    return this.mivs;
  }

  reset() {
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
    this.mivs = null;
    this.vtxTotal = 0;
    this.trisNumber = 0;
    this.vtCount = 0;
  }

}

exports.default = GeometryData;

/***/ }),

/***/ "5469":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const simplePBR_vert_wgsl_1 = __importDefault(__webpack_require__("0dcf"));

const simplePBR_frag_wgsl_1 = __importDefault(__webpack_require__("90af"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class SimplePBRTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("SimplePBRTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, color, arm) {
    color = color ? color : new Color4_1.default();
    let pipelineDefParam = {
      depthWriteEnabled: true,
      blendModes: []
    };
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "simple-pbr-materialx",
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let albedoV = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([color.r, color.g, color.b, 1])
    }); // arm: ao, roughness, metallic

    let armV = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([arm[0], arm[1], arm[2], 1])
    });
    material.uniformValues = [albedoV, armV];
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  initScene() {
    const rc = this.mRscene;
    const geometry = this.createGeom(this.geomData.createSphere(50), true);
    const shdSrc = {
      vert: {
        code: simplePBR_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: simplePBR_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let tot = 7;
    const size = new Vector3_1.default(150, 150, 150);
    const pos = new Vector3_1.default().copyFrom(size).scaleBy(-0.5 * (tot - 1));

    for (let i = 0; i < tot; ++i) {
      for (let j = 0; j < tot; ++j) {
        // arm: ao, roughness, metallic
        let arm = [1.5, i / tot * 0.95 + 0.05, j / tot * 0.95 + 0.05];
        let material = this.createMaterial(shdSrc, new Color4_1.default(0.5, 0.0, 0.0), arm);
        let entity = new Entity3D_1.Entity3D({
          materials: [material],
          geometry
        });
        entity.transform.setPosition(new Vector3_1.default().setXYZ(i * size.x, j * size.y, size.z).addBy(pos));
        rc.addEntity(entity);
      }
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.SimplePBRTest = SimplePBRTest;

/***/ }),

/***/ "5476":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CoSpaceAppData_1 = __webpack_require__("b876");

const CoModuleLoader_1 = __webpack_require__("852d");

class CoDataModule {
  constructor() {
    this.m_init = true;
    this.m_sysIniting = true;
    this.m_initInsFlag = true;
    this.verTool = null;
    this.m_initCalls = [];
  }
  /**
   * 初始化
   * @param sysInitCallback the default value is null
   * @param urlChecker the default value is null
   * @param deferredInit the default value is false
   */


  initialize(sysInitCallback = null, deferredInit = false) {
    if (this.m_init) {
      this.m_init = false;
      this.m_sysInitCallback = sysInitCallback;
      this.m_deferredInit = deferredInit; // let dracoModuleParam = new TaskCodeModuleParam("static/cospace/modules/draco/ModuleDracoGeomParser.umd.js", ModuleNS.dracoParser, ModuleFileType.JS);
      // dracoModuleParam.params = ["static/cospace/modules/dracoLib/"];

      let modules = [{
        url: "static/cospace/core/coapp/CoSpaceApp.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.coSpaceApp,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/core/code/ThreadCore.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.threadCore,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.ctmParser,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/modules/obj/ModuleOBJGeomParser.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.objParser,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/modules/png/ModulePNGParser.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.pngParser,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/modules/fbxFast/ModuleFBXGeomFastParser.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.fbxFastParser,
        type: CoSpaceAppData_1.CoModuleFileType.JS
      }, {
        url: "static/cospace/modules/draco/ModuleDracoGeomParser.umd.js",
        name: CoSpaceAppData_1.CoModuleNS.dracoParser,
        type: CoSpaceAppData_1.CoModuleFileType.JS,
        params: ["static/cospace/modules/dracoLib/"]
      }];
      this.m_modules = modules; // 初始化数据协同中心

      let dependencyGraphObj = {
        nodes: [{
          uniqueName: "dracoGeomParser",
          path: "static/cospace/modules/draco/ModuleDracoGeomParser.umd.js"
        }, {
          uniqueName: "dracoWasmWrapper",
          path: "static/cospace/modules/dracoLib/w2.js"
        }, {
          uniqueName: "ctmGeomParser",
          path: "static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js"
        }],
        maps: [{
          uniqueName: "dracoGeomParser",
          includes: [1]
        } // 这里[1]表示 dracoGeomParser 依赖数组中的第一个元素也就是 dracoWasmWrapper 这个代码模块
        ]
      };
      this.m_dependencyGraphObj = dependencyGraphObj;
      let loader = new CoModuleLoader_1.CoModuleLoader(1, null, this.verTool);

      if (this.verTool) {
        loader.forceFiltering = this.verTool.forceFiltering;
        console.log("this.verTool.forceFiltering: ", this.verTool.forceFiltering);
      }

      let urlChecker = loader.getUrlChecker();

      if (urlChecker) {
        for (let i = 0; i < modules.length; ++i) {
          modules[i].url = urlChecker(modules[i].url);
        }

        let nodes = dependencyGraphObj.nodes;

        for (let i = 0; i < nodes.length; ++i) {
          nodes[i].path = urlChecker(nodes[i].path);
        }
      } // if (this.verTool) {
      // 	for (let i = 0; i < modules.length; ++i) {
      // 		modules[i].url = this.verTool.filterUrl(modules[i].url);
      // 		console.log("VVVVVVV PP0 VVVVVV modules[i].url: ", modules[i].url);
      // 	}
      // 	console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      // 	let nodes = (dependencyGraphObj as any).nodes;
      // 	for (let i = 0; i < nodes.length; ++i) {
      // 		nodes[i].path = this.verTool.filterUrl(nodes[i].path);
      // 		console.log("VVVVVVV PP1 VVVVVV nodes[i].path: ", nodes[i].path);
      // 	}
      // }


      if (!deferredInit) {
        this.loadSys();
      }
    }
  }

  loadSys() {
    if (this.m_sysIniting) {
      new CoModuleLoader_1.CoModuleLoader(1, () => {
        this.initCoSpaceSys();
      }).load(this.m_modules[0].url);
      this.m_sysIniting = false;
    }
  }
  /**
   * 注意: 不建议过多使用这个函数,因为回调函数不安全如果是lambda表达式则由性能问题。
   * 立即获得CPU侧的数据单元实例, 但是数据单元中的数据可能是空的, 因为数据获取的操作实际是异步的。
   * 需要通过 isCpuPhase() 或者 isGpuPhase() 等函数来判定具体数据情况
   * @param url 数据资源url
   * @param dataFormat 数据资源类型
   * @param callback 数据资源接收回调函数, 其值建议为lambda函数表达式
   * @param immediate 是否立即返回数据, 默认是false
   * @returns 数据单元实例，用户只能访问不能更改这个实例内部的数据状态，如果必要则可以申请复制一份
   */


  getCPUDataByUrlAndCallback(url, dataFormat, callback, immediate) {
    if (this.coappIns != null) {
      let unit = this.coappIns.getCPUDataByUrlAndCallback(url, dataFormat, callback, immediate);

      if (this.m_deferredInit) {
        if (this.m_initInsFlag) {
          this.m_initInsFlag = false;
          let modules = this.m_modules;
          this.coappIns.initialize(3, modules[1].url, true);
        }
      }

      return unit;
    }

    return null;
  }

  deferredInit(callback) {
    if (this.coappIns == null) {
      this.m_initCalls.push(callback);
      this.loadSys();
    } else if (callback != null) {
      callback();
    }
  }

  initCoSpaceSys() {
    if (this.coappIns == null && typeof CoSpaceApp !== "undefined") {
      let coappIns = CoSpaceApp.createInstance();
      let modules = this.m_modules;
      let jsonStr = JSON.stringify(this.m_dependencyGraphObj);
      coappIns.setThreadDependencyGraphJsonString(jsonStr);
      coappIns.setTaskModuleParams(modules);

      if (!this.m_deferredInit) {
        coappIns.initialize(3, modules[1].url, true);
      }

      let t = this;
      t.coappIns = coappIns;

      for (let i = 0; i < this.m_initCalls.length; ++i) {
        if (this.m_initCalls[i] != null) {
          this.m_initCalls[i]();
        }
      }

      this.m_initCalls = [];
    }

    if (this.m_sysInitCallback != null) {
      this.m_sysInitCallback();
    }

    this.m_sysInitCallback = null;
  }

  destroy() {}

}

exports.CoDataModule = CoDataModule;
exports.default = CoDataModule;

/***/ }),

/***/ "551f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("9711"));

const ROTransform_1 = __importDefault(__webpack_require__("c433"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const WGRUnitState_1 = __webpack_require__("222c");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Entity3DParam_1 = __webpack_require__("793b");

exports.TransformParam = Entity3DParam_1.TransformParam;
exports.getUniformValueFromParam = Entity3DParam_1.getUniformValueFromParam;
exports.Entity3DParam = Entity3DParam_1.Entity3DParam;

class Entity3D {
  constructor(param) {
    this.mUid = Entity3D.sUid++;
    this.mTransVer = -1;
    /**
     * renderer scene entity flag, be used by the renderer system
     * 第0位到第19位总共20位存放自身在space中的 index id(最小值为1, 最大值为1048575,默认值是0, 也就是最多只能展示1048575个entitys),
     * 第20位开始到26位为总共7位止存放在renderer中的状态数据(renderer unique id and others)
     * 第27位存放是否在container里面
     * 第28位开始到29位总共二位存放renderer 载入状态 的相关信息
     * 第30位位存放是否渲染运行时排序
     */

    this.__$rseFlag = RSEntityFlag_1.default.DEFAULT;
    this.__$bids = [];
    this.cameraViewing = true;
    this.rstate = new WGRUnitState_1.WGRUnitState();
    /**
     * mouse interaction enabled
     */

    this.mouseEnabled = false;
    if (!param) param = {};

    if (!(param.building === false)) {
      this.init(param);
    }

    this.mDescParam = param;
  }

  init(param) {
    this.cameraViewing = param.cameraViewing === false ? false : true;
    let transformEnabled = !param || param.transformEnabled === undefined || param.transformEnabled === true;
    let transform;

    if (param) {
      transform = param.transform;
      transformEnabled = transformEnabled || this.transform !== undefined;
    }

    if (transformEnabled) {
      if (transform) {
        const fs32 = transform;

        if (fs32.byteLength !== undefined) {
          this.transform = ROTransform_1.default.Create({
            fs32
          });
        }

        if (!this.transform) {
          const matrix = transform;

          if (matrix.identity !== undefined) {
            this.transform = ROTransform_1.default.Create({
              matrix
            });
          }
        }

        if (!this.transform) {
          const trans = transform;

          if (trans.getMatrixFS32 !== undefined) {
            this.transform = trans;
          }
        }

        if (!this.transform) {
          const trans = transform;

          if (!trans.scale || !trans.rotation || !trans.position || !trans.matrix) {
            this.transform = ROTransform_1.default.Create({
              transform: trans
            });
          }
        }
      } else {
        this.transform = ROTransform_1.default.Create();
      }
    }

    this.initBounds(transformEnabled);

    if (param) {
      if (param.transufvShared === true) {
        this.transform.uniformv.shared = true;
      } // this.materials = param.materials;


      if (param.materials !== undefined) this.materials = param.materials;
      if (param.geometry !== undefined) this.geometry = param.geometry;
      this.update();
    }
  }

  initBounds(transformEnabled) {
    this.mGBs = new AABB_1.default();
    this.mLBs = new AABB_1.default();
    this.mLBs.version = -137;
  }

  __$testSpaceEnabled() {
    //return this.__$spaceId < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestSpaceEnabled2(this.__$rseFlag);
  }

  __$testContainerEnabled() {
    //return this.__$wuid < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestContainerEnabled(this.__$rseFlag);
  }

  __$testRendererEnabled() {
    //return this.__$wuid < 0 && this.__$weid < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestRendererEnabled(this.__$rseFlag);
  }

  getRendererUid() {
    return RSEntityFlag_1.default.GetRendererUid(this.__$rseFlag);
  }

  get uid() {
    return this.mUid;
  }

  isREnabled() {
    const ms = this.materials;

    if (ms) {
      for (let i = 0; i < ms.length; ++i) {
        if (!ms[i].isREnabled()) {
          return false;
        }
      }
    } else {
      return false;
    }

    let g = this.geometry;

    if (!g || !g.isREnabled()) {
      console.log("aaa g.isREnabled(), !g: ", !g, ', ', this.geometry);
      return false;
    }

    return true;
  } // updateBounds(): void {
  // 	if (this.mGBs) {
  // 	}
  // }


  updateBounds() {
    const trans = this.transform;
    const lb = this.mLBs;

    if (trans && lb) {
      // this.m_transStatus = ROTransform.UPDATE_TRANSFORM;
      const g = this.geometry;

      if (g) {
        const slb = g.bounds;

        if (lb.version != slb.version) {
          lb.reset();
          const gd = g.geometryData;
          let ivs = gd.getIVS();
          const ivsIndex = 0;
          const vtCount = gd.vtCount;
          lb.addFloat32AndIndices(gd.getVS(), ivs.subarray(ivsIndex, ivsIndex + vtCount), gd.getVSStride());
          lb.update();
          this.update();
        }
      }
    }
  }

  updateLocalBoundsVS(bounds) {
    let min = bounds.min;
    let max = bounds.max;

    if (!this.mLBoundsVS) {
      this.mLBoundsVS = new Float32Array(24);
    }

    const pvs = this.mLBoundsVS;
    pvs[0] = min.x;
    pvs[1] = min.y;
    pvs[2] = min.z;
    pvs[3] = max.x;
    pvs[4] = min.y;
    pvs[5] = min.z;
    pvs[6] = min.x;
    pvs[7] = min.y;
    pvs[8] = max.z;
    pvs[9] = max.x;
    pvs[10] = min.y;
    pvs[11] = max.z;
    pvs[12] = min.x;
    pvs[13] = max.y;
    pvs[14] = min.z;
    pvs[15] = max.x;
    pvs[16] = max.y;
    pvs[17] = min.z;
    pvs[18] = min.x;
    pvs[19] = max.y;
    pvs[20] = max.z;
    pvs[21] = max.x;
    pvs[22] = max.y;
    pvs[23] = max.z;
  }

  updateGlobalBounds() {
    // 这里的逻辑也有问题,需要再处理，为了支持摄像机等的拾取以及支持遮挡计算等空间管理计算
    const trans = this.transform;
    const slb = this.geometry.bounds;
    const lb = this.mLBs;

    if (trans && lb && slb) {
      const gb = this.mGBs;
      const DE = Entity3D;

      if (trans.isDirty() || this.mTransVer != trans.version || lb.version != slb.version) {
        this.mTransVer = trans.version;
        lb.version = slb.version;
        trans.update();
        const mat = trans.getMatrix();

        if (lb.version != slb.version || !this.mLBoundsVS) {
          this.updateLocalBoundsVS(lb);
        }

        let invs = this.mLBoundsVS;
        let outvs = DE.sBoundsOutVS;
        mat.transformVectors(invs, 24, outvs);
        gb.reset();
        gb.addFloat32Arr(outvs);
        gb.update();
      } else {
        DE.sPrePos.setXYZ(0, 0, 0);
        DE.sPos.setXYZ(0, 0, 0);
        let matrix = trans.getMatrix(false);
        matrix.transformVector3Self(DE.sPrePos);
        trans.update();
        matrix = trans.getMatrix(false);
        matrix.transformVector3Self(DE.sPos);
        DE.sPos.subtractBy(DE.sPrePos);
        gb.min.addBy(DE.sPos);
        gb.max.addBy(DE.sPos);
        gb.center.addBy(DE.sPos);
        ++gb.version;
      }
    }
  }

  update() {
    const g = this.geometry;

    if (g) {
      const lb = this.mLBs;

      if (lb && g.bounds && lb.version != g.bounds.version) {
        lb.copyFrom(g.bounds);
      }

      this.updateGlobalBounds();
    }

    if (this.transform) {
      this.transform.update();
    }

    return this;
  }

  destroy() {
    if (this.mDescParam) {
      this.mDescParam = null;
    }
  }
  /**
   * 表示没有加入任何渲染场景或者渲染器
   */


  isRenderFree() {
    return !this.rstate.__$inRenderer;
  }
  /**
   * @returns 是否已经加入渲染器中(但是可能还没有进入真正的渲染运行时)
   */


  isInRenderer() {
    return this.rstate.__$inRenderer;
  }
  /**
   * @returns 是否在渲染器实际的渲染工作流中, 返回true并不表示当前帧一定会绘制
   */


  isRendering() {
    return this.rstate.__$rendering;
  }

  get globalBounds() {
    return this.mGBs;
  }

  get localBounds() {
    return this.mLBs;
  }

  get globalBoundsVer() {
    if (this.mGBs) {
      return this.mGBs.version;
    }

    return -1;
  }

  localToGlobal(pv) {
    return this;
  }

  globalToLocal(pv) {
    return null;
  }
  /**
   * @returns value < 12 , the instance is a renderable entity instance, otherwise it is a DisplayEntityContainer instance
   */


  getREType() {
    return 11;
  }

  isContainer() {
    return false;
  }
  /**
   * @returns 自身是否未必任何渲染器相关的系统使用
   */


  isFree() {
    return this.__$rseFlag == RSEntityFlag_1.default.DEFAULT;
  }

  set visible(v) {
    this.rstate.visible = v;
  }

  get visible() {
    return this.rstate.visible;
  }

  setVisible(v) {
    this.rstate.visible = v;
    return this;
  }

  isVisible() {
    return this.rstate.visible;
  }

  getTransform() {
    return this.transform;
  }

  getInvMatrix() {
    return this.transform.getInvMatrix();
  }

  getMatrix() {
    return this.transform.getMatrix();
  }

  hasParent() {
    return this.mParent ? true : false;
  }

  __$getParent() {
    return this.mParent;
  }

  __$setParent(parent) {
    this.mParent = parent;
  }
  /**
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    return -1;
  }
  /**
   * @return 返回true表示包含有geometry对象,反之则没有
   */


  hasGeometry() {
    return this.geometry ? true : false;
  }
  /**
   * @return 返回true表示基于三角面的可渲染多面体, 返回false则是一个数学方程描述的几何体(例如球体)，不能直接用于渲染
   */


  isPolyhedral() {
    return true;
  }

}

Entity3D.sUid = 0;
Entity3D.sBoundsOutVS = new Float32Array(24);
Entity3D.sPos = new Vector3_1.default();
Entity3D.sPrePos = new Vector3_1.default();
exports.Entity3D = Entity3D;

/***/ }),

/***/ "560a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 将加载逻辑打包的loader
 */

class PackedLoader {
  /**
   * @param times 记录总共需要的完成操作的响应次数。这个次数可能是由load直接产生，也可能是由于别的地方驱动。
   * @param callback 完成所有响应的之后的回调
   */
  constructor(times, callback = null, urlChecker = null) {
    this.m_uid = PackedLoader.s_uid++;
    this.m_urlChecker = null;
    this.m_oneTimes = true;
    this.m_loaderMap = null;
    this.m_callback = callback;
    this.m_times = times;
    this.m_urlChecker = urlChecker;
  }

  setUrlChecker(urlChecker = null) {
    this.m_urlChecker = urlChecker;
    return this;
  }

  getUrlChecker() {
    return this.m_urlChecker;
  }

  getUid() {
    return this.m_uid;
  }

  setCallback(callback) {
    this.m_callback = callback;
    return this;
  }

  addLoader(m) {
    if (m != null && m != this) {
      if (this.isFinished()) {
        m.use();
      } else {
        if (this.m_loaderMap == null) {
          this.m_loaderMap = new Map();
        }

        let map = this.m_loaderMap;

        if (!map.has(m.getUid())) {
          map.set(m.getUid(), m);
        }
      }
    }

    return this;
  }

  isFinished() {
    return this.m_times == 0;
  }

  useOnce() {
    if (this.m_oneTimes) {
      this.m_oneTimes = false;
      this.use();
    }
  }

  use() {
    if (this.m_times > 0) {
      this.m_times--;

      if (this.isFinished()) {
        if (this.m_callback != null) {
          this.m_callback();
          this.m_callback = null;

          if (this.m_loaderMap != null) {
            for (let [key, value] of this.m_loaderMap) {
              value.use();
            }

            this.m_loaderMap = null;
          }
        }
      }
    }
  }

  hasModuleByUrl(url) {
    return PackedLoader.loadedMap.has(url);
  }

  load(url) {
    if (url == "") {
      return this;
    }

    if (this.m_urlChecker != null) {
      url = this.m_urlChecker(url);
    }

    let loadedMap = PackedLoader.loadedMap;

    if (loadedMap.has(url)) {
      this.use();
      return;
    }

    let loadingMap = PackedLoader.loadingMap;

    if (loadingMap.has(url)) {
      let list = loadingMap.get(url);

      for (let i = 0; i < list.length; ++i) {
        if (list[i] == this) {
          return;
        }
      }

      list.push(this);
      return;
    }

    loadingMap.set(url, [this]);
    this.loadData(url);
    return this;
  }
  /**
   * subclass need override this function
   * @param url data url
   */


  loadData(url) {
    let codeLoader = new XMLHttpRequest();
    codeLoader.open("GET", url, true);

    codeLoader.onerror = function (err) {
      console.error("load error: ", err);
    }; // codeLoader.onprogress = e => { };


    codeLoader.onload = evt => {
      // this.loadedData(codeLoader.response, url);
      this.loadedUrl(url);
    };

    codeLoader.send(null);
  }
  /**
   * subclass need override this function
   * @param data loaded data
   * @param url data url
   */


  loadedData(data, url) {
    console.log("module js file loaded, url: ", url); // let scriptEle: HTMLScriptElement = document.createElement("script");
    // scriptEle.onerror = evt => {
    // 	console.error("module script onerror, e: ", evt);
    // };
    // scriptEle.type = "text/javascript";
    // scriptEle.innerHTML = data;
    // document.head.appendChild(scriptEle);
  }
  /**
   * does not override this function
   * @param url http req url
   */


  loadedUrl(url) {
    let loadedMap = PackedLoader.loadedMap;
    let loadingMap = PackedLoader.loadingMap;
    loadedMap.set(url, 1);
    let list = loadingMap.get(url);

    for (let i = 0; i < list.length; ++i) {
      list[i].use();
    }

    loadingMap.delete(url);
  }

  getDataByUrl(url) {
    return null;
  }

  clearAllData() {}

  destroy() {
    this.m_urlChecker = null;
  }

}

PackedLoader.s_uid = 0;
PackedLoader.loadedMap = new Map();
PackedLoader.loadingMap = new Map();
exports.PackedLoader = PackedLoader;

/***/ }),

/***/ "5648":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRUnitState_1 = __webpack_require__("222c");

class WGRCompUnitRunSt {}

const __$urst = new WGRCompUnitRunSt();

const __$rcompeust = new WGRUnitState_1.WGRUnitState();

const __$workcounts = new Uint16Array([1, 1, 0, 0]);

class WGRCompUnit {
  constructor() {
    this.rf = true;
    this.pst = __$rcompeust;
    this.st = __$rcompeust;
    this.__$rever = 0;
    this.enabled = true;
    this.workcounts = __$workcounts;
  }

  getRF() {
    return this.enabled && this.st.isDrawable();
  }

  runBegin() {
    const rc = this.rp.compPassEncoder;
    const mt = this.material;
    let rf = this.enabled && this.rp.enabled && this.st.isDrawable();
    rf = rf && mt.visible;

    if (rf) {
      const pipeline = this.pipelinectx.comppipeline;

      if (pipeline) {
        // 这里面的诸多判断逻辑不应该出现，加入渲染器内部渲染流程之前必须处理好， 后续优化
        const st = __$urst;

        if (st.rc != rc) {
          st.pipeline = null;
          st.rc = rc;
          st.unfsuuid = "";
        }

        if (st.pipeline != pipeline) {
          st.pipeline = pipeline; // console.log("ruint setPipeline(), this.pipeline: ", this.pipeline);

          rc.setPipeline(pipeline);
        }

        const ufs = this.uniforms;

        if (ufs) {
          for (let i = 0, ln = ufs.length; i < ln; i++) {
            const uf = ufs[i];

            if (uf.isEnabled()) {
              // console.log("compruint setBindGroup(), bindGroup: ", uf.bindGroup);
              // console.log("ruint setBindGroup(), uf.groupIndex: ", uf.groupIndex,",", uf.bindGroup);
              rc.setBindGroup(uf.groupIndex, uf.bindGroup);

              for (let j = 0, ln = uf.uvfs.length; j < ln; j++) {
                uf.setValue(uf.uvfs[j], j);
              }
            } else {
              rf = false;
            }
          }
        }
      } else {
        rf = false;
      }
    }

    this.rf = rf;
  }

  run() {
    if (this.rf) {
      const rc = this.rp.compPassEncoder;
      const works = this.workcounts; // console.log("dispatchWorkgroups(), works: ", works);

      if (works[1] > 0 && works[2] > 0) {
        rc.dispatchWorkgroups(works[0], works[1], works[2]);
      } else if (works[1] > 0) {
        // console.log("dispatchWorkgroups(x: " + works[0] + ", y: " + works[1] + ")");
        rc.dispatchWorkgroups(works[0], works[1]);
      } else {
        rc.dispatchWorkgroups(works[0]);
      }
    }
  }

  destroy() {
    if (this.pipelinectx) {
      const ufctx = this.pipelinectx.uniformCtx;
      ufctx.removeUniforms(this.uniforms);
      this.pipelinectx = null;
      this.material = null;
      this.rp = null;
      this.pst = null;
      this.st = null;
      this.workcounts = null;
    }
  }

}

exports.WGRCompUnit = WGRCompUnit;

/***/ }),

/***/ "56f9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const DataDrivenEntityBuilder_1 = __webpack_require__("c4ad");

class DataDrivenRScene {
  constructor(uidBase = 0) {
    this.mBuilder = new DataDrivenEntityBuilder_1.DataDrivenEntityBuilder();
    this.mScene = new RendererScene_1.RendererScene(uidBase);
  }

  get rscene() {
    return this.mScene;
  }

  initialize(param) {
    if (!param) param = {};
    const r = param.renderer;
    this.mScene.initialize(r ? r : {});
    const entities = param.entities;

    if (entities && entities.length !== undefined) {
      for (let i = 0; i < entities.length; ++i) {
        this.addObject(entities[i]);
      }
    }
  }
  /**
   * 加入的可能是 entity 也能是 light对象 以及某种场景对象描述 等等
   */


  addObject(entityParam, processIndex) {
    let entity = this.mBuilder.createEntity(entityParam);
    this.mScene.addEntity(entity, processIndex);
  }

  addEntity(entity, processIndex = 0) {
    this.mScene.addEntity(entity, processIndex);
    return this;
  }

  removeEntity(entity) {
    this.mScene.removeEntity(entity);
  }
  /**
   * @param type event type
   * @param func event listerner callback function
   * @param captureEnabled the default value is true
   * @param bubbleEnabled the default value is false
   */


  addEventListener(type, func, captureEnabled = true, bubbleEnabled = true) {
    this.mScene.addEventListener(type, func, captureEnabled, bubbleEnabled);
  }
  /**
   * @param type event type
   * @param func event listerner callback function
   */


  removeEventListener(type, func) {
    this.mScene.removeEventListener(type, func);
  }

  run(rendering = true) {
    this.mScene.run(rendering);
  }

  destroy() {}

}

exports.DataDrivenRScene = DataDrivenRScene;

/***/ }),

/***/ "58c4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGTextureDataDescriptor_1 = __webpack_require__("37b8");

exports.texDescriptorFilter = WGTextureDataDescriptor_1.texDescriptorFilter;
exports.WGTextureDataDescriptor = WGTextureDataDescriptor_1.WGTextureDataDescriptor;

class WGTextureData {
  constructor() {
    this.generateMipmaps = true;
    this.flipY = false;
    this.format = "rgba8unorm";
    this.dimension = "2d";
    this.viewDimension = "2d";
  }

  setDescripter(descriptor) {
    if (descriptor.generateMipmaps) this.generateMipmaps = descriptor.generateMipmaps;
    if (descriptor.flipY) this.flipY = descriptor.flipY;
    if (descriptor.format) this.format = descriptor.format;
    if (descriptor.dimension) this.dimension = descriptor.dimension;
    if (descriptor.viewDimension) this.viewDimension = descriptor.viewDimension;
    this.mDesc = descriptor;
    return this;
  }

  build(ctx) {
    return this.mTex;
  }

  destroy() {}

}

exports.WGTextureData = WGTextureData;

class WGImageTextureData extends WGTextureData {
  constructor() {
    super();
  }

  build(ctx) {
    if (this.mImgs && !this.mTex) {
      console.log("WGImageTextureData::build(), this.mImgs: ", this.mImgs, this.viewDimension);

      switch (this.viewDimension) {
        case "cube":
          this.mTex = ctx.texture.createTexCubeByImages(this.mImgs, this.generateMipmaps, this.flipY, this.format, this.mUrl);
          this.uid = this.mTex.uid;
          if (this.mDesc) this.mDesc.uid = this.mTex.uid;
          break;

        case "2d":
          this.mTex = ctx.texture.createTex2DByImage(this.mImgs[0], this.generateMipmaps, this.flipY, this.format, this.mUrl);
          this.uid = this.mTex.uid;
          if (this.mDesc) this.mDesc.uid = this.mTex.uid;
          break;

        default:
          console.error("Illegal operation !!!");
          break;
      }

      this.mTex.url = this.mUrl;
    }

    return this.mTex;
  }

}

exports.WGImageTextureData = WGImageTextureData;

class WGRTTTextureData extends WGTextureData {
  constructor() {
    super();
  }

  setDescripter(descriptor) {
    super.setDescripter(descriptor);
    this.mTexData = descriptor.rttTexture;
    return this;
  }

  build(ctx) {
    const td = this.mTexData;

    if (td && !this.mTex) {
      if (td.texture) {
        console.log("apply a rtt texture into a WGRTTTextureData instance.");
        this.mTex = td.texture;
        this.uid = this.mTex.uid;
        if (this.mDesc) this.mDesc.uid = this.mTex.uid;
      }
    }

    return this.mTex;
  }

}

exports.WGRTTTextureData = WGRTTTextureData;

class WGDataTextureData extends WGTextureData {
  constructor() {
    super();
  }

  setDescripter(descriptor) {
    super.setDescripter(descriptor);
    this.mTexData = descriptor.dataTexture;
    return this;
  }

  build(ctx) {
    const desc = this.mDesc;
    const td = this.mTexData;

    if (td && desc) {
      if (!this.mTex) {
        if (td.texture) {
          console.log("apply a texture in the WGDataTextureData instance: ", this);
          this.mTex = td.texture;
          this.uid = this.mTex.uid;
          if (this.mDesc) this.mDesc.uid = this.mTex.uid;
        } else if (td.data) {
          console.log("create a texture in the WGDataTextureData instance: ", this);
          this.mTex = ctx.texture.createDataTexture([td.data], td.width, td.height, {
            format: desc.format
          }, desc.generateMipmaps);
          this.uid = this.mTex.uid;
          if (this.mDesc) this.mDesc.uid = this.mTex.uid;
        } else if (td.datas && td.datas.length > 0) {
          console.log("create a custom mipmap texture in the WGDataTextureData instance: ", this);
          this.mTex = ctx.texture.createDataTexture(td.datas, td.width, td.height, {
            format: desc.format,
            viewDimension: this.viewDimension
          }, desc.generateMipmaps);
          this.uid = this.mTex.uid;
          if (this.mDesc) this.mDesc.uid = this.mTex.uid;
        }
      }
    }

    return this.mTex;
  }

}

class WGImage2DTextureData extends WGImageTextureData {
  constructor(url) {
    super();

    if (url && url !== "") {
      this.initByURL(url);
    }
  }

  setImage(image) {
    this.mImgs = [image];
    return this;
  }

  setDescripter(descriptor) {
    super.setDescripter(descriptor);

    if (this.dimension !== "2d") {
      throw Error("Illegal Operation !!!");
    }

    if (descriptor.url) {
      this.initByURL(descriptor.url);
    } else if (descriptor.urls) {
      this.initByURL(descriptor.urls[0]);
    }

    if (descriptor.images) {
      this.setImage(descriptor.images[0]);
    } else if (descriptor.image) {
      this.setImage(descriptor.image);
    }

    return this;
  }

  initByURL(url) {
    this.mUrl = url;
    fetch(url).then(response => {
      try {
        response.blob().then(blob => {
          createImageBitmap(blob).then(bmp => {
            this.mImgs = [bmp];
          });
        });
      } catch (e) {
        console.error("WGImageTextureData::initByURL(), error url: ", url);
        return null;
      }
    });
    return this;
  }

}

exports.WGImage2DTextureData = WGImage2DTextureData;

class WGImageCubeTextureData extends WGImageTextureData {
  constructor(urls) {
    super();

    if (urls && urls.length >= 6 && urls[0] !== "") {
      this.initCubeMapURLs(urls);
    }
  }

  setImages(images) {
    this.mImgs = images;
    return this;
  }

  setDescripter(descriptor) {
    super.setDescripter(descriptor);

    if (this.viewDimension !== "cube") {
      throw Error("Illegal Operation !!!");
    }

    if (descriptor.urls) {
      this.initCubeMapURLs(descriptor.urls);
    }

    if (descriptor.images) {
      this.setImages(descriptor.images);
    }

    return this;
  }

  async createCubeMapImgsByUrls(urls) {
    const promises = urls.map(async src => {
      const response = await fetch(src);
      return createImageBitmap(await response.blob());
    });
    const images = await Promise.all(promises);
    return images;
  }

  initCubeMapURLs(urls) {
    this.viewDimension = "cube";
    this.mUrl = urls[0];
    this.createCubeMapImgsByUrls(urls).then(imgs => {
      this.mImgs = imgs;
    });
    return this;
  }

}

exports.WGImageCubeTextureData = WGImageCubeTextureData;

class WGTexture {
  constructor() {
    this.name = "WGTexture";
    this.shdVarName = "";
    this.generateMipmaps = true;
    this.flipY = true;
    this.dimension = "2d";
    this.viewDimension = '2d';
  }

}

exports.WGTexture = WGTexture;

class WGTexSampler {
  constructor() {
    this.name = "WGTexture";
    this.shdVarName = "";
  }

}

class WGTextureWrapper {
  constructor(param) {
    this.bindGroupIndex = 0;
    const tp = param.texture;
    this.texture = new WGTexture();
    const tex = this.texture;

    for (var k in tp) {
      tex[k] = tp[k];
    }

    if (this.texture.data) {
      let td = this.texture.data;
      if (td.generateMipmaps) tex.generateMipmaps = td.generateMipmaps;
      if (td.flipY) tex.flipY = td.flipY;
      if (td.dimension) tex.dimension = td.dimension;
      if (td.viewDimension) tex.viewDimension = td.viewDimension;
      if (td.format) tex.format = td.format;
    }

    const sp = param.sampler;

    if (sp) {
      this.sampler = new WGTexSampler();
      const s = this.sampler;

      for (var k in sp) {
        s[k] = sp[k];
      }
    }
  }

  destroy() {}

}

exports.WGTextureWrapper = WGTextureWrapper;

const __$texDataMap = new Map();

function createDataWithDescriptor(descriptor) {
  // let dimension = descriptor.dimension ? descriptor.dimension : "2d";
  let td;
  const dpt = WGTextureDataDescriptor_1.texDescriptorFilter(descriptor);
  let viewDimension = dpt.viewDimension ? dpt.viewDimension : "2d";
  const map = __$texDataMap;
  let key = "";

  if (dpt.url !== undefined) {
    key = dpt.url;
  } else if (dpt.urls !== undefined) {
    key = dpt.urls[0];
  }

  if (key === "") {
    if (dpt.uuid !== undefined) {
      key = dpt.uuid;
    }
  }

  if (key !== "") {
    if (map.has(key)) {
      return map.get(key);
    }
  }

  switch (viewDimension) {
    case "2d":
      console.log("create a 2d texture instance ...");

      if (dpt.rttTexture) {
        td = new WGRTTTextureData().setDescripter(dpt);
      } else if (dpt.dataTexture) {
        td = new WGDataTextureData().setDescripter(dpt);
      } else {
        td = new WGImage2DTextureData().setDescripter(dpt);
      }

      break;

    case "cube":
      console.log("create a cube texture instance ...");

      if (dpt.dataTexture) {
        td = new WGDataTextureData().setDescripter(dpt);
      } else {
        td = new WGImageCubeTextureData().setDescripter(dpt);
      }

      break;

    default:
      throw Error("Illegal Operation !!!");
      break;
  }

  if (td) {
    if (key !== "") {
      map.set(key, td);
    }
  }

  return td;
}

exports.createDataWithDescriptor = createDataWithDescriptor;

/***/ }),

/***/ "5b33":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__("9e6d");

const ButtonDivItem_1 = __webpack_require__("8895");

const DemoTagGroup_1 = __webpack_require__("e943");

const define_1 = __webpack_require__("b2e4");

exports.DemoParam = define_1.DemoParam;

class UISystem {
  constructor() {
    this.mPrevBtn = new ButtonDivItem_1.ButtonDivItem();
    this.mNextBtn = new ButtonDivItem_1.ButtonDivItem();
    this.mTagGroup = new DemoTagGroup_1.DemoTagGroup();
  }

  initEvent() {
    console.log('initEvent() ....');

    window.onkeydown = evt => {
      console.log('evt: ', evt);

      switch (evt.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
        case 'PageUp':
          this.toPrevDemo();
          break;

        case 'ArrowDown':
        case 'ArrowRight':
        case 'PageDown':
          this.toNextDemo();
          break;

        default:
          break;
      }
    };
  }

  toPrevDemo() {
    this.mana.downIndex();
    window.location.reload();
  }

  toNextDemo() {
    this.mana.upIndex();
    window.location.reload();
  }

  initialize(param) {
    this.initDemoNameBar(param);
    let div = this.initTagGroupDiv(param);
    this.initEvent();
    this.mTagGroup.mana = this.mana;
    this.mTagGroup.initialize(div, param); // document.body.style.backgroundImage = `linear-gradient(to right bottom, #159957, #155799)`;

    document.body.style.background = `#333333`;
  }

  initDemoNameBar(param) {
    let div = util_1.createDiv(0, 513, 512, 37);
    document.body.appendChild(div);
    div.innerHTML = param.name + "(" + (param.index + 1) + "/" + param.demoNames.length + ")";
    let style = div.style;
    style.textAlign = 'center';
    style.backgroundColor = '#403b54';
    style.color = '#eeeeee';
    style.fontSize = "25px";
  }

  initRightInfoNameBar(param) {
    let btn = this.mPrevBtn;
    let div = util_1.createDiv(513, 513, 255, 37);
    document.body.appendChild(div);
    btn.setDeselectColors([0x008CBA, 0x0094D9, 0x00B4F4]);
    btn.initialize(div, 'Prev Demo', 'prevDemo');
    btn.setTextSize("25px");
    btn.setTextColor(0xffffff);
    btn.setTextAlign('center');

    btn.onmouseup = () => {
      this.toPrevDemo();
    };

    btn = this.mNextBtn;
    div = util_1.createDiv(513 + 257, 513, 255, 37);
    document.body.appendChild(div);
    btn.setDeselectColors([0x008CBA, 0x0094D9, 0x00B4F4]);
    btn.initialize(div, 'Next Demo', 'nextDemo');
    btn.setTextSize("25px");
    btn.setTextColor(0xffffff);
    btn.setTextAlign('center');

    btn.onmouseup = () => {
      this.toNextDemo();
    };
  }

  initTagGroupDiv(param) {
    let div = util_1.createDiv(513, 0, 512, 512);
    document.body.appendChild(div);
    let style = div.style;
    style.backgroundColor = '#272637';
    this.initRightInfoNameBar(param);
    return div;
  }

}

exports.UISystem = UISystem;

/***/ }),

/***/ "5bd3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const gameOfLife_wgsl_1 = __importDefault(__webpack_require__("32d5"));

const WGRUniformValue_1 = __webpack_require__("7650");

const WGRStorageValue_1 = __webpack_require__("e44f");

const ComputeEntity_1 = __webpack_require__("dca8");

const gridSize = 64;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, cell.y+1) +
							cellActive(cell.x+1, cell.y) +
							cellActive(cell.x+1, cell.y-1) +
							cellActive(cell.x, cell.y-1) +
							cellActive(cell.x-1, cell.y-1) +
							cellActive(cell.x-1, cell.y) +
							cellActive(cell.x-1, cell.y+1) +
							cellActive(cell.x, cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
		}
	}
}`;

class GameOfLifeTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mFlag = 6;

    this.mouseDown = evt => {
      this.mFlag = 1;
    };

    this.mNodes = [];
    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLifeTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.6 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0
    };
    let sharedData1 = {
      data: cellStateArray1
    };
    const v0 = new WGRUniformValue_1.WGRUniformValue({
      data: gridsSizesArray,
      stride: 2,
      shared
    });
    v0.toVisibleAll(); // build rendering uniforms

    const va1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const vb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleVertComp(); // build computing uniforms

    const compva1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const compva2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleComp();
    compva2.toBufferForStorage();
    const compvb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const compvb2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleComp();
    compvb2.toBufferForStorage();
    let objs = [{
      ufvs0: [v0, va1],
      ufvs1: [v0, vb1]
    }, {
      ufvs0: [v0, compva1, compva2],
      ufvs1: [v0, compvb1, compvb2]
    }];
    return objs;
  }

  initScene() {
    const rc = this.mRscene;
    let ufvsObjs = this.createUniformValues(); // build ping-pong rendering process

    let shaderSrc = {
      code: gameOfLife_wgsl_1.default,
      uuid: "shader-gameOfLife"
    };
    let instanceCount = gridSize * gridSize;
    let uniformValues = ufvsObjs[0].ufvs0;
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      x: -0.8,
      y: -0.8,
      width: 1.6,
      height: 1.6,
      shadinguuid: "rshd0",
      shaderSrc,
      uniformValues,
      instanceCount
    });
    rc.addEntity(entity);
    this.mNodes = [{
      rendEntity: entity,
      compEntity: null
    }];
    entity.visible = false;
    const geometry = this.mNodes[0].rendEntity.geometry;
    uniformValues = ufvsObjs[0].ufvs1;
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shadinguuid: "rshd1",
      shaderSrc,
      uniformValues,
      instanceCount,
      geometry
    });
    rc.addEntity(entity);
    this.mNodes.push({
      rendEntity: entity,
      compEntity: null
    }); // build ping-pong computing process

    shaderSrc = {
      code: compShdCode,
      uuid: "shader-computing"
    };
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    uniformValues = ufvsObjs[1].ufvs1;
    let compEentity = new ComputeEntity_1.ComputeEntity({
      shadinguuid: "compshd0",
      shaderSrc,
      uniformValues
    }).setWorkcounts(workgroupCount, workgroupCount);
    rc.addEntity(compEentity);
    compEentity.visible = false;
    this.mNodes[0].compEntity = compEentity;
    uniformValues = ufvsObjs[1].ufvs0;
    compEentity = new ComputeEntity_1.ComputeEntity({
      shadinguuid: "compshd1",
      shaderSrc,
      uniformValues
    }).setWorkcounts(workgroupCount, workgroupCount);
    rc.addEntity(compEentity);
    this.mNodes[1].compEntity = compEentity;
  }

  run() {
    let rendering = this.mNodes[0].compEntity.isRendering();

    if (rendering) {
      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        return;
      }

      this.mFrameDelay = 3;
      const nodes = this.mNodes;

      for (let i = 0; i < nodes.length; i++) {
        const t = nodes[i];
        const flag = (this.mStep % 2 + i) % 2 == 0;
        t.rendEntity.visible = flag;
        t.compEntity.visible = flag;
      }

      this.mStep++;
    }

    this.mRscene.run(rendering);
  }

  run2() {
    if (this.mRscene.renderer.isEnabled()) {
      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        return;
      }

      this.mFrameDelay = 3;
      const nodes = this.mNodes;

      for (let i = 0; i < nodes.length; i++) {
        const t = nodes[i];
        t.rendEntity.visible = false;
        t.compEntity.visible = false;
      }

      let index = this.mStep % 2;
      nodes[index].rendEntity.visible = true;
      nodes[index].compEntity.visible = true;
      this.mStep++;
      this.mRscene.run();
    }
  }

}

exports.GameOfLifeTest = GameOfLifeTest;

/***/ }),

/***/ "5dcd":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nconst weight = array<f32, 5>(0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\nfn calcBlurColor(uv: vec2f) -> vec4f {\r\n    var dv = vec2f(0.0, param.z) / param.xy;\r\n    let dy = dv.y;\r\n\r\n    var result = textureSample(texture0, sampler0, uv) * weight[0];\r\n\tfor (var i: i32 = 1; i < 5; i++)  {\r\n        dv.y = dy * f32(i);\r\n        result += textureSample(texture0, sampler0, uv + dv) * weight[i];\r\n        result += textureSample(texture0, sampler0, uv - dv) * weight[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcBlurColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "5df3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class CamDragSwinger {
  constructor() {
    this.m_stage3D = null;
    this.m_camera = null;
    this.m_mouseX = 0.0;
    this.m_mouseY = 0.0;
    this.m_enabled = false;
    this.m_rotationSpeed = 0.0;
    this.m_aotuRotationDelay = 100.0;
    this.autoRotationEnabled = false;
    this.autoRotationSpeed = 0.2;
    this.rotationAttenuationEnabled = false;
    this.rotationSpeed = 0.2;
  }

  initialize(stage3D, camera) {
    if (this.m_stage3D == null) {
      this.m_stage3D = stage3D;
      this.m_camera = camera;
    }
  }

  attach() {
    this.m_mouseX = this.m_stage3D.mouseX;
    this.m_mouseY = this.m_stage3D.mouseY;
    this.m_enabled = true;
    this.m_aotuRotationDelay = 100;
  }

  detach() {
    this.m_enabled = false;
  }

  runWithYAxis() {
    this.runWithAxis(Vector3_1.default.Y_AXIS);
  }

  runWithZAxis() {
    this.runWithAxis(Vector3_1.default.Z_AXIS);
  }

  run(axis, type) {
    if (this.m_enabled) {
      let dx = this.m_mouseX - this.m_stage3D.mouseX;
      let dy = this.m_mouseY - this.m_stage3D.mouseY;
      let abs_dx = Math.abs(dx);
      let abs_dy = Math.abs(dy);

      if (abs_dx > abs_dy) {
        if (abs_dx > 0.5) {
          if (type < 1) {
            this.m_camera.swingHorizontalWithAxis(dx * 0.2, axis);
          } else {
            this.m_camera.swingHorizontal(dx * 0.2);
          }
        }
      } else {
        if (abs_dy > 0.5) {
          this.m_camera.swingVertical(dy * -0.2);
        }
      }

      this.m_mouseX = this.m_stage3D.mouseX;
      this.m_mouseY = this.m_stage3D.mouseY;
    } else if (this.autoRotationEnabled) {
      if (this.m_aotuRotationDelay < 0) {
        if (type < 1) {
          this.m_camera.swingHorizontalWithAxis(this.autoRotationSpeed, axis);
        } else {
          this.m_camera.swingHorizontal(this.autoRotationSpeed);
        }
      } else {
        this.m_aotuRotationDelay--;
      }
    }
  }

  runWithAxis(axis) {
    this.run(axis, 0);
  }

  runWithCameraAxis() {
    this.run(null, 1);
  }

}

exports.CamDragSwinger = CamDragSwinger;

/***/ }),

/***/ "5fd4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const gameOfLifePretty_wgsl_1 = __importDefault(__webpack_require__("7917"));

const WGRUniformValue_1 = __webpack_require__("7650");

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGCompMaterial_1 = __webpack_require__("19f9");

const WGMaterial_1 = __webpack_require__("943f");

const gridSize = 64;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;
@group(0) @binding(3) var<storage, read_write> lifeState: array<f32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, 		cell.y+1) +
							cellActive(cell.x+1, 	cell.y) +
							cellActive(cell.x+1, 	cell.y-1) +
							cellActive(cell.x, 		cell.y-1) +
							cellActive(cell.x-1, 	cell.y-1) +
							cellActive(cell.x-1, 	cell.y) +
							cellActive(cell.x-1, 	cell.y+1) +
							cellActive(cell.x, 		cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
			if(cellStateOut[i] > 0) {
				lifeState[i] += 0.5;
			} else {
				lifeState[i] -= 0.5;
			}
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
			lifeState[i] += 0.5;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
			lifeState[i] = 0.01;
		}
	}
	if(lifeState[i] < 0.01) { lifeState[i] = 0.01; }
}`;

class GameOfLifePretty {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLifePretty::initialize() ...");
    this.initScene();
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.8 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    const lifeStateArray3 = new Float32Array(gridSize * gridSize);

    for (let i = 0; i < lifeStateArray3.length; i++) {
      lifeStateArray3[i] = 0.01;
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0,
      shared
    };
    let sharedData1 = {
      data: cellStateArray1,
      shared
    };
    let sharedData3 = {
      data: lifeStateArray3,
      shared
    };
    const v0 = new WGRUniformValue_1.WGRUniformValue({
      data: gridsSizesArray,
      stride: 2,
      shared
    });
    v0.toVisibleAll(); // build rendering uniforms

    const va1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const vb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const vc1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared
    }).toVisibleAll(); // build computing uniforms

    const compva1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const compva2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleComp();
    compva2.toBufferForStorage();
    const compvb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared
    }).toVisibleVertComp();
    const compvb2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared
    }).toVisibleComp();
    compvb2.toBufferForStorage();
    const compv3 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared
    }).toVisibleComp();
    compv3.toBufferForStorage();
    return [{
      ufvs0: [v0, va1, vc1],
      ufvs1: [v0, vb1, vc1]
    }, {
      ufvs0: [v0, compva1, compva2, compv3],
      ufvs1: [v0, compvb1, compvb2, compv3]
    }];
  }

  createMaterial(shaderSrc, uniformValues, shadinguuid, instanceCount) {
    return new WGMaterial_1.WGMaterial({
      shadinguuid,
      shaderSrc,
      instanceCount,
      uniformValues
    });
  }

  createCompMaterial(shaderSrc, uniformValues, shadinguuid, workgroupCount = 2) {
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid,
      shaderSrc,
      uniformValues
    }).setWorkcounts(workgroupCount, workgroupCount);
  }

  initScene() {
    const rc = this.mRscene;
    const ufvsObjs = this.createUniformValues();
    const instanceCount = gridSize * gridSize;
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    let shaderSrc = {
      code: gameOfLifePretty_wgsl_1.default,
      uuid: "shader-gameOfLife"
    };
    let compShaderSrc = {
      code: compShdCode,
      uuid: "shader-computing"
    };
    const materials = [// build ping-pong rendering process
    this.createMaterial(shaderSrc, ufvsObjs[0].ufvs0, "rshd0", instanceCount), this.createMaterial(shaderSrc, ufvsObjs[0].ufvs1, "rshd1", instanceCount), // build ping-pong computing process
    this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs1, "compshd0", workgroupCount), this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs0, "compshd1", workgroupCount)];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 1.6, 1.6],
      materials
    });
    rc.addEntity(entity);
    this.mEntity = entity;
  }

  run() {
    let rendering = this.mEntity.isRendering();

    if (rendering) {
      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        return;
      }

      this.mFrameDelay = 3;
      const ms = this.mEntity.materials;

      for (let i = 0; i < ms.length; i++) {
        ms[i].visible = (this.mStep % 2 + i) % 2 == 0;
      }

      this.mStep++;
    }

    this.mRscene.run(rendering);
  }

}

exports.GameOfLifePretty = GameOfLifePretty;

/***/ }),

/***/ "601e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const FixScreenEntity_1 = __webpack_require__("f22d");

const WGRenderer_1 = __webpack_require__("cae9"); // import vertWGSL from "./shaders/colorTriangle.vert.wgsl";
// import fragWGSL from "./shaders/colorTriangle.frag.wgsl";


const vertWGSL = `
struct VSOut {
    @builtin(position) Position: vec4f,
    @location(0) color: vec3f,
};

@vertex
fn main(@location(0) inPos: vec3f,
        @location(1) inColor: vec3f) -> VSOut {
    var vsOut: VSOut;
    vsOut.Position = vec4(inPos, 1.0);
    vsOut.color = inColor;
    return vsOut;
}
`;
const fragWGSL = `
@fragment
fn main(@location(0) inColor: vec3f) -> @location(0) vec4f {
    return vec4f(inColor, 1.0);
}
`;
const position = new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, 0.0]);
const color = new Float32Array([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]);

class VertColorTriangle {
  constructor() {
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    const renderer = this.renderer;
    const shdSrc = {
      vert: {
        code: vertWGSL
      },
      frag: {
        code: fragWGSL
      }
    };
    const materials = [new WGMaterial_1.WGMaterial({
      shadinguuid: "shapeMaterial",
      shaderSrc: shdSrc
    })];
    const geometry = new WGGeometry_1.WGGeometry().addAttributes([{
      position
    }, {
      color
    }]);
    renderer.addEntity(new FixScreenEntity_1.FixScreenEntity({
      geometry,
      materials
    }));
  }

  run() {
    this.renderer.run();
  }

}

exports.VertColorTriangle = VertColorTriangle;

/***/ }),

/***/ "603e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Line3DEntity_1 = __webpack_require__("648f");

function buildPosData(param) {
  let size = param.axisLength !== undefined ? param.axisLength : 200;
  let sizeX = param.xAxisLength;
  let sizeY = param.yAxisLength;
  let sizeZ = param.zAxisLength;
  sizeX = sizeX !== undefined ? sizeX : size;
  sizeY = sizeY !== undefined ? sizeY : size;
  sizeZ = sizeZ !== undefined ? sizeZ : size;
  let v0 = new Vector3_1.default();
  let vx = new Vector3_1.default(sizeX);
  let vy = new Vector3_1.default(0, sizeY);
  let vz = new Vector3_1.default(0, 0, sizeZ);
  let linePositions = [v0, vx, v0, vy, v0, vz];
  param.linePositions = linePositions;
}

function buildColorData(param) {
  let c = new Color4_1.default(1.0, 0.0, 0.0);
  let cx = param.xAxisColor ? c.toWhite().setColor(param.xAxisColor) : c;
  c = new Color4_1.default(0.0, 1.0, 0.0);
  let cy = param.yAxisColor ? c.toWhite().setColor(param.yAxisColor) : c;
  c = new Color4_1.default(0.0, 0.0, 1.0);
  let cz = param.zAxisColor ? c.toWhite().setColor(param.zAxisColor) : c;
  let lineColors = [cx, cx, cy, cy, cz, cz];
  param.lineColors = lineColors;
}

class AxisEntity extends Line3DEntity_1.Line3DEntity {
  constructor(param) {
    if (!param) param = {};
    param.dashedData = true;

    if (!param.linePositions) {
      buildPosData(param);
    }

    if (!param.lineColors) {
      buildColorData(param);
    }

    super(param);
  }

}

exports.AxisEntity = AxisEntity;

/***/ }),

/***/ "6065":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTwoTexture_frag_wgsl_1 = __importDefault(__webpack_require__("d0b3"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

class MultiTexturedCube {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    console.log("MultiTexturedCube::initialize() ...");
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTwoTexture_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const texDataList = [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg"), new WGTextureWrapper_1.WGImage2DTextureData("static/assets/default.jpg")];
    const material = this.createMaterial(shdSrc, texDataList);
    this.createEntity([material]);
  }

  createMaterial(shaderSrc, texDatas) {
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createCube(200);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);
    const entity = new Entity3D_1.Entity3D({
      geometry,
      materials
    });
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.renderer.run();
  }

}

exports.MultiTexturedCube = MultiTexturedCube;

/***/ }),

/***/ "611e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n    return vec4f(color.xyz, color.w);\r\n}\r\n");

/***/ }),

/***/ "6130":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGEntityNode_1 = __webpack_require__("0884");

exports.WGWaitEntityNode = WGEntityNode_1.WGWaitEntityNode;

class WGEntityNodeMana {
  constructor() {
    this.mNodes = [];
    this.mEnabled = false;
  }

  receiveNode(wnode) {
    wnode.block.addEntityToBlock(wnode.entity, wnode.node);
    wnode.entity = null;
    wnode.node = null;
    wnode.builder = null;
    wnode.block = null;
  }

  addEntity(node) {
    this.mNodes.push(node); // console.log("WGEntityNodeMana::addEntity(), this.mNodes.length: ", this.mNodes.length);
  }

  update() {
    // console.log("WGEntityNodeMana::update(), this.mNodes.length: ", this.mNodes.length, this.mEnabled);
    if (this.mEnabled) {
      const ls = this.mNodes;

      for (let i = 0; i < ls.length; ++i) {
        const node = ls[i];
        const entity = node.entity;

        if (node.rever == node.node.rstate.__$rever) {
          // console.log('A entity.isREnabled(): ', entity.isREnabled());
          if (!entity.isREnabled()) {
            const ms = entity.materials;

            if (ms) {
              // console.log("ppp b 03");
              for (let j = 0; j < ms.length; ++j) {
                this.updateMaterial(ms[j]);
              }
            } // 保证顺序


            if (!(node.syncSort === false)) {
              break;
            }
          } // console.log('B entity.isREnabled(): ', entity.isREnabled());


          if (entity.isREnabled()) {
            console.log("WGEntityNodeMana::update(), a entity is rendering enabled.");
            ls.splice(i, 1);
            --i;
            this.receiveNode(node);
          }
        } else {
          ls.splice(i, 1);
          --i;
          console.log("WGEntityNodeMana::update(), remove a waiting entity.");
        }
      }
    }
  }

  updateMaterial(m) {
    if (!m.isREnabled()) {
      const ctx = this.wgctx;
      const texs = m.textures;

      for (let i = 0; i < texs.length; ++i) {
        const tex = texs[i];

        if (tex.texture && tex.texture.data && !tex.texture.texture) {
          tex.texture.texture = tex.texture.data.build(ctx);
        }
      }
    }
  }

  updateToTarget() {
    this.mEnabled = true;
  }

}

exports.WGEntityNodeMana = WGEntityNodeMana;

/***/ }),

/***/ "626c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class BitConst {
  static pushThreeBitValueToInt(target, value) {
    return (target << 3) + value;
  }

  static popThreeBitValueFromInt(target) {
    BitConst.value = 7 & target;
    return target >> 3;
  }

  static containsBit(target, bit) {
    return (bit & target) > 0;
  }

  static removeBit(target, bit) {
    return ~bit & target;
  }

  static addBit(target, bit) {
    return bit | target;
  }

  static assembleFromIntArray(intArray) {
    let bit = 0x0;
    let len = intArray.length;

    for (let i = 0; i < len; ++i) {
      if (intArray[i] > 0) {
        bit |= 1 << i;
      }
    }

    return bit;
  }

}

BitConst.ZERO = 0;
BitConst.ONE_0 = 1; // 0b1

BitConst.ONE_1 = 1 << 1; // 0b10

BitConst.ONE_2 = 1 << 2; // 0b100

BitConst.ONE_3 = 1 << 3; // 0b1000

BitConst.ONE_4 = 1 << 4; // 0b10000

BitConst.ONE_5 = 1 << 5; // 0b100000

BitConst.ONE_6 = 1 << 6; // 0b1000000

BitConst.ONE_7 = 1 << 7; // 0b10000000

BitConst.ONE_8 = 1 << 8; // 0b100000000

BitConst.ONE_9 = 1 << 9; // 0b1000000000

BitConst.ONE_10 = 1 << 10; // 0b10000000000

BitConst.ONE_11 = 1 << 11; // 0b100000000000

BitConst.value = 0;
exports.default = BitConst;

/***/ }),

/***/ "63d8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRPrimitive_1 = __webpack_require__("b720");

const WGRUnit_1 = __webpack_require__("842f");

const WGRCompUnit_1 = __webpack_require__("5648");

const WGRPipelineCtxParams_1 = __webpack_require__("bf93");

const Define_1 = __webpack_require__("af1b");

class WGRObjBuilder {
  constructor() {}

  createPrimitive(geomParam) {
    // console.log('XXXXXX createPrimitive() ...');
    const g = new WGRPrimitive_1.WGRPrimitive();
    g.ibuf = geomParam.indexBuffer;
    g.vbufs = geomParam.vertexBuffers;

    if (geomParam.indexCount !== undefined) {
      g.indexCount = geomParam.indexCount;
    }

    if (geomParam.vertexCount !== undefined) {
      g.vertexCount = geomParam.vertexCount;
    }

    if (geomParam.drawMode !== undefined) {
      g.drawMode = geomParam.drawMode;
    }

    return g;
  }

  testShaderSrc(shdSrc) {
    if (shdSrc) {
      if (shdSrc.code !== undefined && !shdSrc.shaderSrc) {
        const obj = {
          code: shdSrc.code,
          uuid: shdSrc.uuid
        };

        if (WGRPipelineCtxParams_1.findShaderEntryPoint('@compute', shdSrc.code) != '') {
          // console.log(">>>>>>>>>>> find comp shader >>>>>>>>>>>>>>>>>>>>>");
          shdSrc.compShaderSrc = shdSrc.compShaderSrc ? shdSrc.compShaderSrc : obj;
        } else {
          // console.log(">>>>>>>>>>> find curr shader >>>>>>>>>>>>>>>>>>>>>");
          shdSrc.shaderSrc = shdSrc.shaderSrc ? shdSrc.shaderSrc : obj;
        }
      }

      if (shdSrc.vert) {
        shdSrc.vertShaderSrc = shdSrc.vert;
      }

      if (shdSrc.frag) {
        shdSrc.fragShaderSrc = shdSrc.frag;
      }

      if (shdSrc.comp) {
        shdSrc.compShaderSrc = shdSrc.comp;
      }
    }
  }

  checkMaterial(material, primitive) {
    if (!material.shaderSrc.compShaderSrc) {
      const vtxParam = material.pipelineVtxParam;

      if (primitive && vtxParam) {
        const vert = vtxParam.vertex;
        vert.buffers = primitive.vbufs;
        vert.drawMode = primitive.drawMode;
      }

      const pipeDef = material.pipelineDefParam;

      if (material.doubleFace !== undefined) {
        pipeDef.faceCullMode = material.doubleFace === true ? 'none' : pipeDef.faceCullMode;
      }
    }
  }

  createRPass(entity, builder, geometry, materialIndex = 0, blockUid = 0) {
    const material = entity.materials[materialIndex]; // console.log("XXXXXXX material: ", material);

    let primitive;
    let pctx = material.getRCtx();

    if (geometry) {
      const wgctx = builder.getWGCtx();
      const dict = geometry.primitive;
      const vertexBuffers = geometry.gpuvbufs;
      const vertexCount = vertexBuffers[0].vectorCount;
      const gibuf = geometry.indexBuffer;

      if (material.wireframe === true) {
        primitive = dict.wireframe;

        if (!primitive) {
          gibuf.toWirframe();
          const indexBuffer = gibuf ? gibuf.gpuwibuf ? gibuf.gpuwibuf : wgctx.buffer.createIndexBuffer(gibuf.wireframeData) : null;
          if (indexBuffer) gibuf.gpuwibuf = indexBuffer;
          const indexCount = indexBuffer ? indexBuffer.elementCount : 0;
          primitive = this.createPrimitive({
            vertexBuffers,
            indexBuffer,
            indexCount,
            vertexCount,
            drawMode: Define_1.WGRDrawMode.LINES
          });
          dict.wireframe = primitive; // console.log("wireframe primitive.drawMode: ", primitive.drawMode, primitive);
        }
      } else {
        primitive = dict.default;

        if (!primitive) {
          const indexBuffer = gibuf ? gibuf.gpuibuf ? gibuf.gpuibuf : wgctx.buffer.createIndexBuffer(gibuf.data) : null;
          if (indexBuffer) gibuf.gpuibuf = indexBuffer;
          const indexCount = indexBuffer ? indexBuffer.elementCount : 0;
          primitive = this.createPrimitive({
            vertexBuffers,
            indexBuffer,
            indexCount,
            vertexCount,
            drawMode: geometry.drawMode
          });
          dict.default = primitive; // console.log("default primitive.drawMode: ", primitive.drawMode, primitive);
        }
      }
    }

    if (!builder.hasMaterial(material)) {
      if (!pctx) {
        this.testShaderSrc(material.shaderSrc);

        if (!material.pipelineVtxParam) {
          if (primitive) {
            material.pipelineVtxParam = {
              vertex: {
                attributeIndicesArray: []
              }
            };
            const ls = [];

            for (let i = 0; i < primitive.vbufs.length; ++i) {
              ls.push([0]);
            }

            material.pipelineVtxParam.vertex.attributeIndicesArray = ls;
          }
        }
      }

      this.checkMaterial(material, primitive);
      const node = builder.getPassNodeWithMaterial(material); // console.log('WGRObjBuilder::createRPass(), node.uid: ', node.uid, ", node: ", node);

      pctx = node.createRenderPipelineCtxWithMaterial(material);
      material.initialize(pctx);
    } // console.log("createRUnit(), utexes: ", utexes);


    const isComputing = material.shaderSrc.compShaderSrc;
    let ru;

    if (isComputing) {
      let et = entity;
      let rcompunit = new WGRCompUnit_1.WGRCompUnit();
      let compMat = material;

      if (et.workcounts) {
        rcompunit.workcounts = et.workcounts;
      }

      if (compMat && compMat.workcounts) {
        rcompunit.workcounts = compMat.workcounts;
      }

      if (!rcompunit.workcounts) {
        rcompunit.workcounts = new Uint16Array([1, 1, 0, 0]);
      }

      rcompunit.rp = pctx.rpass;
      ru = rcompunit;
    } else {
      let runit = new WGRUnit_1.WGRUnit();
      runit.geometry = primitive;
      runit.rp = pctx.rpass;
      ru = runit;
    }

    ru.pipelinectx = pctx;
    const uniformCtx = pctx.uniformCtx;
    let uvalues = [];
    const cam = builder.camera;

    if (!isComputing) {
      if (entity.transform) {
        uvalues.push(entity.transform.uniformv);
      }

      if (entity.cameraViewing) {
        uvalues.push(cam.viewUniformV);
        uvalues.push(cam.projUniformV);
      }
    }

    if (material.uniformValues) {
      uvalues = uvalues.concat(material.uniformValues);
    } // transform 与 其他材质uniform数据构造和使用应该分开,
    // 哪些uniform是依据material变化的，哪些是共享的，哪些是transform等变换的数据


    let groupIndex = 0;
    let texList = material.textures;
    let utexes; // console.log("createRUnit(), texList: ", texList);

    if (!isComputing) {
      if (texList && texList.length > 0) {
        utexes = new Array(texList.length);

        for (let i = 0; i < texList.length; i++) {
          const tex = texList[i].texture;
          let dimension = texList[i].texture.viewDimension;

          if (!tex.view) {
            tex.view = tex.texture.createView({
              dimension
            });
          }

          tex.view.dimension = dimension;
          utexes[i] = {
            texView: tex.view
          };
        }
      }
    }

    if (uvalues && uvalues.length > 0 || utexes && utexes.length > 0) {
      ru.uniforms = uniformCtx.createUniformsWithValues([{
        layoutName: material.shadinguuid,
        groupIndex: groupIndex,
        values: uvalues,
        texParams: utexes
      }], material.uniformAppend);
    }

    ru.material = material;
    ru.etuuid = entity.uuid + '-[block(' + blockUid + '), material(' + material.shadinguuid + ')]';
    return ru;
  }

  createRUnit(entity, builder, node, blockUid = 0) {
    const wgctx = builder.getWGCtx();
    const geometry = entity.geometry;
    let primitiveDict;

    if (entity.geometry) {
      primitiveDict = geometry.primitive; // console.log('>>> primitiveDict: ', primitiveDict);

      if (!primitiveDict) {
        const gts = geometry.attributes;
        const gvbufs = geometry.gpuvbufs;
        const vertexBuffers = gvbufs ? gvbufs : new Array(gts.length);

        if (!gvbufs) {
          for (let i = 0; i < gts.length; ++i) {
            const gt = gts[i];
            vertexBuffers[i] = wgctx.buffer.createVertexBuffer(gt.data, gt.bufferOffset, gt.strides);
          }

          geometry.gpuvbufs = vertexBuffers;
        }

        primitiveDict = {};
        geometry.primitive = primitiveDict;
      }
    }

    let ru;
    const mts = entity.materials;

    if (mts.length > 1) {
      const passes = new Array(mts.length);

      for (let i = 0; i < mts.length; ++i) {
        passes[i] = this.createRPass(entity, builder, geometry, i, blockUid); // passes[i].etuuid = entity.uuid + '-[block(' + blockUid+')]';
      }

      ru = new WGRUnit_1.WGRUnit(); // console.log("xxxxxxxxx passes: ", passes);

      ru.passes = passes;
    } else {
      ru = this.createRPass(entity, builder, geometry);
    }

    ru.bounds = entity.globalBounds;
    ru.st = entity.rstate;
    ru.st.__$rendering = true;
    ru.pst = node.rstate;
    ru.__$rever = ru.pst.__$rever; // ru.etuuid = entity.uuid;

    return ru;
  }

}

exports.WGRObjBuilder = WGRObjBuilder;

/***/ }),

/***/ "648f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGGeometry_1 = __webpack_require__("746a");

const DashedLineGeometry_1 = __importDefault(__webpack_require__("3e26"));

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const WGMaterial_1 = __webpack_require__("943f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const WGRUniformValue_1 = __webpack_require__("7650");

const Entity3D_1 = __webpack_require__("551f");

const line_vert_wgsl_1 = __importDefault(__webpack_require__("a7ea"));

const lineColor_vert_wgsl_1 = __importDefault(__webpack_require__("9fa7"));

const line_frag_wgsl_1 = __importDefault(__webpack_require__("964e"));

const lineColor_frag_wgsl_1 = __importDefault(__webpack_require__("07b0"));

class Line3DEntity extends Entity3D_1.Entity3D {
  constructor(param) {
    super(param);
    this.mHaveCVS = false;
    this.mColor = new Color4_1.default();
    if (!param) param = {};

    if (!(param.building === false)) {
      this.createGeometry(param);
      this.createMaterial(param);
    }

    this.mDescParam = param;

    if (param.lineColor) {
      this.color = param.lineColor;
    }
  }

  clone(param) {
    if (param) {
      if (!param.geometry) param.geometry = this.geometry;
    } else {
      param = this.mDescParam;
      param.materials = this.materials;
      param.geometry = this.geometry;
    }

    let p = new Line3DEntity(param);
    p.color = this.color;
    return p;
  }

  setColor(c) {
    if (c && this.mColorV) {
      this.mColor.setColor(c).toArray4(this.mColorV.data);
      this.mColorV.version++;
    }

    return this;
  }

  set color(c) {
    this.setColor(c);
  }

  get color() {
    return this.mColor;
  }

  getGeometryData(param) {
    if (param.linePositions === undefined) {
      param.linePositions = [new Vector3_1.default(), new Vector3_1.default(100)];
    }

    let g = new DashedLineGeometry_1.default();
    g.dashedData = param.dashedData === true ? true : false;
    g.initialize(param.linePositions, param.lineColors);
    return g;
  }

  createGeometry(param) {
    if (param && param.geometry) {
      this.geometry = param.geometry;
    } else {
      const geom = this.getGeometryData(param);

      if (geom) {
        const g = new WGGeometry_1.WGGeometry().addAttribute({
          position: geom.getVS()
        });

        if (geom.getCVS()) {
          this.mHaveCVS = true;
          g.addAttribute({
            color: geom.getCVS()
          });
        }

        g.drawMode = geom.drawMode;
        g.bounds = geom.bounds;
        g.geometryData = geom;
        this.geometry = g;
      }
    }
  }

  createMaterial(param) {
    if (param.materials) {
      this.materials = param.materials;
    } else {
      if (!param.uniformValues) {
        this.mColorV = Entity3D_1.getUniformValueFromParam("color", param, new WGRUniformValue_1.WGRUniformValue({
          data: new Float32Array([1, 1, 1, 1]),
          shdVarName: "color"
        }));
      }

      const flag = this.mHaveCVS;
      let ns = flag ? "color-" : "";
      const shaderSrc = param.shaderSrc ? param.shaderSrc : {
        vertShaderSrc: {
          code: this.mHaveCVS ? lineColor_vert_wgsl_1.default : line_vert_wgsl_1.default,
          uuid: ns + "line3DEntityVertShdCode"
        },
        fragShaderSrc: {
          code: this.mHaveCVS ? lineColor_frag_wgsl_1.default : line_frag_wgsl_1.default,
          uuid: ns + "line3DEntityFragShdCode"
        }
      };
      let b = param.depthWriteEnabled;
      b = b === false ? false : true;
      let f = param.faceCullMode;
      f = f ? f : "back";
      let bl = param.blendModes;
      bl = bl ? bl : ["solid"];
      let pipelineDefParam = {
        depthWriteEnabled: b,
        faceCullMode: f,
        blendModes: bl
      };
      let shadinguuid = param.shadinguuid !== undefined ? param.shadinguuid : ns + "line3DEntity-material";
      const material = new WGMaterial_1.WGMaterial({
        shadinguuid,
        shaderSrc,
        pipelineDefParam
      });

      if (param.instanceCount !== undefined) {
        material.instanceCount = param.instanceCount;
      }

      material.uniformValues = param.uniformValues ? param.uniformValues : [this.mColorV];

      if (material.uniformValues && material.uniformValues.length > 0) {
        this.mColorV = material.uniformValues[0];
      }

      this.materials = [material];
    }

    WGMaterial_1.checkMaterialRPasses(this.materials, param.rpasses);
  }

}

exports.Line3DEntity = Line3DEntity;

function createCircleData(ix, iy, iz, radius, segsTotal, center, beginRad = 0.0, rangeRad = 0.0) {
  if (segsTotal === undefined) segsTotal = 50;
  if (radius < 0.001) radius = 0.001;
  if (segsTotal < 3) segsTotal = 3;
  if (!center) center = new Vector3_1.default();
  let posList = new Array(segsTotal + 1);
  let vs = new Array(3);
  let j = 0;
  let rad = rangeRad;
  let range = rad > 0.0 ? rad : Math.PI * 2;
  let cvs = [center.x, center.y, center.z];
  let i = 0;

  for (; i < segsTotal; ++i) {
    rad = beginRad + range * i / segsTotal;
    vs[ix] = cvs[ix] + radius * Math.cos(rad);
    vs[iy] = cvs[iy] + radius * Math.sin(rad);
    vs[iz] = cvs[iz];
    posList[i] = new Vector3_1.default().setVector3(vs);
    j += 3;
  }

  posList[i] = posList[0];
  return posList;
}

function createLineCircleXOY(radius, segsTotal, center, beginRad = 0.0, rangeRad = 0.0) {
  let linePositions = createCircleData(0, 1, 2, radius, segsTotal, center, beginRad, rangeRad);
  return new Line3DEntity({
    linePositions
  });
}

exports.createLineCircleXOY = createLineCircleXOY;

function createLineCircleXOZ(radius, segsTotal, center, beginRad = 0.0, rangeRad = 0.0) {
  let linePositions = createCircleData(0, 2, 1, radius, segsTotal, center, beginRad, rangeRad);
  return new Line3DEntity({
    linePositions
  });
}

exports.createLineCircleXOZ = createLineCircleXOZ;

function createLineCircleYOZ(radius, segsTotal, center, beginRad = 0.0, rangeRad = 0.0) {
  let linePositions = createCircleData(1, 2, 0, radius, segsTotal, center, beginRad, rangeRad);
  return new Line3DEntity({
    linePositions
  });
}

exports.createLineCircleYOZ = createLineCircleYOZ;

/***/ }),

/***/ "6524":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class CamDragSlider {
  constructor() {
    this.m_stage3D = null;
    this.m_camera = null;
    this.m_mouseX = 0.0;
    this.m_mouseY = 0.0;
    this.m_enabled = false;
    this.slideSpeed = 2.0;
  }

  initialize(stage3D, camera) {
    if (this.m_stage3D == null) {
      this.m_stage3D = stage3D;
      this.m_camera = camera;
    }
  }

  attach() {
    this.m_mouseX = this.m_stage3D.mouseX;
    this.m_mouseY = this.m_stage3D.mouseY;
    this.m_enabled = true;
  }

  detach() {
    this.m_enabled = false;
  }

  run() {
    if (this.m_enabled) {
      let dx = (this.m_mouseX - this.m_stage3D.mouseX) * this.slideSpeed;
      let dy = (this.m_mouseY - this.m_stage3D.mouseY) * this.slideSpeed;
      this.m_camera.slideViewOffsetXY(dx, dy);
      this.m_mouseX = this.m_stage3D.mouseX;
      this.m_mouseY = this.m_stage3D.mouseY;
    }
  }

}

exports.CamDragSlider = CamDragSlider;

/***/ }),

/***/ "660c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Asserts `condition` is true. Otherwise, throws an `Error` with the provided message.
 */

function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg && (typeof msg === "string" ? msg : msg()));
  }
}

exports.assert = assert;

/***/ }),

/***/ "6729":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorUniform_frag_wgsl_1 = __importDefault(__webpack_require__("e958"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGRUniformValue_1 = __webpack_require__("7650");

class UniformTest {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
  }

  initialize() {
    console.log("UniformTest::initialize() ...");
    let rsv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx rsv.isStorage(): ", rsv.isStorage());
    console.log("xxxxxx rsv.isUniform(): ", rsv.isUniform());
    let ruv = new WGRUniformValue_1.WGRUniformValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx ruv.isStorage(): ", ruv.isStorage());
    console.log("xxxxxx ruv.isUniform(): ", ruv.isUniform());
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorUniform_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let material = this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")], ["solid"], "back");
    this.mEntity = this.createEntity([material]);
  }

  createMaterial(shaderSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc,
      pipelineDefParam
    }); // let ufv = new WGRUniformValue({data: new Float32Array([1,0,0,1])});

    let ufv = {
      data: new Float32Array([1, 0, 0, 1]),
      shdVarName: 'param'
    };
    material.uniformValues = [ufv];
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.UniformTest = UniformTest;

/***/ }),

/***/ "68f4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Matrix4_1 = __importDefault(__webpack_require__("c6d1"));

const WGRUniformValue_1 = __webpack_require__("7650");

const CameraUtils_1 = __webpack_require__("24fe");

const Frustum_1 = __webpack_require__("4942"); // const pmin = MathConst.MATH_MIN_POSITIVE;


class Camera {
  constructor(param) {
    this.mTempV = new Vector3_1.default();
    this.mTempV1 = new Vector3_1.default();
    this.mInitRV = new Vector3_1.default();
    this.mInitUp = new Vector3_1.default();
    this.mMatrix = new Matrix4_1.default();
    this.mViewMat = new Matrix4_1.default();
    this.mViewInvMat = new Matrix4_1.default();
    this.mVPMat = new Matrix4_1.default();
    this.mTempMat = new Matrix4_1.default();
    this.mProjMat = new Matrix4_1.default();
    this.mCamPos = new Vector3_1.default();
    this.mLookAtPos = new Vector3_1.default();
    this.mUp = new Vector3_1.default();
    this.mLookDirectNV = new Vector3_1.default();
    this.mLookAtDirec = new Vector3_1.default();
    this.mLookRHand = true;
    this.mNearPlaneW = 1.0;
    this.mNearPlaneH = 1.0;
    this.mViewX = 0;
    this.mViewY = 0;
    this.mViewW = 800;
    this.mViewH = 600;
    this.mViewHalfW = 400;
    this.mViewHalfH = 300;
    this.mFovRadian = 0.0;
    this.mAspect = 1.0;
    this.mZNear = 0.1;
    this.mZFar = 1000.0;
    this.mB = 0.0;
    this.mT = 0.0;
    this.mL = 0.0;
    this.mR = 0.0;
    this.mPerspective = false;
    this.mProject2Enabled = false;
    this.mRightHandEnabled = true;
    this.mRotV = new Vector3_1.default();
    this.mViewFieldZoom = 1.0;
    this.mChanged = true;
    this.mUnlock = true;
    this.version = 0;
    this.name = "Camera";
    this.frustum = new Frustum_1.Frustum();
    this.inversePerspectiveZ = false;
    this.m_tempNV = new Vector3_1.default();
    this.m_tempUPV = new Vector3_1.default();
    this.m_tempRV = new Vector3_1.default();
    this.m_tempCamPos = new Vector3_1.default();
    this.m_tempLookAtPos = new Vector3_1.default();
    this.m_rotDegree = 0.0;
    this.m_rotAxis = new Vector3_1.default();
    this.m_rotPivotPoint = null;
    this.m_axisRotEnabled = false; // getWordFrustumWAABB(): AABB { return this.mFrustumAABB; }
    // getWordFrustumWAABBCenter(): Vector3 { return this.mFrustumAABB.center; }
    // getWordFrustumVtxArr(): Vector3[] { return this.mWFrustumVS; }
    // getWordFrustumPlaneArr(): Plane[] { return this.mWFruPlanes; }

    /**
     * @param w_cv 世界坐标位置
     * @param radius 球体半径
     * @returns 0表示完全不会再近平面内, 1表示完全在近平面内, 2表示和近平面相交
     */
    // visiTestNearPlaneWithSphere(w_cv: Vector3, radius: number): number {
    //     const v = this.mFpns[1].dot(w_cv) - this.mFpds[1];// - radius;
    //     if((v - radius) > pmin) {
    //         // 表示完全在近平面之外，也就是前面
    //         return 0;
    //     }else if((v + radius) < MathConst.MATH_MAX_NEGATIVE){
    //         // 表示完全在近平面内, 也就是后面
    //         return 1;
    //     }
    //     // 表示和近平面相交
    //     return 2;
    // }
    // visiTestSphere2(w_cv: Vector3, radius: number): boolean {
    //     let boo = (this.mFpns[0].dot(w_cv) - this.mFpds[0] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[1].dot(w_cv) - this.mFpds[1] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[2].dot(w_cv) - this.mFpds[2] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[3].dot(w_cv) - this.mFpds[3] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[4].dot(w_cv) - this.mFpds[4] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[5].dot(w_cv) - this.mFpds[5] - radius) > pmin;
    //     if (boo) return false;
    //     return true;
    // }
    // visiTestSphere3(w_cv: Vector3, radius: number, farROffset: number): boolean {
    //     let boo = (this.mFpns[0].dot(w_cv) - this.mFpds[0] + farROffset - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[1].dot(w_cv) - this.mFpds[1] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[2].dot(w_cv) - this.mFpds[2] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[3].dot(w_cv) - this.mFpds[3] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[4].dot(w_cv) - this.mFpds[4] - radius) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[5].dot(w_cv) - this.mFpds[5] - radius) > pmin;
    //     if (boo) return false;
    //     return true;
    // }
    // visiTestPosition(pv: Vector3): boolean {
    //     let boo = (this.mFpns[0].dot(pv) - this.mFpds[0]) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[1].dot(pv) - this.mFpds[1]) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[2].dot(pv) - this.mFpds[2]) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[3].dot(pv) - this.mFpds[3]) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[4].dot(pv) - this.mFpds[4]) > pmin;
    //     if (boo) return false;
    //     boo = (this.mFpns[5].dot(pv) - this.mFpds[5]) > pmin;
    //     if (boo) return false;
    //     return true;
    // }
    // visiTestPlane(nv: Vector3, distance: number): boolean {
    // 	const ls = this.mWFruPlanes;
    //     let f0 = (nv.dot(ls[0].position) - distance);
    //     let f1 = f0 * (nv.dot(ls[1].position) - distance);
    //     if (f1 < pmin) return true;
    //     f1 = f0 * (nv.dot(ls[2].position) - distance);
    //     if (f1 < pmin) return true;
    //     f1 = f0 * (nv.dot(ls[3].position) - distance);
    //     if (f1 < pmin) return true;
    //     f1 = f0 * (nv.dot(ls[4].position) - distance);
    //     if (f1 < pmin) return true;
    //     f1 = f0 * (nv.dot(ls[5].position) - distance);
    //     if (f1 < pmin) return true;
    //     return false;
    // }
    // frustum intersect sphere in wrod space
    // visiTestSphere(w_cv: Vector3, radius: number): boolean {
    // 	const ls = this.mWFruPlanes;
    //     let boo = this.mFrustumAABB.sphereIntersect(w_cv, radius);
    //     if (boo) {
    //         let pf0 = ls[0].intersectSphere(w_cv, radius);
    //         let pf1 = ls[1].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[0].intersectBoo || ls[1].intersectBoo) {
    //             } else {
    //                 return false;
    //             }
    //         }
    //         pf0 = ls[2].intersectSphere(w_cv, radius);
    //         pf1 = ls[3].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[2].intersectBoo || ls[3].intersectBoo) {
    //             }
    //             else {
    //                 return false;
    //             }
    //         }
    //         pf0 = ls[4].intersectSphere(w_cv, radius);
    //         pf1 = ls[5].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[4].intersectBoo || ls[5].intersectBoo) {
    //             }
    //             else {
    //                 return false;
    //             }
    //         }
    //         return true;
    //     }
    //     return false;
    // }
    // visibility test
    // 可见性检测这边可以做的更精细，例如上一帧检测过的对象如果摄像机没有移动而且它自身也没有位置等变化，就可以不用检测
    // 例如精细检测可以分类: 圆球，圆柱体，长方体 等不同的检测模型计算方式会有区别
    // visiTestAABB(ab: AABB): boolean {
    //     //trace("ro.bounds.getCenter(): "+ro.bounds.getCenter()+","+ro.bounds.getRadius());
    //     //return mFrustumAABB.sphereIntersectFast(ro.bounds.getCenter(),ro.bounds.getRadius());
    //     let w_cv = ab.center;
    //     let radius = ab.radius;
    //     let boo = this.mFrustumAABB.sphereIntersect(w_cv, radius);
    // 	const ls = this.mWFruPlanes;
    //     if (boo) {
    //         let pf0 = ls[0].intersectSphere(w_cv, radius);
    //         let pf1 = ls[1].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[0].intersectBoo || ls[1].intersectBoo) {
    //             }
    //             else {
    //                 return false;
    //             }
    //         }
    //         pf0 = ls[2].intersectSphere(w_cv, radius);
    //         pf1 = ls[3].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[2].intersectBoo || ls[3].intersectBoo) {
    //             } else {
    //                 return false;
    //             }
    //         }
    //         pf0 = ls[4].intersectSphere(w_cv, radius);
    //         pf1 = ls[5].intersectSphere(w_cv, radius);
    //         if (pf0 * pf1 >= 0) {
    //             if (ls[4].intersectBoo || ls[5].intersectBoo) {
    //             } else {
    //                 return false;
    //             }
    //         }
    //         return true;
    //     }
    //     return false;
    // }

    this.mViewMatrix = null;
    this.viewUniformV = new WGRUniformValue_1.WGRUniformValue({
      data: this.mViewMat.getLocalFS32(),
      shared: true,
      shdVarName: "viewMat"
    });
    this.projUniformV = new WGRUniformValue_1.WGRUniformValue({
      data: this.mProjMat.getLocalFS32(),
      shared: true,
      shdVarName: "projMat"
    });

    if (param) {
      this.initialize(param);
    }
  }

  initialize(param) {
    CameraUtils_1.initializeCamera(param, this);
  } // 不允许外界修改camera数据


  lock() {
    this.mUnlock = false;
  } // 允许外界修改camera数据


  unlock() {
    this.mUnlock = true;
  }

  lookAtLH(camPos, lookAtPos, up) {
    if (this.mUnlock) {
      this.mCamPos.copyFrom(camPos);
      this.mLookAtPos.copyFrom(lookAtPos);
      this.mUp.copyFrom(up);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = false;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      this.mInitUp.copyFrom(up);
      this.mInitUp.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);
      this.mInitRV.normalize();
      this.mChanged = true;
    }
  }

  lookAtRH(camPos, lookAtPos, up) {
    if (this.mUnlock) {
      this.mCamPos.copyFrom(camPos);
      this.mLookAtPos.copyFrom(lookAtPos);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, up, this.mInitRV);
      Vector3_1.default.Cross(this.mInitRV, this.mLookAtDirec, this.mInitUp);
      this.mInitUp.normalize();
      this.mInitRV.normalize();
      this.mUp.copyFrom(this.mInitUp);
      this.mChanged = true;
    }
  }

  getLookAtLHToCamera(camera) {
    camera.lookAtLH(this.mCamPos, this.mLookAtPos, this.mUp);
  }

  getLookAtRHToCamera(camera) {
    camera.lookAtRH(this.mCamPos, this.mLookAtPos, this.mUp);
  }
  /**
   * left-hand axis perspective projection
   * @param fovRadian radian value
   * @param aspect the value is the view port width / height
   * @param zNear the camera near plane distance
   * @param zFar the camera far plane distance
   */


  perspectiveLH(fovRadian, aspect, zNear, zFar) {
    if (this.mUnlock) {
      this.mProject2Enabled = false;
      this.mAspect = aspect;
      this.mFovRadian = fovRadian;
      this.mZNear = zNear;
      this.mZFar = zFar;
      this.mProjMat.perspectiveLH(fovRadian, aspect, zNear, zFar);
      this.mViewFieldZoom = Math.tan(fovRadian * 0.5);
      this.mPerspective = true;
      this.mRightHandEnabled = false;
      this.mChanged = true;
    }
  }
  /**
   * right-hand axis perspective projection
   * @param fovRadian radian value
   * @param aspect the value is the view port width / height
   * @param zNear the camera near plane distance
   * @param zFar the camera far plane distance
   */


  perspectiveRH(fovRadian, aspect, zNear, zFar) {
    if (this.mUnlock) {
      this.mAspect = aspect;
      this.mFovRadian = fovRadian;
      this.mZNear = zNear;
      this.mZFar = zFar;
      this.mProjMat.perspectiveRH(fovRadian, aspect, zNear, zFar);
      this.mViewFieldZoom = Math.tan(fovRadian * 0.5);
      this.mProject2Enabled = false;
      this.mPerspective = true;
      this.mRightHandEnabled = true;
      this.mChanged = true;
    }
  }

  perspectiveRH2(fovRadian, pw, ph, zNear, zFar) {
    if (this.mUnlock) {
      this.mAspect = pw / ph;
      this.mFovRadian = fovRadian;
      this.mZNear = zNear;
      this.mZFar = zFar;
      this.mProjMat.perspectiveRH2(fovRadian, pw, ph, zNear, zFar);
      this.mViewFieldZoom = Math.tan(fovRadian * 0.5);
      this.mPerspective = true;
      this.mProject2Enabled = true;
      this.mRightHandEnabled = true;
      this.mChanged = true;
    }
  }

  get aspect() {
    return this.mAspect;
  }

  get viewFieldZoom() {
    return this.mViewFieldZoom;
  }

  orthoRH(zNear, zFar, b, t, l, r) {
    if (this.mUnlock) {
      this.mZNear = zNear;
      this.mZFar = zFar;
      this.mB = b;
      this.mT = t;
      this.mL = l;
      this.mR = r;
      this.mProjMat.orthoRH(b, t, l, r, zNear, zFar, this.inversePerspectiveZ ? -1 : 1);
      this.mPerspective = false;
      this.mRightHandEnabled = true;
      this.mChanged = true;
    }
  }

  orthoLH(zNear, zFar, b, t, l, r) {
    if (this.mUnlock) {
      this.mZNear = zNear;
      this.mZFar = zFar;
      this.mB = b;
      this.mT = t;
      this.mL = l;
      this.mR = r;
      this.mProjMat.orthoLH(b, t, l, r, zNear, zFar, this.inversePerspectiveZ ? -1 : 1);
      this.mPerspective = false;
      this.mRightHandEnabled = false;
      this.mChanged = true;
    }
  }

  setViewXY(px, py) {
    if (this.mUnlock) {
      this.mViewX = px;
      this.mViewY = py;
    }
  }

  setViewSize(pw, ph) {
    if (this.mUnlock) {
      if (pw != this.mViewW || ph != this.mViewH) {
        this.mViewW = pw;
        this.mViewH = ph;
        this.mViewHalfW = pw * 0.5;
        this.mViewHalfH = ph * 0.5;
        this.frustum.setViewSize(pw, ph);

        if (this.mPerspective) {
          if (this.mProject2Enabled) {
            if (this.mRightHandEnabled) this.perspectiveRH2(this.mFovRadian, pw, ph, this.mZNear, this.mZFar);
          } else {
            if (this.mRightHandEnabled) this.perspectiveRH(this.mFovRadian, pw / ph, this.mZNear, this.mZFar);else this.perspectiveLH(this.mFovRadian, pw / ph, this.mZNear, this.mZFar);
          }
        } else {
          this.orthoRH(this.mZNear, this.mZFar, -0.5 * ph, 0.5 * ph, -0.5 * pw, 0.5 * pw);
        }
      }
    }
  }

  get rightHand() {
    return this.mRightHandEnabled;
  }

  get viewX() {
    return this.mViewX;
  }

  get viewY() {
    return this.mViewY;
  }

  get viewWidth() {
    return this.mViewW;
  }

  get viewHeight() {
    return this.mViewH;
  }

  translation(v3) {
    if (this.mUnlock) {
      this.mCamPos.copyFrom(v3); // this.mLookAtPos.x = v3.x + this.mLookAtDirec.x;
      // this.mLookAtPos.y = v3.y + this.mLookAtDirec.y;
      // this.mLookAtPos.z = v3.z + this.mLookAtDirec.z;

      this.mLookAtPos.addVecsTo(v3, this.mLookAtDirec);
      this.mChanged = true;
    }
  }

  translationXYZ(px, py, pz) {
    this.mTempV.setXYZ(px, py, pz);

    if (this.mUnlock && Vector3_1.default.DistanceSquared(this.mCamPos, this.mTempV) > 0.00001) {
      this.mCamPos.setXYZ(px, py, pz);
      this.mLookAtPos.x = px + this.mLookAtDirec.x;
      this.mLookAtPos.y = py + this.mLookAtDirec.y;
      this.mLookAtPos.z = pz + this.mLookAtDirec.z;
      this.mChanged = true;
    }
  }

  forward(dis) {
    if (this.mUnlock) {
      this.mCamPos.x += this.mLookDirectNV.x * dis;
      this.mCamPos.y += this.mLookDirectNV.y * dis;
      this.mCamPos.z += this.mLookDirectNV.z * dis;
      this.mLookAtPos.addVecsTo(this.mCamPos, this.mLookAtDirec);
      this.mChanged = true;
    }
  }
  /**
   * 在平行于远平面的平面上滑动， 垂直于此平面的方向上不变
   * @param dx 摄像机 view 空间内 x方向偏移量
   * @param dy 摄像机 view 空间内 y方向偏移量
   */


  slideViewOffsetXY(dx, dy) {
    if (this.mUnlock) {
      this.mTempV.setXYZ(dx, dy, 0);
      this.mInvViewMat.transformVectorSelf(this.mTempV);
      dx = this.mTempV.x - this.mCamPos.x;
      dy = this.mTempV.y - this.mCamPos.y;
      let dz = this.mTempV.z - this.mCamPos.z;
      this.mCamPos.x += dx;
      this.mCamPos.y += dy;
      this.mCamPos.z += dz;
      this.mLookAtPos.x += dx;
      this.mLookAtPos.y += dy;
      this.mLookAtPos.z += dz;
      this.mChanged = true;
    }
  }

  forwardFixPos(dis, pos) {
    if (this.mUnlock) {
      this.mCamPos.copyFrom(this.mLookDirectNV).scaleBy(dis).addBy(pos);
      this.mLookAtPos.addVecsTo(this.mCamPos, this.mLookAtDirec);
      this.mChanged = true;
    }
  }

  swingHorizontalWithAxis(rad, axis) {
    if (this.mUnlock) {
      this.mTempMat.identity();

      if (axis != null) {
        this.mTempMat.appendRotation(rad * MathConst_1.default.MATH_PI_OVER_180, axis);
      } else {
        this.mTempMat.appendRotation(rad * MathConst_1.default.MATH_PI_OVER_180, Vector3_1.default.Y_AXIS);
      }

      this.mLookAtDirec.subVecsTo(this.mCamPos, this.mLookAtPos);
      this.mTempMat.transformVectorSelf(this.mLookAtDirec);
      this.mCamPos.addVecsTo(this.mLookAtDirec, this.mLookAtPos);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize(); //

      this.mTempMat.transformVectorSelf(this.mInitRV);
      this.mInitRV.normalize(); //Vector3.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);

      Vector3_1.default.Cross(this.mInitRV, this.mLookAtDirec, this.mUp);
      this.mUp.normalize();
      this.mChanged = true;
    }
  }

  swingHorizontal(degree) {
    if (this.mUnlock) {
      this.mTempMat.identity();
      this.mTempMat.appendRotation(degree * MathConst_1.default.MATH_PI_OVER_180, this.mUp); // this.mLookAtDirec.x = this.mCamPos.x - this.mLookAtPos.x;
      // this.mLookAtDirec.y = this.mCamPos.y - this.mLookAtPos.y;
      // this.mLookAtDirec.z = this.mCamPos.z - this.mLookAtPos.z;

      this.mLookAtDirec.subVecsTo(this.mCamPos, this.mLookAtPos);
      this.mTempMat.transformVectorSelf(this.mLookAtDirec); // this.mCamPos.x = this.mLookAtDirec.x + this.mLookAtPos.x;
      // this.mCamPos.y = this.mLookAtDirec.y + this.mLookAtPos.y;
      // this.mCamPos.z = this.mLookAtDirec.z + this.mLookAtPos.z;

      this.mCamPos.addVecsTo(this.mLookAtDirec, this.mLookAtPos); // this.mLookAtDirec.x = this.mLookAtPos.x - this.mCamPos.x;
      // this.mLookAtDirec.y = this.mLookAtPos.y - this.mCamPos.y;
      // this.mLookAtDirec.z = this.mLookAtPos.z - this.mCamPos.z;

      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);
      this.mInitRV.normalize();
      this.mChanged = true;
    }
  }

  swingVertical(degree) {
    if (this.mUnlock) {
      this.mTempMat.identity();
      this.mTempMat.appendRotation(MathConst_1.default.ToRadian(degree), this.mInitRV);
      this.mLookAtDirec.subVecsTo(this.mCamPos, this.mLookAtPos);
      this.mTempMat.transformVectorSelf(this.mLookAtDirec);
      this.mCamPos.addVecsTo(this.mLookAtDirec, this.mLookAtPos);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mInitRV, this.mLookAtDirec, this.mUp);
      this.mUp.normalize();
      this.mInitUp.copyFrom(this.mUp);
      this.mChanged = true;
    }
  }

  get position() {
    this.m_tempCamPos.copyFrom(this.mCamPos);
    return this.m_tempCamPos;
  }

  set position(v3) {
    if (this.mUnlock) {
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mTempV);
      let dot = this.mTempV.dot(this.mInitUp);
      this.mTempV1.copyFrom(this.mInitUp);
      this.mTempV1.scaleBy(dot);
      this.mTempV.subtractBy(this.mTempV1);
      this.mCamPos.copyFrom(v3);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mTempV, this.mLookAtDirec, this.mUp);
      this.mUp.normalize();
      this.mChanged = true;
    }
  }

  setPositionXYZ(px, py, pz) {
    if (this.mUnlock) {
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mTempV);
      var dot = this.mTempV.dot(this.mInitUp);
      this.mTempV1.copyFrom(this.mInitUp);
      this.mTempV1.scaleBy(dot);
      this.mTempV.subtractBy(this.mTempV1);
      this.mCamPos.setXYZ(px, py, pz);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mTempV, this.mLookAtDirec, this.mUp);
      this.mUp.normalize();
      this.mChanged = true;
    }
  }

  setLookPosXYZFixUp(px, py, pz) {
    if (this.mUnlock) {
      this.mLookAtPos.setXYZ(px, py, pz);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);
      this.mInitRV.normalize();
      this.mChanged = true;
    }
  }

  setPositionXYZFixUp(px, py, pz) {
    if (this.mUnlock) {
      this.mCamPos.setXYZ(px, py, pz);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);
      this.mInitRV.normalize();
      this.mChanged = true;
    }
  }

  setPositionFixUp(v3) {
    if (this.mUnlock) {
      this.mCamPos.copyFrom(v3);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookRHand = true;
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      Vector3_1.default.Cross(this.mLookAtDirec, this.mUp, this.mInitRV);
      this.mInitRV.normalize();
      this.mChanged = true;
    }
  }

  copyFrom(tarCam) {
    let pv = tarCam.position;
    this.mCamPos.copyFrom(pv);
    pv = tarCam.lookPosition;
    this.mLookAtPos.copyFrom(pv);
    this.near = tarCam.near;
    this.far = tarCam.far;
    this.nearPlaneWidth = tarCam.nearPlaneWidth;
    this.nearPlaneHeight = tarCam.nearPlaneHeight;
    this.perspective = tarCam.perspective;
    this.mViewInvMat.copyFrom(tarCam.viewInvertMatrix);
  }
  /**
   * @returns view space z-axis vector3 value in the world space
   */


  get nv() {
    this.m_tempNV.copyFrom(this.mLookDirectNV);
    return this.m_tempNV;
  }
  /**
   * @returns view space y-axis vector3 value in the world space
   */


  get uv() {
    this.m_tempUPV.copyFrom(this.mUp);
    return this.m_tempUPV;
  }
  /**
   * @returns view space x-axis vector3 value in the world space
   */


  get rv() {
    this.m_tempRV.copyFrom(this.mInitRV);
    return this.m_tempRV;
  }

  get lookPosition() {
    this.m_tempLookAtPos.copyFrom(this.mLookAtPos);
    return this.m_tempLookAtPos;
  }

  setLookAtPosition(pv) {
    if (this.mUnlock) {
      this.mLookAtPos.copyFrom(pv);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      this.mChanged = true;
    }
  }

  setLookAtXYZ(px, py, pz) {
    if (this.mUnlock) {
      this.mLookAtPos.setXYZ(px, py, pz);
      this.mLookAtDirec.subVecsTo(this.mLookAtPos, this.mCamPos);
      this.mLookDirectNV.copyFrom(this.mLookAtDirec);
      this.mLookDirectNV.normalize();
      this.mChanged = true;
    }
  }

  get perspective() {
    return this.mPerspective;
  }

  set perspective(boo) {
    this.mPerspective = boo;
  }

  appendRotationByAxis(degree, axis, pivotPoint = null) {
    if (this.mUnlock) {
      this.m_rotDegree = degree;
      this.mChanged = true;
      this.m_rotAxis.copyFrom(axis);
      this.m_rotPivotPoint = pivotPoint;
      this.m_axisRotEnabled = true;
    }
  }

  setRotationX(degree) {
    this.mRotV.x = degree;
    this.mChanged = true;
    this.m_axisRotEnabled = false;
  }

  getRotationX() {
    return this.mRotV.x;
  }

  setRotationY(degree) {
    this.mRotV.y = degree;
    this.mChanged = true;
    this.m_axisRotEnabled = false;
  }

  getRotationY() {
    return this.mRotV.y;
  }

  setRotationZ(degree) {
    this.mRotV.z = degree;
    this.mChanged = true;
    this.m_axisRotEnabled = false;
  }

  getRotationZ() {
    return this.mRotV.z;
  }

  setRotationXYZ(rx, ry, rz) {
    if (this.mUnlock) {
      this.mRotV.setXYZ(rx, ry, rz);
      this.mChanged = true;
      this.m_axisRotEnabled = false;
    }
  }

  screenXYToViewXYZ(px, py, outV) {
    px -= this.mViewX;
    py -= this.mViewY;

    if (this.mPerspective) {
      px = this.mNearPlaneW * (px - this.mViewHalfW) / this.mViewHalfW;
      py = this.mNearPlaneH * (this.mViewHalfH - py) / this.mViewHalfH;
    }

    outV.setXYZ(px, py, -this.mZNear); //
  }

  screenXYToWorldXYZ(px, py, outV) {
    px -= this.mViewX;
    py -= this.mViewY;

    if (this.mPerspective) {
      px = 0.5 * this.mNearPlaneW * (px - this.mViewHalfW) / this.mViewHalfW;
      py = 0.5 * this.mNearPlaneH * (this.mViewHalfH - py) / this.mViewHalfH;
    }

    outV.setXYZ(px, py, -this.mZNear);
    outV.w = 1.0;
    this.mViewInvMat.transformVectorSelf(outV);
  }

  getWorldPickingRayByScreenXY(screenX, screenY, ray_pos, ray_tv) {
    //console.log("screenX,screenY: ",screenX,screenY,this.mViewHalfW,this.mViewHalfH);
    screenX -= this.mViewX;
    screenY -= this.mViewY;

    if (this.mPerspective) {
      screenX = 0.5 * this.mNearPlaneW * (screenX - this.mViewHalfW) / this.mViewHalfW;
      screenY = 0.5 * this.mNearPlaneH * (screenY - this.mViewHalfH) / this.mViewHalfH;
      ray_pos.setXYZ(screenX, screenY, -this.mZNear);
      ray_pos.w = 1.0;
      this.mViewInvMat.transformVectorSelf(ray_pos);
      ray_tv.copyFrom(ray_pos);
      ray_tv.subtractBy(this.mCamPos);
      ray_tv.normalize();
    } else {
      screenX -= this.mViewHalfW;
      screenY -= this.mViewHalfH;
      ray_pos.setXYZ(screenX, screenY, -this.mZNear);
      ray_pos.w = 1.0;
      this.mViewInvMat.transformVectorSelf(ray_pos);
      ray_tv.copyFrom(this.mLookDirectNV);
    }
  }

  calcScreenNormalizeXYByWorldPos(pv3, scPV3) {
    scPV3.copyFrom(pv3);
    this.mVPMat.transformVectorSelf(scPV3);
    scPV3.x /= scPV3.w;
    scPV3.y /= scPV3.w;
  }

  worldPosToScreen(pv) {
    this.mViewMat.transformVector3Self(pv);
    this.mProjMat.transformVectorSelf(pv);
    pv.x /= pv.w;
    pv.y /= pv.w;
    pv.x *= this.mViewHalfW;
    pv.y *= this.mViewHalfH;
    pv.x += this.mViewX;
    pv.y += this.mViewY;
  } // 计算3D空间的球体在屏幕空间的最小包围矩形, outV的x,y表示矩形的x和y;outV的z和w表示宽和高,取值为像素数


  calcViewRectByWorldSphere(pv, radius, outV) {
    this.mViewMat.transformVector3Self(pv);
    radius *= 1.15;
    outV.x = pv.x - radius;
    outV.y = pv.y - radius;
    outV.z = pv.z;
    pv.x += radius;
    pv.y += radius;
    this.mProjMat.transformPerspV4Self(outV);
    this.mProjMat.transformPerspV4Self(pv);
    pv.z = 1.0 / pv.w;
    outV.z = pv.x * pv.z;
    outV.w = pv.y * pv.z;
    outV.z *= this.mViewHalfW;
    outV.w *= this.mViewHalfH;
    outV.x *= pv.z;
    outV.y *= pv.z;
    outV.x *= this.mViewHalfW;
    outV.y *= this.mViewHalfH;
    outV.z = outV.z - outV.x;
    outV.w = outV.w - outV.y;
    outV.x += this.mViewX;
    outV.y += this.mViewY;
  } // 计算3D空间的球体在屏幕空间的最小包围矩形, outV的x,y表示矩形的x和y;outV的z和w表示宽和高,取值0.0 - 1.0之间


  calcScreenRectByWorldSphere(pv, radius, outV) {
    this.mViewMat.transformVector3Self(pv);
    radius *= 1.15;
    outV.x = pv.x - radius;
    outV.y = pv.y - radius;
    pv.x += radius;
    pv.y += radius;
    this.mProjMat.transformPerspV4Self(outV);
    this.mProjMat.transformPerspV4Self(pv);
    pv.z = 1.0 / pv.w;
    outV.z = pv.x * pv.z;
    outV.w = pv.y * pv.z;
    outV.x *= pv.z;
    outV.y *= pv.z;
    outV.z = outV.z - outV.x;
    outV.w = outV.w - outV.y;
  }
  /*
  private mFrustumAABB = new AABB();
  private mNearPlaneHalfW = 0.5;
  private mNearPlaneHalfH = 0.5;
  private mNearWCV = new Vector3();
  private mFarWCV = new Vector3();
  private mWNV = new Vector3();
  // 4 far point, 4 near point
  private mWFrustumVS: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), null, null, null];
  // world space front,back ->(view space -z,z), world space left,right ->(view space -x,x),world space top,bottm ->(view space y,-y)
  private mWFruPlanes: Plane[] = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
  private mFpns: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
  private mFpds: number[] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
  //*/
  // getFrustumWorldPlantAt(i: number): Plane {
  //     return this.mWFruPlanes[i];
  // }


  getInvertViewMatrix() {
    return this.mInvViewMat;
  }

  get near() {
    return this.mZNear;
  }

  set near(value) {
    this.mZNear = value;
  }

  get far() {
    return this.mZFar;
  }

  set far(value) {
    this.mZFar = value;
  }

  get nearPlaneWidth() {
    return this.mNearPlaneW;
  }

  set nearPlaneWidth(value) {
    this.mNearPlaneW = value;
  }

  get nearPlaneHeight() {
    return this.mNearPlaneH;
  }

  set nearPlaneHeight(value) {
    this.mNearPlaneH = value;
  }
  /**
   * fov radian value
   */


  get fov() {
    return this.mFovRadian;
  }

  calcParam() {
    if (!this.mInvViewMat) this.mInvViewMat = new Matrix4_1.default();
    this.mInvViewMat.copyFrom(this.mViewMat);
    this.mInvViewMat.invert();
    const frustrum = this.frustum;
    frustrum.perspective = this.mPerspective;
    frustrum.setParam(this.mFovRadian, this.mZNear, this.mZFar, this.mAspect);
    frustrum.update(this.mInvViewMat);
    /*
    let plane: Plane = null;
    let halfMinH = this.mViewHalfH;
    let halfMinW = this.mViewHalfW;
    let halfMaxH = this.mViewHalfH;
    let halfMaxW = this.mViewHalfW;
    if(this.mPerspective) {
        const tanv =  Math.tan(this.mFovRadian * 0.5);
        halfMinH = this.mZNear * tanv;
        halfMinW = halfMinH * this.mAspect;
        halfMaxH = this.mZFar * tanv;
        halfMaxW = halfMaxH * this.mAspect;
    }
      const frustumPositions = this.mWFrustumVS;
    const frustumPlanes = this.mWFruPlanes;
    //console.log("Camera::calcParam(), (halfMinW, halfMinH): "+halfMinW+", "+halfMinH);
    this.mNearPlaneHalfW = halfMinW;
    this.mNearPlaneHalfH = halfMinH;
    // inner view space
    this.mNearWCV.setXYZ(0, 0, -this.mZNear);
    this.mFarWCV.setXYZ(0, 0, -this.mZFar);
    this.mInvViewMat.transformVectorSelf(this.mNearWCV);
    this.mInvViewMat.transformVectorSelf(this.mFarWCV);
    this.mWNV.subVecsTo(this.mFarWCV, this.mNearWCV);
    this.mWNV.normalize();
      // front face, far plane
    plane = frustumPlanes[0];
    plane.nv.copyFrom(this.mWNV);
    plane.distance = plane.nv.dot(this.mFarWCV);
    plane.position.copyFrom(this.mFarWCV);
    // back face, near face
    plane = frustumPlanes[1];
    plane.nv.copyFrom(frustumPlanes[0].nv);
    plane.distance = plane.nv.dot(this.mNearWCV);
    plane.position.copyFrom(this.mNearWCV);
      // frustumPositions[8] = this.mNearWCV;
    // frustumPositions[9] = this.mFarWCV;
    // frustumPositions[11] = this.mWNV;
    // far face
    frustumPositions[0].setXYZ(-halfMaxW,  -halfMaxH, -this.mZFar);
    frustumPositions[1].setXYZ( halfMaxW,  -halfMaxH, -this.mZFar);
    frustumPositions[2].setXYZ( halfMaxW,  halfMaxH,  -this.mZFar);
    frustumPositions[3].setXYZ(-halfMaxW,  halfMaxH,  -this.mZFar);
    // near face
    frustumPositions[4].setXYZ(-halfMinW, -halfMinH, -this.mZNear);
    frustumPositions[5].setXYZ( halfMinW, -halfMinH, -this.mZNear);
    frustumPositions[6].setXYZ( halfMinW,  halfMinH, -this.mZNear);
    frustumPositions[7].setXYZ(-halfMinW,  halfMinH, -this.mZNear);
      const invM = this.mInvViewMat;
    invM.transformVectorSelf(frustumPositions[0]);
    invM.transformVectorSelf(frustumPositions[1]);
    invM.transformVectorSelf(frustumPositions[2]);
    invM.transformVectorSelf(frustumPositions[3]);
    invM.transformVectorSelf(frustumPositions[4]);
    invM.transformVectorSelf(frustumPositions[5]);
    invM.transformVectorSelf(frustumPositions[6]);
    invM.transformVectorSelf(frustumPositions[7]);
      this.mFrustumAABB.reset();
    for (let i = 0; i < 8; ++i) {
        this.mFrustumAABB.addPosition(frustumPositions[i]);
    }
    this.mFrustumAABB.updateFast();
      // bottom
    this.mTempV.subVecsTo(frustumPositions[0], frustumPositions[4]);
    let v0 = frustumPositions[1];
    this.mTempV1.subVecsTo(frustumPositions[1], frustumPositions[5]);
    plane = frustumPlanes[3];
    Vector3.Cross(this.mTempV1, this.mTempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    // top
    this.mTempV.subVecsTo(frustumPositions[3], frustumPositions[7]);
    v0 = frustumPositions[2];
    this.mTempV1.subVecsTo(frustumPositions[2], frustumPositions[6]);
    plane = frustumPlanes[2];
    Vector3.Cross(this.mTempV1, this.mTempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    // left
    this.mTempV.subVecsTo(frustumPositions[0], frustumPositions[4]);
    v0 = frustumPositions[3];
    this.mTempV1.subVecsTo(frustumPositions[3], frustumPositions[7]);
    plane = frustumPlanes[4];
    Vector3.Cross(this.mTempV, this.mTempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    // right
    this.mTempV.subVecsTo(frustumPositions[1], frustumPositions[5]);
    v0 = frustumPositions[2];
    this.mTempV1.subVecsTo(frustumPositions[2], frustumPositions[6]);
    plane = frustumPlanes[5];
    Vector3.Cross(this.mTempV, this.mTempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    const fpna = this.mFpns;
    fpna[0].copyFrom(frustumPlanes[0].nv);
    fpna[1].copyFrom(frustumPlanes[1].nv);
    fpna[1].scaleBy(-1.0);
    fpna[2].copyFrom(frustumPlanes[2].nv);
    fpna[3].copyFrom(frustumPlanes[3].nv);
    fpna[3].scaleBy(-1.0);
    fpna[4].copyFrom(frustumPlanes[4].nv);
    fpna[4].scaleBy(-1.0);
    fpna[5].copyFrom(frustumPlanes[5].nv);
      const fpda = this.mFpds;
    fpda[0] = frustumPlanes[0].distance;
    fpda[1] = -frustumPlanes[1].distance;
    fpda[2] = frustumPlanes[2].distance;
    fpda[3] = -frustumPlanes[3].distance;
    fpda[4] = -frustumPlanes[4].distance;
    fpda[5] = frustumPlanes[5].distance;
    //*/
  }

  setViewMatrix(viewMatrix) {
    this.mViewMatrix = viewMatrix;
    this.mChanged = true;
  }

  update() {
    if (this.mChanged) {
      this.version++;
      this.mChanged = false;

      if (!this.mViewMatrix) {
        if (this.m_axisRotEnabled) {
          this.mMatrix.appendRotationPivot(this.m_rotDegree * MathConst_1.default.MATH_PI_OVER_180, this.m_rotAxis, this.m_rotPivotPoint);
        } else {
          this.mMatrix.identity();
          this.mMatrix.appendRotationEulerAngle(this.mRotV.x * MathConst_1.default.MATH_PI_OVER_180, this.mRotV.y * MathConst_1.default.MATH_PI_OVER_180, this.mRotV.z * MathConst_1.default.MATH_PI_OVER_180);
        }

        if (this.mLookRHand) {
          this.mViewMat.lookAtRH(this.mCamPos, this.mLookAtPos, this.mUp);
        } else {
          this.mViewMat.lookAtLH(this.mCamPos, this.mLookAtPos, this.mUp);
        }

        this.mViewMat.append(this.mMatrix);
      } else {
        this.mViewMat.copyFrom(this.mViewMatrix);
      }

      if (this.mProject2Enabled) {
        this.mNearPlaneW = this.mZNear * Math.tan(this.mFovRadian * 0.5) * 2.0;
        this.mNearPlaneH = this.mNearPlaneW / this.mAspect;
      } else {
        this.mNearPlaneH = this.mZNear * Math.tan(this.mFovRadian * 0.5) * 2.0;
        this.mNearPlaneW = this.mAspect * this.mNearPlaneH;
      }

      this.mViewInvMat.copyFrom(this.mViewMat);
      this.mViewInvMat.invert();
      this.mVPMat.identity();
      this.mVPMat.copyFrom(this.mViewMat);
      this.mVPMat.append(this.mProjMat);
      this.calcParam(); // very very important !!!

      this.updateUniformData();
    }
  }

  updateUniformData() {
    this.viewUniformV.upate();
    this.projUniformV.upate();
  }

  destroy() {}

  get lookRightHand() {
    return this.mLookRHand;
  }

  get lookLeftHand() {
    return !this.mLookRHand;
  }

  get viewProjMatrix() {
    return this.mVPMat;
  }

  get viewMatrix() {
    return this.mViewMat;
  }

  get viewInvertMatrix() {
    return this.mViewInvMat;
  }

  get projectMatrix() {
    return this.mProjMat;
  }

}

exports.default = Camera;

/***/ }),

/***/ "6aa1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CoModuleLoader_1 = __webpack_require__("852d");

exports.CoModuleVersion = CoModuleLoader_1.CoModuleVersion;

const CoGeomModelLoader_1 = __webpack_require__("163b");

exports.CoGeomDataType = CoGeomModelLoader_1.CoGeomDataType;

class LoadingTeam {
  constructor(urls) {
    this.m_map = new Map();
    this.m_total = 0;
    this.m_loadedTotal = 0;
    this.types = null;
    this.models = [];
    this.transforms = [];
    this.init(urls);
  }

  init(urls) {
    this.urls = urls;
    this.m_total = urls.length;

    for (let i = 0; i < this.m_total; ++i) {
      this.m_map.set(urls[i], 0);
    }
  }

  testWithUrl(url) {
    let flag = false;

    if (this.m_map.has(url) && this.m_map.get(url) < 1) {
      this.m_map.set(url, 1);
      this.m_loadedTotal++;
      flag = this.m_loadedTotal >= this.m_total;

      if (flag) {
        let callback = this.callback;
        callback(this.models, this.transforms);
        this.callback = null;
      }
    }

    return flag;
  }

}

class CoModelTeamLoader {
  constructor() {
    this.m_modelLoader = new CoGeomModelLoader_1.CoGeomModelLoader();
    this.m_team = null;
    this.m_teams = [];
    this.m_enabled = true;
    this.verTool = null;
    this.initialize();
  }

  initialize() {
    this.m_modelLoader.setListener((models, transforms, format, url) => {
      // console.log("CoModelTeamLoader, loaded model.");
      if (this.m_team != null) {
        for (let i = 0; i < models.length; ++i) {
          if (models[i] != null) {
            models[i].url = url;

            if (models[i].vertices != null) {
              if (transforms) {
                this.m_team.transforms.push(transforms[i]);
              } else {
                this.m_team.transforms.push(null);
              }

              this.m_team.models.push(models[i]);
            }
          }
        }
      }
    }, (total, url) => {
      console.log("CoModelTeamLoader, loaded model all, url: ", url);
      let flag = this.m_team.testWithUrl(url);

      if (flag) {
        this.m_enabled = true;
        this.loadNext();
      }
    });
  }

  loadNext() {
    if (this.m_enabled && this.m_teams.length > 0) {
      let team = this.m_teams.shift();
      this.m_team = team;
      this.m_enabled = false;
      console.log("CoModelTeamLoader, begin load urls: ", team.urls, ", team.types: ", team.types);

      if (team.types) {
        this.m_modelLoader.loadWithType(team.urls, team.types);
      } else {
        this.m_modelLoader.load(team.urls);
      }
    }
  }

  load(urls, callback) {
    this.m_modelLoader.verTool = this.verTool;
    let team = new LoadingTeam(urls);
    team.callback = callback;
    this.m_teams.push(team);
    this.loadNext();
  }

  loadWithTypes(urls, types, callback) {
    this.m_modelLoader.verTool = this.verTool;
    let team = new LoadingTeam(urls);
    team.types = types;
    team.callback = callback;
    this.m_teams.push(team);
    this.loadNext();
  }

}

exports.CoModelTeamLoader = CoModelTeamLoader;

/***/ }),

/***/ "6b10":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GPUTextureFormat_1 = __webpack_require__("3341");

const GPUMipmapGenerator_1 = __webpack_require__("b3f5");

exports.calculateMipLevels = GPUMipmapGenerator_1.calculateMipLevels;

const WebGPUTextureContext_1 = __webpack_require__("2b0e");

const WebGPUBufferContext_1 = __webpack_require__("bc85");

class WebGPUContext {
  constructor() {
    this.mUid = WebGPUContext.sUid++;
    this.presentationFormat = 'bgra8unorm';
    this.enabled = false;
    this.mipmapGenerator = new GPUMipmapGenerator_1.GPUMipmapGenerator();
    this.texture = new WebGPUTextureContext_1.WebGPUTextureContext();
    this.buffer = new WebGPUBufferContext_1.WebGPUBufferContext();
  }
  /**
   * @param format GPU texture format string.
   * @param error The default value is true.
   * @returns GPU texture format is correct or wrong.
   */


  checkGPUTextureFormat(format, error = true) {
    return GPUTextureFormat_1.checkGPUTextureFormat(format, error);
  }

  get uid() {
    return this.mUid;
  }

  get canvasWidth() {
    return this.canvas.width;
  }

  get canvasHeight() {
    return this.canvas.height;
  }

  async initialize(canvas, wgConfig, deviceDescriptor) {
    const selfT = this;
    selfT.canvas = canvas;
    const gpu = navigator.gpu;

    if (gpu) {
      console.log("WebGPU is supported on this browser.");
      selfT.gpu = gpu;
      if (!deviceDescriptor) deviceDescriptor = {};
      const adapter = await gpu.requestAdapter();

      if (adapter) {
        selfT.gpuAdapter = adapter;
        console.log("Appropriate GPUAdapter found, adapter: ", adapter);

        if (deviceDescriptor.requiredFeatures === undefined) {
          deviceDescriptor.requiredFeatures = [// 'texture-compression-bc',
            // 'texture-compression-etc2',
            // 'texture-compression-astc'
          ];
        }

        const device = await adapter.requestDevice(deviceDescriptor);

        if (device) {
          this.mipmapGenerator.initialize(device);
          selfT.device = device;
          selfT.queue = device.queue;
          console.log("Appropriate GPUDevice found.");
          let canvasFormat = gpu.getPreferredCanvasFormat();
          selfT.canvasFormat = canvasFormat;
          selfT.context = canvas.getContext("webgpu");
          const context = this.context;
          const format = canvasFormat;

          if (GPUTextureFormat_1.checkGPUTextureFormat(format)) {
            console.log("Given canvasFormat('" + format + "') is a valid gpu texture format.");
          } else {
            console.error("Given canvasFormat('" + format + "') is an invalid gpu texture format.");
            canvasFormat = "bgra8unorm";
          }

          if (wgConfig) {
            wgConfig.device = device;

            if (wgConfig.format) {
              canvasFormat = wgConfig.format;
            } else {
              wgConfig.format = canvasFormat;
            }
          }

          selfT.presentationFormat = wgConfig.format;
          context.configure(wgConfig ? wgConfig : {
            device: device,
            format: canvasFormat,
            // usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            alphaMode: "premultiplied"
          });
          selfT.texture.initialize(this);
          selfT.buffer.initialize(this);
          selfT.enabled = true;
          console.log("WebGPUContext instance initialization success ...");
        } else {
          throw new Error("No appropriate GPUDevice found.");
        }
      } else {
        throw new Error("No appropriate GPUAdapter found.");
      }
    } else {
      throw new Error("WebGPU is not supported on this browser.");
    }
  }

  getPreferredCanvasFormat() {
    return this.gpu.getPreferredCanvasFormat();
  }

  createCurrentView() {
    return this.context.getCurrentTexture().createView();
  }

}

WebGPUContext.sUid = 0;
exports.WebGPUContext = WebGPUContext;

/***/ }),

/***/ "6bbe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureMixColor_frag_wgsl_1 = __importDefault(__webpack_require__("3f99"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

class MultiMaterialPass {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
  }

  initialize() {
    console.log("MultiMaterialPass::initialize() ...");
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default
      },
      frag: {
        code: sampleTextureMixColor_frag_wgsl_1.default
      }
    };
    const tds = [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/blueTransparent.png")];
    let material0 = this.createMaterial(shdSrc, tds, ["transparent"], "front");
    let material1 = this.createMaterial(shdSrc, tds, ["transparent"], "back");
    this.mEntity = this.createEntity([material0, material1]);
  }

  createMaterial(shaderSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode: faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal + faceCullMode,
      shaderSrc,
      pipelineDefParam
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);
    const entity = new Entity3D_1.Entity3D({
      geometry,
      materials
    });
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.MultiMaterialPass = MultiMaterialPass;

/***/ }),

/***/ "6cb1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class SpecularBrnTexture {
  constructor(datas, width, height) {
    this.specular = {
      uuid: "SpecularBrnTexture",
      dataTexture: {
        datas: [],
        width: 128,
        height: 128
      },
      viewDimension: '2d',
      format: "rgba8unorm",
      generateMipmaps: false
    };
    let tex = this.specular.dataTexture;
    tex.datas = datas;
    tex.width = width;
    tex.height = height;
    console.log('SpecularBrnTexture::constructor() ...');
  }

  set data(data) {
    this.specular.dataTexture.data = data;
  }

  set datas(datas) {
    this.specular.dataTexture.datas = datas;
  }

  set width(w) {
    this.specular.dataTexture.width = w;
  }

  set height(h) {
    this.specular.dataTexture.width = h;
  }

}

exports.SpecularBrnTexture = SpecularBrnTexture;

/***/ }),

/***/ "6d7a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Line3DEntity_1 = __webpack_require__("648f");

function buildGridMesh(minV3, maxV3, stepsTotal = 10) {
  if (stepsTotal < 1) stepsTotal = 1;
  let minV = new Vector3_1.default().setVector3(minV3);
  let maxV = new Vector3_1.default().setVector3(maxV3); // xoz

  let type = 1;
  let dv = new Vector3_1.default().subVecsTo(maxV, minV);

  if (dv.z < 0.1) {
    // xoy
    type = 0;
  } else if (dv.x < 0.1) {
    // yoz
    type = 2;
  }

  dv.scaleBy(1.0 / stepsTotal);
  let rn = stepsTotal + 1;
  let pv0 = minV.clone();
  let pv1 = maxV.clone();
  let pv2 = maxV.clone();
  let pvs = new Array(rn * 2);
  let j = 0; // xoz

  if (type == 1) {
    for (let i = 0; i < rn; ++i) {
      pv0.x = minV.x + dv.x * i;
      pv0.z = minV.z;
      pv1.copyFrom(pv0);
      pv1.z = maxV.z;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
      pv2.copyFrom(pv0);
      pv0.x = pv1.z;
      pv0.z = pv1.x;
      pv1.x = pv2.z;
      pv1.z = pv2.x;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
    }
  } else if (type == 2) {
    // yoz
    for (let i = 0; i < rn; ++i) {
      pv0.y = minV.y + dv.y * i;
      pv0.z = minV.z;
      pv1.copyFrom(pv0);
      pv1.z = maxV.z;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
      pv2.copyFrom(pv0);
      pv0.y = pv1.z;
      pv0.z = pv1.y;
      pv1.y = pv2.z;
      pv1.z = pv2.y;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
    }
  } else {
    // xoy
    for (let i = 0; i < rn; ++i) {
      pv0.x = minV.x + dv.x * i;
      pv0.y = minV.y;
      pv1.copyFrom(pv0);
      pv1.y = maxV.y;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
      pv2.copyFrom(pv0);
      pv0.x = pv1.y;
      pv0.y = pv1.x;
      pv1.x = pv2.y;
      pv1.y = pv2.x;
      pvs[j++] = pv0.clone();
      pvs[j++] = pv1.clone();
    }
  }

  return pvs;
}

function buildPosData(param) {
  if (param.minPos === undefined) {
    param.minPos = [-600, 0, -600];
  }

  if (param.maxPos === undefined) {
    param.maxPos = [600, 0, 600];
  }

  if (param.stepsTotal === undefined) {
    param.stepsTotal = 20;
  }

  param.linePositions = buildGridMesh(param.minPos, param.maxPos, param.stepsTotal);
}

function buildColorData(param) {}

class RectLineGridEntity extends Line3DEntity_1.Line3DEntity {
  constructor(param) {
    if (!param) param = {};
    param.dashedData = true;

    if (!param.linePositions) {
      buildPosData(param);
    }

    if (!param.lineColors) {
      buildColorData(param);
    }

    super(param);
  }

}

exports.RectLineGridEntity = RectLineGridEntity;

/***/ }),

/***/ "70bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRShaderParams_1 = __webpack_require__("e2cf");

class WGRPipelineShader {
  constructor(wgCtx) {
    this.mShdModuleMap = new Map();

    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  initialize(wgCtx) {
    if (wgCtx && !this.mWGCtx) {
      this.mWGCtx = wgCtx;
    }
  }

  createShaderModule(type, param) {
    if (param) {
      const device = this.mWGCtx.device;

      if (param.uuid && param.uuid !== "") {
        const ns = param.uuid + "-" + type;
        const map = this.mShdModuleMap;

        if (map.has(ns)) {
          console.log("WGRPipelineShader::createShaderModule(), use old shader module ...");
          return map.get(ns);
        }

        const module = device.createShaderModule({
          label: ns,
          code: param.code
        });
        map.set(ns, module);
        return module;
      }

      const module = device.createShaderModule({
        code: param.code
      });
      return module;
    }

    return null;
  }

  build(params, rpass) {
    let shdModule = params.shaderSrc ? this.createShaderModule("Shader", params.shaderSrc) : null;
    let vertShdModule = params.vertShaderSrc ? this.createShaderModule("VertShader", params.vertShaderSrc) : shdModule;
    let fragShdModule = params.fragShaderSrc ? this.createShaderModule("FragShader", params.fragShaderSrc) : shdModule;
    let compShdModule = params.compShaderSrc ? this.createShaderModule("CompShader", params.compShaderSrc) : shdModule;
    let entryPoint = "";
    const vert = params.vertex;
    let shdSrc = params.shaderSrc ? params.shaderSrc : params.vertShaderSrc;

    if (shdSrc) {
      entryPoint = shdSrc.vertEntryPoint !== undefined ? shdSrc.vertEntryPoint : WGRShaderParams_1.findShaderEntryPoint('@vertex', shdSrc.code);

      if (entryPoint !== '') {
        vert.module = vertShdModule;
        vert.entryPoint = entryPoint;
      }
    } else {
      params.vertex = null;
    }

    let frag = params.fragment;
    shdSrc = params.shaderSrc ? params.shaderSrc : params.fragShaderSrc;

    if (shdSrc) {
      entryPoint = shdSrc.fragEntryPoint !== undefined ? shdSrc.fragEntryPoint : WGRShaderParams_1.findShaderEntryPoint('@fragment', shdSrc.code);

      if (entryPoint !== '') {
        if (!frag) {
          frag = params.fragment = WGRShaderParams_1.createFragmentState();
        }

        frag.module = fragShdModule;
        frag.entryPoint = entryPoint;
      }

      this.checkFrag(frag, rpass);
    } else {
      params.fragment = null;
    }

    shdSrc = params.compShaderSrc;

    if (shdSrc && compShdModule) {
      shdSrc = params.compShaderSrc;
      params.compute = WGRShaderParams_1.createComputeState(compShdModule);

      if (shdSrc.compEntryPoint !== undefined) {
        params.compute.entryPoint = shdSrc.compEntryPoint;
      } else {
        shdSrc.compEntryPoint = params.compute.entryPoint = WGRShaderParams_1.findShaderEntryPoint('@compute', shdSrc.code);
      }
    } else if (compShdModule) {
      shdSrc = params.shaderSrc;
      entryPoint = WGRShaderParams_1.findShaderEntryPoint('@compute', shdSrc.code);

      if (entryPoint != '') {
        params.compute = WGRShaderParams_1.createComputeState(compShdModule);
        params.compute.entryPoint = entryPoint;
      }
    }
  }

  checkFrag(frag, rpass) {
    if (frag) {
      let cs = rpass.passColors;
      let ts = frag.targets;

      for (let i = 0; i < cs.length; ++i) {
        // console.log('checkFrag(), textureFormat: ', cs[i].textureFormat);
        // console.log('checkFrag(), AAA, textureFormat: ', cs[i].textureFormat, ', target format: ', ts[i].format);
        if (ts.length > i) {
          ts[i].format = cs[i].textureFormat;
        } else {
          ts.push({
            format: cs[i].textureFormat
          });
        } // console.log('checkFrag(), textureFormat: ', cs[i].textureFormat, ', target format: ', ts[i].format);

      }
    }
  }

}

exports.WGRPipelineShader = WGRPipelineShader;

/***/ }),

/***/ "71f1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CoModelTeamLoader_1 = __webpack_require__("6aa1");

exports.CoGeomDataType = CoModelTeamLoader_1.CoGeomDataType;
const modelLoader = new CoModelTeamLoader_1.CoModelTeamLoader();
exports.modelLoader = modelLoader;

/***/ }),

/***/ "73c4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const MouseInteraction_1 = __webpack_require__("213f"); //src\voxgpu\sample\shaders\gameOfLifeSpherePBR.vert.wgsl


const gameOfLifeSpherePBR_vert_wgsl_1 = __importDefault(__webpack_require__("bd7e"));

const gameOfLifeSpherePBR_frag_wgsl_1 = __importDefault(__webpack_require__("0d77"));

const WGRUniformValue_1 = __webpack_require__("7650");

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGCompMaterial_1 = __webpack_require__("19f9");

const WGMaterial_1 = __webpack_require__("943f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const RenderStatusDisplay_1 = __importDefault(__webpack_require__("e58d"));

const CylinderEntity_1 = __webpack_require__("76e3");

const gridSize = 256;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;
@group(0) @binding(3) var<storage, read_write> lifeState: array<f32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, 		cell.y+1) +
							cellActive(cell.x+1, 	cell.y) +
							cellActive(cell.x+1, 	cell.y-1) +
							cellActive(cell.x, 		cell.y-1) +
							cellActive(cell.x-1, 	cell.y-1) +
							cellActive(cell.x-1, 	cell.y) +
							cellActive(cell.x-1, 	cell.y+1) +
							cellActive(cell.x, 		cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
			if(cellStateOut[i] > 0) {
				lifeState[i] += 0.05;
			} else {
				lifeState[i] -= 0.05;
			}
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
			lifeState[i] += 0.1;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
			lifeState[i] -= 0.05;
		}
	}
	if(lifeState[i] < 0.01) { lifeState[i] = 0.01; }
}`;

class GameOfLifeSpherePBR {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mFlag = 6;

    this.mouseDown = evt => {
      this.mFlag = 1;
    };

    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLifeSpherePBR::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new RenderStatusDisplay_1.default(this.mRscene, true);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.6 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    const lifeStateArray3 = new Float32Array(gridSize * gridSize);

    for (let i = 0; i < lifeStateArray3.length; i++) {
      lifeStateArray3[i] = 0.01;
    }

    const posisitonArray4 = new Float32Array(gridSize * gridSize * 4);
    let sizeV = new Vector3_1.default(40, 1, 40);
    let posV = new Vector3_1.default().copyFrom(sizeV);
    posV.scaleBy(gridSize);
    posV.scaleBy(-0.5);
    let k = 0;

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        let pv = new Vector3_1.default(j * sizeV.x, 0, i * sizeV.z).addBy(posV);
        posisitonArray4[k] = pv.x;
        posisitonArray4[k + 1] = pv.y;
        posisitonArray4[k + 2] = pv.z;
        k += 4;
      }
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0,
      shared
    };
    let sharedData1 = {
      data: cellStateArray1,
      shared
    };
    let sharedData3 = {
      data: lifeStateArray3,
      shared
    };
    let sharedData4 = {
      data: posisitonArray4,
      shared
    };
    const v0 = new WGRUniformValue_1.WGRUniformValue({
      data: gridsSizesArray,
      stride: 2,
      shared,
      shdVarName: 'v0'
    }).toVisibleAll(); // build rendering uniforms

    const va1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'va1'
    }).toVisibleVertComp();
    const vb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'vb1'
    }).toVisibleVertComp();
    const vc1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared,
      shdVarName: 'vc1'
    }).toVisibleAll();
    const v4 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData4,
      stride: 3,
      shared,
      shdVarName: 'v4'
    }).toVisibleVertComp(); // build computing uniforms

    const compva1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'compva1'
    }).toVisibleVertComp();
    const compva2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'compva2'
    }).toVisibleComp();
    compva2.toBufferForStorage();
    const compvb1 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData1,
      stride: 1,
      shared,
      shdVarName: 'compvb1'
    }).toVisibleVertComp();
    const compvb2 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData0,
      stride: 1,
      shared,
      shdVarName: 'compvb2'
    }).toVisibleComp();
    compvb2.toBufferForStorage();
    const compv3 = new WGRStorageValue_1.WGRStorageValue({
      bufData: sharedData3,
      stride: 1,
      shared,
      shdVarName: 'compv3'
    }).toVisibleComp();
    compv3.toBufferForStorage();
    return [{
      ufvs0: [v0, va1, vc1, v4],
      ufvs1: [v0, vb1, vc1, v4]
    }, {
      ufvs0: [v0, compva1, compva2, compv3],
      ufvs1: [v0, compvb1, compvb2, compv3]
    }];
  }

  createMaterial(shaderSrc, uniformValues, instanceCount) {
    return new WGMaterial_1.WGMaterial({
      shadinguuid: 'rendering',
      shaderSrc,
      instanceCount,
      uniformValues,
      uniformAppend: false
    });
  }

  createCompMaterial(shaderSrc, uniformValues, workgroupCount = 2) {
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid: 'computing',
      shaderSrc,
      uniformValues,
      uniformAppend: false
    }).setWorkcounts(workgroupCount, workgroupCount);
  }

  initScene() {
    const rc = this.mRscene;
    const ufvsObjs = this.createUniformValues();
    const instanceCount = gridSize * gridSize;
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    let shaderSrc = {
      vertShaderSrc: {
        code: gameOfLifeSpherePBR_vert_wgsl_1.default,
        uuid: "vert-gameOfLife"
      },
      fragShaderSrc: {
        code: gameOfLifeSpherePBR_frag_wgsl_1.default,
        uuid: "frag-gameOfLife"
      }
    };
    let compShaderSrc = {
      compShaderSrc: {
        code: compShdCode,
        uuid: "shader-computing"
      }
    }; // build ping-pong material rendering/computing process

    const materials = [this.createMaterial(shaderSrc, ufvsObjs[0].ufvs0, instanceCount), this.createMaterial(shaderSrc, ufvsObjs[0].ufvs1, instanceCount), this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs1, workgroupCount), this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs0, workgroupCount)];
    let entity = new CylinderEntity_1.CylinderEntity({
      radius: 20,
      height: 38,
      longitudeNumSegments: 10,
      latitudeNumSegments: 10,
      alignYRatio: 0.0,
      materials
    });
    rc.addEntity(entity);
    this.mEntity = entity;
  }

  run() {
    let flag = this.mEntity.isRendering();
    const ms = this.mEntity.materials;

    if (flag) {
      for (let i = 0; i < ms.length; i++) {
        ms[i].visible = (this.mStep % 2 + i) % 2 == 0;
      }

      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        flag = false;
      } else {
        this.mFrameDelay = 3;
        this.mStep++;
      }
    }

    if (!flag) {
      ms[2].visible = false;
      ms[3].visible = false;
    }

    this.mRscene.run();
  }

}

exports.GameOfLifeSpherePBR = GameOfLifeSpherePBR;

/***/ }),

/***/ "746a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Define_1 = __webpack_require__("af1b");

const CommonUtils_1 = __webpack_require__("fe0b");

class WGGeomAttributeBlock {
  constructor() {
    this.shdVarName = "";
    this.bindIndex = 0;
    this.strides = [3];
    /**
     * buffer bytes offset
     */

    this.bufferOffset = 0;
  }

}

exports.WGGeomAttributeBlock = WGGeomAttributeBlock;

class WGGeomIndexBuffer {
  constructor(param) {
    this.name = "";
    this.name = param.name;
    this.data = param.data;
  }

  createWireframeIvs(ivs) {
    if (ivs) {
      const len = ivs.length * 2;
      const wivs = CommonUtils_1.createIndexArrayWithSize(len);
      let a;
      let b;
      let c;
      let k = 0;

      for (let i = 0, l = ivs.length; i < l; i += 3) {
        a = ivs[i + 0];
        b = ivs[i + 1];
        c = ivs[i + 2];
        wivs[k] = a;
        wivs[k + 1] = b;
        wivs[k + 2] = b;
        wivs[k + 3] = c;
        wivs[k + 4] = c;
        wivs[k + 5] = a;
        k += 6;
      } // console.log("createWireframeIvs(), wivs.length:", wivs.length);


      return wivs;
    }

    return ivs;
  }

  toWirframe() {
    if (!this.wireframeData) {
      this.wireframeData = this.createWireframeIvs(this.data);
    }
  }

}

exports.WGGeomIndexBuffer = WGGeomIndexBuffer;

class WGGeometry {
  constructor() {
    this.name = "WGGeometry";
    this.descParam = {
      vertex: {
        buffers: [],
        attributeIndicesArray: []
      }
    };
    this.drawMode = Define_1.WGRDrawMode.TRIANGLES;
  }

  setIndexBuffer(param) {
    this.indexBuffer = new WGGeomIndexBuffer(param);
    return this;
  }

  setIndices(indicesData) {
    this.indexBuffer = new WGGeomIndexBuffer({
      data: indicesData
    });
    return this;
  }

  filterParam(param, key, strides) {
    if (param[key]) {
      param.data = param[key];

      if (!param.shdVarName) {
        param.shdVarName = key;
      }

      if (!param.strides) {
        param.strides = strides;
      }

      param[key] = undefined;
    }
  }
  /**
   * 每次添加，实际上是添加一个 attribute 组合
   */


  addAttribute(param) {
    if (param) {
      this.filterParam(param, 'position', [3]);
      this.filterParam(param, 'uv', [2]);
      this.filterParam(param, 'uv2', [2]);
      this.filterParam(param, 'normal', [3]);
      this.filterParam(param, 'color', [3]);
      const p = new WGGeomAttributeBlock();
      const ab = p;

      for (var k in param) {
        ab[k] = param[k];
      }

      if (this.attributes) {
        this.attributes.push(p);
      } else {
        this.attributes = [p];
      }
    }

    return this;
  }

  addAttributes(params) {
    if (params) {
      for (let i = 0; i < params.length; ++i) {
        this.addAttribute(params[i]);
      }
    }

    return this;
  }

  isREnabled() {
    let flag = true;
    const ats = this.attributes;

    if (ats) {
      for (let i = 0; i < ats.length; ++i) {
        if (!ats[i].data) {
          flag = false;
          break;
        }
      }
    }

    return flag;
  }

  destroy() {}

}

exports.WGGeometry = WGGeometry;

/***/ }),

/***/ "74d8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n    var result = textureSample(texture0, sampler0, uv) * param;\r\n\tresult = vec4f(result.xyz * result.x/0.2, 1.0);\r\n\t// result = vec4f(result.xyz * 3.0, 1.0);\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "751c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n@group(0) @binding(3) var<storage> positions: array<vec4<f32>>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) wordPos: vec4<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>,\r\n  @location(3) camPos : vec3<f32>\r\n}\r\n\r\n@vertex\r\nfn main(\r\n@builtin(instance_index) insIdx : u32,\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>\r\n) -> VertexOutput {\r\n\r\n  var wpos = objMat * vec4(position.xyz, 1.0);\r\n  wpos = vec4(wpos.xyz + positions[insIdx].xyz, wpos.w);\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * wpos;\r\n  output.uv = uv;\r\n\r\n  let invMat33 = inverseM33( m44ToM33( objMat ) );\r\n  output.normal = normalize( normal * invMat33 );\r\n  output.camPos = (inverseM44(viewMat) * vec4<f32>(0.0,0.0,0.0, 1.0)).xyz;\r\n  output.wordPos = wpos;\r\n  return output;\r\n}\r\n\r\nfn inverseM33(m: mat3x3<f32>)-> mat3x3<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2];\r\n    let b01 = a22 * a11 - a12 * a21;\r\n    let b11 = -a22 * a10 + a12 * a20;\r\n    let b21 = a21 * a10 - a11 * a20;\r\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3x3<f32>(\r\n\t\tvec3<f32>(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11)) / det,\r\n                vec3<f32>(b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det,\r\n                vec3<f32>(b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det);\r\n}\r\nfn m44ToM33(m: mat4x4<f32>) -> mat3x3<f32> {\r\n\treturn mat3x3(m[0].xyz, m[1].xyz, m[2].xyz);\r\n}\r\n\r\nfn inverseM44(m: mat4x4<f32>)-> mat4x4<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\r\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\r\n    let b00 = a00 * a11 - a01 * a10;\r\n    let b01 = a00 * a12 - a02 * a10;\r\n    let b02 = a00 * a13 - a03 * a10;\r\n    let b03 = a01 * a12 - a02 * a11;\r\n    let b04 = a01 * a13 - a03 * a11;\r\n    let b05 = a02 * a13 - a03 * a12;\r\n    let b06 = a20 * a31 - a21 * a30;\r\n    let b07 = a20 * a32 - a22 * a30;\r\n    let b08 = a20 * a33 - a23 * a30;\r\n    let b09 = a21 * a32 - a22 * a31;\r\n    let b10 = a21 * a33 - a23 * a31;\r\n    let b11 = a22 * a33 - a23 * a32;\r\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\treturn mat4x4<f32>(\r\n\t\tvec4<f32>(a11 * b11 - a12 * b10 + a13 * b09,\r\n\t\ta02 * b10 - a01 * b11 - a03 * b09,\r\n\t\ta31 * b05 - a32 * b04 + a33 * b03,\r\n\t\ta22 * b04 - a21 * b05 - a23 * b03) / det,\r\n\t\t\tvec4<f32>(a12 * b08 - a10 * b11 - a13 * b07,\r\n\t\ta00 * b11 - a02 * b08 + a03 * b07,\r\n\t\ta32 * b02 - a30 * b05 - a33 * b01,\r\n\t\ta20 * b05 - a22 * b02 + a23 * b01) / det,\r\n\t\tvec4<f32>(a10 * b10 - a11 * b08 + a13 * b06,\r\n\t\ta01 * b08 - a00 * b10 - a03 * b06,\r\n\t\ta30 * b04 - a31 * b02 + a33 * b00,\r\n\t\ta21 * b02 - a20 * b04 - a23 * b00) / det,\r\n\t\tvec4<f32>(a11 * b07 - a10 * b09 - a12 * b06,\r\n\t\ta00 * b09 - a01 * b07 + a02 * b06,\r\n\t\ta31 * b01 - a30 * b03 - a32 * b00,\r\n\t\ta20 * b03 - a21 * b01 + a22 * b00) / det);\r\n}");

/***/ }),

/***/ "7650":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRBufferValue_1 = __webpack_require__("2d6d");

const WGRBufferVisibility_1 = __webpack_require__("dc4d");

class WGRUniformValue extends WGRBufferValue_1.WGRBufferValue {
  constructor(param) {
    super(param);

    if (!this.visibility) {
      this.visibility = new WGRBufferVisibility_1.WGRBufferVisibility();
    }

    this.toUniform();
  }

}

exports.WGRUniformValue = WGRUniformValue;

/***/ }),

/***/ "76e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const CylinderGeometry_1 = __importDefault(__webpack_require__("4255"));

class CylinderEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {}; // param.radius ??= 100;
    // param.height ??= 300;
    // param.longitudeNumSegments ??= 20;
    // param.latitudeNumSegments ??= 20;
    // param.uvType ??= 1;
    // param.alignYRatio ??= -0.5;

    if (param.radius === undefined) param.radius = 100.0;
    if (param.height === undefined) param.height = 300.0;
    if (param.longitudeNumSegments === undefined) param.longitudeNumSegments = 20;
    if (param.latitudeNumSegments === undefined) param.latitudeNumSegments = 20;
    if (param.uvType === undefined) param.uvType = 1;
    if (param.alignYRatio === undefined) param.alignYRatio = -0.5;
    let g = new CylinderGeometry_1.default();
    g.initialize(param.radius, param.height, param.longitudeNumSegments, param.latitudeNumSegments, param.uvType, param.alignYRatio);
    return g;
  }

}

exports.CylinderEntity = CylinderEntity;

/***/ }),

/***/ "7751":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRendererPass_1 = __webpack_require__("0142");

const WGRPipelineCtxParams_1 = __webpack_require__("bf93");

const WGRPipelineContext_1 = __webpack_require__("36ce");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const WGRenderUnitBlock_1 = __webpack_require__("d5c3");

class WGRenderPassNode {
  constructor(bp, drawing = true) {
    this.mUid = WGRenderPassNode.sUid++;
    this.mDrawing = true;
    this.mPassBuilded = false;
    this.clearColor = new Color4_1.default(0.0, 0.0, 0.0, 1.0);
    this.name = "";
    this.pipelineCtxs = [];
    this.pctxMap = new Map();
    this.enabled = true;
    this.mode = 0;
    this.separate = false;
    this.mRBParam = bp;
    this.camera = bp.camera;
    this.mDrawing = drawing;
    this.rpass = new WGRendererPass_1.WGRendererPass(null, drawing);
    this.rpass.clearColor = this.clearColor;
  }

  setColorAttachmentClearEnabledAt(enabled, index = 0) {
    if (this.mPassBuilded) {
      const ca = this.rpass.passColors[index];

      if (ca) {
        ca.loadOp = enabled ? "clear" : "load";
      }
    }
  }

  isDrawing() {
    return this.mDrawing;
  }

  get uid() {
    return this.mUid;
  }

  getWGCtx() {
    return this.mWGCtx;
  }

  destroy() {
    if (this.rpass) {
      this.mRBParam = null;
      this.prevNode = null;
    }
  }

  getPassNodeWithMaterial(material) {
    const b = this.builder;

    if (b) {
      return b.getPassNodeWithMaterial(material);
    }

    return this;
  }

  initialize(wgCtx, param) {
    this.param = param ? param : this.param;
    if (!this.param) this.param = {};

    if (!this.mWGCtx && wgCtx && wgCtx.enabled) {
      this.mWGCtx = wgCtx;

      if (this.prevNode) {
        this.rpass.prevPass = this.prevNode.rpass;
      }

      this.rpass.initialize(wgCtx);
      this.checkRPassParam(this.param);
      this.rpass.build(this.param);
      this.mPassBuilded = true;
      this.colorAttachments = this.rpass.passColors;
    }
  }

  hasMaterial(material) {
    if (this.unitBlock) {
      return this.unitBlock.hasMaterial(material);
    }

    return false;
  }

  addEntity(entity) {
    if (entity) {
      if (!this.unitBlock) {
        this.unitBlock = WGRenderUnitBlock_1.WGRenderUnitBlock.createBlock();
      }

      const ub = this.unitBlock;
      ub.rbParam = this.mRBParam;
      ub.builder = this;
      console.log("WGRenderPassNode::addEntity(), ub.builder: ", ub.builder);
      this.unitBlock.addEntity(entity);
    }
  }

  checkRPassParam(param) {
    if (param.sampleCount !== undefined && param.sampleCount > 1) {
      param.multisampleEnabled = true;
    } else if (param.multisampleEnabled === true) {
      param.sampleCount = 4;
    } else {
      param.multisampleEnabled = false;
    }

    if (param.depthFormat == undefined) {
      param.depthFormat = "depth24plus";
    }
  }

  createRenderPipelineCtxWithMaterial(material) {
    const flag = material.shadinguuid && material.shadinguuid !== "";
    const map = this.pctxMap;

    if (flag) {
      if (map.has(material.shadinguuid)) {
        console.log("WGRenderPassBlock::createRenderPipelineCtxWithMaterial(), apply old ctx.");
        return map.get(material.shadinguuid);
      }
    }

    const ctx = this.createRenderPipelineCtx(material.shaderSrc, material.pipelineVtxParam, material.pipelineDefParam);

    if (flag) {
      ctx.shadinguuid = material.shadinguuid;
      map.set(material.shadinguuid, ctx);
    }

    console.log("WGRenderPassBlock::createRenderPipelineCtxWithMaterial(), apply new ctx.");
    return ctx;
  } // pipelineParam value likes {blendMode: "transparent", depthWriteEnabled: false, faceCullMode: "back"}


  createRenderPipelineCtx(shdSrc, pipelineVtxParam, pipelineParam) {
    const plp = pipelineParam;
    let depthStencilEnabled = plp ? plp.depthStencilEnabled === false ? false : true : true;
    const pipeParams = new WGRPipelineCtxParams_1.WGRPipelineCtxParams({
      shaderSrc: shdSrc.shaderSrc,
      vertShaderSrc: shdSrc.vertShaderSrc,
      fragShaderSrc: shdSrc.fragShaderSrc,
      compShaderSrc: shdSrc.compShaderSrc,
      depthStencilEnabled
    });

    if (plp) {
      if (plp.blendModes) {
        pipeParams.setBlendModes(plp.blendModes);
      }

      if (plp.depthStencil) {
        pipeParams.setDepthStencil(plp.depthStencil);
      } else {
        pipeParams.setDepthWriteEnabled(plp.depthWriteEnabled === true);
      }

      pipeParams.setPrimitiveState(plp.primitiveState ? plp.primitiveState : {
        cullMode: plp.faceCullMode
      });
    }

    return this.createRenderPipeline(pipeParams, pipelineVtxParam);
  }

  createRenderPipeline(pipelineParams, vtxDesc) {
    const pipelineCtx = new WGRPipelineContext_1.WGRPipelineContext(this.mWGCtx);
    this.pipelineCtxs.push(pipelineCtx);

    if (this.mDrawing) {
      if (this.rpass.depthTexture) {
        pipelineParams.setDepthStencilFormat(this.rpass.depthTexture.format);
      } else {
        pipelineParams.depthStencilEnabled = false;
        pipelineParams.depthStencil = undefined;
      }

      const passParam = this.rpass.getPassParams();

      if (passParam.multisampleEnabled) {
        if (pipelineParams.multisample) {
          pipelineParams.multisample.count = passParam.sampleCount;
        } else {
          pipelineParams.multisample = {
            count: passParam.sampleCount
          };
        }

        pipelineParams.sampleCount = passParam.sampleCount;
      }
    }

    pipelineCtx.createRenderPipelineWithBuf(pipelineParams, vtxDesc);
    pipelineCtx.rpass = this.rpass;
    return pipelineCtx;
  }

  runBegin() {
    this.colorAttachments = this.rpass.passColors;
    this.rpass.enabled = this.enabled;
    this.rcommands = [];
    this.rpass.runBegin();

    if (this.enabled) {
      for (let i = 0; i < this.pipelineCtxs.length;) {
        this.pipelineCtxs[i++].runBegin();
      }
    }
  }

  runEnd() {
    if (this.enabled) {
      for (let i = 0; i < this.pipelineCtxs.length;) {
        this.pipelineCtxs[i++].runEnd();
      }
    }

    let cmd = this.rpass.runEnd();

    if (cmd) {
      this.rcommands = [cmd];
    }
  }

  run() {
    if (this.enabled) {
      const b = this.unitBlock;

      if (b) {
        // console.log("node b: ", b);
        b.run();
      }
    }
  }

  render() {
    if (this.enabled) {
      this.runBegin();
      this.run();
      this.runEnd();
    }
  }

}

WGRenderPassNode.sUid = 0;
exports.WGRenderPassNode = WGRenderPassNode;

/***/ }),

/***/ "7917":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("struct VertexInput {\r\n\t@location(0) pos: vec3f,\r\n  \t@location(1) uv : vec2f,\r\n\t@builtin(instance_index) instance: u32\r\n};\r\n\r\nstruct VertexOutput {\r\n\t@builtin(position) pos: vec4f,\r\n\t@location(0) cell: vec2f,\r\n\t@location(1) uv: vec2f,\r\n\t@location(2) instance: f32,\r\n};\r\n@group(0) @binding(0) var<uniform> grid: vec2f;\r\n@group(0) @binding(1) var<storage> cellState: array<u32>;\r\n@group(0) @binding(2) var<storage> lifeState: array<f32>;\r\n@vertex\r\nfn vertMain(input: VertexInput) -> VertexOutput {\r\n    let i = f32(input.instance);\r\n    let cell = vec2f(i % grid.x, floor(i / grid.x));\r\n    let cellOffset = cell / grid * 2.0;\r\n\r\n    var state = f32(cellState[input.instance]);\r\n    let gridPos = (input.pos.xy * state + 1.0) / grid - 1.0 + cellOffset;\r\n\r\n    var output: VertexOutput;\r\n    output.pos = vec4f(gridPos, 0.0, 1.0);\r\n    output.cell = cell;\r\n    output.uv = input.uv;\r\n    output.instance = i;\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fragMain(input: VertexOutput) -> @location(0) vec4f {\r\n    let c = input.cell / grid;\r\n\tvar dis = length(input.uv - vec2<f32>(0.5, 0.5));\r\n\tdis = min(dis/0.15, 1.0);\r\n\tlet i = u32(input.instance);\r\n\tvar f = clamp((lifeState[i])/100.0, 0.0005, 1.0);\r\n\tdis = (1.0 - pow(dis, 100.0)) * (1.0 - f) + f;\r\n\tvar c3 = vec3f(c, (1.0 - c.x) * (1.0 - f) + f) * dis;\r\n    return vec4f(c3, 1.0);\r\n}");

/***/ }),

/***/ "793b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const TransformParam_1 = __webpack_require__("e594");

exports.TransformParam = TransformParam_1.TransformParam;

function getUniformValueFromParam(key, param, defaultV) {
  const ufvs = param.uniformValues;

  if (param.uniformValues) {
    for (let i = 0; i < ufvs.length; ++i) {
      if (ufvs[i].shdVarName == key) {
        return ufvs[i];
      }
    }
  }

  return defaultV;
}

exports.getUniformValueFromParam = getUniformValueFromParam;

/***/ }),

/***/ "79d0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class AABBCalc {
  IntersectRL(ltv, lpv, ab) {
    let f = 0;
    let tmin = (ab.min.x - lpv.x) / ltv.x;
    let tmax = (ab.max.x - lpv.x) / ltv.x; //console.log("AABB::IntersectRL uses...");

    if (tmin > tmax) {
      f = tmax;
      tmax = tmin;
      tmin = f;
    } //	console.log("\n");
    //	console.log("tmin: "+tmin+",tmax: "+tmax);


    let tymin = (ab.min.y - lpv.y) / ltv.y;
    let tymax = (ab.max.y - lpv.y) / ltv.y; //	console.log("tymin: "+tymin+",tymax: "+tymax);

    if (tymin > tymax) {
      f = tymax;
      tymax = tymin;
      tymin = f;
    }

    if (tmin > tymax || tymin > tmax) return false;
    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;
    let tzmin = (ab.min.z - lpv.z) / ltv.z;
    let tzmax = (ab.max.z - lpv.z) / ltv.z; //	console.log("tzmin: "+tzmin+",tzmax: "+tzmax);
    //	console.log("\n");

    if (tzmin > tzmax) {
      f = tzmax;
      tzmax = tzmin;
      tzmin = f;
    }

    if (tmin > tzmax || tzmin > tmax) return false;
    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax;
    return true;
  }
  /*
  static IntersectionRL3(vecs:IVector3[],rsigns:Uint8Array,ltInvtv:IVector3, ltv:IVector3, lpv:IVector3,outV:IVector3):boolean
  {
      let tmin:number, tmax:number, tymin:number, tymax:number;//, tzmin:number, tzmax:number;
      
      tmin = (vecs[rsigns[0]].x - lpv.x) * ltInvtv.x;
      tmax = (vecs[1-rsigns[0]].x - lpv.x) * ltInvtv.x;
      tymin = (vecs[rsigns[1]].y - lpv.y) * ltInvtv.y;
      tymax = (vecs[1-rsigns[1]].y - lpv.y) * ltInvtv.y;
      if ((tmin > tymax) || (tymin > tmax))
          return false;
      if (tymin > tmin)
          tmin = tymin;
      if (tymax < tmax)
          tmax = tymax;
      
      tymin = (vecs[rsigns[2]].z - lpv.z) * ltInvtv.z;
      tymax = (vecs[1-rsigns[2]].z - lpv.z) * ltInvtv.z;
      if ((tmin > tymax) || (tymin > tmax))
          return false;
      if (tymin > tmin)
          tmin = tymin;
      if (tymax < tmax)
          tmax = tymax;
          
      outV.copyFrom(ltv);
      outV.scaleBy(tmin);
      outV.addBy(lpv);
      console.log("T Hit outV: "+outV.toString());
      return true;
  }
  //*/


  static IntersectionRL3(vecs, rsigns, ltInvtv, ltv, lpv, outV) {
    ltInvtv.w = (vecs[rsigns[0]].x - lpv.x) * ltInvtv.x;
    ltv.w = (vecs[1 - rsigns[0]].x - lpv.x) * ltInvtv.x;
    outV.x = (vecs[rsigns[1]].y - lpv.y) * ltInvtv.y;
    outV.y = (vecs[1 - rsigns[1]].y - lpv.y) * ltInvtv.y;
    if (ltInvtv.w > outV.y || outV.x > ltv.w) return false;
    if (outV.x > ltInvtv.w) ltInvtv.w = outV.x;
    if (outV.y < ltv.w) ltv.w = outV.y;
    outV.x = (vecs[rsigns[2]].z - lpv.z) * ltInvtv.z;
    outV.y = (vecs[1 - rsigns[2]].z - lpv.z) * ltInvtv.z;
    if (ltInvtv.w > outV.y || outV.x > ltv.w) return false;
    if (outV.x > ltInvtv.w) ltInvtv.w = outV.x;
    if (outV.y < ltv.w) ltv.w = outV.y;
    outV.copyFrom(ltv);
    outV.scaleBy(ltInvtv.w);
    outV.addBy(lpv);
    ltv.w = 1.0; //console.log("T Hit outV: "+outV.toString());

    return true;
  }

  static IntersectionRL1(ltv, lpv, ab, outV) {
    let f = 0;
    let tmin = (ab.min.x - lpv.x) / ltv.x;
    let tmax = (ab.max.x - lpv.x) / ltv.x; //console.log("AABB::IntersectRL uses...");

    if (tmin > tmax) {
      f = tmax;
      tmax = tmin;
      tmin = f;
    } //	console.log("\n");
    //	console.log("tmin: "+tmin+",tmax: "+tmax);


    let tymin = (ab.min.y - lpv.y) / ltv.y;
    let tymax = (ab.max.y - lpv.y) / ltv.y; //	console.log("tymin: "+tymin+",tymax: "+tymax);

    if (tymin > tymax) {
      f = tymax;
      tymax = tymin;
      tymin = f;
    }

    if (tmin > tymax || tymin > tmax) return false;
    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;
    let tzmin = (ab.min.z - lpv.z) / ltv.z;
    let tzmax = (ab.max.z - lpv.z) / ltv.z; //	console.log("tzmin: "+tzmin+",tzmax: "+tzmax);
    //	console.log("\n");

    if (tzmin > tzmax) {
      f = tzmax;
      tzmax = tzmin;
      tzmin = f;
    }

    if (tmin > tzmax || tzmin > tmax) return false;
    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax; //	console.log("XXXXXXXXX tmin: "+tmin+",tmax: "+tmax);

    outV.copyFrom(ltv);
    outV.scaleBy(tmin);
    outV.addBy(lpv); // console.log("L Hit outV: " + outV.toString());
    //outV.copyFrom(ltv);
    //outV.scaleBy(tmax);
    //outV.addBy(lpv);
    //console.log("tmax outV: "+outV.toString());

    return true;
  } //
  // 检测射线和AABB是否相交,如果相交计算出交点存放于 outV 中, 这个检测计算是精准高效的
  // @param				ltv		射线的切向
  // @param				lpv		射线上的一点
  // @param				ab		updateFast() 过的 AABB 实例
  // @param				outV	存放交点的 Vector3D实例
  //


  static IntersectionRL2(ltv, lpv, ab, outV) {
    // 计算包围球
    //let dis:number = StraightLine.CalcPVSquaredDis2(ltv, lpv, ab.center);
    outV.x = ab.center.x - lpv.x;
    outV.y = ab.center.y - lpv.y;
    outV.z = ab.center.z - lpv.z; //

    let dis = outV.dot(ltv);
    outV.x -= dis * ltv.x;
    outV.y -= dis * ltv.y;
    outV.z -= dis * ltv.z;

    if (outV.getLengthSquared() > ab.radius2) {
      //console.log("Hit shp failure.");
      return false;
    } // 包含起点，则一定相交


    if (ab.containsV(lpv)) {
      outV.copyFrom(lpv);
      return true;
    } // 确定 x 轴线


    if (lpv.x < ab.min.x) {
      // 说明 起点在 ab 的 -x 侧
      if (ltv.x > 0.0) {
        // 有可能和min x面相交
        dis = (ab.min.x - lpv.x) / ltv.x;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsYZ(outV.y, outV.z)) {
          return true;
        }
      }
    } else if (lpv.x > ab.max.x) {
      // 说明 起点在 ab 的 +x 侧
      if (ltv.x < 0.0) {
        // 有可能和max x面相交
        dis = (ab.max.x - lpv.x) / ltv.x;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsYZ(outV.y, outV.z)) {
          return true;
        }
      }
    } // 确定 y 轴线


    if (lpv.y < ab.min.y) {
      // 说明 起点在 ab 的 -y 侧
      if (ltv.y > 0.0) {
        // 有可能和min y面相交
        dis = (ab.min.y - lpv.y) / ltv.y;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXZ(outV.x, outV.z)) {
          return true;
        }
      }
    } else if (lpv.y > ab.max.y) {
      // 说明 起点在 ab 的 +y 侧
      if (ltv.y < 0.0) {
        // 有可能和max y面相交
        dis = ab.max.y;
        dis = (ab.max.y - lpv.y) / ltv.y;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXZ(outV.x, outV.z)) {
          return true;
        }
      }
    } // 确定 z 轴线


    if (lpv.z < ab.min.z) {
      // 说明 起点在 ab 的 -z 侧
      if (ltv.z > 0.0) {
        // 有可能和min y面相交
        dis = (ab.min.z - lpv.z) / ltv.z;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXY(outV.x, outV.y)) {
          return true;
        }
      }
    } else if (lpv.z > ab.max.z) {
      // 说明 起点在 ab 的 +z 侧
      if (ltv.z < 0.0) {
        // 有可能和max z面相交
        dis = (ab.max.z - lpv.z) / ltv.z;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXY(outV.x, outV.y)) {
          return true;
        }
      }
    }

    return false;
  }

}

exports.AABBCalc = AABBCalc;

/***/ }),

/***/ "7a70":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const AbsGeomBase_1 = __importDefault(__webpack_require__("9e08"));

class Plane extends AbsGeomBase_1.default {
  constructor() {
    super(...arguments);
    this.nv = new Vector3_1.default(0.0, 1.0, 0.0);
    this.distance = 0.0;
    this.intersectBoo = false;
  }

  intersectStraightLinePos(straightL, outV) {
    // intersection or parallel
    let td = this.nv.dot(straightL.tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = this.nv.dot(straightL.position) - this.distance;
      outV.x = straightL.tv.x * 100000.0 + straightL.position.x;
      outV.y = straightL.tv.y * 100000.0 + straightL.position.y;
      outV.z = straightL.tv.z * 100000.0 + straightL.position.z; //

      td = this.nv.dot(outV) - this.distance;
      td = dis / (dis - td);
      outV.subtractBy(straightL.position);
      outV.scaleBy(td);
      outV.addBy(straightL.position);
      return 1;
    }

    td = this.nv.dot(straightL.position) - this.distance;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(straightL.position);
      return 2;
    }

    return 0;
  }

  intersectStraightLinePos2(sl_pos, sl_tv, outV) {
    // intersection or parallel
    let td = this.nv.dot(sl_tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = this.nv.dot(sl_pos) - this.distance;
      outV.x = sl_tv.x * 100000.0 + sl_pos.x;
      outV.y = sl_tv.y * 100000.0 + sl_pos.y;
      outV.z = sl_tv.z * 100000.0 + sl_pos.z; //

      td = this.nv.dot(outV) - this.distance;
      td = dis / (dis - td);
      outV.subtractBy(sl_pos);
      outV.scaleBy(td);
      outV.addBy(sl_pos);
      return 1;
    }

    td = this.nv.dot(sl_pos) - this.distance;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(sl_pos);
      return 2;
    }

    return 0;
  }

  intersectRadialLinePos(radL, outV) {
    let dis = this.nv.dot(radL.position) - this.distance;

    if (dis > MathConst_1.default.MATH_MIN_POSITIVE) {
      // radL position in plane positive space
      let td = this.nv.dot(radL.tv);

      if (td < 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(radL.position, radL.tv, outV);
      }
    } else if (dis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // radL position in plane negative space
      let td2 = this.nv.dot(radL.tv);

      if (td2 > 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(radL.position, radL.tv, outV);
      }
    } else {
      let td3 = this.nv.dot(radL.tv);

      if (td3 > MathConst_1.default.MATH_MIN_POSITIVE || td3 < MathConst_1.default.MATH_MAX_NEGATIVE) {
        outV.copyFrom(radL.position);
        return 1;
      }

      outV.copyFrom(radL.position);
      return 2;
    }

    return -1;
  }

  intersectRadialLinePos2(rl_pos, rl_tv, outV) {
    let dis = this.nv.dot(rl_pos) - this.distance;

    if (dis > MathConst_1.default.MATH_MIN_POSITIVE) {
      // radL position in plane positive space
      let td = this.nv.dot(rl_tv);

      if (td < 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(rl_pos, rl_tv, outV);
      }
    } else if (dis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // radL position in plane negative space
      let td = this.nv.dot(rl_tv);

      if (td > 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(rl_pos, rl_tv, outV);
      }
    } else {
      let td3 = this.nv.dot(rl_tv);

      if (td3 > MathConst_1.default.MATH_MIN_POSITIVE || td3 < MathConst_1.default.MATH_MAX_NEGATIVE) {
        outV.copyFrom(rl_pos);
        return 1;
      }

      outV.copyFrom(rl_pos);
      return 2;
    }

    return -1;
  }

  containsPoint(pos) {
    let f = this.nv.dot(pos) - this.distance;

    if (f > MathConst_1.default.MATH_MIN_POSITIVE) {
      return 1;
    } else if (f < MathConst_1.default.MATH_MAX_NEGATIVE) {
      return -1;
    }

    return 0;
  }

  intersectSphere(cv, radius) {
    this.intersectBoo = false;
    let f = this.nv.dot(cv) - this.distance;

    if (f > MathConst_1.default.MATH_MIN_POSITIVE) {
      this.intersectBoo = f <= radius;
      return 1;
    } else if (f < MathConst_1.default.MATH_MAX_NEGATIVE) {
      this.intersectBoo = -f <= radius;
      return -1;
    }

    return 0;
  }

  intersectAABB(minV, maxV) {
    this.intersectBoo = false;
    let pv = AbsGeomBase_1.default.__tV0;
    pv.setXYZ(maxV.x, minV.y, maxV.z);
    let flag = this.containsPoint(pv);
    pv.setXYZ(maxV.x, minV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, minV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, minV.y, maxV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(maxV.x, maxV.y, maxV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(maxV.x, maxV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, maxV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, maxV.y, maxV.z);
    flag += this.containsPoint(pv);
    this.intersectBoo = flag < 8;
    if (flag < -7) return -1;
    if (flag > 7) return 1;
    return 0;
  } // 判断一个球体是否和一个平面的负空间相交


  intersectSphNegSpace(cv, radius) {
    //this.intersectBoo = (this.nv.dot(cv) - this.distance - radius) < MathConst.MATH_MIN_POSITIVE;
    //this.intersectBoo = (this.nv.dot(cv) - this.distance) < radius;
    this.intersectBoo = Math.abs(this.nv.dot(cv) - this.distance) < radius;
  }

  update() {
    this.nv.normalize();
  }

  updateFast() {
    this.nv.normalize();
  }

  static PlaneIntersectSphere(pnv, pdis, cv, radius) {
    Plane.IntersectBoo = false;
    Plane.IntersectSatus = 0;
    pdis = pnv.dot(cv) - pdis;

    if (pdis > MathConst_1.default.MATH_MIN_POSITIVE) {
      Plane.IntersectBoo = pdis <= radius;
      Plane.IntersectSatus = 1;
    } else if (pdis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      Plane.IntersectBoo = -pdis <= radius;
      Plane.IntersectSatus = -1;
    }
  }

  static CalcPVCloseV(plane, posV, outV) {
    let value = plane.distance - posV.dot(plane.nv);
    outV.setXYZ(value * plane.nv.x, value * plane.nv.y, value * plane.nv.z);
    outV.addBy(posV);
  }

  static CalcPVCloseV2(pnv, pd, posV, outV) {
    let value = pd - posV.dot(pnv);
    outV.setXYZ(value * pnv.x, value * pnv.y, value * pnv.z); //outV.scaleBy(value);

    outV.addBy(posV);
  }

  static IntersectionSLV2(planeNV, planeDis, sl_pos, sl_tv, outV) {
    // intersection or parallel
    let td = planeNV.dot(sl_tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = planeNV.dot(sl_pos) - planeDis;
      outV.x = sl_tv.x * 100000.0 + sl_pos.x;
      outV.y = sl_tv.y * 100000.0 + sl_pos.y;
      outV.z = sl_tv.z * 100000.0 + sl_pos.z; //

      td = planeNV.dot(outV) - planeDis;
      td = dis / (dis - td);
      outV.subtractBy(sl_pos);
      outV.scaleBy(td);
      outV.addBy(sl_pos);
      return 1;
    }

    td = planeNV.dot(sl_pos) - planeDis;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(sl_pos);
      return 2;
    }

    return 0;
  }

  toString() {
    return "Plane(position=" + this.position.toString() + ", nv=" + this.nv.toString() + ")";
  }

}

Plane.IntersectBoo = false;
Plane.IntersectSatus = 0;
exports.default = Plane;

/***/ }),

/***/ "7b86":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

class RTTFixScreenTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mFlag = 6;

    this.mouseDown = evt => {
      // let node = this.mRPass.node;
      // console.log("mousedown evt call this.mRPass: ", this.mRPass);
      // console.log("mousedown evt call AAAA node: ", node);
      // console.log("mousedown evt call node.enabled: ", node.enabled);
      // node.enabled = !node.enabled;
      // console.log("mousedown evt call BBBB node: ", node);
      this.mFlag = 1;
    };
  }

  initialize() {
    console.log("RTTFixScreenTest::initialize() ...");
    let rc = this.mRscene;
    /*
    let callback = (): void => {
        console.log("ready create a rpass.");
        let wg = rc.getWGCtx();
        // let rtt0 = wg.texture.createColorRTTTexture();
        // let rtt0View = rtt0.createView();
        // let rttTex = {diffuse: {uuid:'rtt0', rttTexture: {texture: rtt0}}}
        let rttTex = {diffuse: {uuid:'rtt0', rttTexture: {}}}
        let colorAttachments = [
            {
                // view: rtt0View,
                texture: rttTex,
                  clearValue: { r: 0.1, g: 0.5, b: 0.1, a: 1.0 },
                loadOp: 'clear',
                storeOp: 'store',
              }
        ];
        let rPass = rc.renderer.appendRendererPass({separate: true, colorAttachments});
        this.mRPass = rPass;
          const diffuseTex = { diffuse: { url: "static/assets/default.jpg", flipY: true } };
          let x = -0.5;
        let y = -0.5;
        let width = 0.8;
        let height = 0.8;
          let rttEntity = new FixScreenPlaneEntity({x, y, width, height, textures: [diffuseTex]});
        rttEntity.setColor(new Color4(1.0, 0.3,0.9));
        rPass.node.addEntity(rttEntity);
          // let // entity = new FixScreenPlaneEntity({x, y, width, height, textures: [diffuseTex], rpasses:[{rpass: rPass}]});
        let entity = new FixScreenPlaneEntity({x, y, width, height, textures: [rttTex]});
        entity.setColor(new Color4(1.0, 0.3,0.9));
        rc.addEntity(entity);
    }
    this.mRscene.initialize({rpassparam: {multisampleEnabled: true, depthTestEnabled: false}, callback});
    //*/

    this.mRscene.initialize({
      rpassparam: {
        multisampleEnabled: true,
        depthTestEnabled: false
      }
    });
    this.initEvent();
    this.applyRTT();
    this.initScene();
  }

  applyRTT() {
    let rc = this.mRscene;
    let rttTex = {
      diffuse: {
        uuid: "rtt0",
        rttTexture: {}
      }
    };
    let colorAttachments = [{
      texture: rttTex,
      clearValue: {
        r: 0.1,
        g: 0.5,
        b: 0.1,
        a: 1.0
      },
      loadOp: "clear",
      storeOp: "store"
    }];
    let rPass = rc.renderer.appendRenderPass({
      separate: true,
      colorAttachments
    });
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let x = -0.5;
    let y = -0.5;
    let width = 0.8;
    let height = 0.8;
    let rttEntity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      x,
      y,
      width,
      height,
      textures: [diffuseTex]
    });
    rttEntity.setColor(new Color4_1.default(1.0, 0.3, 0.9));
    rttEntity.uuid = 'rtt-entity';
    rPass.node.addEntity(rttEntity);
    x = 0.3;
    y = 0.3;
    width = 0.6;
    height = 0.6;
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      x,
      y,
      width,
      flipY: true,
      height,
      textures: [rttTex]
    });
    entity.setColor(new Color4_1.default(1.0, 0.3, 0.9));
    entity.uuid = 'apply-rtt-entity';
    rc.addEntity(entity);
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let x = -0.9;
    let y = 0.0;
    let width = 0.5;
    let height = 0.5;
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      x,
      y,
      width,
      height
    });
    entity.setColor(new Color4_1.default(0.2, 0.5, 0.7));
    entity.uuid = 'color-entity';
    rc.addEntity(entity); // x = -0.8;
    // y = 0.1;
    // width = 0.5;
    // height = 0.5;
    // entity = new FixScreenPlaneEntity({x, y, width, height});
    // entity.setColor(new Color4(0.2,0.8,0.3));
    // rc.addEntity(entity);

    x = -0.8;
    y = -0.8;
    width = 0.8;
    height = 0.8; // entity = new FixScreenPlaneEntity({x, y, width, height, textures: [diffuseTex], rpasses:[{rpass: rPass}]});

    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      x,
      y,
      width,
      height,
      textures: [diffuseTex]
    });
    entity.setColor(new Color4_1.default(0.1, 0.3, 0.9));
    rc.addEntity(entity); //*/
  }

  run() {
    // console.log(">>> >>> >>> begin ...");
    // if(this.mFlag < 0) {
    // 	return;
    // }
    // this.mFlag --;
    this.mRscene.run(); // console.log(">>> >>> >>> end ...");
  }

}

exports.RTTFixScreenTest = RTTFixScreenTest;

/***/ }),

/***/ "7ce1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var mySampler: sampler;\r\n@group(0) @binding(4) var myTexture: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragUV: vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  return textureSample(myTexture, mySampler, fragUV) * fragPosition;\r\n}\r\n");

/***/ }),

/***/ "7e70":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const RectPlaneGeometry_1 = __importDefault(__webpack_require__("0540"));

const Extent2_1 = __importDefault(__webpack_require__("f937"));

const __$Extent = new Extent2_1.default();

class PlaneEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    let geom = new RectPlaneGeometry_1.default();
    geom.axisType = param.axisType === undefined ? 0 : param.axisType;

    if (param.extent !== undefined) {
      const t = __$Extent;
      t.setExtent(param.extent);
      geom.initialize(t.x, t.y, t.width, t.height);
    } else {
      geom.initialize(param.x === undefined ? -50 : param.x, param.y === undefined ? -50 : param.y, param.width === undefined ? 100 : param.width, param.height === undefined ? 100 : param.height);
    }

    return geom;
  }

}

exports.PlaneEntity = PlaneEntity;

/***/ }),

/***/ "81d0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));
/**
 * Add some entitices into scene.
 * Remove some entitices from scene.
 * Create some new entitices and add them into scene.
 */


class RSceneEntityManagement {
  constructor() {
    this.mEntitices = [];
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.mRenderingFlag = 6;

    this.mouseDown = evt => {
      const rc = this.mRscene;
      let visibleTest = false;

      if (visibleTest) {
        // let et = this.mEntitices[Math.round(Math.random() * (this.mEntitices.length - 1))];
        let et = this.mEntitices[0];
        console.log("et: ", et);
        console.log("et.isInRenderer(): ", et.isInRenderer());

        if (et.isInRenderer()) {
          rc.removeEntity(et);
        } else {
          let vs = et.materials[0].uniformValues[0].data;
          vs.set([Math.random() + 0.2, Math.random() + 0.2, Math.random() + 0.2, 1.0]);
          rc.addEntity(et);
        } // this.mRenderingFlag = 1;

      } else {
        const geometry = this.createGeom(this.geomData.createSphere(50));
        const shdSrc = {
          vert: {
            code: defaultEntity_vert_wgsl_1.default,
            uuid: "vertShdCode"
          },
          frag: {
            code: sampleTextureColorParam_frag_wgsl_1.default,
            uuid: "fragShdCode"
          }
        };
        const diffuseTex = {
          diffuse: {
            url: "static/assets/default.jpg"
          }
        };
        let materials = [this.createMaterial(shdSrc, [diffuseTex], new Color4_1.default(Math.random() * 1.5, Math.random() * 1.5, Math.random() * 1.5))];
        let entity = new Entity3D_1.Entity3D({
          materials,
          geometry
        });
        entity.transform.setPosition(new Vector3_1.default(-500 + this.mEntitices.length * 130, 0, 0));
        this.mEntitices.push(entity);
        rc.addEntity(entity);
      }
    };
  }

  initialize() {
    console.log("RSceneEntityManagement::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texs, color, blendModes = ["solid"], faceCullMode = "back") {
    color = color ? color : new Color4_1.default();
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texs ? texs.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let ufv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([color.r, color.g, color.b, 1])
    });
    material.uniformValues = [ufv];
    material.addTextures(texs);
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  initScene() {
    const rc = this.mRscene;
    const geometry = this.createGeom(this.geomData.createCube(80));
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const diffuseTex = {
      diffuse: {
        url: "static/assets/box.jpg"
      }
    };
    let materials = [this.createMaterial(shdSrc, [diffuseTex], new Color4_1.default(Math.random() * 1.5, Math.random() * 1.5, Math.random() * 1.5))];

    for (let i = 0; i < 1; ++i) {
      let entity = new Entity3D_1.Entity3D({
        materials,
        geometry
      });
      entity.transform.setPosition(new Vector3_1.default(-500 + i * 130, 0, 0));
      this.mEntitices.push(entity);
      rc.addEntity(entity);
    }

    let et = this.mEntitices[0];
    console.log("XXXXXXXXXX et.isInRenderer(): ", et.isInRenderer());
    return;
    let urls = ["static/assets/box.jpg", "static/assets/default.jpg", "static/assets/metal_02.jpg", "static/assets/displacement_01.jpg", "static/assets/brickwall_big512.jpg"];
    let tot = 3;
    const size = new Vector3_1.default(150, 150, 150);
    const pos = new Vector3_1.default().copyFrom(size).scaleBy(-0.5 * (tot - 1));

    for (let i = 0; i < tot; ++i) {
      for (let j = 0; j < tot; ++j) {
        for (let k = 0; k < tot; ++k) {
          const tex = {
            diffuse: {
              url: urls[Math.round(Math.random() * (urls.length - 1))]
            }
          };
          materials = [this.createMaterial(shdSrc, [tex], new Color4_1.default(Math.random() * 1.5, Math.random() * 1.5, Math.random() * 1.5))];
          let entity = new Entity3D_1.Entity3D({
            materials,
            geometry
          });
          entity.transform.setPosition(new Vector3_1.default(i * size.x, j * size.y, k * size.z).addBy(pos));
          this.mEntitices.push(entity);
          rc.addEntity(entity);
        }
      }
    }
  }

  run() {
    // if (this.mRenderingFlag < 1) {
    // 	return;
    // }
    // this.mRenderingFlag--;
    this.mRscene.run();
  }

}

exports.RSceneEntityManagement = RSceneEntityManagement;

/***/ }),

/***/ "821b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> param: vec4f;\r\n@group(0) @binding(4) var sampler0: sampler;\r\n@group(0) @binding(5) var texture0: texture_2d<f32>;\r\n\r\nstruct FragOutput {\r\n  @location(0) color: vec4<f32>,\r\n  @location(1) albedo: vec4<f32>,\r\n  @location(2) normal: vec4<f32>\r\n}\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n    var result = textureSample(texture0, sampler0, uv) * param;\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f,\r\n\t@location(1) normal: vec3f\r\n\t) -> FragOutput {\r\n\r\n\tlet c4 = calcColor( uv );\r\n\tvar output: FragOutput;\r\n\toutput.color = vec4f( c4.xyz * 0.5 + normal * c4.xyz, 1.0);\r\n\toutput.albedo = c4;\r\n\toutput.normal = vec4f(normal, 1.0);\r\n\r\n\treturn output;\r\n}\r\n");

/***/ }),

/***/ "8286":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const CoModelTeamLoader_1 = __webpack_require__("6aa1");

const WGGeometry_1 = __webpack_require__("746a");

const PrimitiveEntity_1 = __webpack_require__("1eee");

const primitiveIns_vert_wgsl_1 = __importDefault(__webpack_require__("751c"));

const primitiveIns_frag_wgsl_1 = __importDefault(__webpack_require__("0444"));

const WGRUniformValue_1 = __webpack_require__("7650");

const WGRStorageValue_1 = __webpack_require__("e44f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class DrawInstanceTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mTeamLoader = new CoModelTeamLoader_1.CoModelTeamLoader();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("DrawInstanceTest::initialize() ...");
    this.initEvent();
    this.initModels();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createGeometry(gd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: gd.vertices
    }).addAttribute({
      uv: gd.uvsList[0]
    }).setIndices(gd.indices);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: gd.normals
      });
    }

    return geometry;
  }

  initModels() {
    let url0 = "static/assets/fbx/mat_ball.fbx";
    let loader = this.mTeamLoader;
    loader.load([url0], (models, transforms) => {
      console.log("loaded models: ", models);

      for (let i = 0; i < models.length; ++i) {
        this.createEntity(models[i]);
      }
    });
  }

  createEntity(model) {
    let tot = 4;
    let instanceCount = tot * tot * tot;
    const stride = 4;
    const posData = new Float32Array(stride * instanceCount);
    const size = new Vector3_1.default(150, 150, 150);
    const pos = new Vector3_1.default().copyFrom(size).scaleBy(-0.5 * (tot - 1));
    let index = 0;

    for (let i = 0; i < tot; ++i) {
      for (let j = 0; j < tot; ++j) {
        for (let k = 0; k < tot; ++k) {
          const pv = new Vector3_1.default().setXYZ(i * size.x, j * size.y, k * size.z).addBy(pos);
          const t = index * stride;
          posData[t] = pv.x;
          posData[t + 1] = pv.y;
          posData[t + 2] = pv.z;
          posData[t + 3] = 1;
          index++;
        }
      }
    }

    let positionsV = new WGRStorageValue_1.WGRStorageValue({
      stride,
      data: posData,
      shdVarName: 'positions'
    });
    let albedoV = new WGRUniformValue_1.WGRUniformValue({
      data: new Float32Array([1.0, 0.01, 0.05, 1]),
      shdVarName: 'albedo'
    });
    let armV = new WGRUniformValue_1.WGRUniformValue({
      data: new Float32Array([1, 0.1, 0.1, 1]),
      shdVarName: 'arm'
    });
    let uniformValues = [positionsV, albedoV, armV];
    let shaderSrc = {
      vert: {
        code: primitiveIns_vert_wgsl_1.default,
        uuid: "vert-primitive-ins"
      },
      frag: {
        code: primitiveIns_frag_wgsl_1.default,
        uuid: "frag-primitive-ins"
      }
    };
    const rc = this.mRscene;
    const geometry = this.createGeometry(model, true);
    let entity = new PrimitiveEntity_1.PrimitiveEntity({
      geometry,
      shaderSrc,
      uniformValues,
      instanceCount
    });
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.DrawInstanceTest = DrawInstanceTest;

/***/ }),

/***/ "842f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRUnitState_1 = __webpack_require__("222c");

class WGRUnitRunSt {}

const __$urst = new WGRUnitRunSt();

const __$reust = new WGRUnitState_1.WGRUnitState();

class WGRUnit {
  constructor() {
    this.rf = true;
    this.pst = __$reust;
    this.st = __$reust;
    this.__$rever = 0;
    this.enabled = true;
  }

  getRF() {
    // console.log("this.st.isDrawable(): ", this.st.isDrawable());
    return this.enabled && this.st.isDrawable();
  }

  runBegin() {
    const rc = this.rp.passEncoder;
    const mt = this.material;
    let rf = this.enabled && this.rp.enabled && this.st.isDrawable();
    rf = rf && mt.visible && mt.instanceCount > 0; // console.log("rnit::runBegin(), rf: ", rf);

    if (rf) {
      const gt = this.geometry;
      const pipeline = this.pipelinectx.pipeline;

      if (gt && pipeline) {
        // 这里面的诸多判断逻辑不应该出现，加入渲染器内部渲染流程之前必须处理好， 后续优化
        const st = __$urst;

        if (st.rc != rc) {
          st.pipeline = null;
          st.ibuf = null;
          st.gt = null;
          st.rc = rc;
          st.unfsuuid = "";
        }

        if (st.gt != gt) {
          st.gt = gt;
          gt.run(rc);
        }

        if (st.pipeline != pipeline) {
          st.pipeline = pipeline; // console.log("ruint setPipeline(), this.pipeline: ", this.pipeline);

          rc.setPipeline(pipeline);
        }

        gt.instanceCount = mt.instanceCount; // console.log("mt.instanceCount: ", mt.instanceCount);

        const ufs = this.uniforms;

        if (ufs) {
          for (let i = 0, ln = ufs.length; i < ln; i++) {
            const uf = ufs[i];

            if (uf.isEnabled()) {
              // console.log("ruint setBindGroup(), bindGroup: ", uf.bindGroup);
              // console.log("ruint setBindGroup(), bindGroup: ", uf.bindGroup, ", uf.getUid(): ", uf.getUid());
              // console.log("ruint setBindGroup(), uf.groupIndex: ", uf.groupIndex,",", uf.bindGroup);
              rc.setBindGroup(uf.groupIndex, uf.bindGroup);

              for (let j = 0, ln = uf.uvfs.length; j < ln; j++) {
                // console.log("ruint uf(",i,") setValue(), j: ", j);
                uf.setValue(uf.uvfs[j], j);
              }
            } else {
              rf = false;
            }
          }
        }
      } else {
        rf = false;
      }
    }

    this.rf = rf;
  }

  run() {
    // console.log("rnit::run(), rf: ", this.rf);
    if (this.rf) {
      const rc = this.rp.passEncoder;
      const gt = this.geometry;

      if (gt.ibuf) {
        const st = __$urst;

        if (st.ibuf != gt.ibuf) {
          st.ibuf = gt.ibuf;
          rc.setIndexBuffer(gt.ibuf, gt.ibuf.dataFormat);
        } // console.log("runit drawIndexed this.etuuid: ", this.etuuid,',', ', indexCount: ',gt.indexCount);
        // console.log("runit drawIndexed this.etuuid: ", this.etuuid,',', gt.indexCount,',', gt.instanceCount,',', this.material);
        // console.log("runit drawIndexed indexCount: ", gt.indexCount, ", gt.instanceCount: ", gt.instanceCount);


        rc.drawIndexed(gt.indexCount, gt.instanceCount);
      } else {
        // console.log("runit draw(), vertexCount: ", gt.vertexCount,", instanceCount: ", gt.instanceCount);
        rc.draw(gt.vertexCount, gt.instanceCount);
      }
    }
  }

  destroy() {
    if (this.pipelinectx) {
      const ufctx = this.pipelinectx.uniformCtx;
      ufctx.removeUniforms(this.uniforms);
      this.pipelinectx = null;
      this.material = null;
      this.rp = null;
      this.pst = null;
      this.st = null;
    }
  }

}

exports.WGRUnit = WGRUnit;

/***/ }),

/***/ "852d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const URLFilter_1 = __importDefault(__webpack_require__("3247"));

const ModuleLoader_1 = __webpack_require__("fa7f");

class CoModuleVersion {
  constructor(infoObj) {
    this.m_infoObj = null;
    this.m_verMap = new Map();
    this.forceFiltering = false;

    if (infoObj != null) {
      this.m_infoObj = infoObj;
      const versionInfo = this.m_infoObj;
      const versionInfoMap = this.m_verMap;
      let items = versionInfo.items;

      for (let i = 0; i < items.length; ++i) {
        const ia = items[i];
        versionInfoMap.set(ia.name, ia);

        if (ia.type) {
          if (ia.type == "dir") {
            let ls = ia.items;

            for (let i = 0; i < ls.length; ++i) {
              const ib = ls[i];
              versionInfoMap.set(ib.name, ib);
            }
          }
        }
      }
    }
  }

  filterUrl(url) {
    let isDL = url.indexOf("/dracoLib/") > 0;

    if (isDL) {
      let name = URLFilter_1.default.getFileNameAndSuffixName(url, true);

      if (this.m_verMap.has(name)) {
        let item = this.m_verMap.get(name);
        url += "?ver=" + item.ver;
      }
    } else {
      let name = URLFilter_1.default.getFileName(url, true);

      if (this.m_verMap.has(name)) {
        let item = this.m_verMap.get(name);
        url += "?ver=" + item.ver;
      }
    }

    return url;
  }

}

exports.CoModuleVersion = CoModuleVersion;

function toReleaseUrl(url, host) {
  let i = url.lastIndexOf("/");
  let j = url.indexOf(".", i);
  let fileName = url.slice(i, j);

  if (url.indexOf(".umd.") > 0) {
    fileName = fileName.toLocaleLowerCase();
    url = host + url.slice(0, i) + fileName + ".js";
  } else {
    url = host + url;
  }

  if (fileName == "") {
    console.error("err: ", url);
    console.error("i, j: ", i, j);
  }

  console.log("toReleaseUrl(), fileName:-" + fileName + "-");
  console.log("toReleaseUrl(), new url: ", url);
  return url;
}

class CoModuleLoader extends ModuleLoader_1.ModuleLoader {
  /**
   * @param times 记录总共需要的加载完成操作的响应次数。这个次数可能是由load直接产生，也可能是由于别的地方驱动。
   * @param callback 完成所有响应的之后的回调
   */
  constructor(times, callback = null, versionFilter = null) {
    super(times, callback, null);
    this.forceFiltering = false;

    let urlChecker = url => {
      console.log("XX MMMM XXXX init url: ", url);

      if (url.indexOf(".artvily.") > 0) {
        return url;
      }

      let hostUrl = window.location.href;
      url = url.trim();

      if (hostUrl.indexOf(".artvily.") > 0 || this.forceFiltering) {
        console.log(">>>>> NNNN 1 >>>>>>>>>>>>>>>>"); // hostUrl = "http://localhost:9000/test/";

        if (CoModuleLoader.urlHostFilterEnabled) {
          if (!this.forceFiltering) {
            hostUrl = "http://www.artvily.com:9090/";
          } else {
            hostUrl = URLFilter_1.default.getHostUrl("9090");
          }
        } // let i = url.lastIndexOf("/");
        // let j = url.indexOf(".", i);
        // let fileName = url.slice(i, j);
        // if (url.indexOf(".umd.") > 0) {
        // 	fileName = fileName.toLocaleLowerCase();
        // 	url = hostUrl + url.slice(0, i) + fileName + ".js";
        // } else {
        // 	url = hostUrl + url;
        // }


        url = toReleaseUrl(url, hostUrl);

        if (versionFilter) {
          url = versionFilter.filterUrl(url);
        }

        return url;
      } else {
        if (CoModuleLoader.forceReleaseEnabled) {
          url = toReleaseUrl(url, "");
        }
      }

      if (versionFilter) {
        url = versionFilter.filterUrl(url);
      }

      return url;
    };

    this.setUrlChecker(urlChecker);
  }

}

CoModuleLoader.urlHostFilterEnabled = true;
CoModuleLoader.forceReleaseEnabled = false;
exports.CoModuleLoader = CoModuleLoader;

/***/ }),

/***/ "85fd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class MultiGPUPassTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.mIndex = 0;

    this.mouseDown = evt => {
      // // this.testAddEntityToBlock();
      // this.testAddEntityToPassNode();
      // return;
      let node = this.mRPass1.node; // node = this.mRPass0.node;

      console.log("mousedown evt call this.mRPass1: ", this.mRPass1);
      console.log("mousedown evt call AAAA node: ", node);
      console.log("mousedown evt call node.enabled: ", node.enabled);
      node.enabled = !node.enabled;
      console.log("mousedown evt call BBBB node: ", node);
    };
  }

  initialize() {
    console.log("MultiGPUPassTest::initialize() ...");
    this.mRscene.initialize({
      rpassparam: {
        multisampleEnabled: true,
        depthTestEnabled: true
      },
      camera: {
        eye: new Vector3_1.default(600.0, 600.0, 0.0)
      }
    });
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texs, param, blendModes = ["solid"], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texs ? texs.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let ufv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array(new Color4_1.default().setColor(param).getArray4())
    });
    material.uniformValues = [ufv];
    material.addTextures(texs);
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  testAddEntityToBlock() {
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const geometry = this.createGeom(this.geomData.createSphere(50));
    const diffuseTex = {
      diffuse: {
        url: "static/assets/box.jpg"
      }
    };
    let materials = [this.createMaterial(shdSrc, [diffuseTex], [1.0, 0.0, 1.0])];
    let entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    entity.transform.setXYZ(0, 0, 180 + this.mIndex * 110);
    this.mRBlock.addEntity(entity);
    this.mIndex++;
  }

  testAddEntityToPassNode() {
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const geometry = this.createGeom(this.geomData.createSphere(50));
    const diffuseTex = {
      diffuse: {
        url: "static/assets/box.jpg"
      }
    };
    let materials = [this.createMaterial(shdSrc, [diffuseTex], [1.0, 0.0, 1.0])];
    let entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    entity.transform.setXYZ(0, 0, -(180 + this.mIndex * 110));
    this.mRPass0.node.addEntity(entity);
    this.mIndex++;
  }

  initScene() {
    const rc = this.mRscene;
    this.mRBlock = rc.renderer.getRPBlockAt(0);
    const geometry = this.createGeom(this.geomData.createCube(80));
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const diffuseTex = {
      diffuse: {
        url: "static/assets/box.jpg"
      }
    };
    let materials0 = [this.createMaterial(shdSrc, [diffuseTex], [1.0, 0.0, 0.0])];
    let materials1 = [this.createMaterial(shdSrc, [diffuseTex], [0.0, 1.0, 0.0])];
    this.mRPass0 = rc.renderer.getRPBlockAt(0).getRenderPassAt(0);
    this.mRPass1 = rc.renderer.appendRenderPass();
    materials1[0].rpass = {
      rpass: this.mRPass1
    };
    let entity = new Entity3D_1.Entity3D({
      geometry,
      materials: materials0
    });
    rc.addEntity(entity);
    entity = new Entity3D_1.Entity3D({
      geometry,
      materials: materials1
    });
    entity.transform.setXYZ(200, 0, 0);
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.MultiGPUPassTest = MultiGPUPassTest;

/***/ }),

/***/ "8637":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> albedo: vec4f;\r\n@group(0) @binding(4) var<uniform> arm: vec4f;\r\n\r\nconst PI = 3.141592653589793;\r\nconst PI2 = 6.283185307179586;\r\nconst PI_HALF = 1.5707963267948966;\r\nconst RECIPROCAL_PI = 0.3183098861837907;\r\nconst RECIPROCAL_PI2 = 0.15915494309189535;\r\nconst EPSILON = 1e-6;\r\n\r\nfn approximationSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(srgbColor, vec3<f32>(2.2));\r\n}\r\nfn approximationLinearToSRCB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfn accurateSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    let linearRGBLo = srgbColor / 12.92;\r\n    let linearRGBHi = pow((srgbColor + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n\tif( all( srgbColor <= vec3(0.04045) ) ) {\r\n\t\treturn linearRGBLo;\r\n\t}\r\n    return linearRGBHi;\r\n}\r\nfn accurateLinearToSRGB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    let srgbLo = linearColor * 12.92;\r\n    let srgbHi = (pow(abs(linearColor), vec3(1.0 / 2.4)) * 1.055) - 0.055;\r\n    if(all(linearColor <= vec3(0.0031308))) {\r\n\t\treturn srgbLo;\r\n\t}\r\n    return srgbHi;\r\n}\r\n\r\n// Trowbridge-Reitz(Generalized-Trowbridge-Reitz,GTR)\r\nfn DistributionGTR1(NdotH: f32, roughness: f32) -> f32 {\r\n    if (roughness >= 1.0) {\r\n\t\treturn 1.0/PI;\r\n\t}\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0)*NdotH*NdotH;\r\n    return (a2 - 1.0) / (PI * log(a2) *t);\r\n}\r\nfn DistributionGTR2(NdotH: f32, roughness: f32) -> f32 {\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\r\n    return a2 / (PI * t * t);\r\n}\r\n\r\n\r\nfn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {\r\n    let a = roughness*roughness;\r\n    let a2 = a*a;\r\n    let NdotH = max(dot(N, H), 0.0);\r\n    let NdotH2 = NdotH*NdotH;\r\n\r\n    let nom   = a2;\r\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n\r\n\r\nfn GeometryImplicit(NdotV: f32, NdotL: f32) -> f32 {\r\n    return NdotL * NdotV;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\r\n    let r = (roughness + 1.0);\r\n    let k = (r*r) / 8.0;\r\n\r\n    let nom   = NdotV;\r\n    let denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {\r\n    let NdotV = max(dot(N, V), 0.0);\r\n    let NdotL = max(dot(N, L), 0.0);\r\n    let ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    let ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// @param cosTheta is clamp(dot(H, V), 0.0, 1.0)\r\nfn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\r\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\r\n}\r\nfn fresnelSchlick2(specularColor: vec3<f32>, L: vec3<f32>, H: vec3<f32>) -> vec3<f32> {\r\n   return specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(L, H)), 5.0);\r\n}\r\n//fresnelSchlick2(specularColor, L, H) * ((SpecularPower + 2) / 8 ) * pow(saturate(dot(N, H)), SpecularPower) * dotNL;\r\n\r\nconst OneOnLN2_x6 = 8.656171;// == 1/ln(2) * 6 (6 is SpecularPower of 5 + 1)\r\n// dot -> dot(N,V) or\r\nfn fresnelSchlick3(specularColor: vec3<f32>, dot: f32, glossiness: f32) -> vec3<f32> {\r\n\treturn specularColor + (max(vec3(glossiness), specularColor) - specularColor) * exp2(-OneOnLN2_x6 * dot);\r\n}\r\nfn fresnelSchlickWithRoughness(specularColor: vec3<f32>, L: vec3<f32>, N: vec3<f32>, gloss: f32) -> vec3<f32> {\r\n   return specularColor + (max(vec3(gloss), specularColor) - specularColor) * pow(1.0 - saturate(dot(L, N)), 5.0);\r\n}\r\n\r\nconst A = 2.51f;\r\nconst B = 0.03f;\r\nconst C = 2.43f;\r\nconst D = 0.59f;\r\nconst E = 0.14f;\r\nfn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32> {\r\n\r\n\tlet c = color * adapted_lum;\r\n\treturn (c * (A * c + B)) / (c * (C * c + D) + E);\r\n}\r\n\r\n//color = color / (color + vec3(1.0));\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn reinhard_extended(v: vec3<f32>, max_white: f32) -> vec3<f32> {\r\n    let numerator = v * (1.0f + (v / vec3(max_white * max_white)));\r\n    return numerator / (1.0f + v);\r\n}\r\nfn luminance(v: vec3<f32>) -> f32 {\r\n    return dot(v, vec3<f32>(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn change_luminance(c_in: vec3<f32>, l_out: f32) -> vec3<f32> {\r\n    let l_in = luminance(c_in);\r\n    return c_in * (l_out / l_in);\r\n}\r\nfn reinhard_extended_luminance(v: vec3<f32>, max_white_l: f32) -> vec3<f32> {\r\n    let l_old = luminance(v);\r\n    let numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\r\n    let l_new = numerator / (1.0f + l_old);\r\n    return change_luminance(v, l_new);\r\n}\r\nfn ReinhardToneMapping( color: vec3<f32>, toneMappingExposure: f32 ) -> vec3<f32> {\r\n\r\n\tlet c = color * toneMappingExposure;\r\n\treturn saturate( c / ( vec3( 1.0 ) + c ) );\r\n\r\n}\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nconst highp_a = 12.9898;\r\nconst highp_b = 78.233;\r\nconst highp_c = 43758.5453;\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n\tlet dt = dot( uv.xy, vec2<f32>( highp_a, highp_b ) );\r\n\tlet sn = modf( dt / PI ).fract;\r\n\treturn fract(sin(sn) * highp_c);\r\n}\r\n// // based on https://www.shadertoy.com/view/MslGR8\r\nfn dithering( color: vec3<f32>, fragCoord: vec2<f32> ) -> vec3<f32> {\r\n    //Calculate grid position\r\n    let grid_position = rand( fragCoord );\r\n\r\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n    var dither_shift_RGB = vec3<f32>( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n    //modify shift acording to grid position.\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n    //shift the color by dither_shift\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nconst dis = 600.0;\r\nconst disY = 400.0;\r\nconst lightPositions = array<vec3<f32>, 4>(\r\n\tvec3<f32>(-dis, disY, dis),\r\n\tvec3<f32>(dis, disY, dis),\r\n\tvec3<f32>(-dis, disY, -dis),\r\n\tvec3<f32>(dis, disY, -dis)\r\n);\r\nconst colorValue = 300.0;\r\nconst lightColors = array<vec3<f32>, 4>(\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n);\r\n\r\nfn calcPBRColor3(Normal: vec3<f32>, WorldPos: vec3<f32>, camPos: vec3<f32>) -> vec3<f32> {\r\n\r\n\tvar color = vec3<f32>(0.0);\r\n\r\n    var ao = arm.x;\r\n    var roughness = arm.y;\r\n    var metallic = arm.z;\r\n\r\n\tvar N = normalize(Normal);\r\n    var V = normalize(camPos.xyz - WorldPos);\r\n    var dotNV = clamp(dot(N, V), 0.0, 1.0);\r\n\r\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\r\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\r\n    var F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo.xyz, metallic);\r\n\r\n    // reflectance equation\r\n    var Lo = vec3(0.0);\r\n\r\n\tfor (var i: i32 = 0; i < 4; i++) {\r\n\t\t// calculate per-light radiance\r\n        let L = normalize(lightPositions[i].xyz - WorldPos);\r\n        let H = normalize(V + L);\r\n        let distance = length(lightPositions[i].xyz - WorldPos);\r\n\r\n        let attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0003 * distance * distance);\r\n        let radiance = lightColors[i].xyz * attenuation;\r\n\r\n        // Cook-Torrance BRDF\r\n        let NDF = DistributionGGX(N, H, roughness);\r\n        let G   = GeometrySmith(N, V, L, roughness);\r\n        //vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\r\n        let F    = fresnelSchlick3(F0,clamp(dot(H, V), 0.0, 1.0), 0.9);\r\n        //vec3 F    = fresnelSchlick3(F0,dotNV, 0.9);\r\n\r\n        let nominator    = NDF * G * F;\r\n        let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\r\n        let specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\r\n\r\n        // kS is equal to Fresnel\r\n        let kS = F;\r\n        // for energy conservation, the diffuse and specular light can't\r\n        // be above 1.0 (unless the surface emits light); to preserve this\r\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\r\n        var kD = vec3<f32>(1.0) - kS;\r\n        // multiply kD by the inverse metalness such that only non-metals\r\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\r\n        // have no diffuse light).\r\n        kD *= 1.0 - metallic;\r\n\r\n        // scale light by NdotL\r\n        let NdotL = max(dot(N, L), 0.0);\r\n\r\n        // add to outgoing radiance Lo\r\n        // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\r\n        Lo += (kD * albedo.xyz / PI + specular) * radiance * NdotL;\r\n\t}\r\n\t// ambient lighting (note that the next IBL tutorial will replace\r\n    // this ambient lighting with environment lighting).\r\n    let ambient = vec3<f32>(0.03) * albedo.xyz * ao;\r\n\r\n    color = ambient + Lo;\r\n    // HDR tonemapping\r\n    color = reinhard( color );\r\n    // gamma correct\r\n    color = pow(color, vec3<f32>(1.0/2.2));\r\n\treturn color;\r\n}\r\nstruct FragOutput {\r\n  @location(0) color: vec4<f32>,\r\n  @location(1) vpos: vec4<f32>\r\n}\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>,\r\n  @location(3) camPos: vec3<f32>\r\n) -> FragOutput {\r\n  var output: FragOutput;\r\n  output.color = vec4(calcPBRColor3(normal, pos.xyz, camPos), 1.0);\r\n  output.vpos = vec4f(camPos.xyz - pos.xyz, 1.0);\r\n  return output;\r\n}");

/***/ }),

/***/ "8777":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const WGRPassNodeGraph_1 = __webpack_require__("f083");

class PassGraph extends WGRPassNodeGraph_1.WGRPassNodeGraph {
  constructor() {
    super();
  }

  runBegin() {
    super.runBegin();
  }

  run() {
    let pass = this.passes[0];

    for (let i = 0; i < 16; ++i) {
      pass.colorAttachments[0].clearEnabled = i < 1;
      pass.render();
    }
  }

}

class PassNodeGraphTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("PassNodeGraphTest::initialize() ...");
    let multisampleEnabled = true;
    let depthTestEnabled = false;
    let rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam
    });
    this.initEvent();
    this.initScene();
  }

  applyNewRPass(texUUID, entities, clearColor, extent = [0.4, 0.3, 0.5, 0.5]) {
    let rs = this.mRscene;
    let rttTex = {
      diffuse: {
        uuid: texUUID,
        rttTexture: {}
      }
    };
    let colorAttachments = [{
      texture: rttTex,
      clearValue: clearColor,
      loadOp: "clear",
      storeOp: "store"
    }];
    let rPass = rs.renderer.appendRenderPass({
      separate: true,
      colorAttachments
    });

    for (let i = 0; i < entities.length; ++i) {
      rPass.addEntity(entities[i]);
    }

    let graph = new PassGraph();
    graph.passes = [rPass];
    rs.setPassNodeGraph(graph);
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [rttTex]
    });
    rs.addEntity(entity);
  }

  initEvent() {
    const rs = this.mRscene;
    new MouseInteraction_1.MouseInteraction().initialize(rs, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rs = this.mRscene;
    let entity;
    const diffuseTex = {
      diffuse: {
        url: "static/assets/guangyun_40.png",
        flipY: true
      }
    };
    let blendModes = ['add'];
    let entities = [];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 0.8, 0.8],
      textures: [diffuseTex],
      blendModes
    });
    entity.setColor([0.9, 0.3, 0.9]);
    rs.addEntity(entity);
    entities.push(entity);
    this.applyNewRPass('rtt0', entities, [0.2, 0.2, 0.2, 1.0], [-0.2, 0.1, 0.8, 0.8]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.PassNodeGraphTest = PassNodeGraphTest;

/***/ }),

/***/ "87b6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@group(0) @binding(1) var<storage> params: array<vec4<f32>>;\r\n\r\nfn calcColor3(vtxUV: vec2f) -> vec3f{\r\n\r\n\tlet stSize = params[1].zw;\r\n\tlet time = params[2].x;\r\n    let fragCoord = vtxUV * stSize;\r\n\r\n\tlet color1 = vec3f(1.7, 0.25, 0.5);\r\n\tlet color2 = vec3f(0.5, 0.7, 0.25);\r\n\tlet color3 = vec3f(0.25, 0.5, 0.7);\r\n\tlet point1 = stSize * 0.5 + vec2f(sin(time*2.0) * 10.0, cos(time*2.0) * 50.0) * (vtxUV - 0.5) * 4.0;\r\n\tlet point2 = stSize * 0.5 + vec2f(sin(time) * 75.0, cos(time)*50.0);\r\n\tlet point3 = stSize * 0.5 + vec2f(sin(time) * 25.0, sin(time*2.0)*50.0)*2.0;\r\n\t\r\n\tlet dist1 = fragCoord - point1;\r\n\tlet intensity1 = pow(32.0/(0.01+length(dist1)), 2.0);\r\n\t\r\n\tlet dist2 = fragCoord - point2;\r\n\tlet intensity2 = pow(3.0/(0.01+length(dist2)), 2.0);\r\n\t\r\n\tlet dist3 = fragCoord - point3;\r\n\tlet intensity3 = pow(80.0/(0.01+length(dist3)), 1.0);\r\n\t\r\n\treturn vec3f((color1*intensity1 + color2*intensity2 + color3*intensity3)*modf(fragCoord.y/2.0).fract);\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\t//let c3 = calcColor3(fract(uv/0.5));\r\n\tlet c3 = calcColor3( uv );\r\n\tlet c4 = vec4f(c3.xyz * color.xyz, color.w);\r\n\treturn c4;\r\n}\r\n");

/***/ }),

/***/ "87f6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8890":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const defaultEntity_frag_wgsl_1 = __importDefault(__webpack_require__("7ce1"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

class ImgTexturedCube {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    console.log("ImgTexturedCube::initialize() ...");
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: defaultEntity_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const material = this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")]);
    this.createEntity([material]);
  }

  createMaterial(shdSrc, texDatas) {
    let pipelineDefParam = {
      faceCullMode: "back"
    };
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createCube(200);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.renderer.run();
  }

}

exports.ImgTexturedCube = ImgTexturedCube;

/***/ }),

/***/ "8895":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const HTMLViewerLayer_1 = __webpack_require__("992e");

class ButtonDivItem extends HTMLViewerLayer_1.HTMLViewerLayer {
  constructor() {
    super();
    this.mBtnName = "";
    this.mBtnIdns = "";
    this.mSelected = false;
    this.mSelectColors = [0xbdd9e1, 0xaed4df, 0x83c4d7];
    this.mDeselectColors = [0x7aacda, 0x4a93d5, 0x3b7bb5];
    this.group = null;
    this.onmousedown = null;
    this.onmouseup = null;
  }

  initialize(viewerLayer, btn_name, btn_idns) {
    console.log("ButtonDivItem::initialize()......");
    let style = viewerLayer.style;
    style.cursor = "pointer";
    style.userSelect = "none"; // style.color = "#eeeeee";

    this.setViewer(viewerLayer);
    this.mBtnName = btn_name;
    this.mBtnIdns = btn_idns;
    viewerLayer.innerHTML = btn_name;
    this.initEvent(viewerLayer);
    this.applyColorAt(0);
  }

  toRoundedRectangleStyle(style = null) {
    if (!style) {
      style = this.getStyle();
    }

    style.borderRadius = "10px"; // style.outline = "10px solid #00ff"

    style.outline = "none";
    style.boxShadow = "0 0 0 5px #7aacda";
  }

  setSelectColors(colors) {
    this.mSelectColors = colors;
  }

  setDeselectColors(colors) {
    this.mDeselectColors = colors;
  }

  getName() {
    return this.mBtnName;
  }

  getIdns() {
    return this.mBtnIdns;
  }

  applyColorAt(i) {
    let colors = this.mSelected ? this.mSelectColors : this.mDeselectColors; // this.m_viewerLayer.style.backgroundColor = "#" + colors[i].toString(16);

    this.setBackgroundColor(colors[i]);
  }

  initEvent(viewerLayer) {
    viewerLayer.onmouseover = evt => {
      // console.log("mouse over, name: ", this.m_itemData.name);
      this.applyColorAt(1);
    };

    viewerLayer.onmouseout = evt => {
      // console.log("mouse out, name: ", this.m_itemData.name);
      this.applyColorAt(0);
    };

    viewerLayer.onmouseup = evt => {
      // console.log("mouse up, name: ", this.m_itemData.name);
      this.select();
      this.applyColorAt(1);

      if (this.onmouseup) {
        evt.buttonTarget = this;
        evt.button_idns = this.mBtnIdns;
        this.onmouseup(evt);
      }
    };

    viewerLayer.onmousedown = evt => {
      // console.log("mouse down, name: ", this.m_itemData.name);
      this.applyColorAt(2);

      if (this.onmousedown) {
        evt.buttonTarget = this;
        evt.button_idns = this.mBtnIdns;
        this.onmousedown(evt);
      }
    };
  }

  isSelected() {
    return this.mSelected;
  }

  select() {
    if (this.group != null) {
      let ls = this.group;
      let len = ls.length;

      for (let i = 0; i < len; ++i) {
        if (ls[i].isSelected()) {
          ls[i].deselect();
          break;
        }
      }

      this.mSelected = true;
      this.applyColorAt(0);
    } else {// this.mSelected = true;
    }
  }

  deselect() {
    if (this.group != null) {
      this.mSelected = false;
      this.applyColorAt(0);
    } else {// this.mSelected = false;
    }
  }

}

exports.ButtonDivItem = ButtonDivItem;

/***/ }),

/***/ "89ff":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const util_1 = __webpack_require__("660c");
/** Clamp a number to the provided range. */


function clamp(n, {
  min,
  max
}) {
  util_1.assert(max >= min);
  return Math.min(Math.max(n, min), max);
}

exports.clamp = clamp;

/***/ }),

/***/ "8a88":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GPURenderPipelineEmpty_1 = __webpack_require__("c812");

const WGRPipelineContextImpl_1 = __webpack_require__("374c");

exports.BufDataParamType = WGRPipelineContextImpl_1.BufDataParamType;
exports.VtxPipelinDescParam = WGRPipelineContextImpl_1.VtxPipelinDescParam;

const WGRUniformContext_1 = __webpack_require__("b2fd");

exports.WGRUniformParam = WGRUniformContext_1.WGRUniformParam;
/**
 * one type shading shader, one WGRBindGroupContext instance
 */

class WGRBindGroupContext {
  constructor(wgCtx) {
    this.mUid = WGRBindGroupContext.sUid++;
    this.mBGLayouts = new Array(8);
    this.pipeline = new GPURenderPipelineEmpty_1.GPURenderPipelineEmpty();
    this.type = "render"; // console.log("XXX XXX create a WGRBindGroupContext instance.");

    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  getUid() {
    return this.mUid;
  }

  destroy() {
    if (this.mWGCtx) {
      this.mWGCtx = null;
    }
  }

  initialize(wgCtx) {
    if (wgCtx && !this.mWGCtx) {
      this.mWGCtx = wgCtx;
      this.queue = wgCtx.queue;
    }
  }

  getWGCtx() {
    return this.mWGCtx;
  }

  createUniformBufferWithParam(bufSize, usage, mappedAtCreation = false) {
    const desc = {
      size: bufSize,
      usage: usage,
      mappedAtCreation
    };
    const buf = this.mWGCtx.device.createBuffer(desc);
    return buf;
  }
  /**
   * @param params UniformBufferParam instance.
   * @param initSize The defaut value is 0.
   * @param force256 The defaut value is true.
   * @param mappedAtCreation The defaut value is false.
   */


  createUniformsBuffer(params, initSize = 0, force256 = true, mappedAtCreation = false) {
    if (params && params.sizes.length > 0) {
      let total = params.sizes.length;
      let size = initSize;
      let bufSize = size;
      let segs = new Array(total);

      if (force256) {
        for (let i = 0; i < total; ++i) {
          size = size <= 256 ? size : size % 256;
          size = size > 0 ? 256 - size : 0;
          bufSize += size;
          size = params.sizes[i];
          segs[i] = {
            index: bufSize,
            size: size
          };
          bufSize += size;
        }
      } else {
        for (let i = 0; i < total; ++i) {
          size = params.sizes[i];
          segs[i] = {
            index: bufSize,
            size: size
          };
          bufSize += size;
        }
      }

      const desc = {
        size: bufSize,
        usage: params.usage,
        arrayStride: params.arrayStride
      }; // const buf = this.mWGCtx.device.createBuffer(desc);

      const buf = this.mWGCtx.buffer.createBuffer(desc);
      buf.segs = segs;
      buf.arrayStride = params.arrayStride; // console.log("createUniformsBuffer(), segs: ", segs);
      // console.log("createUniformsBuffer(), bufSize: ", bufSize, ", usage: ", params.usage);

      return buf;
    }

    return null;
  } // updateUniformBufferAt(buffer: GPUBuffer, td: NumberArrayDataType, index: number, offset = 0): void {
  // 	// console.log("updateUniformBufferAt() index: ", index,",segs: ", buffer.segs);
  // 	// console.log("updateUniformBufferAt() buffer.size: ", buffer.size);
  // 	// console.log("updateUniformBufferAt() buffer.segs[index].index + offset: ", buffer.segs[index].index + offset);
  // 	// console.log("updateUniformBufferAt() td: ", td);
  // 	this.queue.writeBuffer(buffer, buffer.segs[index].index + offset, td.buffer, td.byteOffset, td.byteLength);
  // }


  createBindGroupLayout(descriptor) {
    const device = this.mWGCtx.device;
    return device.createBindGroupLayout(descriptor);
  }

  bindGroupDescUpdate(desc, dataParams, texParams, index = 0, uniformAppend) {
    let ei = 0;
    let es = desc.entries;
    let flag = uniformAppend === false ? true : false;

    if (dataParams) {
      const dps = dataParams;

      for (let i = 0; i < dps.length; ++i) {
        const dp = dps[i];

        if (dp.buffer && dp.bufferSize > 0) {
          const res = es[i].resource;

          if (res.offset !== undefined) {
            // the minimum BufferBindingType::ReadOnlyStorage alignment (256)
            res.offset = res.shared || flag ? 0 : index * 256;
            res.buffer = dp.buffer;
            res.size = dp.bufferSize;
          }

          ei++;
        } else {
          throw Error("Illegal operaiton !!!");
        }
      }
    }

    if (texParams && texParams.length > 0) {
      for (let i = 0; i < texParams.length; ++i) {
        const t = texParams[i];

        if (t.texView) {
          let et = es[ei++];

          if (t.sampler && et.resource !== t.sampler) {
            et.resource = t.sampler;
          }

          et = es[ei++];

          if (et.resource !== t.texView) {
            et.resource = t.texView;
          }
        }
      }
    }
  }

  createBindGroupDesc(groupIndex, dataParams, texParams, bindIndex = 0, layout) {
    const device = this.mWGCtx.device;

    if (!layout && !this.mBGLayouts[groupIndex]) {
      if (this.pipeline) {
        this.mBGLayouts[groupIndex] = this.pipeline.getBindGroupLayout(groupIndex);
      } else {
        this.mBGLayouts[groupIndex] = this.comppipeline.getBindGroupLayout(groupIndex);
      }
    }

    let desc = {
      layout: layout ? layout : this.mBGLayouts[groupIndex],
      entries: []
    };
    let bindI = 0;

    if (dataParams) {
      const dps = dataParams;

      for (let i = 0; i < dps.length; ++i) {
        const dp = dps[i];

        if (dp.buffer && dp.bufferSize > 0) {
          const offset = dp.shared ? 0 : 256 * dp.index; // console.log("ooooooooo bindI: ", bindI, ", i: ", i);
          // console.log("		offset: ", offset);
          // console.log("		dp.shared: ", dp.shared, ", bufferSize: ",dp.bufferSize);
          // console.log("		", dp.buffer);

          const ed = {
            binding: bindIndex + bindI++,
            resource: {
              offset,
              buffer: dp.buffer,
              size: dp.bufferSize,
              shared: dp.shared
            }
          };
          desc.entries.push(ed);
        }
      }
    } // console.log("createUniformBindGroup(), texParams: ", texParams);


    if (texParams && texParams.length > 0) {
      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear"
      }); // const sampler = device.createSampler({
      // 	magFilter: 'nearest',
      // 	minFilter: 'nearest',
      // 	mipmapFilter: 'nearest'
      // });

      for (let i = 0; i < texParams.length; ++i) {
        const t = texParams[i];

        if (t.texView) {
          const es = {
            binding: bindIndex + bindI++,
            resource: t.sampler ? t.sampler : sampler
          };
          const et = {
            binding: bindIndex + bindI++,
            resource: t.texView
          };
          console.log('es, et: ', es, et);
          desc.entries.push(es, et);
        }
      }
    } // console.log("createUniformBindGroup(), desc: ", desc);


    if (desc.entries.length < 1) {
      throw Error("Illegal operation !!!");
    }

    return desc;
  }

  createBindGroupObj(desc) {
    const device = this.mWGCtx.device;

    if (desc.entries.length < 1) {
      throw Error("Illegal operation !!!");
    } // console.log("createBindGroupObj(), desc: ", desc);


    const p = device.createBindGroup(desc);
    p.uid = WGRBindGroupContext.sBindGroupUid++;
    return p;
  }

  createBindGroupWithDesc(desc) {
    return this.createBindGroupObj(desc);
  }

  createBindGroup(groupIndex, dataParams, texParams, bindIndex = 0, layout) {
    const desc = this.createBindGroupDesc(groupIndex, dataParams, texParams, bindIndex, layout);
    return this.createBindGroupObj(desc);
  }

}

WGRBindGroupContext.sUid = 0;
WGRBindGroupContext.sBindGroupUid = 0;
exports.WGRBindGroupContext = WGRBindGroupContext;

/***/ }),

/***/ "8b6a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n\r\n    var vpos = textureSample(texture0, sampler0, uv) * param;\r\n\tvar f = clamp((length(vpos.xyz) - 300.0)/200.0, 0.0, 1.0);\r\n\tf = f * f;\r\n\tvpos = vec4f(vec3(f), 1.0);\r\n\r\n    return vpos;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "8bc3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGRUniformValue_1 = __webpack_require__("7650");

class StorageTest {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
  }

  initialize() {
    console.log("StorageTest::initialize() ...");
    let rsv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx rsv.isStorage(): ", rsv.isStorage());
    console.log("xxxxxx rsv.isUniform(): ", rsv.isUniform());
    let ruv = new WGRUniformValue_1.WGRUniformValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx ruv.isStorage(): ", ruv.isStorage());
    console.log("xxxxxx ruv.isUniform(): ", ruv.isUniform());
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let material = this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")], ["solid"], "back");
    this.mEntity = this.createEntity([material]);
  }

  createMaterial(shaderSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc,
      pipelineDefParam
    }); // let ufv = new WGRStorageValue({data: new Float32Array([1,0,0,1])});

    let ufv = {
      storage: {
        data: new Float32Array([1, 0, 0, 1]),
        shdVarName: 'param'
      }
    };
    material.uniformValues = [ufv];
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.StorageTest = StorageTest;

/***/ }),

/***/ "8e9d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const CommonUtils_1 = __webpack_require__("fe0b");

class WGRPColorAttachment {
  constructor() {
    this.clearValue = new Color4_1.default();
    /**
     * Possible values are: "clear", "load"
     */

    this.loadOp = "clear";
    /**
     * Possible values are: "discard", "store"
     */

    this.storeOp = "store";
    this.textureFormat = 'bgra8unorm';
  } // gpuTexture: GPUTexture;


  set clearEnabled(enabled) {
    this.loadOp = enabled ? "clear" : "load"; // console.log("xxx this.loadOp: ", this.loadOp, ', uid: ',this.mUid);
  }

  get clearEnabled() {
    return this.loadOp === "clear";
  }

  setParam(param) {
    if (param) {
      this.param = param;
      let c = this.clearValue;
      CommonUtils_1.copyFromObjectValueWithKey(param, this);
      c.setColor(this.clearValue);
      this.clearValue = c;
      this.texture = param.texture;
      console.log("xxx setParam(), this.loadOp: ", this.loadOp, ', clearValue: ', this.clearValue);
    }

    return this;
  }

  linkToPrev(prev, multisampleEnabled) {
    if (multisampleEnabled) {
      this.view = prev.view;
      this.resolveTarget = prev.resolveTarget;
    } else {
      this.view = prev.view;
    }
  }

}

exports.WGRPColorAttachment = WGRPColorAttachment;

/***/ }),

/***/ "9069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRPipelineContextImpl_1 = __webpack_require__("374c");

exports.BufDataParamType = WGRPipelineContextImpl_1.BufDataParamType;

class WGRUniformWrapper {
  constructor() {
    this.usage = 0;
    this.groupIndex = 0;
    this.enabled = true;
    this.uniformAppend = true;
  }

}

exports.WGRUniformWrapper = WGRUniformWrapper;

class WGRUniformBufObj {
  constructor() {
    this.uniformAppend = true;
  }

  destroy() {
    if (this.oldBufs) {
      for (let i = 0; i < this.oldBufs.length; ++i) {
        this.oldBufs[i].destroy();
        this.oldBufs[i] = null;
      }
    }

    this.oldBufs = null;
    this.buffers = null;
  }

}

exports.WGRUniformBufObj = WGRUniformBufObj;

/***/ }),

/***/ "90af":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<storage> albedo: vec4f;\r\n@group(0) @binding(4) var<storage> param: vec4f;\r\n\r\nconst PI = 3.141592653589793;\r\nconst PI2 = 6.283185307179586;\r\nconst PI_HALF = 1.5707963267948966;\r\nconst RECIPROCAL_PI = 0.3183098861837907;\r\nconst RECIPROCAL_PI2 = 0.15915494309189535;\r\nconst EPSILON = 1e-6;\r\n\r\nfn approximationSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(srgbColor, vec3<f32>(2.2));\r\n}\r\nfn approximationLinearToSRCB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    return pow(linearColor, vec3(1.0/2.2));\r\n}\r\n\r\nfn accurateSRGBToLinear(srgbColor: vec3<f32>) -> vec3<f32> {\r\n    let linearRGBLo = srgbColor / 12.92;\r\n    let linearRGBHi = pow((srgbColor + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n\tif( all( srgbColor <= vec3(0.04045) ) ) {\r\n\t\treturn linearRGBLo;\r\n\t}\r\n    return linearRGBHi;\r\n}\r\nfn accurateLinearToSRGB(linearColor: vec3<f32>) -> vec3<f32> {\r\n    let srgbLo = linearColor * 12.92;\r\n    let srgbHi = (pow(abs(linearColor), vec3(1.0 / 2.4)) * 1.055) - 0.055;\r\n    if(all(linearColor <= vec3(0.0031308))) {\r\n\t\treturn srgbLo;\r\n\t}\r\n    return srgbHi;\r\n}\r\n\r\n// Trowbridge-Reitz(Generalized-Trowbridge-Reitz,GTR)\r\nfn DistributionGTR1(NdotH: f32, roughness: f32) -> f32 {\r\n    if (roughness >= 1.0) {\r\n\t\treturn 1.0/PI;\r\n\t}\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0)*NdotH*NdotH;\r\n    return (a2 - 1.0) / (PI * log(a2) *t);\r\n}\r\nfn DistributionGTR2(NdotH: f32, roughness: f32) -> f32 {\r\n    let a2 = roughness * roughness;\r\n    let t = 1.0 + (a2 - 1.0) * NdotH * NdotH;\r\n    return a2 / (PI * t * t);\r\n}\r\n\r\n\r\nfn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {\r\n    let a = roughness*roughness;\r\n    let a2 = a*a;\r\n    let NdotH = max(dot(N, H), 0.0);\r\n    let NdotH2 = NdotH*NdotH;\r\n\r\n    let nom   = a2;\r\n    var denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.0000001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n\r\n\r\nfn GeometryImplicit(NdotV: f32, NdotL: f32) -> f32 {\r\n    return NdotL * NdotV;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {\r\n    let r = (roughness + 1.0);\r\n    let k = (r*r) / 8.0;\r\n\r\n    let nom   = NdotV;\r\n    let denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {\r\n    let NdotV = max(dot(N, V), 0.0);\r\n    let NdotL = max(dot(N, L), 0.0);\r\n    let ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    let ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// @param cosTheta is clamp(dot(H, V), 0.0, 1.0)\r\nfn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\r\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\r\n}\r\nfn fresnelSchlick2(specularColor: vec3<f32>, L: vec3<f32>, H: vec3<f32>) -> vec3<f32> {\r\n   return specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(L, H)), 5.0);\r\n}\r\n//fresnelSchlick2(specularColor, L, H) * ((SpecularPower + 2) / 8 ) * pow(saturate(dot(N, H)), SpecularPower) * dotNL;\r\n\r\nconst OneOnLN2_x6 = 8.656171;// == 1/ln(2) * 6 (6 is SpecularPower of 5 + 1)\r\n// dot -> dot(N,V) or\r\nfn fresnelSchlick3(specularColor: vec3<f32>, dot: f32, glossiness: f32) -> vec3<f32> {\r\n\treturn specularColor + (max(vec3(glossiness), specularColor) - specularColor) * exp2(-OneOnLN2_x6 * dot);\r\n}\r\nfn fresnelSchlickWithRoughness(specularColor: vec3<f32>, L: vec3<f32>, N: vec3<f32>, gloss: f32) -> vec3<f32> {\r\n   return specularColor + (max(vec3(gloss), specularColor) - specularColor) * pow(1.0 - saturate(dot(L, N)), 5.0);\r\n}\r\n\r\nconst A = 2.51f;\r\nconst B = 0.03f;\r\nconst C = 2.43f;\r\nconst D = 0.59f;\r\nconst E = 0.14f;\r\nfn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32> {\r\n\r\n\tlet c = color * adapted_lum;\r\n\treturn (c * (A * c + B)) / (c * (C * c + D) + E);\r\n}\r\n\r\n//color = color / (color + vec3(1.0));\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn reinhard_extended(v: vec3<f32>, max_white: f32) -> vec3<f32> {\r\n    let numerator = v * (1.0f + (v / vec3(max_white * max_white)));\r\n    return numerator / (1.0f + v);\r\n}\r\nfn luminance(v: vec3<f32>) -> f32 {\r\n    return dot(v, vec3<f32>(0.2126f, 0.7152f, 0.0722f));\r\n}\r\n\r\nfn change_luminance(c_in: vec3<f32>, l_out: f32) -> vec3<f32> {\r\n    let l_in = luminance(c_in);\r\n    return c_in * (l_out / l_in);\r\n}\r\nfn reinhard_extended_luminance(v: vec3<f32>, max_white_l: f32) -> vec3<f32> {\r\n    let l_old = luminance(v);\r\n    let numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\r\n    let l_new = numerator / (1.0f + l_old);\r\n    return change_luminance(v, l_new);\r\n}\r\nfn ReinhardToneMapping( color: vec3<f32>, toneMappingExposure: f32 ) -> vec3<f32> {\r\n\r\n\tlet c = color * toneMappingExposure;\r\n\treturn saturate( c / ( vec3( 1.0 ) + c ) );\r\n\r\n}\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nconst highp_a = 12.9898;\r\nconst highp_b = 78.233;\r\nconst highp_c = 43758.5453;\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n\tlet dt = dot( uv.xy, vec2<f32>( highp_a, highp_b ) );\r\n\tlet sn = modf( dt / PI ).fract;\r\n\treturn fract(sin(sn) * highp_c);\r\n}\r\n// // based on https://www.shadertoy.com/view/MslGR8\r\nfn dithering( color: vec3<f32>, fragCoord: vec2<f32> ) -> vec3<f32> {\r\n    //Calculate grid position\r\n    let grid_position = rand( fragCoord );\r\n\r\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n    var dither_shift_RGB = vec3<f32>( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n    //modify shift acording to grid position.\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n    //shift the color by dither_shift\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nconst dis = 700.0;\r\nconst disZ = 400.0;\r\nconst u_lightPositions = array<vec3<f32>, 4>(\r\n\tvec3<f32>(-dis, dis, disZ),\r\n\tvec3<f32>(dis, dis, disZ),\r\n\tvec3<f32>(-dis, -dis, disZ),\r\n\tvec3<f32>(dis, -dis, disZ)\r\n);\r\nconst colorValue = 300.0;\r\nconst u_lightColors = array<vec3<f32>, 4>(\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n\tvec3<f32>(colorValue, colorValue, colorValue),\r\n);\r\n\r\nfn calcPBRColor3(Normal: vec3<f32>, WorldPos: vec3<f32>, camPos: vec3<f32>) -> vec3<f32> {\r\n\r\n\tvar color = vec3<f32>(0.0);\r\n\r\n    var ao = param.x;\r\n    var roughness = param.y;\r\n    var metallic = param.z;\r\n\r\n\tvar N = normalize(Normal);\r\n    var V = normalize(camPos.xyz - WorldPos);\r\n    var dotNV = clamp(dot(N, V), 0.0, 1.0);\r\n\r\n    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0\r\n    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)\r\n    var F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo.xyz, metallic);\r\n\r\n    // reflectance equation\r\n    var Lo = vec3(0.0);\r\n    \r\n\tfor (var i: i32 = 0; i < 4; i++) {\r\n\t\t// calculate per-light radiance\r\n        let L = normalize(u_lightPositions[i].xyz - WorldPos);\r\n        let H = normalize(V + L);\r\n        let distance = length(u_lightPositions[i].xyz - WorldPos);\r\n\r\n        let attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0003 * distance * distance);\r\n        let radiance = u_lightColors[i].xyz * attenuation;\r\n\r\n        // Cook-Torrance BRDF\r\n        let NDF = DistributionGGX(N, H, roughness);\r\n        let G   = GeometrySmith(N, V, L, roughness);\r\n        //vec3 F    = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);\r\n        let F    = fresnelSchlick3(F0,clamp(dot(H, V), 0.0, 1.0), 0.9);\r\n        //vec3 F    = fresnelSchlick3(F0,dotNV, 0.9);\r\n\r\n        let nominator    = NDF * G * F;\r\n        let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\r\n        let specular = nominator / max(denominator, 0.001); // prevent divide by zero for NdotV=0.0 or NdotL=0.0\r\n\r\n        // kS is equal to Fresnel\r\n        let kS = F;\r\n        // for energy conservation, the diffuse and specular light can't\r\n        // be above 1.0 (unless the surface emits light); to preserve this\r\n        // relationship the diffuse component (kD) should equal 1.0 - kS.\r\n        var kD = vec3<f32>(1.0) - kS;\r\n        // multiply kD by the inverse metalness such that only non-metals\r\n        // have diffuse lighting, or a linear blend if partly metal (pure metals\r\n        // have no diffuse light).\r\n        kD *= 1.0 - metallic;\r\n\r\n        // scale light by NdotL\r\n        let NdotL = max(dot(N, L), 0.0);\r\n\r\n        // add to outgoing radiance Lo\r\n        // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again\r\n        Lo += (kD * albedo.xyz / PI + specular) * radiance * NdotL;\r\n\t}\r\n\t// ambient lighting (note that the next IBL tutorial will replace\r\n    // this ambient lighting with environment lighting).\r\n    let ambient = vec3<f32>(0.03) * albedo.xyz * ao;\r\n\r\n    color = ambient + Lo;\r\n    // HDR tonemapping\r\n    color = reinhard( color );\r\n    // gamma correct\r\n    color = pow(color, vec3<f32>(1.0/2.2));\r\n\treturn color;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>,\r\n  @location(3) camPos: vec3<f32>\r\n) -> @location(0) vec4<f32> {\r\n  var color4 = vec4(calcPBRColor3(normal, pos.xyz, camPos), 1.0);\r\n  return color4;\r\n}\r\n");

/***/ }),

/***/ "9243":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const RadialLine_1 = __importDefault(__webpack_require__("c3d6"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryVertex_1 = __importDefault(__webpack_require__("98bb"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const CommonUtils_1 = __webpack_require__("fe0b");

class SphereGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.mLongitudeNumSegments = 10;
    this.mLatitudeNumSegments = 10;
    this.mRadius = 50;
    this.inverseUV = false;
    this.uvScale = 1.0;
    /**
     *  1: positive half sphere
     *  0: entire sphere
     * -1:negative half sphere
     */

    this.mode = 0;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getNVS() {
    return this.mnvs;
  }

  getIVS() {
    return this.mivs;
  }

  initialize(radius, longitudeNumSegments, latitudeNumSegments, doubleTriFaceEnabled) {
    if (this.vtxTotal < 1) {
      if (radius < 0.0001) radius = 0.0001;
      this.bounds = new AABB_1.default();
      if (longitudeNumSegments < 2) longitudeNumSegments = 2;
      if (latitudeNumSegments < 2) latitudeNumSegments = 2;
      this.mRadius = Math.abs(radius);
      this.mLongitudeNumSegments = longitudeNumSegments;
      this.mLatitudeNumSegments = latitudeNumSegments;

      if ((this.mLatitudeNumSegments + 1) % 2 == 0) {
        this.mLatitudeNumSegments += 1;
      }

      if (this.mLongitudeNumSegments = this.mLatitudeNumSegments) {
        this.mLongitudeNumSegments += 1;
      }

      let i = 1,
          j = 0,
          trisTot = 0;
      let xRad = 0.0,
          yRad = 0.0,
          px = 0.0,
          py = 0.0;
      let vtx = new GeometryVertex_1.default(0, -this.mRadius, 0, trisTot); // 计算绕 y轴 的纬度线上的点

      let vtxVec = [];
      let vtxRows = [];
      vtxRows.push([]);
      let vtxRow = vtxRows[0];
      let centerUV = this.inverseUV ? 1.0 : 0.5;
      vtx.u = vtx.v = centerUV;
      vtx.nx = 0.0;
      vtx.ny = -1.0;
      vtx.nz = 0.0;
      let v0 = vtx.cloneVertex();

      for (j = 0; j <= this.mLongitudeNumSegments; ++j) {
        vtxRow.push(v0);
      }

      vtxVec.push(v0); // console.log("vtxRow first: ", vtxRow);

      let pr = 0.0;
      let py2 = 0.0;
      let f = 1.0 / this.mRadius;

      for (i = 1; i < this.mLatitudeNumSegments; ++i) {
        yRad = Math.PI * i / this.mLatitudeNumSegments;
        px = Math.sin(yRad);
        py = Math.cos(yRad);
        vtx.y = -this.mRadius * py;
        pr = this.mRadius * px;

        if (this.inverseUV) {
          py2 = Math.abs(yRad / Math.PI - 0.5);
        } else {
          py2 = 0.5 - Math.abs(yRad / Math.PI - 0.5);
        }

        py2 *= this.uvScale;
        vtxRows.push([]);
        let row = vtxRows[i];

        for (j = 0; j < this.mLongitudeNumSegments; ++j) {
          xRad = Math.PI * 2 * j / this.mLongitudeNumSegments;
          ++trisTot;
          px = Math.sin(xRad);
          py = Math.cos(xRad);
          vtx.x = px * pr;
          vtx.z = py * pr;
          vtx.index = trisTot; // calc uv

          vtx.u = 0.5 + px * py2;
          vtx.v = 0.5 + py * py2;
          vtx.nx = vtx.x * f;
          vtx.ny = vtx.y * f;
          vtx.nz = vtx.z * f;
          row.push(vtx.cloneVertex());
          vtxVec.push(row[j]);
        }

        row.push(row[0]);
      }

      ++trisTot;
      vtx.index = trisTot;
      vtx.x = 0;
      vtx.y = this.mRadius;
      vtx.z = 0;
      vtx.u = vtx.v = centerUV;
      vtx.nx = 0.0;
      vtx.ny = 1.0;
      vtx.nz = 0.0;
      vtxRows.push([]);
      let lastRow = vtxRows[this.mLatitudeNumSegments];
      let v1 = vtx.cloneVertex();

      for (j = 0; j <= this.mLongitudeNumSegments; ++j) {
        lastRow.push(v1);
      }

      vtxVec.push(v1); // console.log("vtxRows: ", vtxRows);

      let pvtx = null; ///////////////////////////   ///////////////////////////    ////////////////

      let pivs = [];
      let rowa = null;
      let rowb = null;
      let layerN = this.mLatitudeNumSegments;

      if (this.mode == 1) {
        let halfN = layerN / 2 + 1;

        for (i = halfN; i <= layerN; ++i) {
          rowa = vtxRows[i - 1];
          rowb = vtxRows[i];

          for (j = 1; j <= this.mLongitudeNumSegments; ++j) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j - 1].index);
            pivs.push(rowa[j - 1].index);
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          }
        }

        this.bounds.min.setXYZ(-radius, 0, -radius);
        this.bounds.max.setXYZ(radius, radius, radius);
      } else if (this.mode == -1) {
        let halfN = layerN / 2 + 1;

        for (i = 1; i < halfN; ++i) {
          rowa = vtxRows[i - 1];
          rowb = vtxRows[i];

          for (j = 1; j <= this.mLongitudeNumSegments; ++j) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j - 1].index);
            pivs.push(rowa[j - 1].index);
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          }
        }

        this.bounds.min.setXYZ(-radius, -radius, -radius);
        this.bounds.max.setXYZ(radius, 0, radius);
      } else if (this.mode == 2) {
        let halfN = layerN / 2 + 1;
        let mi = halfN - 1;
        let miRow = vtxRows[mi].slice();
        let n = miRow.length - 1;

        for (i = 0; i < n; ++i) {
          vtx = miRow[i].cloneVertex();
          ++trisTot;
          vtx.index = trisTot;
          miRow[i] = vtx;
          vtxVec.push(vtx);
        }

        miRow[miRow.length - 1] = miRow[0];
        let list0 = [];

        for (i = 0; i < halfN; ++i) {
          list0.push(vtxRows[i]);
        }

        list0[list0.length - 1] = miRow;
        let list1 = vtxRows;
        let list1_copy = [];

        for (i = halfN - 1; i <= layerN; ++i) {
          list1_copy.push(vtxRows[i]);
        }

        console.log("calc UV_U XXXXX"); ///*

        for (i = 1; i < halfN; ++i) {
          yRad = Math.PI * i / this.mLatitudeNumSegments;
          px = Math.sin(yRad);
          py = Math.cos(yRad);

          if (this.inverseUV) {
            py2 = Math.abs(yRad / Math.PI - 0.5);
          } else {
            py2 = 0.5 - Math.abs(yRad / Math.PI - 0.5);
          }

          py2 *= this.uvScale;
          const ls = list0[i];

          for (j = 0; j < this.mLongitudeNumSegments; ++j) {
            vtx = ls[j];
            xRad = Math.PI * 2 * j / this.mLongitudeNumSegments; // calc uv

            vtx.u = 0.25 + Math.sin(xRad) * py2 * 0.5;
            vtx.v = 0.5 + Math.cos(xRad) * py2;
          }
        }

        vtx = list0[0][0];
        vtx.u = 0.25;
        vtx.v = 0.5; //*/

        for (i = halfN - 1; i < layerN; ++i) {
          yRad = Math.PI * i / this.mLatitudeNumSegments;
          px = Math.sin(yRad);
          py = Math.cos(yRad);

          if (this.inverseUV) {
            py2 = Math.abs(yRad / Math.PI - 0.5);
          } else {
            py2 = 0.5 - Math.abs(yRad / Math.PI - 0.5);
          }

          py2 *= this.uvScale;
          const ls = list1[i];

          for (j = 0; j < this.mLongitudeNumSegments; ++j) {
            vtx = ls[j];
            xRad = Math.PI * 2 * j / this.mLongitudeNumSegments; // calc uv

            vtx.u = 0.75 + Math.sin(xRad) * py2 * 0.5;
            vtx.v = 0.5 + Math.cos(xRad) * py2;
          }
        }

        vtx = list1[list1.length - 1][0];
        vtx.u = 0.75;
        vtx.v = 0.5;

        for (i = 1; i < halfN; ++i) {
          rowa = list0[i - 1];
          rowb = list0[i];

          for (j = 1; j <= this.mLongitudeNumSegments; ++j) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j - 1].index);
            pivs.push(rowa[j - 1].index);
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          }
        }

        for (i = halfN; i <= layerN; ++i) {
          rowa = list1[i - 1];
          rowb = list1[i];

          for (j = 1; j <= this.mLongitudeNumSegments; ++j) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j - 1].index);
            pivs.push(rowa[j - 1].index);
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          }
        }

        this.bounds.min.setXYZ(-radius, -radius, -radius);
        this.bounds.max.setXYZ(radius, radius, radius);
      } else {
        for (i = 1; i <= layerN; ++i) {
          rowa = vtxRows[i - 1];
          rowb = vtxRows[i];

          for (j = 1; j <= this.mLongitudeNumSegments; ++j) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j - 1].index);
            pivs.push(rowa[j - 1].index);
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          }
        }

        this.bounds.min.setXYZ(-radius, -radius, -radius);
        this.bounds.max.setXYZ(radius, radius, radius);
      }

      this.bounds.updateFast();
      this.vtxTotal = vtxVec.length;

      if (doubleTriFaceEnabled) {
        this.mivs = CommonUtils_1.createIndexArrayWithSize(pivs.length * 2);
        this.mivs.set(pivs, 0);
        pivs.reverse();
        this.mivs.set(pivs, pivs.length);
      } else {
        this.mivs = CommonUtils_1.createIndexArray(pivs);
      }

      this.mvs = new Float32Array(this.vtxTotal * 3);
      i = 0;

      for (j = 0; j < this.vtxTotal; ++j) {
        pvtx = vtxVec[j];
        this.mvs[i++] = pvtx.x;
        this.mvs[i++] = pvtx.y;
        this.mvs[i++] = pvtx.z;
      }

      if (true) {
        // uv
        this.muvs = new Float32Array(this.vtxTotal * 2);
        i = 0;

        for (j = 0; j < this.vtxTotal; ++j) {
          pvtx = vtxVec[j]; //trace(tri.index0, ",", tri.index1, ",", tri.index2);

          this.muvs[i] = pvtx.u;
          this.muvs[i + 1] = pvtx.v;
          i += 2;
        }
      }

      if (true) {
        this.mnvs = new Float32Array(this.vtxTotal * 3);
        i = 0;

        for (j = 0; j < this.vtxTotal; ++j) {
          pvtx = vtxVec[j];
          this.mnvs[i] = pvtx.nx;
          this.mnvs[i + 1] = pvtx.ny;
          this.mnvs[i + 2] = pvtx.nz;
          i += 3;
        }
      }

      this.vtCount = this.mivs.length;
      this.trisNumber = this.vtCount / 3;
    }
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;

      super.__$destroy();
    }
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    return RadialLine_1.default.IntersectioNearSphere2(rlpv, rltv, Vector3_1.default.ZERO, this.mRadius, outV);
  }

}

exports.default = SphereGeometry;

/***/ }),

/***/ "9290":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<storage> param: vec4f;\r\n@group(0) @binding(4) var sampler0: sampler;\r\n@group(0) @binding(5) var texture0: texture_2d<f32>;\r\n\r\nconst lightDirec = vec3<f32>(0.3,0.6,0.9);\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) pos: vec4<f32>,\r\n  @location(1) uv: vec2<f32>,\r\n  @location(2) normal: vec3<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n  let nDotL = max(dot(normal, lightDirec), 0.0);\r\n  var color4 = textureSample(texture0, sampler0, uv) * param;\r\n  color4 = vec4(color4.xyz * (vec3<f32>(1.0 - param.w) + vec3<f32>((param.w) * nDotL) * param.xyz), color4.w);\r\n  return color4;\r\n}\r\n");

/***/ }),

/***/ "9355":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const HttpFileLoader_1 = __webpack_require__("2fc9");

const CommonUtils_1 = __webpack_require__("fe0b");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const fixScreenPlaneRGBTex_frag_wgsl_1 = __importDefault(__webpack_require__("4c75"));

class FloatTextureTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("FloatTextureTest::initialize() ...");

    let callback = () => {
      this.initScene();
      this.initAssets();
    };

    this.mRscene.initialize({
      callback
    });
  }

  initAssets() {
    let hdrBrnEnabled = true;
    let envMapUrl = "static/bytes/spe.mdf";

    if (hdrBrnEnabled) {
      envMapUrl = "static/bytes/spb.bin";
    }

    new HttpFileLoader_1.HttpFileLoader().load(envMapUrl, (buf, url) => {
      console.log("buf: ", buf);
      this.buildFloatTex(hdrBrnEnabled, buf);
    });
  }

  buildFloatTex(hdrBrnEnabled, buf) {
    if (hdrBrnEnabled) {} else {
      this.parseFloat(buf);
    }
  }

  parseFloat(buffer) {
    let begin = 0;
    let width = 128;
    let height = 128;
    let component = 3;
    let fs32 = new Float32Array(buffer);
    let subArr;
    let mipLevelCount = CommonUtils_1.calculateMipLevels(width, height);
    console.log("mipLevelCount: ", mipLevelCount); // let tex: IFloatCubeTexture = this.texture as IFloatCubeTexture;
    // tex.toRGBFormat();
    // tex.minFilter = TextureConst.LINEAR_MIPMAP_LINEAR;
    // tex.magFilter = TextureConst.LINEAR;

    for (let j = 0; j < mipLevelCount; j++) {
      for (let i = 0; i < 6; i++) {
        const size = width * height * component;
        subArr = fs32.subarray(begin, begin + size);

        if (i == 0) {
          console.log("width: ", width, ", subArr.length: ", subArr.length);
        } // tex.setDataFromBytesToFaceAt(i, subArr, width, height, j);


        begin += size;
      }

      width >>= 1;
      height >>= 1;
    }
  }

  applyRGBAFloat16Tex() {
    let rc = this.mRscene;
    let width = 256;
    let height = 256;
    let stride = 4;
    let dataFs32 = new Float32Array(width * height * stride);
    let scale = 1.0;
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * stride;
        dataFs32[k] = scale * (j / width);
        dataFs32[k + 1] = scale * (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width)));
        dataFs32[k + 2] = scale * (1.0 - i * j / (width * height));
        dataFs32[k + 3] = scale * 1.0;
      }
    }

    const tex = {
      diffuse: {
        uuid: "tex0",
        dataTexture: {
          data: dataFs32,
          width,
          height
        },
        format: "rgba16float",
        generateMipmaps: true
      }
    }; // let shaderSrc = {
    // 	vert:{code: vertWGSL, uuid: 'vert'},
    // 	frag:{code: rgbTexWGSL, uuid: 'frag'},
    // }

    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 0.6, 0.6],
      textures: [tex]
    }); // entity.color = [0.1, 0.1, 0.1, 0.1];

    rc.addEntity(entity);
  } //


  applyRGB9E5UFloatTex() {
    let rc = this.mRscene;
    let width = 8;
    let height = 8;
    let stride = 3;
    let dataFs32 = new Float32Array(width * height * stride);
    let scale = 1.0;
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * stride;
        dataFs32[k] = scale * (j / width);
        dataFs32[k + 1] = scale * (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width)));
        dataFs32[k + 2] = scale * (1.0 - i * j / (width * height));
      }
    }

    const tex = {
      diffuse: {
        uuid: "texreb9e5u",
        dataTexture: {
          data: dataFs32,
          width,
          height
        },
        format: "rgb9e5ufloat",
        generateMipmaps: true
      }
    };
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: fixScreenPlaneRGBTex_frag_wgsl_1.default,
        uuid: "frag"
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shadinguuid: 'texreb9e5uM',
      shaderSrc,
      extent: [-0.3, -0.3, 0.6, 0.6],
      textures: [tex]
    }); // entity.color = [1.0,1.0,1.0, 1.0];

    rc.addEntity(entity);
  }

  applyRGBA8Tex() {
    let rc = this.mRscene;
    let width = 256;
    let height = 256;
    let stride = 4;
    let dataU8 = new Uint8Array(width * height * stride);
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * 4;
        dataU8[k] = j / width * 255 | 0;
        dataU8[k + 1] = (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width))) * 255 | 0;
        dataU8[k + 2] = (1.0 - i * j / (width * height)) * 255 | 0;
        dataU8[k + 3] = 255;
      }
    }

    let tex = {
      diffuse: {
        uuid: "texRGBA8Tex",
        dataTexture: {
          data: dataU8,
          width,
          height
        },
        format: "rgba8unorm",
        generateMipmaps: false
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shadinguuid: "texRGBA8",
      extent: [.2, .2, 0.6, 0.6],
      textures: [tex]
    });
    rc.addEntity(entity);
  }

  initScene() {
    this.applyRGBAFloat16Tex();
    this.applyRGB9E5UFloatTex();
    this.applyRGBA8Tex();
  }

  run() {
    this.mRscene.run();
  }

}

exports.FloatTextureTest = FloatTextureTest;

/***/ }),

/***/ "943f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGTextureWrapper_1 = __webpack_require__("58c4");

exports.WGTextureDataDescriptor = WGTextureWrapper_1.WGTextureDataDescriptor;

const WGRPipelineCtxParams_1 = __webpack_require__("bf93");

exports.WGRShderSrcType = WGRPipelineCtxParams_1.WGRShderSrcType;

const IWGMaterial_1 = __webpack_require__("3850");

exports.checkMaterialRPasses = IWGMaterial_1.checkMaterialRPasses;

class WGMaterial {
  constructor(descriptor) {
    this.mUid = WGMaterial.sUid++;
    this.mREnabled = false;
    /**
     * unique shading process uuid
     */

    this.shadinguuid = "default-material";
    this.rpass = {
      rpass: {
        index: 0
      }
    };
    this.instanceCount = 1;
    this.visible = true;
    this.setDescriptor(descriptor);
  }

  get uid() {
    return this.mUid;
  }

  addTextureWithDatas(datas, shdVarNames) {
    if (datas) {
      if (shdVarNames) {
        for (let i = 0; i < datas.length; ++i) {
          this.addTextureWithData(datas[i], shdVarNames[i]);
        }
      } else {
        for (let i = 0; i < datas.length; ++i) {
          this.addTextureWithData(datas[i]);
        }
      }
    }

    return this;
  }

  addTextureWithData(data, shdVarName = "") {
    if (shdVarName === "") {
      shdVarName = "texture" + (this.textures ? this.textures.length : 0);
    }

    this.addTextureWithParam({
      texture: {
        data: data,
        shdVarName
      }
    });
  }

  addTextureWithParam(param) {
    if (this.textures) {
      this.textures.push(new WGTextureWrapper_1.WGTextureWrapper(param));
    } else {
      this.textures = [new WGTextureWrapper_1.WGTextureWrapper(param)];
    }
  }

  addTextureWithParams(params) {
    for (let i = 0; i < params.length; ++i) {
      this.addTextureWithParam(params[i]);
    }
  }

  addTexture(descriptor) {
    const td = WGTextureWrapper_1.createDataWithDescriptor(descriptor);
    this.addTextureWithData(td, descriptor.shdVarName);
    return this;
  }

  addTextures(descriptors) {
    if (descriptors) {
      for (let i = 0; i < descriptors.length; ++i) {
        this.addTexture(descriptors[i]);
      }
    }

    return this;
  }

  isREnabled() {
    if (this.mREnabled) {
      return this.mREnabled;
    }

    const texs = this.textures;

    if (texs) {
      for (let i = 0; i < texs.length; ++i) {
        const tex = texs[i];

        if (!tex.texture || !tex.texture.texture) {
          return false;
        }
      }
    }

    this.mREnabled = true;
    return this.mREnabled;
  }

  getRCtx() {
    return this.mRCtx;
  }

  setDescriptor(descriptor) {
    const d = descriptor;

    if (d) {
      if (d.shadinguuid) this.shadinguuid = d.shadinguuid;
      if (d.shaderSrc) this.shaderSrc = d.shaderSrc;
      if (d.pipelineVtxParam) this.pipelineVtxParam = d.pipelineVtxParam;
      if (d.pipelineDefParam) this.pipelineDefParam = d.pipelineDefParam;
      if (d.rpass) this.rpass = d.rpass;
      if (d.uniformAppend !== undefined) this.uniformAppend = d.uniformAppend;
      if (d.uniformValues) this.uniformValues = d.uniformValues;
      if (d.instanceCount !== undefined) this.instanceCount = d.instanceCount;
    }
  }

  initialize(pipelineCtx) {
    if (!this.mRCtx) {
      if (!pipelineCtx) {
        throw Error("pipelineCtx is undefined.");
      }

      this.mRCtx = pipelineCtx;
    }
  }

  copyfrom(src) {
    return this;
  }

  destroy() {
    if (this.mRCtx) {
      this.mRCtx = null;
    }
  }

}

WGMaterial.sUid = 0;
exports.WGMaterial = WGMaterial;

/***/ }),

/***/ "949a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const CamDragSwinger_1 = __webpack_require__("5df3");

const CamDragSlider_1 = __webpack_require__("6524");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

class MouseCamDrager {
  constructor() {
    this.m_stage3D = null;
    this.m_dragSwinger = new CamDragSwinger_1.CamDragSwinger();
    this.m_dragSlider = new CamDragSlider_1.CamDragSlider();
    this.m_swing = true;
    /**
     * the value contains 0(mouse down), 1(mouse middle), 2(mouse right)
     */

    this.buttonType = 0;
    this.bgEventEnabled = true;
  }

  initialize(stage3D, camera) {
    if (this.m_stage3D == null) {
      this.m_stage3D = stage3D;
      this.m_dragSwinger.initialize(stage3D, camera);
      this.m_dragSlider.initialize(stage3D, camera);
      const ME = MouseEvent_1.default;
      let downType = ME.MOUSE_DOWN;

      if (this.bgEventEnabled) {
        downType = ME.MOUSE_BG_DOWN;
      }

      let upType = ME.MOUSE_UP;

      if (this.buttonType == 1) {
        if (this.bgEventEnabled) {
          downType = ME.MOUSE_BG_MIDDLE_DOWN;
        } else {
          downType = ME.MOUSE_MIDDLE_DOWN;
        }

        upType = ME.MOUSE_MIDDLE_UP;
      } else if (this.buttonType == 2) {
        if (this.bgEventEnabled) {
          downType = ME.MOUSE_BG_RIGHT_DOWN;
        } else {
          downType = ME.MOUSE_RIGHT_DOWN;
        }

        upType = ME.MOUSE_RIGHT_UP;

        document.oncontextmenu = function (e) {
          e.preventDefault();
        };
      }

      stage3D.addEventListener(downType, this.mouseDownListener.bind(this), true, false);
      stage3D.addEventListener(upType, this.mouseUpListener.bind(this), true, true);
    }
  }

  setSlideSpeed(slideSpeed) {
    this.m_dragSlider.slideSpeed = slideSpeed;
  }

  enableSwing() {
    this.m_swing = true;
  }

  isEnabledSwing() {
    return this.m_swing;
  }

  enableSlide() {
    this.m_swing = false;
  }

  mouseDownListener(evt) {
    this.attach();
  }

  mouseUpListener(evt) {
    this.detach();
  }

  attach() {
    this.m_dragSwinger.attach();
    this.m_dragSlider.attach();
  }

  detach() {
    this.m_dragSwinger.detach();
    this.m_dragSlider.detach();
  }

  runWithYAxis() {
    if (this.m_swing) {
      this.m_dragSwinger.runWithYAxis();
    } else {
      this.m_dragSlider.run();
    }
  }

  runWithZAxis() {
    if (this.m_swing) {
      this.m_dragSwinger.runWithZAxis();
    } else {
      this.m_dragSlider.run();
    }
  }

}

exports.default = MouseCamDrager;

/***/ }),

/***/ "964e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> color: vec4f;\r\n\r\n@fragment\r\nfn main() -> @location(0) vec4<f32> {\r\n  var color4 = color;\r\n  return color4;\r\n}");

/***/ }),

/***/ "9711":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RSEntityFlag {
  static AddContainerFlag(flag) {
    //return flag | RSEntityFlag.CONTAINER_FLAG;
    return flag | 0x80000000;
  }

  static RemoveContainerFlag(flag) {
    //return flag & RSEntityFlag.CONTAINER_NOT_FLAG;
    return flag & -0x80000001;
  }

  static AddSpaceUid(flag, rawUid) {
    return flag & -0x100000 | rawUid;
  }

  static RemoveSpaceUid(flag) {
    //return flag & RSEntityFlag.SPACE_NOT_FLAG;
    return flag & -0x100000;
  }

  static GetSpaceUid(flag) {
    //return flag & RSEntityFlag.SPACE_FLAG;
    return flag & 0xFFFFF;
  }

  static AddRendererUid(flag, rawUid) {
    return flag & -0x7f00001 | rawUid << 20;
  }

  static RemoveRendererUid(flag) {
    //return flag | RSEntityFlag.RENDERER_UID_FLAG;
    return flag | 0x7F00000;
  }

  static GetRendererUid(flag) {
    //return (flag & RSEntityFlag.RENDERER_UID_FLAG)>>20;
    flag = (flag & 0x7F00000) >> 20;
    return flag < 127 ? flag : -1;
  }

  static TestRendererUid(flag) {
    //return (flag & RSEntityFlag.RENDERER_UID_FLAG)>>20;
    flag = (flag & 0x7F00000) >> 20;
    return flag < 127;
  }

  static AddSortEnabled(flag) {
    //return flag | RSEntityFlag.SORT_FLAG;
    return flag | 0x40000000;
  }

  static RemoveSortEnabled(flag) {
    //return flag & RSEntityFlag.SORT_NOT_FLAG;
    return flag & -0x40000001;
  }

  static TestSortEnabled(flag) {
    //return (flag & RSEntityFlag.SORT_FLAG) == RSEntityFlag.SORT_FLAG;
    return (flag & 0x40000000) == 0x40000000;
  }

  static AddRendererLoad(flag) {
    //return flag | RSEntityFlag.RENDERER_LOAD_FLAG;
    return flag | 0x30000000;
  }

  static RemoveRendererLoad(flag) {
    //return flag & RSEntityFlag.RENDERER_LOAD_NOT_FLAG;
    return flag & -0x30000001;
  }

  static TestSpaceContains(flag) {
    return (0xFFFFF & flag) > 0;
  }

  static TestSpaceEnabled(flag) {
    return (0xFFFFF & flag) < 1;
  }

  static TestSpaceEnabled2(flag) {
    // console.log("   TestSpaceEnabled2(), 0xFFFFF & flag: ", (0xFFFFF & flag));
    // console.log("                       (0x80000000 & flag) != 0x80000000: ", ((0x80000000 & flag) != 0x80000000));
    return (0xFFFFF & flag) < 1 && (0x80000000 & flag) != 0x80000000;
  }

  static TestContainerEnabled(flag) {
    //return (RSEntityFlag.RENDERER_UID_FLAG & flag) == RSEntityFlag.RENDERER_UID_FLAG && (RSEntityFlag.CONTAINER_FLAG & flag) != RSEntityFlag.CONTAINER_FLAG;
    return (0x7F00000 & flag) == 0x7F00000 && (0x80000000 & flag) != 0x80000000;
  }

  static TestRendererEnabled(flag) {
    //return (RSEntityFlag.RENDERER_ADN_LOAD_FLAG & flag) == RSEntityFlag.RENDERER_UID_FLAG && (RSEntityFlag.CONTAINER_FLAG & flag) != RSEntityFlag.CONTAINER_FLAG;
    return (0x37F00000 & flag) == 0x7F00000 && (0x80000000 & flag) != 0x80000000;
  }

}

RSEntityFlag.DEFAULT = 0x7f00000; // 第27位存放是否在container里面
// 在 container 内

RSEntityFlag.CONTAINER_FLAG = 0x80000000; // (1<<27)
// 没在 container 内

RSEntityFlag.CONTAINER_NOT_FLAG = -0x80000001; //~(0x80000000), ~(1<<27)
// 第0位到第19位总共20位存放自身在space中的 index id(1 到 1048575(0xFFFFF), 但是不会包含0xFFFFF)

RSEntityFlag.SPACE_FLAG = 0xFFFFF;
RSEntityFlag.SPACE_NOT_FLAG = -0x100000; // ~0xFFFFF;
// 第20位开始到26位为总共7位止存放在renderer中的状态数据(renderer unique id and others),
// 最多可以支持同时构建64个renderer instance

RSEntityFlag.RENDERER_UID_FLAG = 0x7F00000; // (1<<20 | 1<<21 | 1<<22 | 1<<23 | 1<<24 | 1<<25 | 1<<26);

RSEntityFlag.RENDERER_UID_NOT_FLAG = -0x7f00001; // ~0x7F00000;

RSEntityFlag.RENDERER_UID_INVALID = 127; // ~0x7F00000;
//0x40000000
// 第30位存放 是否渲染运行时排序(rendering sort enabled) 的相关信息

RSEntityFlag.SORT_FLAG = 0x40000000; // (1<<30);

RSEntityFlag.SORT_NOT_FLAG = -0x40000001; // ~0x40000000;
// 第28位开始到29位总共2位存放renderer 载入状态 的相关信息

RSEntityFlag.RENDERER_LOAD_FLAG = 0x30000000; // (1<<28 | 1<<29);

RSEntityFlag.RENDERER_LOAD_NOT_FLAG = -0x30000001; // ~0x30000000;

RSEntityFlag.RENDERER_ADN_LOAD_FLAG = 0x37F00000; // 0x7f00000 | 0x30000000;

exports.default = RSEntityFlag;

/***/ }),

/***/ "97f2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const ConeGeometry_1 = __importDefault(__webpack_require__("ebca"));

class ConeEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {};
    if (param.radius === undefined) param.radius = 100.0;
    if (param.height === undefined) param.height = 200.0;
    if (param.longitudeNumSegments === undefined) param.longitudeNumSegments = 20;
    if (param.alignYRatio === undefined) param.alignYRatio = -0.5;
    let g = new ConeGeometry_1.default();
    g.initialize(param.radius, param.height, param.longitudeNumSegments, param.alignYRatio);
    return g;
  }

}

exports.ConeEntity = ConeEntity;

/***/ }),

/***/ "9849":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PrimitiveEntity_1 = __webpack_require__("1eee");

const SphereGeometry_1 = __importDefault(__webpack_require__("9243"));

class SphereEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    super(param);
  }

  getGeometryData(param) {
    if (!param) param = {};
    if (param.radius === undefined) param.radius = 100.0;
    if (param.longitudeNumSegments === undefined) param.longitudeNumSegments = 20;
    if (param.latitudeNumSegments === undefined) param.latitudeNumSegments = 20;
    let sph = new SphereGeometry_1.default();
    sph.initialize(param.radius, param.longitudeNumSegments, param.latitudeNumSegments, false);
    return sph;
  }

}

exports.SphereEntity = SphereEntity;

/***/ }),

/***/ "98bb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class GeometryVertex {
  constructor(px = 0, py = 0, pz = 0, pindex = 0) {
    // pos
    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0; // uv

    this.u = 0.0;
    this.v = 1.0; // normal

    this.nx = 0.0;
    this.ny = 0.0;
    this.nz = 0.0;
    this.index = 0;
    this.f = 0; // pos

    this.x = px;
    this.y = py;
    this.z = pz;
    this.index = pindex;
  }

  cloneVertex() {
    let vtx = new GeometryVertex(this.x, this.y, this.z, this.index);
    vtx.nx = this.nx;
    vtx.ny = this.ny;
    vtx.nz = this.nz;
    vtx.u = this.u;
    vtx.v = this.v;
    vtx.f = this.f;
    return vtx;
  }

  copyFrom(pv) {
    this.x = pv.x;
    this.y = pv.y;
    this.z = pv.z;
    this.u = pv.u;
    this.v = pv.v;
    this.nx = pv.nx;
    this.ny = pv.ny;
    this.nz = pv.nz;
    this.index = pv.index;
    this.f = pv.f;
  }

}

exports.default = GeometryVertex;

/***/ }),

/***/ "992e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const HtmlDivUtils_1 = __webpack_require__("c58a");

class HTMLViewerLayer {
  constructor(viewer = null) {
    // protected m_rect = new AABB2D();
    this.unit = "px";
    this.m_viewer = viewer;

    if (viewer) {
      this.mStyle = viewer.style;
    }
  }

  getDiv() {
    return this.m_viewer;
  }

  getStyle() {
    return this.m_viewer.style;
  }

  setViewer(viewer) {
    this.m_viewer = viewer;

    if (viewer) {
      this.mStyle = viewer.style;
    }
  }

  setInnerHTML(html) {
    this.m_viewer.innerHTML = html;
  }

  clearInnerHTML() {
    this.m_viewer.innerHTML = "";
  }

  setDisplayMode(display = "block") {
    if (display != "") {
      this.mStyle.display = display;
    }
  }

  setPositionMode(position = "relative") {
    if (position != "") {
      this.mStyle.position = position;
    }
  }

  setTextSize(fontSize) {
    this.mStyle.fontSize = fontSize;
  }

  setTextAlign(align) {
    this.mStyle.textAlign = align;
  }

  contentAlignToCenter() {
    let s = this.mStyle;
    s.textAlign = "center";
    s.alignItems = "center";
    s.justifyContent = "center";
  }

  layoutToCenter(offsetX = 0, offsetY = 0) {
    let rect = this.m_viewer.getBoundingClientRect();
    let parent_rect = this.m_viewer.parentElement.getBoundingClientRect();
    console.log("layoutToCenter(), rect: ", rect);
    console.log("layoutToCenter(), parent_rect: ", parent_rect);
    let px = (parent_rect.width - rect.width) * 0.5 + offsetX;
    let py = (parent_rect.height - rect.height) * 0.5 + offsetY;
    this.setXY(px, py);
  }

  setXY(px, py) {
    // this.m_rect.x = px;
    // this.m_rect.y = py;
    this.mStyle.left = px + this.unit;
    this.mStyle.top = py + this.unit;
  }

  setX(px) {
    // this.m_rect.x = px;
    this.mStyle.left = px + this.unit;
  }

  setY(py) {
    // this.m_rect.y = py;
    this.mStyle.top = py + this.unit;
  }

  setSize(pw, ph) {
    if (pw > 0 && ph > 0) {
      // this.m_rect.width = pw;
      // this.m_rect.height = ph;
      this.mStyle.width = pw + this.unit;
      this.mStyle.height = ph + this.unit;
    }
  }

  setWidth(pw) {
    if (pw > 0) {
      // this.m_rect.width = pw;
      this.mStyle.width = pw + this.unit;
    }
  }

  setHeight(ph) {
    if (ph > 0) {
      // this.m_rect.height = ph;
      this.mStyle.height = ph + this.unit;
    }
  }

  uint24ToHtmlColor(uint24) {
    let color = uint24.toString(16);
    let len = 6 - color.length;

    for (let i = 0; i < len; ++i) {
      color = '0' + color;
    }

    color = '#' + color;
    return color;
  }

  setTextColor(uint24, alpha = 1.0) {
    this.mStyle.color = this.uint24ToHtmlColor(uint24);
  }

  setBackgroundColor(uint24, alpha = 1.0) {
    this.mStyle.backgroundColor = this.uint24ToHtmlColor(uint24);
  }

  setVisible(v) {
    HtmlDivUtils_1.DivTool.setVisible(this.m_viewer, v);
  }

  isVisible() {
    return HtmlDivUtils_1.DivTool.isVisible(this.m_viewer);
  }

  show() {
    this.setVisible(true);
  }

  hide() {
    this.setVisible(false);
  }

  clearDivAllEles() {
    HtmlDivUtils_1.DivTool.clearDivAllEles(this.m_viewer);
  }

  getRect() {
    return this.m_viewer.getBoundingClientRect();
  }

}

exports.HTMLViewerLayer = HTMLViewerLayer;

/***/ }),

/***/ "993b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@fragment\r\nfn main(\r\n  @location(0) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  return fragPosition;\r\n}");

/***/ }),

/***/ "9b05":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 摄像机拉近拉远的控制(主要是移动端的多点触摸)

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // import RendererDevice from "../render/RendererDevice";

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class MouseCamZoomer {
  constructor() {
    this.m_camera = null;
    this.m_touchZoomBoo = false;
    this.m_preDis = 0;
    this.m_touchZoomSpd = 2.0;
    this.m_slideSpd = 1.0;
    this.m_mouseWheelZoomSpd = 6.0;
    this.m_fowardDis = 0;
    this.m_initBoo = true;
    this.m_lookAtCtrlEnabled = true;
    this.m_flagDrag = 0;
    this.m_flagZoom = 0;
    this.m_windowsEnvFlag = true;
    this.syncLookAt = false;
    /**
     * 取值为2, 表示相机的拉近拉远
     * 取值为1, 表示相机的拖动
     */

    this.m_flagType = 2; // this.m_windowsEnvFlag = !(RendererDevice.IsMobileWeb() || RendererDevice.IsSafariWeb());

    this.m_windowsEnvFlag = true;
  }

  setMobileZoomSpeed(spd) {
    this.m_touchZoomSpd = spd;
  }

  seSlideSpeed(spd) {
    this.m_slideSpd = spd;
  }
  /**
   * set mousewheel zoom camera forward speed
   * @param spd default value is 6.0
   */


  setMouseWheelZoomSpd(spd) {
    this.m_mouseWheelZoomSpd = spd;
  }

  bindCamera(camera) {
    this.m_camera = camera;
  }

  createVec3() {
    return new Vector3_1.default();
  }

  initialize(stage3D) {
    if (this.m_initBoo) {
      this.m_initBoo = false;
      this.m_tempa = this.createVec3();
      this.m_tempb = this.createVec3();
      this.m_preva = this.createVec3();
      this.m_prevb = this.createVec3();
      this.m_va = this.createVec3();
      this.m_vb = this.createVec3();
      this.m_lookAt = this.createVec3();
      this.m_lookAtPos = this.createVec3();
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_WHEEL, this.mouseWheelListener.bind(this), true, true);
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_MULTI_MOVE, this.mouseMultiMoveListener.bind(this), true, true);
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_MULTI_UP, this.mouseMultiUpListener.bind(this), true, true);
    }
  }

  setLookAtCtrlEnabled(enabled) {
    this.m_lookAtCtrlEnabled = enabled;
  }

  mouseWheelListener(evt) {
    if (evt.wheelDeltaY > 0) {
      this.m_fowardDis += this.m_mouseWheelZoomSpd;
    } else {
      this.m_fowardDis -= this.m_mouseWheelZoomSpd;
    }
  }

  mouseMultiMoveListener(evt) {
    this.setTouchPosArray(evt.posArray);
  }

  mouseMultiUpListener(evt) {
    this.setTouchPosArray(evt.posArray);
  }

  resetState() {
    this.m_flagDrag = 0;
    this.m_flagZoom = 0;
    this.m_flagType = 0;
  }

  setTouchPosArray(posArray) {
    if (posArray != null && posArray.length > 1) {
      let dis = 0;
      this.m_va.setXYZ(posArray[0].x, posArray[0].y, 0);
      this.m_vb.setXYZ(posArray[1].x, posArray[1].y, 0);

      if (this.m_touchZoomBoo) {
        dis = Vector3_1.default.Distance(this.m_va, this.m_vb);

        if (this.m_flagType < 1) {
          this.m_tempa.copyFrom(this.m_va);
          this.m_tempb.copyFrom(this.m_vb);
          this.m_tempa.subVecsTo(this.m_va, this.m_preva);
          this.m_tempb.subVecsTo(this.m_vb, this.m_prevb);
          this.m_tempa.normalize();
          this.m_tempb.normalize();

          if (this.m_tempa.dot(this.m_tempb) > 0.9) {
            // 可能是拖动
            this.m_flagDrag++;
          } else {
            // 可能是缩放
            this.m_flagZoom++;
          } //DivLog.ShowLog("> "+this.m_flagDrag+","+this.m_flagZoom);


          if (this.m_flagDrag > 3 || this.m_flagZoom > 3) {
            this.m_flagType = this.m_flagDrag > this.m_flagZoom ? 1 : 2;
          }
        } else {
          this.m_tempa.subVecsTo(this.m_va, this.m_preva);
        }

        let dv = Math.abs(this.m_preDis - dis);

        if (dv > 0.1) {
          this.m_fowardDis = (dis - this.m_preDis) * this.m_touchZoomSpd;
          this.m_preDis = dis;
        }
      } else {
        this.m_touchZoomBoo = true;
        this.m_preDis = Vector3_1.default.Distance(this.m_va, this.m_vb);
        this.resetState();
      }
    } else {
      this.resetState();
      this.m_touchZoomBoo = false;
    }

    this.m_preva.copyFrom(this.m_va);
    this.m_prevb.copyFrom(this.m_vb);
  }

  setLookAtPosition(v) {
    if (this.syncLookAt) {
      if (v == null) {
        v = this.m_lookAt;
      }

      let disFunc = Vector3_1.default.DistanceSquared;
      let pv = this.m_camera.lookPosition;

      if (disFunc(v, this.m_lookAtPos) > 0.0001 || disFunc(pv, v) > 0.0001) {
        this.m_camera.setLookAtPosition(v);
        this.m_lookAtPos.copyFrom(v);
      }
    }
  }

  run(minDis) {
    let lookAtEnabled = this.m_lookAtCtrlEnabled;

    if (this.m_camera != null) {
      if (this.m_flagType == 2) {
        // camera foward update
        if (Math.abs(this.m_fowardDis) > 0.001) {
          let dis = Vector3_1.default.Distance(this.m_camera.position, this.m_camera.lookPosition);
          let pd = this.m_fowardDis;

          if (this.m_fowardDis > 0) {
            if (dis > minDis) {
              pd = dis - minDis;
              if (pd > this.m_fowardDis) pd = this.m_fowardDis;
            } else {
              pd = 0;
            }
          }

          if (Math.abs(pd) > 0.1) {
            this.m_camera.forward(pd);
            let v = this.m_lookAtPos;
            if (lookAtEnabled) this.m_camera.setLookPosXYZFixUp(v.x, v.y, v.z);
          }

          if (this.m_windowsEnvFlag) {
            this.m_fowardDis *= 0.95;
          } else {
            this.m_fowardDis = 0;
          }
        }
      } else if (this.m_flagType == 1) {
        // drag to slide
        this.m_camera.slideViewOffsetXY(-this.m_tempa.x * this.m_slideSpd, this.m_tempa.y * this.m_slideSpd);
      }
    }
  }

}

exports.default = MouseCamZoomer;

/***/ }),

/***/ "9b48":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTwoTextureParam_frag_wgsl_1 = __importDefault(__webpack_require__("25ba"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const WGRStorageValue_1 = __webpack_require__("e44f");

const WGRUniformValue_1 = __webpack_require__("7650");

class MixValue extends WGRUniformValue_1.WGRUniformValue {
  constructor() {
    super({
      data: new Float32Array([1, 1, 1, 1])
    });
  }

  setFactors(f0, f1, f2) {
    const factors = this.data;
    factors[0] = f0;
    factors[1] = f1;
    factors[2] = f2;
    this.upate();
  }

}

class MultiUniformTest {
  constructor() {
    this.mMixValue = new MixValue();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
    this.mTime = 0.0;
  }

  initialize() {
    console.log("MultiUniformTest::initialize() ...");
    let rsv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx rsv.isStorage(): ", rsv.isStorage());
    console.log("xxxxxx rsv.isUniform(): ", rsv.isUniform());
    let ruv = new WGRUniformValue_1.WGRUniformValue({
      data: new Float32Array(16)
    });
    console.log("xxxxxx ruv.isStorage(): ", ruv.isStorage());
    console.log("xxxxxx ruv.isUniform(): ", ruv.isUniform());
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: sampleTwoTextureParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let tds = [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg"), new WGTextureWrapper_1.WGImage2DTextureData("static/assets/default.jpg")];
    let material = this.createMaterial(shdSrc, tds, ["solid"], "back");
    this.mEntity = this.createEntity([material]);
  }

  createMaterial(shdSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode: faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    material.uniformValues = [this.mMixValue];
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials, pv) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    entity.transform.setPosition(pv ? pv : new Vector3_1.default());
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mTime += 0.02;
    this.mMixValue.setFactors(Math.abs(Math.cos(this.mTime * 0.2)), Math.cos(this.mTime) * 0.5 + 0.5, Math.sin(this.mTime + 2.0) * 0.5 + 0.5);
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.MultiUniformTest = MultiUniformTest;

/***/ }),

/***/ "9e08":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class AbsGeomBase {
  constructor() {
    // unique id
    this.id = -1;
    this.position = new Vector3_1.default();
  }

  update() {}

  updateFast() {}

}

AbsGeomBase.__tV0 = new Vector3_1.default();
AbsGeomBase.__tV1 = new Vector3_1.default();
AbsGeomBase.__tV2 = new Vector3_1.default();
exports.AbsGeomBase = AbsGeomBase;
exports.default = AbsGeomBase;

/***/ }),

/***/ "9e6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function createDiv(px, py, pw, ph) {
  let div = document.createElement("div");
  let style = div.style;
  style.width = pw + "px";
  style.height = ph + "px";
  style.display = "bolck";
  style.left = px + "px";
  style.top = py + "px";
  style.position = "absolute";
  style.display = "bolck";
  style.position = "absolute";
  return div;
}

exports.createDiv = createDiv;

/***/ }),

/***/ "9f80":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntityNormal_vert_wgsl_1 = __importDefault(__webpack_require__("395b"));

const sampleTextureNormalParam_frag_wgsl_1 = __importDefault(__webpack_require__("9290"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const TransObject_1 = __webpack_require__("4a64");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class SimpleLightTest {
  constructor() {
    this.mObjs = [];
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {
      console.log("mousedown evt call ...");
    };
  }

  initialize() {
    console.log("SimpleLightTest::initialize() ...");
    this.initEvent();
    const shdSrc = {
      vert: {
        code: defaultEntityNormal_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureNormalParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let geometry = this.createGeom(this.geomData.createCube(100), true);
    let texList = [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/white.jpg")];
    let tot = 4;
    const size = new Vector3_1.default(150, 150, 150);
    const pos = new Vector3_1.default().copyFrom(size).scaleBy(-0.5 * (tot - 1));

    for (let i = 0; i < tot; ++i) {
      for (let j = 0; j < tot; ++j) {
        for (let k = 0; k < tot; ++k) {
          let material = this.createMaterial(shdSrc, texList, new Color4_1.default().randomRGB(1.0, 0.2));
          let scale = Math.random() * 0.2 + 0.3;
          const entity = this.createEntity(geometry, [material]);
          const obj = new TransObject_1.TransObject();
          obj.entity = entity;
          obj.scale.setXYZ(scale, scale, scale);
          obj.rotationSpdv.setXYZ(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
          obj.position.setXYZ(i * size.x, j * size.y, k * size.z).addBy(pos);
          this.mObjs.push(obj);
        }
      }
    }
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texDatas, color, blendModes = ["solid"], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    if (!color) color = new Color4_1.default(1.0, 1.0, 1.0);
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let ufv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([color.r, color.g, color.b, 0.9])
    });
    material.uniformValues = [ufv];
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  createEntity(geometry, materials) {
    const rc = this.mRscene;
    const entity = new Entity3D_1.Entity3D({
      geometry,
      materials
    });
    rc.addEntity(entity);
    return entity;
  }

  run() {
    for (let i = 0; i < this.mObjs.length; ++i) {
      this.mObjs[i].run();
    }

    this.mRscene.run();
  }

}

exports.SimpleLightTest = SimpleLightTest;

/***/ }),

/***/ "9fa7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) vertColor : vec4<f32>\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) color : vec3<f32>,\r\n) -> VertexOutput {\r\n\r\n  let wpos = objMat * vec4(position.xyz, 1.0);\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * wpos;\r\n  output.vertColor = vec4f(color.xyz, 1.0);\r\n  return output;\r\n}");

/***/ }),

/***/ "a059":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

class AddEntityIntoMultiRPasses {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("AddEntityIntoMultiRPasses::initialize() ...");
    this.mRscene.initialize({
      rpassparam: {
        multisampleEnabled: true,
        depthTestEnabled: false
      }
    });
    this.initEvent();
    this.initScene();
  }

  applyNewRPass(texUUID, entities, clearColor, extent = [0.4, 0.3, 0.5, 0.5]) {
    let rc = this.mRscene;
    let rttTex = {
      diffuse: {
        uuid: texUUID,
        rttTexture: {}
      }
    };
    let colorAttachments = [{
      texture: rttTex,
      clearValue: clearColor,
      loadOp: "clear",
      storeOp: "store"
    }];
    let rPass = rc.renderer.appendRenderPass({
      separate: true,
      colorAttachments
    });

    for (let i = 0; i < entities.length; ++i) {
      rPass.addEntity(entities[i]);
    }

    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      flipY: true,
      textures: [rttTex]
    });
    entity.setColor([0.7, 0.5, 0.5]);
    entity.uuid = 'apply-rtt-entity';
    rc.addEntity(entity);
  }

  initEvent() {
    const rc = this.mRscene;
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    let entity;
    const diffuseTex = {
      diffuse: {
        url: "static/assets/default.jpg",
        flipY: true
      }
    };
    let entities = [];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 0.8, 0.8],
      textures: [diffuseTex]
    });
    entity.setColor([0.9, 0.3, 0.9]);
    entity.uuid = "pl-0";
    rc.addEntity(entity);
    entities.push(entity);
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.2, -0.2, 0.4, 0.4],
      textures: [diffuseTex]
    });
    entity.setColor([0.2, 0.9, 0.9]);
    entity.uuid = "pl-1";
    rc.addEntity(entity);
    entities.push(entity);
    this.applyNewRPass('rtt0', entities, [0.1, 0.5, 0.9, 1.0]);
    this.applyNewRPass('rtt1', entities, [0.3, 0.5, 0.1, 1.0], [-0.2, 0.3, 0.5, 0.5]);
    this.applyNewRPass('rtt2', entities, [0.3, 0.5, 0.7, 1.0], [-0.8, 0.3, 0.5, 0.5]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.AddEntityIntoMultiRPasses = AddEntityIntoMultiRPasses;

/***/ }),

/***/ "a229":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const AABBCalc_1 = __webpack_require__("79d0");

const Define_1 = __webpack_require__("af1b");

class BoxGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.mList = new Array(8);
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
    this.normalType = Define_1.WGRNormalType.FLAT;
    this.flipVerticalUV = false;
    this.uvPartsNumber = 0;
    this.minV = new Vector3_1.default();
    this.maxV = new Vector3_1.default();
    this.uScale = 1.0;
    this.vScale = 1.0;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getNVS() {
    return this.mnvs;
  }

  setPositionAt(i, position) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        let arr = this.mList[i];
        arr[0] = position.x;
        arr[1] = position.y;
        arr[2] = position.z;
      }
    }
  }

  getPositionAt(i, position) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        let arr = this.mList[i];
        position.x = arr[0];
        position.y = arr[1];
        position.z = arr[2];
      }
    }
  }

  setEdgeAt(i, lsPA, lsPB) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        let arr0 = this.mList[i];
        i++;
        if (i == 3) i = 0;else if (i == 7) i = 4;
        let arr1 = this.mList[i];
        arr0[0] = lsPA.x;
        arr0[1] = lsPA.y;
        arr0[2] = lsPA.z;
        arr1[0] = lsPB.x;
        arr1[1] = lsPB.y;
        arr1[2] = lsPB.z;
      }
    }
  }

  getEdgeAt(i, lsPA, lsPB) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        let arr0 = this.mList[i];
        i++;
        if (i == 3) i = 0;else if (i == 7) i = 4;
        let arr1 = this.mList[i];
        lsPA.x = arr0[0];
        lsPA.y = arr0[1];
        lsPA.z = arr0[2];
        lsPB.x = arr1[0];
        lsPB.y = arr1[1];
        lsPB.z = arr1[2];
      }
    }
  }

  setFaceAt(i, lsPA, lsPB, lsPC, lsPD) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        i *= 4;
        let posList = [lsPA, lsPB, lsPC, lsPD];
        let idList = BoxGeometry.sFacePosIds;
        let list = this.mList;
        let arr;
        let pos;

        for (let iMax = i + 4, j = 0; i < iMax; ++i) {
          arr = list[idList[i]];
          pos = posList[j++];
          arr[0] = pos.x;
          arr[1] = pos.y;
          arr[2] = pos.z;
        }
      }
    }
  }

  getFaceAt(i, lsPA, lsPB, lsPC, lsPD) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        i *= 4;
        let posList = [lsPA, lsPB, lsPC, lsPD];
        let idList = BoxGeometry.sFacePosIds;
        let list = this.mList;
        let arr;
        let pos;

        for (let iMax = i + 4, j = 0; i < iMax; ++i) {
          arr = list[idList[i]];
          pos = posList[j++];
          pos.x = arr[0];
          pos.y = arr[1];
          pos.z = arr[2];
        }
      }
    }
  }

  getFaceCenterAt(i, outV) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        i *= 4;
        let idList = BoxGeometry.sFacePosIds;
        let list = this.mList;
        let arr;
        outV.setXYZ(0.0, 0.0, 0.0);

        for (let iMax = i + 4; i < iMax; ++i) {
          arr = list[idList[i]];
          outV.x += arr[0];
          outV.y += arr[1];
          outV.z += arr[2];
        }

        outV.scaleBy(0.33333);
      }
    }
  }

  transformFaceAt(i, mat4) {
    if (i >= 0 && i < 8) {
      if (this.mvs != null) {
        i *= 4;
        let idList = BoxGeometry.sFacePosIds;
        let list = this.mList;

        for (let iMax = i + 4; i < iMax; ++i) {
          mat4.transformVectorsSelf(list[idList[i]], 3);
        }
      }
    }
  }

  initializeWithYFace(bottomFaceMinV, bottomFaceMaxV, topFaceMinV, topFaceMaxV) {
    let minV = bottomFaceMinV;
    let maxV = bottomFaceMaxV;
    let minY = (minV.y + maxV.y) * 0.5;
    this.mList[0] = [maxV.x, minY, maxV.z];
    this.mList[1] = [maxV.x, minY, minV.z];
    this.mList[2] = [minV.x, minY, minV.z];
    this.mList[3] = [minV.x, minY, maxV.z];
    minV = topFaceMinV;
    maxV = topFaceMaxV;
    let maxY = (minV.y + maxV.y) * 0.5;
    this.mList[4] = [maxV.x, maxY, maxV.z];
    this.mList[5] = [maxV.x, maxY, minV.z];
    this.mList[6] = [minV.x, maxY, minV.z];
    this.mList[7] = [minV.x, maxY, maxV.z];
    this.initData();
  }

  initialize(minV, maxV) {
    const min = this.minV;
    const max = this.maxV;
    min.setXYZ(0, 0, 0).setVector3(minV);
    max.setXYZ(0, 0, 0).setVector3(maxV); // this.mList[0] = [maxV.x, minV.y, maxV.z];
    // this.mList[1] = [maxV.x, minV.y, minV.z];
    // this.mList[2] = [minV.x, minV.y, minV.z];
    // this.mList[3] = [minV.x, minV.y, maxV.z];
    // this.mList[4] = [maxV.x, maxV.y, maxV.z];
    // this.mList[5] = [maxV.x, maxV.y, minV.z];
    // this.mList[6] = [minV.x, maxV.y, minV.z];
    // this.mList[7] = [minV.x, maxV.y, maxV.z];

    this.mList[0] = [max.x, min.y, max.z];
    this.mList[1] = [max.x, min.y, min.z];
    this.mList[2] = [min.x, min.y, min.z];
    this.mList[3] = [min.x, min.y, max.z];
    this.mList[4] = [max.x, max.y, max.z];
    this.mList[5] = [max.x, max.y, min.z];
    this.mList[6] = [min.x, max.y, min.z];
    this.mList[7] = [min.x, max.y, max.z];
    this.initData();
    return this;
  }

  scaleUVFaceAt(faceI, u, v, du, dv) {
    if (this.muvs != null && faceI >= 0 && faceI < 6) {
      let i = faceI * 8;
      let t = i + 8;
      let uvs = this.muvs;

      for (; i < t; i += 2) {
        uvs[i] = u + uvs[i] * du;
        uvs[i + 1] = v + uvs[i + 1] * dv;
      }
    }
  }

  reinitialize() {
    this.initData();
  }

  initData() {
    this.vtxTotal = 24;
    let i = 0;
    let k = 0;
    let baseI = 0;
    let newBuild = this.mivs == null;

    if (newBuild) {
      this.mvs = new Float32Array(72);
      this.mivs = new Uint16Array(36);
      let flags = [3, 2, 3, 3, 2, 2];

      for (i = 0; i < 6; ++i) {
        if (flags[i] == 3) {
          this.mivs[baseI] = k + 3;
          this.mivs[baseI + 1] = k + 2;
          this.mivs[baseI + 2] = k + 1;
          this.mivs[baseI + 3] = k + 3;
          this.mivs[baseI + 4] = k + 1;
          this.mivs[baseI + 5] = k;
        } else {
          this.mivs[baseI] = k + 2;
          this.mivs[baseI + 1] = k + 3;
          this.mivs[baseI + 2] = k;
          this.mivs[baseI + 3] = k + 2;
          this.mivs[baseI + 4] = k;
          this.mivs[baseI + 5] = k + 1;
        }

        baseI += 6;
        k += 4;
      }
    }

    let idList = BoxGeometry.sFacePosIds;
    let list = this.mList;
    let arr;
    let pvs = this.mvs;
    k = 0;

    for (i = 0; i < this.vtxTotal; ++i) {
      arr = list[idList[i]];
      pvs.set(arr, k);
      k += 3;
    }

    if (!this.bounds) {
      this.bounds = new AABB_1.default();
    } else {
      this.bounds.reset();
    }

    if (this.mTransMatrix != null) {
      this.mTransMatrix.transformVectorsSelf(this.mvs, this.mvs.length);
      this.bounds.addFloat32Arr(this.mvs);
    } else {
      this.bounds.addFloat32Arr(this.mvs);
    }

    this.bounds.updateFast();
    let faceTotal = 6;

    if (true) {
      if (this.muvs == null) {
        // uv
        this.muvs = new Float32Array(48);
        this.initUVData(this.vtxTotal * 2);

        if (this.uvPartsNumber == 4) {
          this.scaleUVFaceAt(0, 0.5, 0.5, 0.5, 0.5);
          this.scaleUVFaceAt(1, 0.0, 0.0, 0.5, 0.5);
          this.scaleUVFaceAt(2, 0.5, 0.0, 0.5, 0.5);
          this.scaleUVFaceAt(3, 0.0, 0.5, 0.5, 0.5);
          this.scaleUVFaceAt(4, 0.5, 0.0, 0.5, 0.5);
          this.scaleUVFaceAt(5, 0.0, 0.5, 0.5, 0.5);
        } else if (this.uvPartsNumber == 6) {
          this.scaleUVFaceAt(0, 0.0, 0.0, 0.25, 0.5);
          this.scaleUVFaceAt(1, 0.25, 0.0, 0.25, 0.5);
          this.scaleUVFaceAt(2, 0.5, 0.0, 0.25, 0.5);
          this.scaleUVFaceAt(3, 0.75, 0.0, 0.25, 0.5);
          this.scaleUVFaceAt(4, 0.0, 0.5, 0.25, 0.5);
          this.scaleUVFaceAt(5, 0.25, 0.5, 0.25, 0.5);
        }
      }
    }

    if (true) {
      this.mnvs = new Float32Array(72);
      baseI = 0;
      let nx = 0.0;
      let ny = 0.0;
      let nz = 0.0;

      if (this.normalType == Define_1.WGRNormalType.FLAT) {
        while (baseI < faceTotal) {
          nx = 0.0;
          ny = 0.0;
          nz = 0.0;

          switch (baseI) {
            case 0:
              ny = -1.0;
              break;

            case 1:
              ny = 1.0;
              break;

            case 2:
              nx = 1.0;
              break;

            case 3:
              nz = -1.0;
              break;

            case 4:
              nx = -1.0;
              break;

            case 5:
              nz = 1.0;
              break;

            default:
              break;
          }

          i = baseI * 12;
          nx *= this.normalScale;
          ny *= this.normalScale;
          nz *= this.normalScale;
          this.mnvs[i] = nx;
          this.mnvs[i + 1] = ny;
          this.mnvs[i + 2] = nz;
          this.mnvs[i + 3] = nx;
          this.mnvs[i + 4] = ny;
          this.mnvs[i + 5] = nz;
          this.mnvs[i + 6] = nx;
          this.mnvs[i + 7] = ny;
          this.mnvs[i + 8] = nz;
          this.mnvs[i + 9] = nx;
          this.mnvs[i + 10] = ny;
          this.mnvs[i + 11] = nz;
          ++baseI;
        }
      } else {
        let centV = this.bounds.center;
        let d = 0.0;

        while (baseI < this.vtxTotal) {
          i = baseI * 3;
          nx = this.mvs[i] - centV.x;
          ny = this.mvs[i + 1] - centV.y;
          nz = this.mvs[i + 2] - centV.z;
          d = Math.sqrt(nx * nx + ny * ny + nz * nz);

          if (d > MathConst_1.default.MATH_MIN_POSITIVE) {
            this.mnvs[i] = nx / d;
            this.mnvs[i + 1] = ny / d;
            this.mnvs[i + 2] = nz / d;
          }

          ++baseI;
        }
      }
    }

    this.vtCount = this.mivs.length;
    this.trisNumber = 12;
  }

  setFaceUVSAt(i, uvsLen8, offset = 0) {
    if (this.muvs != null) {
      if (offset < 1) {
        this.muvs.set(uvsLen8, i * 8);
      } else {
        i *= 8;
        if (offset < 0) offset = 0;

        for (let k = 0; k < 4; ++k) {
          this.muvs[i++] = uvsLen8[offset * 2];
          this.muvs[i++] = uvsLen8[offset * 2 + 1];
          offset++;
          offset = offset % 4;
        }
      }
    }
  }

  initUVData(baseI) {
    let uScale = this.uScale;
    let vScale = this.vScale;
    let i = 0;

    if (this.flipVerticalUV) {
      while (i < baseI) {
        this.muvs[i] = 1.0 * uScale;
        this.muvs[i + 1] = 1.0 * vScale;
        this.muvs[i + 2] = 0.0 * uScale;
        this.muvs[i + 3] = 1.0 * vScale;
        this.muvs[i + 4] = 0.0 * uScale;
        this.muvs[i + 5] = 0.0 * vScale;
        this.muvs[i + 6] = 1.0 * uScale;
        this.muvs[i + 7] = 0.0 * vScale;
        i += 8;
      }
    } else {
      while (i < baseI) {
        this.muvs[i] = 0.0 * uScale;
        this.muvs[i + 1] = 0.0 * vScale;
        this.muvs[i + 2] = 1.0 * uScale;
        this.muvs[i + 3] = 0.0 * vScale;
        this.muvs[i + 4] = 1.0 * uScale;
        this.muvs[i + 5] = 1.0 * vScale;
        this.muvs[i + 6] = 0.0 * uScale;
        this.muvs[i + 7] = 1.0 * vScale;
        i += 8;
      }
    }
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    let boo = AABBCalc_1.AABBCalc.IntersectionRL2(rltv, rlpv, this.bounds, outV);
    return boo ? 1 : -1;
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;

      super.__$destroy();
    }
  }

} // face order: -y,+y,+x,-z,-x,+z


BoxGeometry.sFacePosIds = [0, 1, 2, 3, 4, 5, 6, 7, 4, 5, 1, 0, 5, 6, 2, 1, 7, 6, 2, 3, 4, 7, 3, 0];
exports.default = BoxGeometry;

/***/ }),

/***/ "a3a5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@fragment\r\nfn main(\r\n  @location(0) fragUV: vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n  return fragPosition;\r\n}");

/***/ }),

/***/ "a3fd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const RSEntityFlag_1 = __importDefault(__webpack_require__("9711"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const Matrix4Pool_1 = __importDefault(__webpack_require__("4e74"));

class Entity3DContainer {
  constructor(boundsEnabled = true, spaceEnabled = false, renderingFlow = false) {
    this.mUid = Entity3DContainer.sUid++; // protected m_eventDispatcher: IEvtDispatcher = null;

    this.mSpaceEnabled = false;
    this.mRenderingFlow = false;
    this.mTransformStatus = 0;
    this.mRotateBoo = false; // It is a flag that need inverted mat yes or no

    this.mInvMatEnabled = false;
    this.mInvLocMatEnabled = false;
    this.mOMatEnabled = false;
    this.mPos = new Vector3_1.default();
    this.mVisible = true;
    this.mParentVisible = true;
    this.mGlobalBounds = null;
    this.mGboundsStatus = -1;
    this.__$renderer = null;
    this.m_entities = [];
    this.m_entitiesTotal = 0;
    this.m_children = [];
    this.m_childrenTotal = 0;
    /**
     * entity global bounds version list
     */

    this.m_ebvers = null;
    /**
     * child container global bounds version list
     */

    this.m_cbvers = null;
    this.m_$updateBounds = true;
    /**
     * renderer scene entity flag, be used by the renderer system
     * 第0位到第19位总共20位存放自身在space中的 index id(最小值为1, 最大值为1048575,默认值是0, 也就是最多只能展示1048575个entitys),
     * 第20位开始到26位为总共7位止存放在renderer中的状态数据(renderer unique id and others)
     * 第27位存放是否在container里面
     * 第28位开始到29位总共二位存放renderer 载入状态 的相关信息
     * 第30位位存放是否渲染运行时排序
     */

    this.__$rseFlag = RSEntityFlag_1.default.DEFAULT; // 自身所在的world的唯一id, 通过这个id可以找到对应的world

    this.__$wuid = -1;
    /**
     * render process uid
     */

    this.__$wprocuid = -1; // 自身在world中被分配的唯一id, 通过这个id就能在world中快速找到自己所在的数组位置

    this.__$weid = -1; // 记录自身是否再容器中(取值为0和1), 不允许外外面其他代码调用

    this.__$contId = 0;
    /**
     * 可见性裁剪是否开启, 如果不开启，则摄像机和遮挡剔除都不会裁剪, 取值于 SpaceCullingMask, 默认只会有摄像机裁剪
     */
    // spaceCullMask = SpaceCullingMask.CAMERA;

    /**
     * mouse interaction enabled
     */

    this.mouseEnabled = false;
    this.mRendering = true;
    this.m_rx = 0;
    this.m_ry = 0;
    this.m_rz = 0;
    this.m_sx = 1.0;
    this.m_sy = 1.0;
    this.m_sz = 1.0; // local matrix

    this.m_localMat = Matrix4Pool_1.default.GetMatrix();
    this.m_invLocalMat = null; // local to world spcae matrix

    this.m_omat = null; // word to local matrix

    this.m_invOmat = null;
    this.m_parentMat = null;

    if (boundsEnabled) {
      this.createBounds();
    }

    this.mSpaceEnabled = spaceEnabled;
    this.mRenderingFlow = renderingFlow;
  }

  __$setRenderer(renderer) {
    let i = 0;

    if (this.__$renderer) {
      if (!renderer) {
        // remove all entities from renderer with container
        for (; i < this.m_entitiesTotal; ++i) {
          this.__$renderer.removeEntity(this.m_entities[i]);
        }
      }

      this.__$renderer = renderer;
    } else {
      this.__$renderer = renderer;

      if (renderer) {
        // add all entities into renderer
        for (; i < this.m_entitiesTotal; ++i) {
          const et = this.m_entities[i];
          et.__$rseFlag = RSEntityFlag_1.default.RemoveContainerFlag(et.__$rseFlag);

          this.__$renderer.addEntity(et, this.__$wprocuid, false);

          et.__$rseFlag = RSEntityFlag_1.default.AddContainerFlag(et.__$rseFlag);
        }
      }
    }

    for (i = 0; i < this.m_childrenTotal; ++i) {
      this.m_children[i].__$wprocuid = this.__$wprocuid;

      this.m_children[i].__$setRenderer(renderer);
    }
  }

  __$setParent(parent) {
    if (parent != this && parent != this.__$parent) {
      this.m_$updateBounds = true;
      this.__$parent = parent;

      if (parent != null) {
        this.__$wprocuid = parent.__$wprocuid;
        this.mParentVisible = parent.__$getParentVisible() && parent.getVisible();

        this.__$setRenderer(parent.__$renderer);
      } else {
        this.__$setRenderer(null);
      }

      this.__$setParentMatrix(parent);
    }
  }

  isInRenderer() {
    return this.__$wprocuid >= 0;
  }

  hasParent() {
    return this.__$parent ? true : false;
  }

  getRenderer() {
    return this.__$renderer;
  }

  getParent() {
    return this.__$parent;
  }

  getTransform() {
    return null;
  }
  /**
   * @returns 是否用于空间管理系统
   */


  isSpaceEnabled() {
    return this.mSpaceEnabled;
  }

  isRendering() {
    return this.mRendering;
  }

  __$setRendering(r) {
    this.mRendering = r;
  }

  createBounds() {
    if (this.mGlobalBounds == null) {
      this.mGlobalBounds = new AABB_1.default();
      this.m_ebvers = [];
      this.m_cbvers = [];
    }
  }
  /**
   * @return 返回true表示当前entity能被用于渲染
   */


  isDrawEnabled() {
    return true;
  }

  get globalBounds() {
    return this.mGlobalBounds;
  }

  get localBounds() {
    return null;
  }

  get globalBoundsVer() {
    if (this.mGlobalBounds != null) {
      return this.mGlobalBounds.version;
    }

    return -1;
  }

  getEntities() {
    return this.m_entities;
  }

  getChildren() {
    return this.m_children;
  }

  addChild(et) {
    if (et != null) {
      if (et.getREType() < 12) {
        this.addEntity(et);
        return;
      }

      let child = et;

      if (child.__$wuid < 0 && child.__$contId < 1) {
        let i = 0;

        for (; i < this.m_childrenTotal; ++i) {
          if (this.m_children[i] == child) {
            return;
          }
        }

        if (i >= this.m_childrenTotal) {
          let flag = false;
          let parent = this;

          while (parent) {
            if (parent.isSpaceEnabled()) {
              flag = true;
            }

            parent = parent.getParent();
          }

          if (flag != child.isSpaceEnabled()) {
            throw Error("flag != child.isSpaceEnabled(), illegal operation !!!");
          }

          if (this.m_cbvers != null) {
            this.m_cbvers.push(-1);
          } // child.spaceCullMask |= this.spaceCullMask;


          child.__$contId = 1;
          child.__$wprocuid = this.__$wprocuid;

          child.__$setParent(this);

          this.m_children.push(child);
          this.m_childrenTotal++;
        }
      }
    }
  }

  removeChild(et) {
    if (et != null) {
      if (et.getREType() < 12) {
        this.removeEntity(et);
        return;
      }

      let child = et;

      if (child.getParent() == this) {
        for (let i = 0; i < this.m_childrenTotal; ++i) {
          if (this.m_children[i] == child) {
            child.__$contId = 0;
            child.__$wprocuid = -1;

            child.__$setParent(null);

            this.m_children.splice(i, 1);

            if (this.m_cbvers != null) {
              this.m_cbvers.slice(i, 1);
            }

            --this.m_childrenTotal;
            break;
          }
        }
      }
    }
  }

  removeChildByUid(uid) {
    if (uid > -1) {
      for (let i = 0; i < this.m_childrenTotal; ++i) {
        if (this.m_children[i].uid == uid) {
          this.m_children[i].__$contId = 0;
          this.m_children.splice(i, 1);

          if (this.m_cbvers != null) {
            this.m_cbvers.slice(i, 1);
          }

          --this.m_childrenTotal;
          break;
        }
      }
    }
  }

  getChildAt(i) {
    if (i >= 0 && i < this.m_childrenTotal) {
      return this.m_children[i];
    }

    return null;
  }

  getChildByUid(uid) {
    if (uid > -1) {
      for (let i = 0; i < this.m_entitiesTotal; ++i) {
        if (this.m_entities[i].uid == uid) {
          return this.m_entities[i];
        }
      }
    }

    return null;
  }

  getChildrenTotal() {
    return this.m_childrenTotal;
  }

  addEntity(et) {
    if (et != null) {
      if (et.getREType() >= 12) {
        this.addChild(et);
        return;
      }

      let entity = et; // if (entity.getMesh() == null) {
      // 	throw Error("Error: entity.getMesh() == null.");
      // }

      if (entity.__$testContainerEnabled()) {
        let i = 0;

        for (; i < this.m_entitiesTotal; ++i) {
          if (this.m_entities[i] == entity) {
            return;
          }
        }

        if (i >= this.m_entitiesTotal) {
          this.m_entities.push(entity);
          this.m_entitiesTotal++;

          if (this.m_ebvers != null) {
            this.m_ebvers.push(-1);
          }

          entity.getTransform().setParentMatrix(this.getMatrix()); // entity.spaceCullMask |= this.spaceCullMask;

          entity.__$setParent(this);

          if (this.__$renderer) {
            entity.__$rseFlag = RSEntityFlag_1.default.RemoveContainerFlag(entity.__$rseFlag);

            this.__$renderer.addEntity(this.m_entities[i], this.__$wprocuid, false);
          }

          entity.__$rseFlag = RSEntityFlag_1.default.AddContainerFlag(entity.__$rseFlag);
          entity.update();
        }
      }
    }
  }

  removeEntity(et) {
    if (et != null) {
      if (et.getREType() >= 12) {
        this.removeChild(et);
        return;
      }

      let entity = et;

      if (entity.__$getParent() == this) {
        for (let i = 0; i < this.m_entitiesTotal; ++i) {
          if (this.m_entities[i] == entity) {
            entity.__$rseFlag = RSEntityFlag_1.default.RemoveContainerFlag(entity.__$rseFlag);

            this.m_entities[i].__$setParent(null);

            this.m_entities.splice(i, 1);

            if (this.m_ebvers != null) {
              this.m_ebvers.slice(i, 1);
            }

            --this.m_entitiesTotal;

            if (this.__$renderer != null) {
              this.__$renderer.removeEntity(entity);
            }

            break;
          }
        }
      }
    }
  }

  removeEntityByUid(uid) {
    if (uid > -1) {
      for (let i = 0; i < this.m_entitiesTotal; ++i) {
        if (this.m_entities[i].uid == uid) {
          // this.m_entities[i].__$rseFlag = REF.RemoveContainerFlag(this.m_entities[i].__$rseFlag);
          this.m_entities[i].__$setParent(null);

          if (this.__$renderer != null) {
            this.__$renderer.removeEntity(this.m_entities[i]);
          }

          this.m_entities.splice(i, 1);

          if (this.m_ebvers != null) {
            this.m_ebvers.slice(i, 1);
          }

          --this.m_entitiesTotal;
          break;
        }
      }
    }
  }

  getEntityAt(i) {
    if (i >= 0 && i < this.m_entitiesTotal) {
      return this.m_entities[i];
    }

    return null;
  }

  getAllEntities() {
    let entities = null;

    if (this.m_entities != null) {
      entities = this.m_entities.slice(0);
    }

    for (let i = 0; i < this.m_children.length; ++i) {
      let list = this.m_children[i].getAllEntities();

      if (list != null) {
        entities = entities.concat(list);
      }
    }

    return entities;
  }

  getEntityByUid(uid) {
    if (uid > -1) {
      for (let i = 0; i < this.m_entitiesTotal; ++i) {
        if (this.m_entities[i].uid == uid) {
          return this.m_entities[i];
        }
      }
    }

    return null;
  }

  getEntitiesTotal() {
    return this.m_entitiesTotal;
  } // sphereIntersect(centerV: Vector3, radius: number): boolean {
  // 	return false;
  // }


  __$getParentVisible() {
    return this.mParentVisible;
  }

  __$updateVisible() {
    if (this.__$parent != null) {
      this.mParentVisible = this.__$parent.__$getParentVisible() && this.__$parent.getVisible();
    }

    let i = 0; //console.log("this.mVisible: "+this.mVisible+", this.mParentVisible: "+this.mParentVisible);

    let boo = this.mVisible && this.mParentVisible; // for (; i < this.m_entitiesTotal; ++i) {
    // 	this.m_entities[i].__$setDrawEnabled(boo);
    // }

    for (i = 0; i < this.m_childrenTotal; ++i) {
      this.m_children[i].__$updateVisible();
    }
  }

  setVisible(boo) {
    this.mVisible = boo;

    this.__$updateVisible();

    return this;
  }

  getVisible() {
    return this.mVisible;
  }

  isVisible() {
    return this.mVisible;
  }

  set visible(v) {
    this.mVisible = v;
  }

  get visible() {
    return this.mVisible;
  }

  getREType() {
    return this.mRenderingFlow ? 20 : 12;
  }

  isContainer() {
    return true;
  }
  /**
   * @returns 自身是否未必任何渲染器相关的系统使用
   */


  isFree() {
    return this.__$rseFlag == RSEntityFlag_1.default.DEFAULT;
  }

  get uid() {
    return this.mUid;
  }

  getX() {
    return this.mPos.x;
  }

  getY() {
    return this.mPos.y;
  }

  getZ() {
    return this.mPos.z;
  }

  setX(p) {
    this.mPos.x = p;
    this.mTransformStatus |= 1;
  }

  setY(p) {
    this.mPos.y = p;
    this.mTransformStatus |= 1;
  }

  setZ(p) {
    this.mPos.z = p;
    this.mTransformStatus |= 1;
  }

  setXYZ(px, py, pz) {
    this.mPos.x = px;
    this.mPos.y = py;
    this.mPos.z = pz;
    this.mTransformStatus |= 1;
    return this;
  }

  offsetPosition(pv) {
    this.mPos.x += pv.x;
    this.mPos.y += pv.y;
    this.mPos.z += pv.z;
    this.mTransformStatus |= 1;
  }

  setPosition(pv) {
    this.mPos.x = pv.x;
    this.mPos.y = pv.y;
    this.mPos.z = pv.z;
    this.mTransformStatus |= 1;
    return this;
  }

  getPosition(pv) {
    if (!pv) pv = new Vector3_1.default();
    pv.copyFrom(this.mPos);
    return pv;
  }

  getRotationX() {
    return this.m_rx;
  }

  getRotationY() {
    return this.m_ry;
  }

  getRotationZ() {
    return this.m_rz;
  }

  setRotationX(degrees) {
    this.m_rx = degrees;
    this.mTransformStatus |= 2;
    this.mRotateBoo = true;
  }

  setRotationY(degrees) {
    this.m_ry = degrees;
    this.mTransformStatus |= 2;
    this.mRotateBoo = true;
  }

  setRotationZ(degrees) {
    this.m_rz = degrees;
    this.mTransformStatus |= 2;
    this.mRotateBoo = true;
  }

  getRotation(rv) {
    if (!rv) rv = new Vector3_1.default();
    rv.setXYZ(this.m_rx, this.m_ry, this.m_rz);
    return rv;
  }

  setRotation(r) {
    this.m_rx = r.x;
    this.mTransformStatus |= 2;
    this.mRotateBoo = true;
    this.m_ry = r.y;
    this.m_rz = r.z;
    return this;
  }

  setRotationXYZ(rx, ry, rz) {
    this.m_rx = rx;
    this.m_ry = ry;
    this.m_rz = rz;
    this.mTransformStatus |= 2;
    this.mRotateBoo = true;
    return this;
  }

  getScaleX() {
    return this.m_sx;
  }

  getScaleY() {
    return this.m_sy;
  }

  getScaleZ() {
    return this.m_sz;
  }

  setScaleX(p) {
    this.m_sx = p;
    this.mTransformStatus |= 2;
  }

  setScaleY(p) {
    this.m_sy = p;
    this.mTransformStatus |= 2;
  }

  setScaleZ(p) {
    this.m_sz = p;
    this.mTransformStatus |= 2;
  }

  setScaleXYZ(sx, sy, sz) {
    this.m_sx = sx;
    this.m_sy = sy;
    this.m_sz = sz;
    this.mTransformStatus |= 2;
    return this;
  }

  getScale(sv) {
    if (!sv) sv = new Vector3_1.default();
    sv.setXYZ(this.m_sx, this.m_sy, this.m_sz);
    return sv;
  }

  setScale(sv) {
    this.setScaleXYZ(sv.x, sv.y, sv.z);
  }

  setScaleXY(sx, sy) {
    this.setScaleXYZ(sx, sy, this.m_sz);
  }

  setScaleAll(s) {
    this.setScaleXYZ(s, s, s);
  }

  localToParent(pv) {
    this.m_localMat.transformVectorSelf(pv);
  }

  parentToLocal(pv) {
    if (this.m_invLocalMat != null) {
      if (this.mInvLocMatEnabled) {
        this.mInvLocMatEnabled = false;
        this.m_invLocalMat.copyFrom(this.m_localMat);
      }
    } else {
      this.m_localMat = Matrix4Pool_1.default.GetMatrix();
      this.mInvLocMatEnabled = false;
    }

    this.m_invLocalMat.transformVectorSelf(pv);
  }

  localToGlobal(pv) {
    this.getMatrix().transformVectorSelf(pv);
    return this;
  }

  globalToLocal(pv) {
    this.getInvMatrix().transformVectorSelf(pv);
    return this;
  }

  getInvMatrix() {
    if (this.m_invOmat) {
      if (this.mInvMatEnabled) {
        this.m_invOmat.copyFrom(this.getMatrix());
        this.m_invOmat.invert();
        this.mInvMatEnabled = false;
      }
    } else {
      this.m_invOmat = Matrix4Pool_1.default.GetMatrix();
      this.m_invOmat.copyFrom(this.getMatrix());
      this.m_invOmat.invert();
    }

    this.mInvMatEnabled = false;
    return this.m_invOmat;
  }

  getLocalMatrix() {
    return this.m_localMat;
  } // local to world matrix


  getMatrix() {
    if (this.m_parentMat != null) {
      if (this.mOMatEnabled) {
        this.m_omat.copyFrom(this.m_localMat);
        this.m_omat.append(this.m_parentMat);
        this.mOMatEnabled = false;
      }

      return this.m_omat;
    } else {
      this.mOMatEnabled = false;
      return this.m_localMat;
    }
  }

  __$setParentMatrix(parent) {
    this.m_parentMat = parent.getMatrix();

    if (this.m_parentMat != null) {
      if (this.m_omat == null) {
        this.m_omat = Matrix4Pool_1.default.GetMatrix();
      }
    }

    this.mTransformStatus |= 2; //this.update();

    let i = 0;

    for (; i < this.m_childrenTotal; ++i) {
      this.m_children[i].__$setParentMatrix(this);
    }
  }

  __$updateBoundsDo() {
    let i = 0;

    if (this.m_$updateBounds) {
      this.m_$updateBounds = false;

      if (this.mGlobalBounds) {
        this.mGlobalBounds.reset();
        let bounds = null;

        for (; i < this.m_entitiesTotal; ++i) {
          bounds = this.m_entities[i].globalBounds;

          if (bounds != null) {
            this.mGlobalBounds.union(bounds);
          }

          this.m_ebvers[i] != this.m_entities[i].globalBoundsVer;
        }

        for (i = 0; i < this.m_childrenTotal; ++i) {
          this.m_children[i].__$updateBoundsDo();

          bounds = this.m_children[i].globalBounds;

          if (bounds != null) {
            this.mGlobalBounds.union(bounds);
          }

          this.m_cbvers[i] != this.m_children[i].globalBoundsVer;
        }

        this.mGlobalBounds.update();
      }
    } else {
      for (i = 0; i < this.m_childrenTotal; ++i) {
        this.m_children[i].__$updateBoundsDo();
      }
    }
  }

  __$updateBounds() {
    this.m_$updateBounds = true;
  }

  updateBounds() {
    const gb = this.mGlobalBounds;

    if (gb && this.mGboundsStatus > 0) {
      let i = 0;

      if (this.mGboundsStatus < 2) {
        // 表示父级和子集的global bounds都要发生变化
        for (; i < this.m_childrenTotal; ++i) {
          this.m_children[i].updateBounds();
        }
      }

      gb.reset();
      i = 0;
      let bounds = null;

      for (; i < this.m_entitiesTotal; ++i) {
        bounds = this.m_entities[i].globalBounds;

        if (bounds != null) {
          gb.union(bounds);
        }

        this.m_ebvers[i] = this.m_entities[i].globalBoundsVer;
      }

      for (i = 0; i < this.m_childrenTotal; ++i) {
        bounds = this.m_children[i].globalBounds;

        if (bounds != null) {
          gb.union(bounds);
        }

        this.m_cbvers[i] = this.m_children[i].globalBoundsVer;
      }

      gb.update();

      if (this.__$parent != null) {
        // 只需要父级执行bounds尺寸范围的调节
        let parent = this.__$parent;

        while (parent != null) {
          parent.__$updateBounds();

          parent = parent.getParent();
        }
      }

      this.mGboundsStatus = -1;
    }
  }

  update() {
    const lmt = this.m_localMat;

    if (lmt) {
      if (this.mTransformStatus > 0) {
        lmt.identity();

        if (this.mRotateBoo) {
          lmt.setScaleXYZ(this.m_sx, this.m_sy, this.m_sz);
          lmt.setRotationEulerAngle(this.m_rx * MathConst_1.default.MATH_PI_OVER_180, this.m_ry * MathConst_1.default.MATH_PI_OVER_180, this.m_rz * MathConst_1.default.MATH_PI_OVER_180);
          lmt.setTranslation(this.mPos);
        } else {
          lmt.setScaleXYZ(this.m_sx, this.m_sy, this.m_sz);
          lmt.setTranslation(this.mPos);
        }

        this.mInvMatEnabled = true;
        this.mOMatEnabled = true;
        this.mInvLocMatEnabled = true; // 把平移与旋转缩放分开，是不是能增加效能?

        this.mTransformStatus = 0; //console.log("Entity3DContainer::update(), this: "+this);
        //console.log("Entity3DContainer::update(), this.getMatrix(): "+this.getMatrix().toString());
        //console.log("this.m_entitiesTotal: "+this.m_entitiesTotal+", this: "+this);

        let i = 0;

        for (; i < this.m_entitiesTotal; ++i) {
          //console.log("this.m_entities["+i+"].getTransform().");
          this.m_entities[i].getTransform().setParentMatrix(this.getMatrix()); //if(this.m_entities[i].__$wuid > -1)this.m_entities[i].update();

          this.m_entities[i].update();
        } // 重构自己的AABB
        // 通知子集自己的 transform信息变了


        for (i = 0; i < this.m_childrenTotal; ++i) {
          this.m_children[i].__$setParentMatrix(this);

          this.m_children[i].update();
        } // 依次通知父级一些信息, 例如aabb需要重新计算, 注意，这里可能因为上面的几步操作子级和父级相互循环调用，出现堆栈溢出
        // 容器本身不需要localBounds
        // bounds变化的诱因: a.自身的transform发生变化(可能这个变化来自于父级的transform变化);b.包含的entity发生了transform变换或者mesh数据变换;
        // c.子类出现了a或者b的情况
        // mGboundsStatus 为1, 表示容器自身发生了tansform变化因此自身的子集需要做global bounds的变化, 而父级的bounds需要做对应的重新计算而不要影响到子集


        this.mGboundsStatus = 1;
      } else {
        // 这样的话会导致这里每帧都会被执行
        this.mGboundsStatus = -1;
        let i = 0;

        if (this.m_entitiesTotal > 0) {
          for (; i < this.m_entitiesTotal; ++i) {
            this.m_entities[i].update();

            if (this.m_ebvers[i] != this.m_entities[i].globalBoundsVer) {
              this.mGboundsStatus = 2;
            }
          }
        } // 如果 mGboundsStatus 为2, 则表示自身的 bounds 因为自身的 entity 的bounds变化,父级的bounds需要做对应的重新计算而不要影响到子集


        if (this.m_childrenTotal > 0) {
          for (i = 0; i < this.m_childrenTotal; ++i) {
            this.m_children[i].update();

            if (this.m_cbvers[i] != this.m_children[i].globalBoundsVer) {
              this.mGboundsStatus = 2; //break;
            }
          }
        } // 如果 mGboundsStatus 为2, 则表示子容器的 bounds 发生了变化, 父级的bounds需要做对应的重新计算而不要影响到子集

      }

      this.updateBounds();

      this.__$updateBoundsDo();
    }

    return this;
  } //// local to world matrix, 使用的时候注意数据安全->防止多个显示对象拥有而出现多次修改的问题,因此此函数尽量不要用


  destroy() {
    // 当自身被完全移出RenderWorld之后才能执行自身的destroy
    if (this.__$wuid < 0 && this.isFree()) {
      // if (this.m_eventDispatcher != null) {
      // 	this.m_eventDispatcher.destroy();
      // 	this.m_eventDispatcher = null;
      // }
      if (this.m_omat != null && this.m_omat != this.m_localMat) Matrix4Pool_1.default.RetrieveMatrix(this.m_omat);
      if (this.m_invOmat != null) Matrix4Pool_1.default.RetrieveMatrix(this.m_invOmat);
      if (this.m_localMat != null) Matrix4Pool_1.default.RetrieveMatrix(this.m_localMat);
      if (this.m_invLocalMat != null) Matrix4Pool_1.default.RetrieveMatrix(this.m_invLocalMat);
      this.m_localMat = null;
      this.m_invLocalMat = null;
      this.m_invOmat = null;
      this.m_parentMat = null;
      this.m_omat = null;
    }
  }

}

Entity3DContainer.sUid = 0;
exports.Entity3DContainer = Entity3DContainer;

/***/ }),

/***/ "a5b0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RViewElement {
  constructor() {
    this.m_canvas = null;
    this.m_div = null;
    this.m_divW = -1;
    this.m_divH = -1;
    this.resized = true;
  }

  setDiv(div) {
    this.m_div = div;
  }
  /**
   * @returns for example: #350b7e
   */


  getCSSHEXRGB(r, g, b) {
    let str = "#";
    let t = Math.floor(r * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    t = Math.floor(g * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    t = Math.floor(b * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    return str;
  }

  createViewEle(pdocument, autoResize, pw, ph, autoAttachingHtmlDoc, offscreenCanvas) {
    if (this.m_div == null) {
      this.m_div = document.getElementById("voxEngineDiv");
    }

    if (this.m_div == null) {
      this.m_div = pdocument.createElement("div");

      if (autoAttachingHtmlDoc) {
        document.body.appendChild(this.m_div);
      }
    }

    const style = this.m_div.style;
    style.display = "bolck";
    style.position = "absolute";

    if (style.left == "") {
      style.left = "0px";
      style.top = "0px";
    }

    if (autoResize) {
      style.width = "100%";
      style.height = "100%";
    } else {
      this.m_div.style.width = pw + "px";
      this.m_div.style.height = ph + "px";
    }

    if (this.m_canvas == null) {
      this.m_canvas = document.createElement("canvas");
      this.m_div.appendChild(this.m_canvas);

      if (offscreenCanvas) {
        this.m_canvas.width = pw;
        this.m_canvas.height = ph;
      } else {
        this.m_canvas.width = 800;
        this.m_canvas.height = 600;
      }

      this.m_canvas.style.display = "bolck";
      this.m_canvas.style.left = "0px";
      this.m_canvas.style.top = "0px";
      this.m_canvas.style.position = "absolute";
    }
  }

  setDivStyleLeftAndTop(px, py) {
    this.m_div.style.left = px + "px";
    this.m_div.style.top = py + "px";
  }

  setDivStyleSize(pw, ph) {
    if (this.m_divW != pw || this.m_divH != ph) {
      this.m_div.style.width = pw + "px";
      this.m_div.style.height = ph + "px";
      this.resized = true;
    }
  }

  getDiv() {
    return this.m_div;
  }

  getCanvas() {
    return this.m_canvas;
  }

  setCanvas(canvas) {
    if (canvas && this.m_canvas != canvas) {
      if (this.m_canvas) {
        this.m_div.removeChild(this.m_canvas);
      }

      this.m_canvas = canvas;
      this.m_div.appendChild(this.m_canvas);
    }
  }

}

exports.default = RViewElement;

/***/ }),

/***/ "a6bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const AxisEntity_1 = __webpack_require__("603e");

const BoundsFrameEntity_1 = __webpack_require__("1ee1");

const SphereEntity_1 = __webpack_require__("9849");

const Camera_1 = __importDefault(__webpack_require__("68f4"));

const BoxEntity_1 = __webpack_require__("5009");

const OBB_1 = __importDefault(__webpack_require__("c7cf"));

const RectLineGridEntity_1 = __webpack_require__("6d7a");

const TorusEntity_1 = __webpack_require__("5118");

const Line3DEntity_1 = __webpack_require__("648f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class LineObjectTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("LineObjectTest::initialize() ...");

    document.oncontextmenu = function (e) {
      e.preventDefault();
    };

    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  testOBB() {
    const rsc = this.mRscene;
    let box = new BoxEntity_1.BoxEntity();
    box.setColor([0.8, 0.2, 0.6]);
    box.transform.setRotationXYZ(70, 150, 0);
    box.transform.setXYZ(100, 100, 500);
    rsc.addEntity(box);
    let obb = new OBB_1.default();
    obb.fromAABB(box.localBounds, box.transform.getMatrix());
    let boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      obb,
      obbFrameScale: 1.01
    });
    boxFrame.setColor([0.1, 0.8, 0.7]);
    rsc.addEntity(boxFrame);
  }

  testFrustumFrame() {
    const cam = new Camera_1.default({
      eye: new Vector3_1.default(500, 500, -300),
      near: 50,
      far: 200
    });
    const rsc = this.mRscene;
    let frameColors = [[1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0]];
    let boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      vertices8: cam.frustum.vertices,
      frameColors
    });
    rsc.addEntity(boxFrame);
  }

  createCurve() {
    const rsc = this.mRscene;
    let total = 100;
    let linePositions = new Array(total);
    let lineColors = new Array(total);

    for (let i = 0; i < total; ++i) {
      const factor = Math.sin(20.0 * i / total);
      linePositions[i] = [350, factor * 100 + 100, -300 + i * 10.0];
      lineColors[i] = [factor * 0.5 + 0.5, 1.0 - (factor * 0.5 + 0.5), 1.0];
    }

    let line = new Line3DEntity_1.Line3DEntity({
      linePositions,
      lineColors
    });
    rsc.addEntity(line);
    let circleLine = Line3DEntity_1.createLineCircleXOZ(100);
    circleLine.transform.setY(100.0);
    circleLine.color = [0.1, 0.5, 1.0];
    rsc.addEntity(circleLine);
  }

  initScene() {
    const rsc = this.mRscene;
    let color = new Color4_1.default().toBlack().setColor([1.0]);
    let sph = new SphereEntity_1.SphereEntity();
    sph.transform.setXYZ(-200, 200, -300);
    rsc.addEntity(sph);
    sph.color = color;
    this.createCurve();
    let gridPlane = new RectLineGridEntity_1.RectLineGridEntity();
    gridPlane.color = [0.2, 0.3, 0.1];
    rsc.addEntity(gridPlane);
    let axis = new AxisEntity_1.AxisEntity({
      axisLength: 300
    });
    axis.transform.setY(1.5);
    rsc.addEntity(axis);
    this.testOBB();
    this.testFrustumFrame();
    let boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      bounds: sph.globalBounds
    });
    rsc.addEntity(boxFrame);
    let tor = new TorusEntity_1.TorusEntity();
    tor.color = [0.1, 0.8, 0.3];
    tor.transform.setXYZ(-300, 200, 300);
    tor.transform.setRotationXYZ(60, 130, 70);
    rsc.addEntity(tor);
    boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      bounds: tor.globalBounds
    });
    rsc.addEntity(boxFrame);
    let obb = new OBB_1.default();
    obb.fromAABB(tor.localBounds, tor.transform.getMatrix());
    boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      obb,
      obbFrameScale: 1.01
    });
    boxFrame.color = [0.6, 0.8, 0.3];
    rsc.addEntity(boxFrame);
    boxFrame = new BoundsFrameEntity_1.BoundsFrameEntity({
      minPos: [200, 200, 400],
      maxPos: [300, 300, 450]
    });
    boxFrame.color = [1.0, 0.2, 0.6];
    rsc.addEntity(boxFrame);
  }

  run() {
    this.mRscene.run();
  }

}

exports.LineObjectTest = LineObjectTest;

/***/ }),

/***/ "a6ef":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function getCookieByName(cname) {
  let ckInfo = document.cookie + "";
  let index0 = ckInfo.indexOf(cname + "=");

  if (index0 >= 0) {
    let index1 = ckInfo.indexOf(";", index0 + 1);

    if (index1 < 0) {
      index1 = ckInfo.length;
    }

    let kvalue = ckInfo.slice(index0, index1);
    kvalue = kvalue.split("=")[1];
    return kvalue;
  }

  return "";
}

exports.getCookieByName = getCookieByName;

function setCookieByName(cname, value) {
  let pvalue = cname + "=" + value + ";";
  console.log('setCookieByName(), pvalue: ', pvalue);
  document.cookie = pvalue;
}

exports.setCookieByName = setCookieByName;

class UnitsTestMana {
  constructor(demoNames) {
    this.mKeyName = 'unit_test-index';
    this.mUnitIndex = -1;
    this.mdDemoNames = demoNames;
  }

  downIndex() {
    this.mUnitIndex--;

    if (this.mUnitIndex < 0) {
      this.mUnitIndex += this.mdDemoNames.length;
    }

    this.setIndex();
  }

  upIndex() {
    this.mUnitIndex++;

    if (this.mUnitIndex >= this.mdDemoNames.length) {
      this.mUnitIndex -= this.mdDemoNames.length;
    }

    this.setIndex();
  }

  gotoIndex(i) {
    this.mUnitIndex = i;
    this.setIndex();
  }

  getIndex() {
    if (this.mUnitIndex >= 0) {
      return this.mUnitIndex;
    }

    let sv = getCookieByName(this.mKeyName);
    let index = 0;

    if (sv.length > 0) {
      index = parseInt(sv);
    }

    this.mUnitIndex = index;
    return this.mUnitIndex;
  }

  setIndex() {
    setCookieByName(this.mKeyName, this.mUnitIndex + '');
  }

}

exports.UnitsTestMana = UnitsTestMana;

/***/ }),

/***/ "a7a5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const WGGeometry_1 = __webpack_require__("746a");

const PrimitiveEntity_1 = __webpack_require__("1eee");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const utils_1 = __webpack_require__("71f1");

class ModelLoadTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mTeamLoader = utils_1.modelLoader;

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("ModelLoadTest::initialize() ...");
    this.initEvent();
    this.initModels();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createGeometry(gd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: gd.vertices
    }).addAttribute({
      uv: gd.uvsList[0]
    }).setIndices(gd.indices);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: gd.normals
      });
    }

    return geometry;
  }

  initModels() {
    let url0 = "static/assets/fbx/mat_ball.fbx";
    let loader = this.mTeamLoader;
    loader.load([url0], (models, transforms) => {
      console.log("loaded models: ", models);

      for (let i = 0; i < models.length; ++i) {
        this.createEntity(models[i]);
      }
    });
  }

  createEntity(model) {
    const rc = this.mRscene;
    const geometry = this.createGeometry(model, true);
    let entity = new PrimitiveEntity_1.PrimitiveEntity({
      geometry
    }).setAlbedo(new Color4_1.default().randomRGB(1.5, 0.1)).setARM([1.1, Math.random() * 0.95 + 0.05, Math.random() * 0.9 + 0.1]);
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.ModelLoadTest = ModelLoadTest;

/***/ }),

/***/ "a7ea":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>\r\n) -> VertexOutput {\r\n\r\n  let wpos = objMat * vec4(position.xyz, 1.0);\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * wpos;\r\n  return output;\r\n}");

/***/ }),

/***/ "ab24":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

class DataTextureTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
  }

  initialize() {
    console.log("DataTextureTest::initialize() ...");
    this.initScene();
  }

  applyRGBAFloat16Tex() {
    let rc = this.mRscene;
    let width = 256;
    let height = 256;
    let stride = 4;
    let dataFs32 = new Float32Array(width * height * stride);
    let scale = 10.0;
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * stride;
        dataFs32[k] = scale * (j / width);
        dataFs32[k + 1] = scale * (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width)));
        dataFs32[k + 2] = scale * (1.0 - i * j / (width * height));
        dataFs32[k + 3] = scale * 1.0;
      }
    }

    const tex = {
      diffuse: {
        uuid: "tex0",
        dataTexture: {
          data: dataFs32,
          width,
          height
        },
        format: "rgba16float",
        generateMipmaps: true
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 0.8, 0.8],
      textures: [tex]
    });
    entity.color = [0.1, 0.1, 0.1, 0.1];
    rc.addEntity(entity);
  }

  applyRGBA8Tex() {
    let rc = this.mRscene;
    let width = 256;
    let height = 256;
    let stride = 4;
    let dataU8 = new Uint8Array(width * height * stride);
    let k = 0;

    for (let i = 0; i < height; ++i) {
      for (let j = 0; j < width; ++j) {
        k = (width * i + j) * 4;
        dataU8[k] = j / width * 255 | 0;
        dataU8[k + 1] = (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width))) * 255 | 0;
        dataU8[k + 2] = (1.0 - i * j / (width * height)) * 255 | 0;
        dataU8[k + 3] = 255;
      }
    }

    let tex = {
      diffuse: {
        uuid: "tex1",
        dataTexture: {
          data: dataU8,
          width,
          height
        },
        format: "rgba8unorm",
        generateMipmaps: true
      }
    };
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [0.0, 0.0, 0.8, 0.8],
      textures: [tex]
    });
    rc.addEntity(entity);
  }

  initScene() {
    this.applyRGBAFloat16Tex();
    this.applyRGBA8Tex();
  }

  run() {
    this.mRscene.run();
  }

}

exports.DataTextureTest = DataTextureTest;

/***/ }),

/***/ "ae81":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const ComputeEntity_1 = __webpack_require__("dca8");

const WGCompMaterial_1 = __webpack_require__("19f9");

const gridSize = 32;
const shdWorkGroupSize = 8; // an example compute shader

const compShdCode0 = `
			@group(0) @binding(0) var<uniform> grid: vec2f;
			@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
			@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

			fn cellIndex(cell: vec2u) -> u32 {
				return cell.y * u32(grid.x) + cell.x;
			}

			@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
			fn compMain(@builtin(global_invocation_id) cell: vec3u) {
				if (cellStateIn[cellIndex(cell.xy)] == 1) {
					cellStateOut[cellIndex(cell.xy)] = 0;
				} else {
					cellStateOut[cellIndex(cell.xy)] = 1;
				}
			}`; // an example compute shader

const compShdCode1 = `
			@group(0) @binding(0) var<uniform> grid: vec2f;
			@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
			@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

			fn cellIndex(cell: vec2u) -> u32 {
				return cell.y * u32(grid.x) + cell.x;
			}

			@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
			fn compMain(@builtin(global_invocation_id) cell: vec3u) {
				if (cellStateIn[cellIndex(cell.xy)]%5 == 0) {
					cellStateOut[cellIndex(cell.xy)] = 0;
				} else {
					cellStateOut[cellIndex(cell.xy)] = 1;
				}
			}`;

class ComputeMaterialTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("ComputeMaterialTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i += 3) {
      cellStateArray0[i] = 1;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    } // const v0 = new WGRUniformValue({ data: gridsSizesArray, stride: 2 }).toVisibleAll();
    // const v1 = new WGRStorageValue({ data: cellStateArray0, stride: 1 }).toVisibleVertComp();
    // const v2 = new WGRStorageValue({ data: cellStateArray1, stride: 1 }).toVisibleComp();
    // all
    // let layout = {visibility:'vert_comp', access:'read_write'};
    // let visibility = new WGRBufferVisibility().toVisibleAll();
    // const v0 = { data: gridsSizesArray, stride: 2, visibility };
    // visibility = new WGRBufferVisibility().toVisibleVertComp();
    // const v1 = {uuid:"v1", storage: { data: cellStateArray0, stride: 1, visibility }};
    // visibility = new WGRBufferVisibility().toVisibleComp().toBufferForStorage();
    // const v2 = {uuid:"v2", storage: { data: cellStateArray1, stride: 1, visibility }};


    const v0 = {
      data: gridsSizesArray,
      stride: 2,
      layout: {
        visibility: 'all'
      }
    };
    const v1 = {
      storage: {
        data: cellStateArray0,
        stride: 1,
        layout: {
          visibility: 'vert_comp'
        }
      }
    };
    const v2 = {
      storage: {
        data: cellStateArray1,
        stride: 1,
        layout: {
          visibility: 'comp',
          access: 'read_write'
        }
      }
    };
    return [v0, v1, v2];
  }

  createMaterial(shaderSrc, shadinguuid, uniformValues) {
    const workcounts = [4, 4];
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid,
      shaderSrc,
      uniformValues,
      workcounts
    });
  }

  initScene() {
    const rc = this.mRscene;
    const uniformValues = this.createUniformValues();
    let shaderCodeSrc0 = {
      code: compShdCode0,
      uuid: "computing-0"
    };
    let shaderCodeSrc1 = {
      code: compShdCode1,
      uuid: "computing-1"
    };
    let materials = [this.createMaterial(shaderCodeSrc0, "comp-1", uniformValues), this.createMaterial(shaderCodeSrc1, "comp-2", uniformValues)];
    rc.addEntity(new ComputeEntity_1.ComputeEntity({
      materials
    }));
  }

  run() {
    this.mRscene.run();
  }

}

exports.ComputeMaterialTest = ComputeMaterialTest;

/***/ }),

/***/ "af1b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // for some defined objs

Object.defineProperty(exports, "__esModule", {
  value: true
});
var WGRDrawMode;

(function (WGRDrawMode) {
  WGRDrawMode[WGRDrawMode["DISABLE"] = 0] = "DISABLE";
  WGRDrawMode[WGRDrawMode["TRIANGLES"] = 1] = "TRIANGLES";
  WGRDrawMode[WGRDrawMode["LINE_STRIP"] = 2] = "LINE_STRIP";
  WGRDrawMode[WGRDrawMode["POINTS"] = 3] = "POINTS";
  WGRDrawMode[WGRDrawMode["LINES"] = 4] = "LINES";
})(WGRDrawMode || (WGRDrawMode = {}));

exports.WGRDrawMode = WGRDrawMode;
var WGRNormalType;

(function (WGRNormalType) {
  WGRNormalType[WGRNormalType["FLAT"] = 0] = "FLAT";
  WGRNormalType[WGRNormalType["GOURAND"] = 1] = "GOURAND";
})(WGRNormalType || (WGRNormalType = {}));

exports.WGRNormalType = WGRNormalType;

/***/ }),

/***/ "af80":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const v_m_180pk = 180.0 / Math.PI;
const v_m_minp = 1e-7;

class Vector3 {
  constructor(px = 0.0, py = 0.0, pz = 0.0, pw = 1.0) {
    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0;
    this.w = 0.0;
    this.x = px;
    this.y = py;
    this.z = pz;
    this.w = pw;
  }

  clone() {
    return new Vector3(this.x, this.y, this.z, this.w);
  }

  toZero() {
    return this.setXYZW(0, 0, 0, 0);
  }

  toOne() {
    return this.setXYZW(1, 1, 1, 1);
  }

  setVector3(vector3) {
    let v = vector3;

    if (v) {
      const t = this;
      const vs = v;

      if (vs.length !== undefined) {
        const len = vs.length;
        if (len > 0) t.x = vs[0];
        if (len > 1) t.y = vs[1];
        if (len > 2) t.z = vs[2];
        if (len > 3) t.w = vs[3];
      } else {
        const tv = v;
        if (tv.x !== undefined) t.x = tv.x;
        if (tv.y !== undefined) t.y = tv.y;
        if (tv.z !== undefined) t.z = tv.z;
        if (tv.w !== undefined) t.w = tv.w;
      }
    }

    return this;
  }

  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    this.z = Math.abs(this.z);
    return this;
  }

  setXYZW(px, py, pz, pw) {
    this.x = px;
    this.y = py;
    this.z = pz;
    this.w = pw;
    return this;
  }

  setXYZ(px, py, pz) {
    this.x = px;
    this.y = py;
    this.z = pz;
    return this;
  }
  /**
   * example: [0],[1],[2],[3] => x,y,z,w
   */


  fromArray3(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.z = arr[offset + 2];
    return this;
  }
  /**
   * example: x,y,z => [0],[1],[2]
   */


  toArray3(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.z;
    return this;
  }

  fromArray4(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.z = arr[offset + 2];
    this.w = arr[offset + 3];
    return this;
  }

  toArray4(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.z;
    arr[offset + 3] = this.w;
    return this;
  }

  copyFrom(v3) {
    this.x = v3.x;
    this.y = v3.y;
    this.z = v3.z;
    return this;
  }

  dot(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  }

  multBy(a) {
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  }

  normalize() {
    let d = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    if (d > v_m_minp) {
      this.x /= d;
      this.y /= d;
      this.z /= d;
    }

    return this;
  }

  normalizeTo(a) {
    let d = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    if (d > v_m_minp) {
      a.x = this.x / d;
      a.y = this.y / d;
      a.z = this.z / d;
    } else {
      a.x = this.x;
      a.y = this.y;
      a.z = this.z;
    }
  }

  scaleVector(s) {
    this.x *= s.x;
    this.y *= s.y;
    this.z *= s.z;
    return this;
  }

  scaleBy(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  equalsXYZ(a) {
    return Math.abs(this.x - a.x) < v_m_minp && Math.abs(this.y - a.y) < v_m_minp && Math.abs(this.z - a.z) < v_m_minp;
  }

  equalsAll(a) {
    return Math.abs(this.x - a.x) < v_m_minp && Math.abs(this.y - a.y) < v_m_minp && Math.abs(this.z - a.z) < v_m_minp && Math.abs(this.w - a.w) < v_m_minp;
  }

  project() {
    let t = 1.0 / this.w;
    this.x *= t;
    this.y *= t;
    this.z *= t;
  }

  getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  getLengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  addBy(a) {
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  }

  subtractBy(a) {
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  }

  subtract(a) {
    return new Vector3(this.x - a.x, this.y - a.y, this.z - a.z);
  }

  add(a) {
    return new Vector3(this.x + a.x, this.y + a.y, this.z + a.z);
  }

  crossProduct(a) {
    return new Vector3(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
  }

  crossBy(a) {
    let px = this.y * a.z - this.z * a.y;
    let py = this.z * a.x - this.x * a.z;
    let pz = this.x * a.y - this.y * a.x;
    this.x = px;
    this.y = py;
    this.z = pz;
    return this;
  }

  reflectBy(nv) {
    let idotn2 = (this.x * nv.x + this.y * nv.y + this.z * nv.z) * 2.0;
    this.x = this.x - idotn2 * nv.x;
    this.y = this.y - idotn2 * nv.y;
    this.z = this.z - idotn2 * nv.z;
    return this;
  }

  scaleVecTo(va, scale) {
    this.x = va.x * scale;
    this.y = va.y * scale;
    this.z = va.z * scale;
    return this;
  }

  subVecsTo(va, vb) {
    this.x = va.x - vb.x;
    this.y = va.y - vb.y;
    this.z = va.z - vb.z;
    return this;
  }

  addVecsTo(va, vb) {
    this.x = va.x + vb.x;
    this.y = va.y + vb.y;
    this.z = va.z + vb.z;
    return this;
  }

  crossVecsTo(va, vb) {
    this.x = va.y * vb.z - va.z * vb.y;
    this.y = va.z * vb.x - va.x * vb.z;
    this.z = va.x * vb.y - va.y * vb.x;
    return this;
  }

  toString() {
    return "Vector3(" + this.x + "" + this.y + "" + this.z + ")";
  }
  /**
   * 右手法则(为正)
   */


  static Cross(a, b, result) {
    result.x = a.y * b.z - a.z * b.y;
    result.y = a.z * b.x - a.x * b.z;
    result.z = a.x * b.y - a.y * b.x;
  } // (va1 - va0) 叉乘 (vb1 - vb0), 右手法则(为正)


  static CrossSubtract(va0, va1, vb0, vb1, result) {
    v_m_v0.x = va1.x - va0.x;
    v_m_v0.y = va1.y - va0.y;
    v_m_v0.z = va1.z - va0.z;
    v_m_v1.x = vb1.x - vb0.x;
    v_m_v1.y = vb1.y - vb0.y;
    v_m_v1.z = vb1.z - vb0.z;
    va0 = v_m_v0;
    vb0 = v_m_v1;
    result.x = va0.y * vb0.z - va0.z * vb0.y;
    result.y = va0.z * vb0.x - va0.x * vb0.z;
    result.z = va0.x * vb0.y - va0.y * vb0.x;
  }

  static Subtract(a, b, result) {
    result.x = a.x - b.x;
    result.y = a.y - b.y;
    result.z = a.z - b.z;
  }

  static DistanceSquared(a, b) {
    v_m_v0.x = a.x - b.x;
    v_m_v0.y = a.y - b.y;
    v_m_v0.z = a.z - b.z;
    return v_m_v0.getLengthSquared();
  }

  static DistanceXYZ(x0, y0, z0, x1, y1, z1) {
    v_m_v0.x = x0 - x1;
    v_m_v0.y = y0 - y1;
    v_m_v0.z = z0 - z1;
    return v_m_v0.getLength();
  }

  static Distance(v0, v1) {
    v_m_v0.x = v0.x - v1.x;
    v_m_v0.y = v0.y - v1.y;
    v_m_v0.z = v0.z - v1.z;
    return v_m_v0.getLength();
  }
  /**
   * get angle degree between two Vector3 objects
   * @param v0 src Vector3 object
   * @param v1 dst Vector3 object
   * @returns angle degree
   */


  static AngleBetween(v0, v1) {
    v0.normalizeTo(v_m_v0);
    v1.normalizeTo(v_m_v1);
    return Math.acos(v_m_v0.dot(v_m_v1)) * v_m_180pk;
  }
  /**
   * get angle radian between two Vector3 objects
   * @param v0 src Vector3 object
   * @param v1 dst Vector3 object
   * @returns angle radian
   */


  static RadianBetween(v0, v1) {
    v0.normalizeTo(v_m_v0);
    v1.normalizeTo(v_m_v1);
    return Math.acos(v_m_v0.dot(v_m_v1));
  }

  static RadianBetween2(v0, v1) {
    //  // c^2 = a^2 + b^2 - 2*a*b * cos(x)
    //  // cos(x) = (a^2 + b^2 - c^2) / 2*a*b
    let pa = v0.getLengthSquared();
    let pb = v1.getLengthSquared();
    v_m_v0.subVecsTo(v0, v1);
    return Math.acos((pa + pb - v_m_v0.getLengthSquared()) / (2.0 * Math.sqrt(pa) * Math.sqrt(pb)));
  }

  static Reflect(iv, nv, rv) {
    let idotn2 = (iv.x * nv.x + iv.y * nv.y + iv.z * nv.z) * 2.0;
    rv.x = iv.x - idotn2 * nv.x;
    rv.y = iv.y - idotn2 * nv.y;
    rv.z = iv.z - idotn2 * nv.z;
  }
  /**
   * 逆时针转到垂直
   */


  static VerticalCCWOnXOY(v) {
    const x = v.x;
    v.x = -v.y;
    v.y = x;
  }
  /**
   * 顺时针转到垂直
   */


  static VerticalCWOnXOY(v) {
    const y = v.y;
    v.y = -v.x;
    v.x = y;
  }

}

Vector3.X_AXIS = new Vector3(1, 0, 0);
Vector3.Y_AXIS = new Vector3(0, 1, 0);
Vector3.Z_AXIS = new Vector3(0, 0, 1);
Vector3.ZERO = new Vector3(0, 0, 0);
Vector3.ONE = new Vector3(1, 1, 1);
exports.default = Vector3;
const v_m_v0 = new Vector3();
const v_m_v1 = new Vector3();

/***/ }),

/***/ "afaf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> color: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\nconst hdrBrnDecodeVec4 = vec4f(255.0, 2.55, 0.0255, 0.000255);\r\nfn rgbaToHdrBrn(color: vec4f) -> f32 {\r\n    return dot(hdrBrnDecodeVec4, color);\r\n}\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\t// var color4 = vec4f(textureSample(texture0, sampler0, uv).xyz, 1.0) * color;\r\n\t// let brn3 = vec3f(rgbaToHdrBrn(textureSample(texture0, sampler0, uv)));\r\n\tlet brn3 = vec3f(rgbaToHdrBrn(textureSampleLevel(texture0, sampler0, uv, color.w)));\r\n\tvar color4 = vec4f(brn3, 1.0) * vec4f(color.xyz,1.0);\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "b1fa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventBase {
  constructor() {
    this.uuid = ""; // phase is event flow phase: 0(none phase),1(capture phase),2(bubble phase)

    this.phase = 0; // 事件类型

    this.type = EventBase.RESIZE; // 元事件发送者

    this.target = null; // 逻辑事件产生者, 例如容器发送了一个mouse down事件, 则容器是target而ray pick到的这个 entity就是currentTarget

    this.currentTarget = null;
    this.data = null;
    this.__$preventBoo = false;
  } //classType:number = 1001;


  getClassType() {
    return EventBase.EventClassType;
  }

  preventDefault() {
    this.__$preventBoo = true;
  }

  reset() {
    this.__$preventBoo = false;
  }

  toString() {
    return "[EventBase]";
  }

}

EventBase.EventClassType = 1001;
EventBase.RESIZE = 3001;
EventBase.ENTER_FRAME = 3002;
exports.default = EventBase;

/***/ }),

/***/ "b2e4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "b2fd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRPipelineContextImpl_1 = __webpack_require__("374c");

exports.BufDataParamType = WGRPipelineContextImpl_1.BufDataParamType;

const IWGRUniformContext_1 = __webpack_require__("9069");

exports.WGRUniformParam = IWGRUniformContext_1.WGRUniformParam;

const WGRUniformCtxInstance_1 = __webpack_require__("3590");

const WGRBufferValue_1 = __webpack_require__("2d6d");

const WGRBufferView_1 = __webpack_require__("dfa8");

class WGRUniformContext {
  constructor(layoutAuto) {
    this.mMap = new Map();
    this.mInsList = [];
    this.mLayoutAuto = true;
    this.mLayoutAuto = layoutAuto;
    console.log("WGRUniformContext::constructor() ...");
  }

  isLayoutAuto() {
    return this.mLayoutAuto;
  }

  getWGCtx() {
    return this.mBindGCtx.getWGCtx();
  }

  getUCtx(layoutName, creation = true) {
    let uctx = null;
    const m = this.mMap;

    if (m.has(layoutName)) {
      uctx = m.get(layoutName);
    } else {
      if (creation) {
        uctx = new WGRUniformCtxInstance_1.WGRUniformCtxInstance();
        uctx.layoutAuto = this.mLayoutAuto;
        uctx.shdUniform = WGRUniformContext.shdUniform;
        uctx.initialize(this.mBindGCtx);
        m.set(layoutName, uctx);
        this.mUCtxIns = uctx;
      }
    }

    return uctx;
  }

  initialize(bindGCtx) {
    if (!this.mBindGCtx && bindGCtx) {
      this.mBindGCtx = bindGCtx;
    }
  }

  getBindGroupLayout(multisampled) {
    if (this.mUCtxIns) {
      return this.mUCtxIns.getBindGroupLayout(multisampled);
    }

    return null;
  }

  runBegin() {
    const ls = this.mInsList; // console.log("WGRUniformContext::runBegin(), ls.length: ", ls.length);

    for (let i = 0; i < ls.length;) {
      ls[i].runBegin();

      if (ls[i].isEnabled()) {
        ls[i].ready = false;
        ls.splice(i, 1);
        console.log("finish and remove a old ready uniform ctx ins.");
      } else {
        i++;
      }
    }
  }

  runEnd() {}

  createUniformsWithValues(params, uniformAppend) {
    // console.log("WGRUniformContext::createUniformsWithValues(), params: ", params);
    let uniforms = [];

    for (let i = 0; i < params.length; ++i) {
      const p = params[i];
      uniforms.push(this.createUniformWithValues(p.layoutName, p.groupIndex, p.values, p.texParams, uniformAppend));
    }

    return uniforms;
  }

  createUniformWithValues(layoutName, groupIndex, values, texParams, uniformAppend) {
    if (this.mBindGCtx) {
      const uctx = this.getUCtx(layoutName);

      if (!uctx.ready) {
        this.mInsList.push(uctx);
        uctx.ready = true;
        console.log("add a new ready uniform ctx ins.");
      }

      const bufDataParams = [];

      for (let i = 0; i < values.length; ++i) {
        // console.log(values[i], ", A0-KKK v instanceof WGRBufferValue: ", values[i] instanceof WGRBufferValue);
        let v = values[i];
        v = WGRBufferValue_1.checkBufferData(v);

        if (v.uid == undefined || v.uid < 0) {
          v.uid = WGRBufferView_1.createNewWRGBufferViewUid();
        }

        const vuid = v.uid;
        const arrayStride = v.arrayStride;
        const visibility = v.visibility.clone(); // console.log(v, ", B1 v instanceof WGRBufferValue: ", v instanceof WGRBufferValue);

        let param = {
          arrayStride,
          size: v.byteLength,
          usage: v.usage,
          shared: v.shared,
          vuid,
          visibility,
          ufvalue: v
        }; // console.log("XXX XXX param: ", param);

        bufDataParams.push(param);
      }

      return uctx.createUniform(layoutName, groupIndex, bufDataParams, texParams, uniformAppend);
    }

    throw Error("Illegal operation !!!");
    return null;
  }

  createUniform(layoutName, groupIndex, bufDataParams, texParams, uniformAppend) {
    if (this.mBindGCtx) {
      const uctx = this.getUCtx(layoutName);
      this.mInsList.push(uctx);
      return uctx.createUniform(layoutName, groupIndex, bufDataParams, texParams, uniformAppend);
    }

    return null;
  }

  removeUniforms(ufs) {
    if (ufs && this.mBindGCtx) {
      // console.log("WGRUniformContext::removeUniforms(), ufs.length: ", ufs.length);
      for (let i = 0; i < ufs.length; ++i) {
        this.removeUniform(ufs[i]);
      }
    }
  }

  removeUniform(u) {
    if (this.mBindGCtx) {
      // console.log("WGRUniformContext::removeUniform(), u: ", u);
      if (u.layoutName !== undefined) {
        const m = this.mMap;

        if (m.has(u.layoutName)) {
          const uctx = m.get(u.layoutName);
          uctx.removeUniform(u);
        }
      }
    }
  }

  destroy() {
    if (this.mBindGCtx) {
      for (var [k, v] of this.mMap) {
        v.destroy();
      }

      this.mBindGCtx = null;
    }
  }

}

WGRUniformContext.shdUniform = new WGRUniformCtxInstance_1.SharedUniformObj();
exports.WGRUniformContext = WGRUniformContext;

/***/ }),

/***/ "b3f5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CommonUtils_1 = __webpack_require__("fe0b");

exports.calculateMipLevels = CommonUtils_1.calculateMipLevels;
/**
 * thanks: https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js
 */

class GPUMipmapGenerator {
  constructor(device) {
    this.pipelines = {};
    this.initialize(device);
  }

  initialize(device) {
    if (device && !this.device) {
      this.device = device;
      this.sampler = device.createSampler({
        minFilter: "linear"
      });
    }
  }
  /**
   * @param {string} format - format of the texture
   * @returns {GPURenderPipeline} pipeline - a GPURenderPipeline instance
   */


  getMipmapPipeline(format) {
    let pipeline = this.pipelines[format];

    if (!pipeline) {
      // Shader modules is shared between all pipelines, so only create once.
      if (!this.mipmapShaderModule) {
        this.mipmapShaderModule = this.device.createShaderModule({
          label: "Mipmap Generator",
          code: `
            var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
              vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

            struct VertexOutput {
              @builtin(position) position : vec4<f32>,
              @location(0) texCoord : vec2<f32>,
            };

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
              var output : VertexOutput;
              output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
              output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
              return output;
            }

            @group(0) @binding(0) var imgSampler : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
              return textureSample(img, imgSampler, texCoord);
            }
          `
        });
        this.bindGroupLayout = this.device.createBindGroupLayout({
          label: "Mipmap Generator",
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {}
          }, {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
          }]
        });
        this.pipelineLayout = this.device.createPipelineLayout({
          label: "Mipmap Generator",
          bindGroupLayouts: [this.bindGroupLayout]
        });
      }

      pipeline = this.device.createRenderPipeline({
        layout: this.pipelineLayout,
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [{
            format
          }]
        }
      });
      this.pipelines[format] = pipeline;
    }

    return pipeline;
  }
  /**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   *
   * @param {GPUTexture} texture - Texture to generate mipmaps for.
   * @param {object} textureDescriptor - GPUTextureDescriptor the texture was created with.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */


  generateMipmap(texture, textureDescriptor) {
    // TODO: Does this need to handle sRGB formats differently?
    const pipeline = this.getMipmapPipeline(textureDescriptor.format);

    if (textureDescriptor.dimension == "3d" || textureDescriptor.dimension == "1d") {
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    }

    let texSizeDesc = textureDescriptor.size;
    const sizeArr = textureDescriptor.size;

    if (sizeArr.length !== undefined) {
      const len = sizeArr.length;
      texSizeDesc = {
        depthOrArrayLayers: 1
      };

      if (len >= 0) {
        texSizeDesc.width = sizeArr[0];

        if (len >= 1) {
          texSizeDesc.height = sizeArr[1];

          if (len >= 2) {
            texSizeDesc.depthOrArrayLayers = sizeArr[2];
          }
        }
      }
    }

    let mipTexture = texture;
    const arrayLayerCount = texSizeDesc.depthOrArrayLayers || 1; // Only valid for 2D textures.
    // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.

    const renderToSource = textureDescriptor.usage & GPUTextureUsage.RENDER_ATTACHMENT; // console.log('GPUMipmapGenerator::generateMipmap(), AAA, !renderToSource: ', !renderToSource);

    if (!renderToSource) {
      // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source
      // texture, since we already have the top level.
      const mipTextureDescriptor = {
        size: {
          width: Math.max(1, texSizeDesc.width >>> 1),
          height: Math.max(1, texSizeDesc.height >>> 1),
          depthOrArrayLayers: arrayLayerCount
        },
        format: textureDescriptor.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: textureDescriptor.mipLevelCount - 1
      };
      mipTexture = this.device.createTexture(mipTextureDescriptor);
    }

    const commandEncoder = this.device.createCommandEncoder({});

    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
      let srcView = texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: arrayLayer,
        arrayLayerCount: 1
      });
      let dstMipLevel = renderToSource ? 1 : 0;

      for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {
        const dstView = mipTexture.createView({
          baseMipLevel: dstMipLevel++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: arrayLayer,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            loadOp: "clear",
            storeOp: "store"
          }]
        });
        const bindGroup = this.device.createBindGroup({
          layout: this.bindGroupLayout,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: srcView
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(3, 1, 0, 0);
        passEncoder.end();
        srcView = dstView;
      }
    } // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture
    // to the source.
    // console.log('GPUMipmapGenerator::generateMipmap(), BBB, !renderToSource: ', !renderToSource);


    if (!renderToSource) {
      const mipLevelSize = {
        width: Math.max(1, texSizeDesc.width >>> 1),
        height: Math.max(1, texSizeDesc.height >>> 1),
        depthOrArrayLayers: arrayLayerCount
      };

      for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {
        commandEncoder.copyTextureToTexture({
          texture: mipTexture,
          mipLevel: i - 1
        }, {
          texture: texture,
          mipLevel: i
        }, mipLevelSize);
        mipLevelSize.width = Math.max(1, mipLevelSize.width >>> 1);
        mipLevelSize.height = Math.max(1, mipLevelSize.height >>> 1);
      }
    }

    this.device.queue.submit([commandEncoder.finish()]);

    if (!renderToSource) {
      mipTexture.destroy();
    }

    return texture;
  }

}

exports.GPUMipmapGenerator = GPUMipmapGenerator;

/***/ }),

/***/ "b512":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRBufferData_1 = __webpack_require__("87f6");

exports.WGRBufferLayout = WGRBufferData_1.WGRBufferLayout;
exports.WGRBufferData = WGRBufferData_1.WGRBufferData;

const WGRBufferVisibility_1 = __webpack_require__("dc4d");

function applyParamToBufferData(bufData, param) {
  if (param.uuid !== undefined) bufData.uuid = param.uuid;
  let d = param.data;
  bufData.data = d;

  if (param.bufData) {
    const bd = param.bufData;
    bufData.bufData = bd;
    d = bd.data;
    bufData.data = d;
  }

  if (bufData.shared === undefined) bufData.shared = false;

  if (bufData !== param) {
    if (param.usage !== undefined) bufData.usage = param.usage;
    if (param.shared !== undefined) bufData.shared = param.shared;
    if (param.stride !== undefined) bufData.stride = param.stride;
    if (param.shdVarName !== undefined) bufData.shdVarName = param.shdVarName;
    if (param.arrayStride !== undefined) bufData.arrayStride = param.arrayStride;
  }

  if (bufData.arrayStride === undefined) bufData.arrayStride = 1;

  if (bufData.arrayStride < 2) {
    const bpe = d.BYTES_PER_ELEMENT;

    if (bufData.stride !== undefined && bpe !== undefined) {
      bufData.arrayStride = bpe * bufData.stride;
    } else if (d) {
      if (d.byteLength <= 64) bufData.arrayStride = d.byteLength;
    }
  }

  if (!bufData.visibility) {
    bufData.visibility = new WGRBufferVisibility_1.WGRBufferVisibility();
  }
}

exports.applyParamToBufferData = applyParamToBufferData;

/***/ }),

/***/ "b6ed":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const UnitsTest_1 = __webpack_require__("b8ec");

let demo = new UnitsTest_1.UnitsTest();
demo.initialize();

/***/ }),

/***/ "b720":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Define_1 = __webpack_require__("af1b"); // dynamic or static for materials?
// shared or private for materials?


class WGRPrimitive {
  constructor() {
    this.indexCount = 0;
    this.layoutUid = 0;
    this.instanceCount = 1;
    this.vertexCount = 0;
    this.drawMode = Define_1.WGRDrawMode.TRIANGLES;
  }

  run(rc) {
    const vs = this.vbufs;

    if (vs) {
      for (let j = 0, ln = vs.length; j < ln; ++j) {
        rc.setVertexBuffer(j, vs[j]);
      }
    }
  }

  update() {
    if (this.ibuf) {
      this.indexCount = this.indexCount > 0 ? this.indexCount : this.ibuf.elementCount;
    } else {
      this.vertexCount = this.vertexCount > 0 ? this.vertexCount : this.vbufs[0].vectorCount;
    }
  }

  clone() {
    const g = new WGRPrimitive();
    g.layoutUid = this.layoutUid;
    g.vbufs = this.vbufs;
    g.ibuf = this.ibuf;
    g.indexCount = this.indexCount;
    g.instanceCount = this.instanceCount;
    g.vertexCount = this.vertexCount;
    return g;
  }

}

exports.WGRPrimitive = WGRPrimitive;

/***/ }),

/***/ "b876":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var CoModuleNS;

(function (CoModuleNS) {
  CoModuleNS["ctmParser"] = "ctmGeomParser";
  CoModuleNS["objParser"] = "objGeomParser";
  CoModuleNS["dracoParser"] = "dracoGeomParser";
  CoModuleNS["pngParser"] = "pngParser";
  CoModuleNS["fbxFastParser"] = "fbxFastParser";
  CoModuleNS["threadCore"] = "threadCore";
  CoModuleNS["coSpaceApp"] = "coSpaceApp";
})(CoModuleNS || (CoModuleNS = {}));

exports.CoModuleNS = CoModuleNS;
/**
 * 数据文件类型，例如 ctm, draco
 */

var CoDataFormat;

(function (CoDataFormat) {
  CoDataFormat["Undefined"] = "undefined-format";
  CoDataFormat["CTM"] = "ctm";
  CoDataFormat["Draco"] = "draco";
  CoDataFormat["OBJ"] = "obj";
  CoDataFormat["FBX"] = "fbx";
  CoDataFormat["GLB"] = "glb";
  CoDataFormat["Jpg"] = "jpg";
  CoDataFormat["Png"] = "png";
  CoDataFormat["Gif"] = "gif";
})(CoDataFormat || (CoDataFormat = {}));

exports.CoDataFormat = CoDataFormat;
var CoModuleFileType;

(function (CoModuleFileType) {
  CoModuleFileType["JS"] = "js-text";
  CoModuleFileType["Binasy"] = "binary";
})(CoModuleFileType || (CoModuleFileType = {}));

exports.CoModuleFileType = CoModuleFileType;

/***/ }),

/***/ "b8ec":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const VertColorTriangle_1 = __webpack_require__("601e");

const VertColorCube_1 = __webpack_require__("fd5e");

const VertEntityTest_1 = __webpack_require__("ede0");

const DefaultEntityTest_1 = __webpack_require__("ed04");

const ImgTexturedCube_1 = __webpack_require__("8890");

const ImgCubeMap_1 = __webpack_require__("5326");

const MultiTexturedCube_1 = __webpack_require__("6065");

const BlendTest_1 = __webpack_require__("cc22");

const MultiMaterialPass_1 = __webpack_require__("6bbe");

const MultiUniformTest_1 = __webpack_require__("9b48");

const UniformTest_1 = __webpack_require__("6729");

const StorageTest_1 = __webpack_require__("8bc3");

const RSceneTest_1 = __webpack_require__("c14c");

const SimpleLightTest_1 = __webpack_require__("9f80");

const REntity3DContainerTest_1 = __webpack_require__("27e9");

const Entity3DVisibilityTest_1 = __webpack_require__("e0de");

const RSceneEntityManagement_1 = __webpack_require__("81d0");

const SimplePBRTest_1 = __webpack_require__("5469");

const FixScreenPlaneTest_1 = __webpack_require__("381c");

const PrimitiveEntityTest_1 = __webpack_require__("245e");

const ScreenPostEffect_1 = __webpack_require__("f78a");

const ModelLoadTest_1 = __webpack_require__("a7a5");

const DrawInstanceTest_1 = __webpack_require__("8286");

const ComputeEntityTest_1 = __webpack_require__("e8b6");

const GameOfLifeTest_1 = __webpack_require__("5bd3");

const ComputeMaterialTest_1 = __webpack_require__("ae81");

const GameOfLifeMultiMaterialPass_1 = __webpack_require__("d95d");

const GameOfLifePretty_1 = __webpack_require__("5fd4");

const GameOfLifeSphere_1 = __webpack_require__("4dc1");

const GameOfLifeSpherePBR_1 = __webpack_require__("73c4");

const GameOfLife3DPBR_1 = __webpack_require__("c862");

const MultiGPUPassTest_1 = __webpack_require__("85fd");

const RTTFixScreenTest_1 = __webpack_require__("7b86");

const RTTTest_1 = __webpack_require__("46a3");

const AddEntityIntoMultiRPasses_1 = __webpack_require__("a059");

const PassNodeGraphTest_1 = __webpack_require__("8777");

const ColorAttachmentReplace_1 = __webpack_require__("4173");

const PingpongBlur_1 = __webpack_require__("3645");

const FloatRTT_1 = __webpack_require__("2d03");

const MRT_1 = __webpack_require__("ee65");

const DepthBlur_1 = __webpack_require__("0a09");

const LineEntityTest_1 = __webpack_require__("20e0");

const LineObjectTest_1 = __webpack_require__("a6bd");

const WireframeEntityTest_1 = __webpack_require__("5150");

const EntityCloneTest_1 = __webpack_require__("d493");

const ModelEntityTest_1 = __webpack_require__("fba9");

const DataDrivenTest_1 = __webpack_require__("425a");

const DataTextureTest_1 = __webpack_require__("ab24");

const FloatTextureTest_1 = __webpack_require__("9355");

const Set32BitsTexMipmapData_1 = __webpack_require__("2b4f");

const manager_1 = __webpack_require__("a6ef");

const UISystem_1 = __webpack_require__("5b33");

const demoNames = ['VertColorTriangle', 'VertColorCube', 'VertEntityTest', 'DefaultEntityTest', 'ImgTexturedCube', 'ImgCubeMap', 'MultiTexturedCube', 'BlendTest', 'MultiMaterialPass', 'MultiUniformTest', 'UniformTest', 'StorageTest', 'RSceneTest', 'SimpleLightTest', 'REntity3DContainerTest', 'Entity3DVisibilityTest', 'RSceneEntityManagement', 'SimplePBRTest', 'FixScreenPlaneTest', 'PrimitiveEntityTest', 'ScreenPostEffect', 'ModelLoadTest', 'DrawInstanceTest', 'ComputeEntityTest', 'GameOfLifeTest', 'ComputeMaterialTest', 'GameOfLifeMultiMaterialPass', 'GameOfLifePretty', 'GameOfLifeSphere', 'GameOfLifeSpherePBR', 'GameOfLife3DPBR', 'MultiGPUPassTest', 'RTTFixScreenTest', 'RTTTest', 'AddEntityIntoMultiRPasses', 'PassNodeGraphTest', 'ColorAttachmentReplace', 'PingpongBlur', 'FloatRTT', 'MRT', 'DepthBlur', 'LineEntityTest', 'LineObjectTest', 'WireframeEntityTest', 'EntityCloneTest', 'ModelEntityTest', 'DataDrivenTest', 'DataTextureTest', 'FloatTextureTest', 'Set32BitsTexMipmapData'];

function mainFunc(demoIns) {
  demoIns.initialize();

  function mainLoop(now) {
    demoIns.run();
    window.requestAnimationFrame(mainLoop);
  }

  window.requestAnimationFrame(mainLoop);
}

class UnitsTest {
  constructor() {
    this.mMana = new manager_1.UnitsTestMana(demoNames);
    this.mUISys = new UISystem_1.UISystem();
  }

  initialize() {
    //
    let href = window.location.href;
    let k = href.indexOf('?');
    let demoName = '';

    if (k > 0) {
      href = href.slice(k + 1);
      let hrefs = href.split('&');
      console.log('hrefs: ', hrefs);

      if (hrefs && hrefs.length > 0) {
        for (let i = 0; i < hrefs.length; ++i) {
          const str = hrefs[i];

          if (str) {
            const items = str.split('=');

            if (items.length == 2) {
              if (items[0] == 'webgpudemounit') {
                demoName = items[1].toLocaleLowerCase();
              }
            }
          }
        }
      }
    }

    console.log('href: ', href); //

    let index = this.mMana.getIndex();
    let ns = 'MRT';

    if (demoName.length > 0) {
      let ls = new Array(demoNames.length);

      for (let i = 0; i < ls.length; ++i) {
        ls[i] = demoNames[i].toLocaleLowerCase();
      }

      let i = ls.indexOf(demoName);

      if (i >= 0) {
        index = i;
      }
    }

    console.log("######## index: ", index, ", demoName: ", demoName);
    ns = demoNames[index];
    let param = {
      name: ns,
      index,
      demoNames
    };
    this.mUISys.mana = this.mMana;
    this.mUISys.initialize(param);

    switch (ns) {
      case 'VertColorTriangle':
        mainFunc(new VertColorTriangle_1.VertColorTriangle());
        break;

      case 'VertColorCube':
        mainFunc(new VertColorCube_1.VertColorCube());
        break;

      case 'VertEntityTest':
        mainFunc(new VertEntityTest_1.VertEntityTest());
        break;

      case 'DefaultEntityTest':
        mainFunc(new DefaultEntityTest_1.DefaultEntityTest());
        break;

      case 'ImgTexturedCube':
        mainFunc(new ImgTexturedCube_1.ImgTexturedCube());
        break;

      case 'ImgCubeMap':
        mainFunc(new ImgCubeMap_1.ImgCubeMap());
        break;

      case 'MultiTexturedCube':
        mainFunc(new MultiTexturedCube_1.MultiTexturedCube());
        break;

      case 'BlendTest':
        mainFunc(new BlendTest_1.BlendTest());
        break;

      case 'BlendTest':
        mainFunc(new BlendTest_1.BlendTest());
        break;

      case 'MultiMaterialPass':
        mainFunc(new MultiMaterialPass_1.MultiMaterialPass());
        break;

      case 'MultiUniformTest':
        mainFunc(new MultiUniformTest_1.MultiUniformTest());
        break;

      case 'UniformTest':
        mainFunc(new UniformTest_1.UniformTest());
        break;

      case 'StorageTest':
        mainFunc(new StorageTest_1.StorageTest());
        break;

      case 'RSceneTest':
        mainFunc(new RSceneTest_1.RSceneTest());
        break;

      case 'SimpleLightTest':
        mainFunc(new SimpleLightTest_1.SimpleLightTest());
        break;

      case 'REntity3DContainerTest':
        mainFunc(new REntity3DContainerTest_1.REntity3DContainerTest());
        break;

      case 'Entity3DVisibilityTest':
        mainFunc(new Entity3DVisibilityTest_1.Entity3DVisibilityTest());
        break;

      case 'RSceneEntityManagement':
        mainFunc(new RSceneEntityManagement_1.RSceneEntityManagement());
        break;

      case 'SimplePBRTest':
        mainFunc(new SimplePBRTest_1.SimplePBRTest());
        break;

      case 'FixScreenPlaneTest':
        mainFunc(new FixScreenPlaneTest_1.FixScreenPlaneTest());
        break;

      case 'PrimitiveEntityTest':
        mainFunc(new PrimitiveEntityTest_1.PrimitiveEntityTest());
        break;

      case 'ScreenPostEffect':
        mainFunc(new ScreenPostEffect_1.ScreenPostEffect());
        break;

      case 'ModelLoadTest':
        mainFunc(new ModelLoadTest_1.ModelLoadTest());
        break;

      case 'DrawInstanceTest':
        mainFunc(new DrawInstanceTest_1.DrawInstanceTest());
        break;

      case 'ComputeEntityTest':
        mainFunc(new ComputeEntityTest_1.ComputeEntityTest());
        break;

      case 'GameOfLifeTest':
        mainFunc(new GameOfLifeTest_1.GameOfLifeTest());
        break;

      case 'ComputeMaterialTest':
        mainFunc(new ComputeMaterialTest_1.ComputeMaterialTest());
        break;

      case 'GameOfLifeMultiMaterialPass':
        mainFunc(new GameOfLifeMultiMaterialPass_1.GameOfLifeMultiMaterialPass());
        break;

      case 'GameOfLifePretty':
        mainFunc(new GameOfLifePretty_1.GameOfLifePretty());
        break;

      case 'GameOfLifeSphere':
        mainFunc(new GameOfLifeSphere_1.GameOfLifeSphere());
        break;

      case 'GameOfLifeSpherePBR':
        mainFunc(new GameOfLifeSpherePBR_1.GameOfLifeSpherePBR());
        break;

      case 'GameOfLife3DPBR':
        mainFunc(new GameOfLife3DPBR_1.GameOfLife3DPBR());
        break;

      case 'MultiGPUPassTest':
        mainFunc(new MultiGPUPassTest_1.MultiGPUPassTest());
        break;

      case 'RTTFixScreenTest':
        mainFunc(new RTTFixScreenTest_1.RTTFixScreenTest());
        break;

      case 'RTTTest':
        mainFunc(new RTTTest_1.RTTTest());
        break;

      case 'AddEntityIntoMultiRPasses':
        mainFunc(new AddEntityIntoMultiRPasses_1.AddEntityIntoMultiRPasses());
        break;

      case 'PassNodeGraphTest':
        mainFunc(new PassNodeGraphTest_1.PassNodeGraphTest());
        break;

      case 'ColorAttachmentReplace':
        mainFunc(new ColorAttachmentReplace_1.ColorAttachmentReplace());
        break;

      case 'PingpongBlur':
        mainFunc(new PingpongBlur_1.PingpongBlur());
        break;

      case 'FloatRTT':
        mainFunc(new FloatRTT_1.FloatRTT());
        break;

      case 'MRT':
        mainFunc(new MRT_1.MRT());
        break;

      case 'DepthBlur':
        mainFunc(new DepthBlur_1.DepthBlur());
        break;

      case 'LineEntityTest':
        mainFunc(new LineEntityTest_1.LineEntityTest());
        break;

      case 'LineObjectTest':
        mainFunc(new LineObjectTest_1.LineObjectTest());
        break;

      case 'WireframeEntityTest':
        mainFunc(new WireframeEntityTest_1.WireframeEntityTest());
        break;

      case 'EntityCloneTest':
        mainFunc(new EntityCloneTest_1.EntityCloneTest());
        break;

      case 'ModelEntityTest':
        mainFunc(new ModelEntityTest_1.ModelEntityTest());
        break;

      case 'DataDrivenTest':
        mainFunc(new DataDrivenTest_1.DataDrivenTest());
        break;

      case 'DataTextureTest':
        mainFunc(new DataTextureTest_1.DataTextureTest());
        break;

      case 'FloatTextureTest':
        mainFunc(new FloatTextureTest_1.FloatTextureTest());
        break;

      case 'Set32BitsTexMipmapData':
        mainFunc(new Set32BitsTexMipmapData_1.Set32BitsTexMipmapData());
        break;

      default:
        break;
    }
  }

}

exports.UnitsTest = UnitsTest;

/***/ }),

/***/ "bc85":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class WebGPUBufferContext {
  constructor(wgCtx) {
    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  initialize(wgCtx) {
    if (!this.mWGCtx && wgCtx) {
      this.mWGCtx = wgCtx;
      this.queue = wgCtx.queue;
    }
  }

  createIndices(dataArray) {
    if (dataArray.length <= 65536) {
      return new Uint16Array(dataArray);
    }

    return new Uint32Array(dataArray);
  }

  createIndicesWithSize(size) {
    if (size <= 65536) {
      return new Uint16Array(size);
    }

    return new Uint32Array(size);
  }

  createIndexBuffer(data, offset = 0, mappedAtCreation = true) {
    return this.createVtxBuffer(data, offset, GPUBufferUsage.INDEX, mappedAtCreation);
  }

  createVertexBuffer(data, offset = 0, vectorLengths, mappedAtCreation = true) {
    return this.createVtxBuffer(data, offset, GPUBufferUsage.VERTEX, mappedAtCreation, vectorLengths);
  }

  createVtxBuffer(data, offset = 0, usage = GPUBufferUsage.VERTEX, mappedAtCreation = true, vectorLengths) {
    let size = data.byteLength % 4; // 如果不是4的倍数会报错

    size = data.byteLength + (size > 0 ? 4 - size : 0);
    const buf = this.createBuffer({
      size: size,
      usage: usage,
      mappedAtCreation
    });
    let eleBytes = 1;

    if (data instanceof Float32Array) {
      buf.dataFormat = "float32";
      eleBytes = 4;
    } else if (data instanceof Uint32Array) {
      buf.dataFormat = "uint32";
      eleBytes = 4;
    } else if (data instanceof Uint16Array) {
      buf.dataFormat = "uint16";
      eleBytes = 2;
    } else if (data instanceof Int32Array) {
      buf.dataFormat = "int32";
      eleBytes = 4;
    } else if (data instanceof Int16Array) {
      buf.dataFormat = "int16";
      eleBytes = 2;
    } else if (data instanceof Int8Array) {
      buf.dataFormat = "int8";
    } else if (data instanceof Uint8Array) {
      buf.dataFormat = "uint8";
    } else {
      throw Error("Illegal data type, need: Float32Array | Uint32Array | Uint16Array  | Int32Array | Int16Array | Uint8Array | Int8Array");
    }

    if (mappedAtCreation) {
      const b = buf.getMappedRange();

      if (data instanceof Float32Array) {
        new Float32Array(b).set(data, offset);
      } else if (data instanceof Uint32Array) {
        new Uint32Array(b).set(data, offset);
      } else if (data instanceof Uint16Array) {
        new Uint16Array(b).set(data, offset);
      } else if (data instanceof Int32Array) {
        new Int32Array(b).set(data, offset);
      } else if (data instanceof Int16Array) {
        new Int16Array(b).set(data, offset);
      } else if (data instanceof Int8Array) {
        new Int8Array(b).set(data, offset);
      } else if (data instanceof Uint8Array) {
        new Uint8Array(b).set(data, offset);
      }

      buf.unmap();
    }

    buf.elementCount = data.length;

    if (vectorLengths && vectorLengths.length > 0) {
      let arrayStride = 0;
      const offsets = new Array(vectorLengths.length);
      const formats = new Array(vectorLengths.length);

      for (let i = 0; i < formats.length; ++i) {
        offsets[i] = arrayStride;
        arrayStride += vectorLengths[i] * eleBytes;
        formats[i] = buf.dataFormat + "x" + vectorLengths[i];
      }

      buf.vectorOffsets = offsets;
      buf.vectorFormats = formats;
      buf.arrayStride = arrayStride;
      buf.vectorLengths = vectorLengths.slice();
      buf.vectorCount = buf.elementCount / vectorLengths[0];
    }

    buf.enabled = true;
    buf.shared = false;
    buf.uid = WebGPUBufferContext.sVtxUid++;
    return buf;
  }

  createBuffer(desc) {
    const buf = this.mWGCtx.device.createBuffer(desc);
    buf.uid = WebGPUBufferContext.sVtxUid++;
    return buf;
  }

  updateUniformBuffer(buffer, td, index, offset = 0) {
    // console.log("WebGPUBufferContext::updateUniformBuffer() index: ", index,",segs: ", buffer.segs);
    // console.log("WebGPUBufferContext::updateUniformBuffer() buffer.size: ", buffer.size);
    // console.log("WebGPUBufferContext::updateUniformBuffer() buffer.segs[index].index + offset: ", buffer.segs[index].index + offset);
    // console.log("WebGPUBufferContext::updateUniformBuffer() td: ", td);
    this.queue.writeBuffer(buffer, buffer.segs[index].index + offset, td.buffer, td.byteOffset, td.byteLength);
  }

}

WebGPUBufferContext.sVtxUid = 0;
exports.WebGPUBufferContext = WebGPUBufferContext;

/***/ }),

/***/ "bcc5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

class KeyboardEvent extends EventBase_1.default {
  constructor() {
    super();
    this.altKey = false;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.repeat = false;
    this.key = "";
    this.keyCode = 0;
    this.location = 0;
  }

  getClassType() {
    return KeyboardEvent.EventClassType;
  }

}

KeyboardEvent.EventClassType = 1003;
KeyboardEvent.KEY_DOWN = 6001;
KeyboardEvent.KEY_UP = 6002;
exports.default = KeyboardEvent;

/***/ }),

/***/ "bd36":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const PipeGeometryData_1 = __importDefault(__webpack_require__("f522"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Matrix4_1 = __importDefault(__webpack_require__("c6d1"));

class TorusGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.mvs = null;
    this.muvs = null;
    this.mnvs = null;
    this.m_cvs = null;
    this.m_boundsChanged = false;
    this.geometry = new PipeGeometryData_1.default();
    this.uScale = 1.0;
    this.vScale = 1.0;
    /**
     * axisType = 0 is XOY plane,
     * axisType = 1 is XOZ plane,
     * axisType = 2 is YOZ plane
     */

    this.axisType = 0;
  }

  getCircleCenterAt(i, outV) {
    this.geometry.getCenterAt(i, outV);
    this.m_boundsChanged = true;
  }

  transformCircleAt(i, mat4) {
    this.geometry.transformAt(i, mat4);
    this.m_boundsChanged = true;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getNVS() {
    return this.mnvs;
  }

  getCVS() {
    return this.m_cvs;
  }

  getIVS() {
    return this.mivs;
  }

  initialize(ringRadius, axisRadius, longitudeNumSegments, latitudeNumSegments, uvType = 1, alignYRatio = -0.5) {
    if (this.mvs == null) {
      let g = this.geometry;

      switch (this.axisType) {
        case 1:
          g.axisType = 2;
          break;

        case 2:
          g.axisType = 0;
          break;

        default:
          g.axisType = 1;
          break;
      }

      g.initialize(axisRadius, 0.0, longitudeNumSegments, latitudeNumSegments, uvType, alignYRatio);
      let nvFlag = true;
      let vs = g.getVS();
      let uvs = g.getUVS();
      let ivs = g.getIVS();

      if (nvFlag) {
        this.mnvs = new Float32Array(vs.length);
      }

      let nvs = this.mnvs;
      let pi2 = 2.0 * Math.PI;
      let rad = 0.0;
      let pv = new Vector3_1.default();
      let nv = new Vector3_1.default();
      let mat4 = new Matrix4_1.default();

      for (let i = 0; i <= latitudeNumSegments; ++i) {
        mat4.identity();
        rad = pi2 * i / latitudeNumSegments;

        switch (this.axisType) {
          case 1:
            pv.x = Math.cos(rad) * ringRadius;
            pv.z = Math.sin(rad) * ringRadius;
            mat4.rotationY(-rad);
            break;

          case 2:
            pv.y = Math.cos(rad) * ringRadius;
            pv.x = Math.sin(rad) * ringRadius;
            mat4.rotationZ(-rad);
            break;

          default:
            pv.z = Math.cos(rad) * ringRadius;
            pv.y = Math.sin(rad) * ringRadius;
            mat4.rotationX(-rad);
            break;
        }

        mat4.setTranslation(pv);
        g.transformAt(i, mat4);

        if (nvFlag) {
          let cv = pv;
          let range = g.getRangeAt(i);
          let pvs = vs.subarray(range[0], range[1]);
          let pnvs = nvs.subarray(range[0], range[1]);
          let tot = pvs.length / 3;
          let k = 0;

          for (let j = 0; j < tot; ++j) {
            k = j * 3;
            nv.setXYZ(pvs[k], pvs[k + 1], pvs[k + 2]);
            nv.subtractBy(cv);
            nv.normalize();
            pnvs[k] = nv.x;
            pnvs[k + 1] = nv.y;
            pnvs[k + 2] = nv.z;
          }
        }
      }

      this.mvs = vs;
      this.muvs = uvs;
      this.mivs = ivs;
      this.bounds = this.geometry.bounds;
      this.bounds.reset();
      this.bounds.addFloat32Arr(this.mvs);
      this.bounds.update();
      this.vtCount = this.geometry.vtCount;
      this.trisNumber = this.geometry.trisNumber;
      this.vtxTotal = this.mvs.length / 3;
    }

    this.initializeBuf(true);
  }

  reinitialize() {
    if (this.mvs != null) {
      this.initializeBuf(false);
    }
  }

  initializeBuf(newBuild) {
    if (this.mTransMatrix != null) {
      this.m_boundsChanged = true;
      this.mTransMatrix.transformVectorsSelf(this.mvs, this.mvs.length);
    }

    if (this.m_boundsChanged) {
      this.bounds.reset();
      this.bounds.addFloat32Arr(this.mvs);
      this.bounds.updateFast();
    }

    this.m_boundsChanged = false;
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;
      this.m_cvs = null;

      super.__$destroy();
    }
  }

}

exports.default = TorusGeometry;

/***/ }),

/***/ "bd7e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\r\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\n@group(0) @binding(3) var<uniform> grid: vec2f;\r\n@group(0) @binding(4) var<storage> cellState: array<u32>;\r\n@group(0) @binding(5) var<storage> lifeState: array<f32>;\r\n@group(0) @binding(6) var<storage> wpositions: array<vec4f>;\r\n\r\nstruct VertexInput {\r\n\t@location(0) pos: vec3f,\r\n  \t@location(1) uv : vec2f,\r\n  \t@location(2) normal : vec3f,\r\n\t@builtin(instance_index) instance: u32\r\n};\r\n\r\nstruct VertexOutput {\r\n\t@builtin(position) position: vec4f,\r\n\t@location(0) pos : vec4<f32>,\r\n\t@location(1) uv: vec2f,\r\n\t@location(2) normal : vec3<f32>,\r\n\t@location(3) camPos : vec3<f32>,\r\n\t@location(4) albedo : vec3<f32>,\r\n\t@location(5) param : vec3<f32>,\r\n};\r\n\r\nfn m44ToM33(m: mat4x4<f32>) -> mat3x3<f32> {\r\n\treturn mat3x3(m[0].xyz, m[1].xyz, m[2].xyz);\r\n}\r\nfn inverseM33(m: mat3x3<f32>)-> mat3x3<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2];\r\n    let b01 = a22 * a11 - a12 * a21;\r\n    let b11 = -a22 * a10 + a12 * a20;\r\n    let b21 = a21 * a10 - a11 * a20;\r\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3x3<f32>(\r\n\t\tvec3<f32>(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11)) / det,\r\n                vec3<f32>(b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det,\r\n                vec3<f32>(b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det);\r\n}\r\nfn inverseM44(m: mat4x4<f32>)-> mat4x4<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\r\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\r\n    let b00 = a00 * a11 - a01 * a10;\r\n    let b01 = a00 * a12 - a02 * a10;\r\n    let b02 = a00 * a13 - a03 * a10;\r\n    let b03 = a01 * a12 - a02 * a11;\r\n    let b04 = a01 * a13 - a03 * a11;\r\n    let b05 = a02 * a13 - a03 * a12;\r\n    let b06 = a20 * a31 - a21 * a30;\r\n    let b07 = a20 * a32 - a22 * a30;\r\n    let b08 = a20 * a33 - a23 * a30;\r\n    let b09 = a21 * a32 - a22 * a31;\r\n    let b10 = a21 * a33 - a23 * a31;\r\n    let b11 = a22 * a33 - a23 * a32;\r\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\treturn mat4x4<f32>(\r\n\t\tvec4<f32>(a11 * b11 - a12 * b10 + a13 * b09,\r\n\t\ta02 * b10 - a01 * b11 - a03 * b09,\r\n\t\ta31 * b05 - a32 * b04 + a33 * b03,\r\n\t\ta22 * b04 - a21 * b05 - a23 * b03) / det,\r\n\t\t\tvec4<f32>(a12 * b08 - a10 * b11 - a13 * b07,\r\n\t\ta00 * b11 - a02 * b08 + a03 * b07,\r\n\t\ta32 * b02 - a30 * b05 - a33 * b01,\r\n\t\ta20 * b05 - a22 * b02 + a23 * b01) / det,\r\n\t\tvec4<f32>(a10 * b10 - a11 * b08 + a13 * b06,\r\n\t\ta01 * b08 - a00 * b10 - a03 * b06,\r\n\t\ta30 * b04 - a31 * b02 + a33 * b00,\r\n\t\ta21 * b02 - a20 * b04 - a23 * b00) / det,\r\n\t\tvec4<f32>(a11 * b07 - a10 * b09 - a12 * b06,\r\n\t\ta00 * b09 - a01 * b07 + a02 * b06,\r\n\t\ta31 * b01 - a30 * b03 - a32 * b00,\r\n\t\ta20 * b03 - a21 * b01 + a22 * b00) / det);\r\n}\r\n\r\n@vertex\r\nfn vertMain(input: VertexInput) -> VertexOutput {\r\n\r\n    var state = f32(cellState[input.instance]);\r\n    var output: VertexOutput;\r\n\tlet f = clamp((lifeState[ input.instance ])/100.0, 0.0005, 1.0);\r\n\tvar scale = 0.5;\r\n\tif(state < 1.0) {\r\n\t\tscale = 0.1;\r\n\t}\r\n\tvar scaleY = 5.0;\r\n\tif(state < 1.0) {\r\n\t\tscaleY = 1.0;\r\n\t}\r\n    var wpos = objMat * vec4f(input.pos.xyz * vec3f(f * 0.5 + scale, f * scaleY + scale , f * 0.5 + scale), 1.0);\r\n\twpos = vec4f(wpos.xyz + wpositions[ input.instance ].xyz, wpos.w);\r\n\r\n  \tlet invMat33 = inverseM33( m44ToM33( objMat ) );\r\n\toutput.normal = normalize( input.normal * invMat33 );\r\n  \toutput.camPos = (inverseM44(viewMat) * vec4<f32>(0.0,0.0,0.0, 1.0)).xyz;\r\n  \toutput.pos = wpos;\r\n\r\n    let i = f32(input.instance);\r\n    let cell = vec2f(i % grid.x, floor(i / grid.x));\r\n\r\n\r\n\r\n    var projPos = projMat * viewMat * wpos;\r\n\t// if(state < 1.0) {\r\n\t// \tprojPos = vec4f(projPos.xyz, -1);\r\n\t// }\r\n    output.position = projPos;\r\n\r\n    output.uv = input.uv;\r\n\r\n\tlet c = cell / grid;\r\n\tvar dis = length(input.uv - vec2<f32>(0.5, 0.5));\r\n\tdis = min(dis/0.51, 1.0);\r\n\tdis = (1.0 - pow(dis, 50.0)) * (1.0 - f) + f;\r\n\tvar c3 = vec3f(c, (1.0 - c.x) * (1.0 - f) + f) * dis;\r\n    output.albedo = c3 * 2.0;\r\n\toutput.param = vec3f(1.1, 0.6 - (f* 0.6) + 0.1, 0.5 + (f* 0.5));\r\n    return output;\r\n}");

/***/ }),

/***/ "bd91":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var EulerOrder;

(function (EulerOrder) {
  EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
  EulerOrder[EulerOrder["YZX"] = 1] = "YZX";
  EulerOrder[EulerOrder["ZXY"] = 2] = "ZXY";
  EulerOrder[EulerOrder["XZY"] = 3] = "XZY";
  EulerOrder[EulerOrder["YXZ"] = 4] = "YXZ";
  EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
})(EulerOrder || (EulerOrder = {}));

exports.EulerOrder = EulerOrder;

/***/ }),

/***/ "bf93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRShaderParams_1 = __webpack_require__("e2cf");

exports.findShaderEntryPoint = WGRShaderParams_1.findShaderEntryPoint;
exports.WGRShadeSrcParam = WGRShaderParams_1.WGRShadeSrcParam;
exports.WGRShderSrcType = WGRShaderParams_1.WGRShderSrcType;

class WGRPipelineCtxParams {
  constructor(param) {
    this.buildDeferred = true;
    this.sampleCount = 1;
    this.multisampleEnabled = false;
    this.depthStencilEnabled = false;
    this.fragmentEnabled = true;
    this.layout = "auto";
    this.vertex = {
      module: null,
      entryPoint: "main",
      buffers: []
    };

    if (param) {
      const selfT = this;

      for (var k in param) {
        selfT[k] = param[k];
      }

      this.depthStencilEnabled = this.depthStencil ? true : this.depthStencilEnabled;

      if (this.depthStencilEnabled && !this.depthStencil) {
        this.depthStencil = {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus" // format: "depth32float"
          // format: "depth24plus"

        };
      }

      if (this.fragmentEnabled) {
        this.fragment = WGRShaderParams_1.createFragmentState();
      }

      this.primitive = {
        frontFace: "ccw",
        topology: "triangle-list",
        cullMode: "back"
      };

      if (this.multisampleEnabled) {
        this.multisample = {
          count: this.sampleCount
        };
      }
    }
  }

  setDepthStencilParam(state) {
    if (this.depthStencilEnabled) {
      this.depthStencil = state;
    }
  }

  setDepthStencil(state) {
    if (state) {
      if (!this.depthStencil) {
        this.depthStencil = state;
      }

      const src = state;
      const dst = this.depthStencil;

      for (var k in src) {
        dst[k] = src[k];
      }
    }
  }

  setDepthWriteEnabled(enabled) {
    this.depthStencilEnabled = enabled;

    if (this.depthStencil) {
      this.depthStencil.depthWriteEnabled = enabled;
    }

    if (enabled) {
      if (!this.depthStencil) {
        this.depthStencil = {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        };
      }
    }
  }

  setDepthStencilFormat(format) {
    if (this.depthStencil) {
      this.depthStencil.format = format;
    }
  }
  /**
   *
   * @param primitiveState cullMode, Possible values are: "back", "front", "none", the default value is "none".
   * 						 frontFace, Possible values are: "cw", "ccw", the default value is "ccw".
   * 						 topology, Possible values are: "triangle-strip", "triangle-list", "point-list", "line-list", "line-strip",
   * 						 the default value is "triangle-list"
   */


  setPrimitiveState(state) {
    if (state) {
      if (!this.primitive) {
        this.primitive = state;
      }

      switch (state.cullMode) {
        case "back":
        case "front":
        case "none":
          this.primitive.cullMode = state.cullMode;
          break;
      }

      switch (state.frontFace) {
        case "cw":
        case "ccw":
          this.primitive.frontFace = state.frontFace;
          break;
      }

      switch (state.topology) {
        case "triangle-strip":
        case "triangle-list":
        case "point-list":
        case "line-list":
        case "line-strip":
          this.primitive.topology = state.topology;
          break;
      }
    }
  }

  setBlendModes(modes) {
    for (let i = 0; i < modes.length; ++i) {
      this.setBlendMode(modes[i], i);
    }
  }

  setBlendMode(mode, targetIndex = 0) {
    let color = {
      srcFactor: "one",
      dstFactor: "zero"
    };
    let alpha = {
      srcFactor: "one",
      dstFactor: "zero"
    };

    switch (mode) {
      case "transparent":
        color = {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha"
        };
        alpha = {
          srcFactor: "zero",
          dstFactor: "one"
        };
        break;

      case "add":
        color = {
          srcFactor: "src-alpha",
          dstFactor: "one"
        };
        alpha = {
          srcFactor: "zero",
          dstFactor: "one"
        };
        break;

      case "alpha_add":
        color = {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha"
        };
        alpha = {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha"
        };
        break;
      // the default mode value is "solid":

      default:
        break;
    }

    this.setBlendParam(color, alpha, targetIndex);
  }

  setBlendParam(color, alpha, targetIndex = 0) {
    if (this.fragmentEnabled) {
      const frag = this.fragment;
      const target = frag.targets[targetIndex];

      if (target.blend) {
        if (color) {
          target.blend.color = color;
        }

        if (alpha) {
          target.blend.alpha = alpha;
        }
      } else {
        target.blend = {
          color,
          alpha
        };
      }
    }
  }

  addFragmentColorTarget(colorState) {
    if (this.fragmentEnabled && colorState) {
      const frag = this.fragment;
      frag.targets.push(colorState);
    }
  }

  setFragmentColorTarget(colorState, targetIndex = 0) {
    if (this.fragmentEnabled && colorState) {
      const frag = this.fragment;
      frag.targets[targetIndex] = colorState;
    }
  }

  setVertexBufferArrayStrideAt(arrayStride, bufferIndex = 0) {
    const vert = this.vertex;

    if (vert.buffers.length < 1) {
      this.addVertexBufferLayout({
        arrayStride: 0,
        attributes: [],
        stepMode: "vertex"
      });
    }

    vert.buffers[bufferIndex].arrayStride = arrayStride;
  }
  /**
   * @param attribute for example: { shaderLocation: 0, offset: 0, format: "float32x4" }
   * @param bufferIndex an index of vertex.buffers
   */


  addVertexBufferAttribute(attribute, bufferIndex = 0) {
    const vert = this.vertex; // console.log("vert.buffers: ", vert.buffers);

    if (vert.buffers.length < 1) {
      this.addVertexBufferLayout({
        arrayStride: 0,
        attributes: [],
        stepMode: "vertex"
      });
    }

    let attributes = vert.buffers[bufferIndex].attributes;
    attributes.push(attribute);
  }
  /**
   * @param vtxBufLayout for example: {arrayStride: 0, attributes: [], stepMode: "vertex"}
   */


  addVertexBufferLayout(vtxBufLayout) {
    const vert = this.vertex;
    vert.buffers.push(vtxBufLayout);
  }

}

exports.WGRPipelineCtxParams = WGRPipelineCtxParams;

/***/ }),

/***/ "c14c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

class RSceneTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {
      console.log("mousedown evt call ...");
    };
  }

  initialize() {
    console.log("RSceneTest::initialize() ...");
    this.initEvent();
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const materials = [this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")], ["solid"], "back"), this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/brickwall_big512.jpg")], ["solid"], "back"), this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/metal_02.jpg")], ["solid"], "back")];
    this.createEntities(materials, new Vector3_1.default(0, 200, 0));
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let ufv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([1, 1, 1, 1])
    });
    material.uniformValues = [ufv];
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createGeom(rgd) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    return geometry;
  }

  createEntities(materials, pv) {
    const rc = this.mRscene;
    pv = pv ? pv : new Vector3_1.default();
    let sphGeom = this.createGeom(this.geomData.createSphere(30, 30, 30));
    let boxGeom = this.createGeom(this.geomData.createCube(100));
    let torusGeom = this.createGeom(this.geomData.createTorus(100));
    const floor = new Entity3D_1.Entity3D();
    floor.materials = [materials[0]];
    floor.geometry = boxGeom;
    floor.transform.setPosition(new Vector3_1.default(0, -150, 0).addBy(pv));
    floor.transform.setScaleXYZ(8, 0.1, 8);
    rc.addEntity(floor);

    for (let i = 0; i < 6; ++i) {
      const torus = new Entity3D_1.Entity3D();
      torus.materials = [materials[1]];
      torus.geometry = torusGeom;
      torus.transform.setPosition(new Vector3_1.default(-200 + i * 80, 0, 0).addBy(pv));
      rc.addEntity(torus);
    }

    for (let i = 0; i < 12; ++i) {
      const sphere = new Entity3D_1.Entity3D();
      sphere.materials = [materials[2]];
      sphere.geometry = sphGeom;
      sphere.transform.setPosition(new Vector3_1.default(-400 + i * 80, 0, 0).addBy(pv));
      rc.addEntity(sphere);
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.RSceneTest = RSceneTest;

/***/ }),

/***/ "c29f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const utils_1 = __webpack_require__("71f1");

const WGGeometry_1 = __webpack_require__("746a");

const PrimitiveEntity_1 = __webpack_require__("1eee");

class ModelEntity extends PrimitiveEntity_1.PrimitiveEntity {
  constructor(param) {
    let flag = param.modelUrl !== undefined && param.geometry === undefined;

    if (flag) {
      param.building = false;
    }

    super(param);

    if (flag) {
      this.initModel();
    }
  }

  createModelGeometry(gd) {
    const g = new WGGeometry_1.WGGeometry().addAttribute({
      position: gd.vertices
    }).addAttribute({
      uv: gd.uvsList[0]
    }).addAttribute({
      normal: gd.normals
    }).setIndices(gd.indices);
    return g; // console.log("ModelEntity::createModelGeometry(), this.geometry: ", this.geometry);
  }

  initModel() {
    let url = this.mDescParam.modelUrl;
    utils_1.modelLoader.load([url], (models, transforms) => {
      console.log("ModelEntity::initModel(), loaded models: ", models);
      let len = models.length;

      for (let i = 0; i < len; ++i) {
        this.geometry = this.createModelGeometry(models[i]);
        this.mDescParam.building = true;
        this.init(this.mDescParam);
        this.createMaterial(this.mDescParam);
        break;
      }
    });
  }

}

exports.ModelEntity = ModelEntity;

/***/ }),

/***/ "c3d6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const AbsGeomBase_1 = __importDefault(__webpack_require__("9e08"));

class RadialLine extends AbsGeomBase_1.default {
  constructor() {
    super(...arguments);
    this.tv = new Vector3_1.default(1.0, 0.0, 0.0);
  }

  update() {
    this.tv.normalize();
  }

  updateFast() {
    this.tv.normalize();
  } // 射线和三个点表示的三角形是否相交


  static IntersectionTri(rlpv, rltv, triva, trivb, trivc, outV) {
    return 0;
  } // 射线和两个点表示的线段是否相交


  static IntersectionLS(rlpv, rltv, lspva, lspvb, outV, radius = 1.0) {
    let pv = RadialLine.__tAv;
    pv.copyFrom(lspvb);
    pv.subtractBy(lspva);
    pv.normalize();
    Vector3_1.default.Cross(rltv, pv, outV);
    outV.normalize();
    pv.w = outV.dot(rlpv) - outV.dot(lspvb);

    if (Math.abs(pv.w) <= radius) {
      // 两条直线已经相交
      // outV 和 rlpv rltv 计算构成了一个平面
      outV.crossBy(rltv);
      outV.normalize();
      outV.w = outV.dot(rlpv); // 计算 lspva 所在的直线与平面的交点
      //let tv2:Vector3 = AbsGeomBase.__tV1;

      pv.w = (outV.w - outV.dot(lspva)) / pv.dot(outV);
      outV.copyFrom(pv);
      outV.scaleBy(pv.w);
      outV.addBy(lspva);
      pv.copyFrom(outV);
      pv.subtractBy(lspva);
      let pv1 = AbsGeomBase_1.default.__tV1;
      pv1.copyFrom(outV);
      pv1.subtractBy(lspvb);

      if (pv.dot(pv1) <= 0.0) {
        return 1;
      }
    }

    return 0;
  }
  /**
   * @param rlpv 射线起点
   * @param rltv  射线朝向
   * @param cv 球心坐标
   * @param radius 球体半径
   * @param outV 如果相交，记录下交点
   * @returns 检测得到距离射线起点最近的点, 1表示相交, 0表示不相交
   */


  static IntersectioNearSphere2(rlpv, rltv, cv, radius, outV) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);
    radius *= radius;

    if (pv.w > MathConst_1.default.MATH_MIN_POSITIVE) {
      outV.copyFrom(rltv);
      outV.scaleBy(pv.w);
      outV.subtractBy(pv);
      pv.x = outV.getLengthSquared();

      if (pv.x <= radius) {
        // 远距离
        //outV.w = pv.w + Math.sqrt(radius * radius - outV.getLengthSquared());
        // 取近距离
        pv.w -= Math.sqrt(radius - pv.x);
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    } else if (pv.getLengthSquared() <= radius) {
      outV.copyFrom(rltv);
      outV.scaleBy(pv.w);
      outV.subtractBy(pv);
      pv.x = outV.getLengthSquared();

      if (pv.x <= radius) {
        // 取远距离
        pv.w += Math.sqrt(radius - pv.x);
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    }

    return 0;
  } // @return 检测得到距离射线起点最近的点, 1表示相交,0表示不相交


  static IntersectioNearSphere(rlpv, rltv, cv, radius, outV) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);

    if (pv.w > MathConst_1.default.MATH_MIN_POSITIVE) {
      outV.x = pv.x - pv.w * rltv.x;
      outV.y = pv.y - pv.w * rltv.y;
      outV.z = pv.z - pv.w * rltv.z;
      outV.x = outV.getLengthSquared();
      outV.w = radius * radius;

      if (outV.x <= outV.w) {
        // rlpv到远交点记作XP, rlpv到球心记作CP, CP到远交点记作RP
        // 通过余弦定律得到一元二次方程得并且解这个方程得到 XP 的距离
        // 获得CP距离的平方值
        outV.x = pv.getLengthSquared(); // RP距离的平方值 减去 CP距离的平方值

        outV.z = outV.w - outV.x; //	// 获得CP距离值
        //	outV.w = Math.sqrt(outV.x);
        // 准备计算 CP和XP 之间夹角a的余弦值, cos(a)值

        pv.normalize(); // cos(a) 值 和 CP距离值相乘
        //pv.y = pv.dot(rltv) * outV.w;

        outV.y = pv.dot(rltv) * Math.sqrt(outV.x); // 求解方程的根,得到近些的距离

        pv.w = (-outV.y + Math.sqrt(outV.y * outV.y + 4.0 * outV.z)) * 0.5;
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    } else {
      outV.x = pv.getLengthSquared();
      outV.w = radius * radius;

      if (outV.x <= outV.w) {
        outV.z = outV.w - outV.x;
        pv.normalize();
        outV.y = pv.dot(rltv) * Math.sqrt(outV.x); // 求解方程的根,得到远些的距离

        pv.w = (-outV.y + Math.sqrt(outV.y * outV.y + 4.0 * outV.z)) * 0.5;
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    }

    return 0;
  }

  static IntersectSphere(rlpv, rltv, cv, radius) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);

    if (pv.w < MathConst_1.default.MATH_MIN_POSITIVE) {
      return pv.getLengthSquared() <= radius * radius;
    }

    pv.x -= pv.w * rltv.x;
    pv.y -= pv.w * rltv.y;
    pv.z -= pv.w * rltv.z;
    return pv.getLengthSquared() <= radius * radius;
  }

}

RadialLine.__tAv = new Vector3_1.default();
exports.default = RadialLine;

/***/ }),

/***/ "c433":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Matrix4Pool_1 = __importDefault(__webpack_require__("4e74"));

const WGRUniformValue_1 = __webpack_require__("7650");

const MatrixUtils_1 = __webpack_require__("406a");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const v3 = new Vector3_1.default();

class ROTransform {
  constructor(fs32) {
    this.mUid = ROTransform.sUid++;
    this.mFS32 = null; // It is a flag that need inverted mat yes or no

    this.mInvMat = false;
    this.mRot = false;
    this.mDt = 0;
    this.version = -1;
    /**
     * the default value is 0
     */

    this.__$transUpdate = 0;
    this.updatedStatus = ROTransform.POSITION;
    this.updateStatus = ROTransform.TRANSFORM;
    this.mToParentMatFlag = true;
    this.mDt = fs32 ? 1 : 0;
    this.mFS32 = fs32 ? fs32 : new Float32Array(16);
  }

  set transform(t) {
    if (t) {
      this.setScale(t.scale);
      this.setRotation(t.rotation);
      this.setPosition(t.position);

      if (t.matrix && t.matrix.length == 16) {
        this.mFS32.set(t.matrix);
      }
    }
  }

  get transform() {
    return {
      scale: this.getScale(),
      rotation: this.getRotation(),
      position: this.getPosition()
    };
  }

  get uid() {
    return this.mUid;
  }

  get fs32Data() {
    return this.mFS32;
  }
  /**
   * 防止因为共享 fs32 数据带来的逻辑错误
   */


  rebuildFS32Data() {
    if (this.mDt > 0) {
      this.mDt = 0;
      this.mFS32 = new Float32Array(16);
    }
  }

  getRotationFlag() {
    return this.mRot;
  }

  getX() {
    return this.mFS32[12];
  }

  getY() {
    return this.mFS32[13];
  }

  getZ() {
    return this.mFS32[14];
  }

  setX(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.mFS32[12] = p;
    this.updateTo();
    return this;
  }

  setY(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.mFS32[13] = p;
    this.updateTo();
    return this;
  }

  setZ(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.mFS32[14] = p;
    this.updateTo();
    return this;
  }

  setXYZ(px, py, pz) {
    this.mFS32[12] = px;
    this.mFS32[13] = py;
    this.mFS32[14] = pz;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.updateTo();
    return this;
  }

  offsetPosition(pv) {
    v3.setXYZ(0, 0, 0).setVector3(pv);
    this.mFS32[12] += v3.x;
    this.mFS32[13] += v3.y;
    this.mFS32[14] += v3.z;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.updateTo();
    return this;
  }

  setPosition(pv) {
    v3.setXYZ(0, 0, 0).setVector3(pv);
    this.mFS32[12] = v3.x;
    this.mFS32[13] = v3.y;
    this.mFS32[14] = v3.z;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.updateTo();
    return this;
  }

  getPosition(pv) {
    if (!pv) pv = new Vector3_1.default();
    pv.x = this.mFS32[12];
    pv.y = this.mFS32[13];
    pv.z = this.mFS32[14];
    return pv;
  }

  copyPositionFrom(t) {
    if (t) {
      this.mFS32[12] = t.mFS32[12];
      this.mFS32[13] = t.mFS32[13];
      this.mFS32[14] = t.mFS32[14];
      this.updateStatus |= ROTransform.POSITION;
      this.updatedStatus |= ROTransform.POSITION;
      this.updateTo();
    }

    return this;
  }

  getRotationX() {
    return this.mFS32[1];
  }

  getRotationY() {
    return this.mFS32[6];
  }

  getRotationZ() {
    return this.mFS32[9];
  }

  setRotationX(degrees) {
    this.mFS32[1] = degrees;
    this.mRot = true;
    this.updateStatus |= ROTransform.ROTATION;
    this.updatedStatus |= ROTransform.ROTATION;
    this.updateTo();
    return this;
  }

  setRotationY(degrees) {
    this.mFS32[6] = degrees;
    this.mRot = true;
    this.updateStatus |= ROTransform.ROTATION;
    this.updatedStatus |= ROTransform.ROTATION;
    this.updateTo();
    return this;
  }

  setRotationZ(degrees) {
    this.mFS32[9] = degrees;
    this.mRot = true;
    this.updateStatus |= ROTransform.ROTATION;
    this.updatedStatus |= ROTransform.ROTATION;
    this.updateTo();
    return this;
  }

  setRotationXYZ(rx, ry, rz) {
    this.mFS32[1] = rx;
    this.mFS32[6] = ry;
    this.mFS32[9] = rz;
    this.updateStatus |= ROTransform.ROTATION;
    this.updatedStatus |= ROTransform.ROTATION;
    this.mRot = true;
    this.updateTo();
    return this;
  }

  setRotation(pv) {
    v3.setXYZ(0, 0, 0).setVector3(pv);
    this.setRotationXYZ(v3.x, v3.y, v3.z);
    return this;
  }

  getRotation(pv) {
    if (!pv) pv = new Vector3_1.default();
    pv.x = this.mFS32[1];
    pv.y = this.mFS32[6];
    pv.z = this.mFS32[9];
    return pv;
  }

  getScaleX() {
    return this.mFS32[0];
  }

  getScaleY() {
    return this.mFS32[5];
  }

  getScaleZ() {
    return this.mFS32[10];
  }

  setScaleX(p) {
    this.mFS32[0] = p;
    this.updateStatus |= ROTransform.SCALE;
    this.updatedStatus |= ROTransform.SCALE;
    return this;
  }

  setScaleY(p) {
    this.mFS32[5] = p;
    this.updateStatus |= ROTransform.SCALE;
    this.updatedStatus |= ROTransform.SCALE;
    return this;
  }

  setScaleZ(p) {
    this.mFS32[10] = p;
    this.updateStatus |= ROTransform.SCALE;
    this.updatedStatus |= ROTransform.SCALE;
    return this;
  }

  setScaleXYZ(sx, sy, sz) {
    this.mFS32[0] = sx;
    this.mFS32[5] = sy;
    this.mFS32[10] = sz;
    this.updateStatus |= ROTransform.SCALE;
    this.updatedStatus |= ROTransform.SCALE;
    this.updateTo();
    return this;
  }

  setScale(pv) {
    v3.setXYZ(1, 1, 1).setVector3(pv);
    this.setScaleXYZ(v3.x, v3.y, v3.z);
    return this;
  }

  getScale(pv) {
    if (!pv) pv = new Vector3_1.default();
    pv.x = this.mFS32[0];
    pv.y = this.mFS32[5];
    pv.z = this.mFS32[10];
    return pv;
  }

  setScaleAll(s) {
    this.mFS32[0] = s;
    this.mFS32[5] = s;
    this.mFS32[10] = s;
    this.updateStatus |= ROTransform.SCALE;
    this.updatedStatus |= ROTransform.SCALE;
    this.updateTo();
    return this;
  }

  localToGlobal(pv) {
    this.getMatrix().transformVectorSelf(pv);
  }

  globalToLocal(pv) {
    this.getInvMatrix().transformVectorSelf(pv);
  } // maybe need call update function


  getInvMatrix() {
    if (this.mInvOmat) {
      if (this.mInvMat) {
        this.mInvOmat.copyFrom(this.mOMat);
        this.mInvOmat.invert();
      }
    } else {
      this.mInvOmat = Matrix4Pool_1.default.GetMatrix();
      this.mInvOmat.copyFrom(this.mOMat);
      this.mInvOmat.invert();
    }

    this.mInvMat = false;
    return this.mInvOmat;
  }

  getLocalMatrix() {
    if (this.updateStatus > 0) {
      this.update();
    }

    return this.mLocalMat;
  } // get local to world matrix, maybe need call update function


  getMatrix(flag = true) {
    if (this.updateStatus > 0 && flag) {
      this.update();
    }

    return this.mOMat;
  } // get local to parent space matrix, maybe need call update function


  getToParentMatrix() {
    if (this.mToParentMat) {
      //  if(this.mToParentMatFlag)
      //  {
      //      console.log("....");
      //      this.mToParentMat.invert();
      //  }
      return this.mToParentMat;
    }

    return this.mOMat;
  } // local to world matrix, 使用的时候注意数据安全->防止多个显示对象拥有而出现多次修改的问题,因此此函数尽量不要用


  setParentMatrix(matrix) {
    //  console.log("sTOTransform::etParentMatrix(), this.mParentMat != matrix: ",(this.mParentMat != matrix),this.mUid);
    this.mParentMat = matrix;
    this.mInvMat = true;

    if (this.mParentMat) {
      if (this.mLocalMat == this.mOMat) {
        this.updateStatus = ROTransform.TRANSFORM;
        this.updatedStatus = this.updateStatus;
        this.mLocalMat = Matrix4Pool_1.default.GetMatrix();
      } else {
        this.updateStatus |= ROTransform.PARENT_MAT;
        this.updatedStatus = this.updateStatus;
      }

      this.updateTo();
    }

    return this;
  }

  getParentMatrix() {
    return this.mParentMat;
  }

  updateMatrixData(matrix) {
    if (matrix) {
      this.updateStatus = ROTransform.NONE;
      this.mInvMat = true;
      this.mOMat.copyFrom(matrix);
      this.updateTo();
    }

    return this;
  }

  __$setMatrix(matrix) {
    if (matrix != null) {
      this.updateStatus = ROTransform.NONE;
      this.mInvMat = true;

      if (this.mLocalMat == this.mOMat) {
        this.mLocalMat = matrix;
      }

      if (this.mOMat) {
        Matrix4Pool_1.default.RetrieveMatrix(this.mOMat);
      }

      this.mOMat = matrix;
      this.updateTo();
    }
  }

  destroy() {
    // 当自身被完全移出RenderWorld之后才能执行自身的destroy
    if (this.mInvOmat) Matrix4Pool_1.default.RetrieveMatrix(this.mInvOmat);

    if (this.mLocalMat) {
      Matrix4Pool_1.default.RetrieveMatrix(this.mLocalMat);
    }

    if (this.mOMat && this.mOMat != this.mLocalMat) {
      Matrix4Pool_1.default.RetrieveMatrix(this.mOMat);
    }

    this.mInvOmat = null;
    this.mLocalMat = null;
    this.mOMat = null;
    this.mParentMat = null;
    this.updateStatus = ROTransform.TRANSFORM;
    this.mFS32 = null; // this.wrapper = null;
  }

  copyFrom(src) {
    this.mFS32.set(src.mFS32, 0);
    this.updatedStatus |= 1;
    this.updateStatus |= ROTransform.TRANSFORM;
    this.mRot = src.mRot;
    this.updateTo();
    return;
  }

  forceUpdate() {
    this.updateStatus |= ROTransform.TRANSFORM;
    this.update();
    return;
  }

  updateTo() {// if (this.wrapper) this.wrapper.updateTo();
  } // setUpdater(updater: ITransUpdater): void {
  // 	// if (this.wrapper) this.wrapper.setUpdater(updater);
  // }


  isDirty() {
    return this.updateStatus != ROTransform.NONE;
  }

  update() {
    let st = this.updateStatus;

    if (st > 0) {
      this.mInvMat = true;
      st = st | this.updatedStatus;

      if ((st & ROTransform.TRANSFORM) > 0) {
        const factor = MathConst_1.default.MATH_PI_OVER_180;
        this.mLocalMat.getLocalFS32().set(this.mFS32, 0);

        if (this.mRot) {
          this.mLocalMat.setRotationEulerAngle(this.mFS32[1] * factor, this.mFS32[6] * factor, this.mFS32[9] * factor);
        }

        if (this.mParentMat) {
          st = st | ROTransform.PARENT_MAT;
        }
      }

      if (this.mOMat != this.mLocalMat) {
        this.mOMat.copyFrom(this.mLocalMat);
      }

      if ((st & ROTransform.PARENT_MAT) == ROTransform.PARENT_MAT) {
        if (this.mToParentMat) {
          this.mToParentMat.copyFrom(this.mOMat);
        } else {
          this.mToParentMat = Matrix4Pool_1.default.GetMatrix();
          this.mToParentMat.copyFrom(this.mOMat);
        }

        this.mToParentMatFlag = true;
        this.mOMat.append(this.mParentMat);
      }

      st = ROTransform.NONE;
      this.version++;
      this.uniformv.upate();
    }

    this.updateStatus = st;
    this.__$transUpdate = 0;
  }

  getMatrixFS32() {
    return this.getMatrix().getLocalFS32();
  }

  static GetFreeId() {
    if (ROTransform.sFreeIds.length > 0) {
      return ROTransform.sFreeIds.pop();
    }

    return -1;
  }

  static Create(param) {
    param = param ? param : {};
    let unit;
    const index = param.fs32 ? -1 : ROTransform.GetFreeId();

    if (index >= 0) {
      unit = ROTransform.sUList[index];
      ROTransform.sFlags[index] = ROTransform.sFBUSY;
      unit.rebuildFS32Data();
    } else {
      unit = new ROTransform(param.fs32);
      ROTransform.sUList.push(unit);
      ROTransform.sFlags.push(ROTransform.sFBUSY);
    }

    if (param.matrix) {
      unit.mOMat = param.matrix;
    } else {
      unit.mOMat = Matrix4Pool_1.default.GetMatrix();
    }

    unit.mLocalMat = unit.mOMat;

    if (!param.fs32) {
      const ida = MatrixUtils_1.IdentityMat4Data;

      if (unit.mFS32) {
        unit.mFS32.set(ida, 0);
      } else {
        unit.mFS32 = ida.slice(0);
      }
    }

    unit.uniformv = new WGRUniformValue_1.WGRUniformValue({
      data: unit.mOMat.getLocalFS32(),
      shdVarName: "objMat"
    });

    if (param.transform) {
      unit.transform = param.transform;
    }

    return unit;
  }

  static Restore(pt) {
    if (pt && ROTransform.sFlags[pt.uid] == ROTransform.sFBUSY) {
      const uid = pt.uid;
      ROTransform.sFreeIds.push(uid);
      ROTransform.sFlags[uid] = ROTransform.sFFREE;
      pt.destroy();
    }
  }

}

ROTransform.sUid = 0;
ROTransform.NONE = 0;
ROTransform.POSITION = 1;
ROTransform.ROTATION = 2;
ROTransform.SCALE = 4;
ROTransform.TRANSFORM = 7;
ROTransform.PARENT_MAT = 8;
ROTransform.sFBUSY = 1;
ROTransform.sFFREE = 0;
ROTransform.sFlags = [];
ROTransform.sUList = [];
ROTransform.sFreeIds = [];
exports.default = ROTransform;

/***/ }),

/***/ "c4ad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const AxisEntity_1 = __webpack_require__("603e");

const BoundsFrameEntity_1 = __webpack_require__("1ee1");

const BoxEntity_1 = __webpack_require__("5009");

const ConeEntity_1 = __webpack_require__("97f2");

const CubeEntity_1 = __webpack_require__("0069");

const CylinderEntity_1 = __webpack_require__("76e3");

const Line3DEntity_1 = __webpack_require__("648f");

const ModelEntity_1 = __webpack_require__("c29f");

const PlaneEntity_1 = __webpack_require__("7e70");

const RectLineGridEntity_1 = __webpack_require__("6d7a");

const SphereEntity_1 = __webpack_require__("9849");

const TorusEntity_1 = __webpack_require__("5118");

const ettyes = ['axis', 'line', 'rectLineGrid', 'boundsFrame', 'plane', 'box', 'cube', 'sphere', 'cylinder', 'cone', 'torus', 'model', 'container'];

function ddeParamFilter(d) {
  if (!d) {
    return d;
  }

  let rd = d;

  for (let i = 0; i < ettyes.length; ++i) {
    rd = d[ettyes[i]]; // console.log('rd: ', rd, ', key: ', ettyes[i]);

    if (rd) {
      rd.entityType = ettyes[i];
      console.log("rd.entityType: ", rd.entityType);
      break;
    }
  }

  if (!rd) rd = d;
  return rd;
}

function createEntity(param) {
  let entity;

  if (param) {
    let et = param.entity;

    switch (param.entityType) {
      case 'axis':
        if (et.size !== undefined) {
          et.axisLength = et.size;
        }

        et.size = undefined;
        entity = new AxisEntity_1.AxisEntity(param.entity);
        break;

      case 'line':
        entity = new Line3DEntity_1.Line3DEntity(param.entity);
        break;

      case 'rectLineGrid':
        entity = new RectLineGridEntity_1.RectLineGridEntity(param.entity);
        break;

      case 'boundsFrame':
        entity = new BoundsFrameEntity_1.BoundsFrameEntity(param.entity);
        break;

      case 'plane':
        entity = new PlaneEntity_1.PlaneEntity(param.entity);
        break;

      case 'box':
        et = param.entity;

        if (et.size !== undefined) {
          et.cubeSize = et.size;
        }

        et.size = undefined;
        entity = new BoxEntity_1.BoxEntity(param.entity);
        break;

      case 'cube':
        entity = new CubeEntity_1.CubeEntity(param.entity);
        break;

      case 'sphere':
        entity = new SphereEntity_1.SphereEntity(param.entity);
        break;

      case 'cylinder':
        entity = new CylinderEntity_1.CylinderEntity(param.entity);
        break;

      case 'cone':
        entity = new ConeEntity_1.ConeEntity(param.entity);
        break;

      case 'torus':
        entity = new TorusEntity_1.TorusEntity(param.entity);
        break;

      case 'model':
        et = param.entity;

        if (et.url !== undefined) {
          et.modelUrl = et.url;
        }

        et.url = undefined;
        entity = new ModelEntity_1.ModelEntity(param.entity);
        break;

      case 'container':
        // entity = new AxisEntity(param.entity);
        break;

      default:
        break;
    }

    if (entity) {
      param.uid = entity.uid;
    }
  }

  return entity;
}

class DataDrivenEntityBuilder {
  constructor() {}

  createEntity(param) {
    let et;

    if (param) {
      let p = param;
      let ep = ddeParamFilter(p);
      et = createEntity(ep);
    } else {
      throw Error('Illegal Operation !!!');
    }

    return et;
  }

}

exports.DataDrivenEntityBuilder = DataDrivenEntityBuilder;

/***/ }),

/***/ "c58a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class DivTool {
  /**
   * 水平均匀排列
   */
  static hArrangementDivs(divChildren) {
    if (divChildren.length > 0) {
      let parentDiv = divChildren[0].parentElement;

      if (parentDiv) {
        let parent_rect = parentDiv.getBoundingClientRect();
        let sizeTotal = 0;

        for (let i = 0; i < divChildren.length; ++i) {
          const r = divChildren[i].getBoundingClientRect();
          sizeTotal += r.width;
        }

        let dis = parent_rect.width - sizeTotal;
        let px = dis * 0.5;
        dis /= divChildren.length + 1;
        console.log("hArrangementDivs(), dis: ", dis, "parent_rect.width: ", parent_rect.width, ", sizeTotal: ", sizeTotal, ", px: ", px);

        if (dis <= 0) {
          dis = 0;
        } else {
          px = (parent_rect.width - sizeTotal - dis * (divChildren.length - 1)) * 0.5;
        }

        for (let i = 0; i < divChildren.length; ++i) {
          let div = divChildren[i];
          const r = div.getBoundingClientRect();
          div.style.left = Math.round(px) + "px";
          px += r.width + dis;
        }
      }
    }
  }

  static createDiv(pw, ph, display = "", position = "", center = false) {
    const div = document.createElement("div");
    let style = div.style;

    if (pw > 0 && ph > 0) {
      style.width = pw + "px";
      style.height = ph + "px";
    }

    style.display = "block";

    if (display != "") {
      style.display = display;
    }

    style.position = "relative";

    if (position != "") {
      style.position = position;
    }

    if (center) {
      style.alignItems = "center";
      style.justifyContent = "center";
    }

    return div;
  }
  /**
   * @param px the div left
   * @param py the div top
   * @param pw the div width
   * @param ph the div height
   * @param display the default value is ""
   * @param position the default value is ""
   * @param center the default value is false
   * @returns a HTMLDivElement instance
   */


  static createDivT1(px, py, pw, ph, display = "", position = "", center = true) {
    const div = document.createElement("div");
    let style = div.style;
    style.left = px + "px";
    style.top = py + "px";

    if (pw > 0 && ph > 0) {
      style.width = pw + "px";
      style.height = ph + "px";
    }

    style.display = "block";

    if (display != "") {
      style.display = display;
    }

    style.position = "relative";

    if (position != "") {
      style.position = position;
    }

    if (center) {
      style.alignItems = "center";
      style.justifyContent = "center";
    }

    return div;
  }

  static clearDivAllEles(div) {
    div.replaceChildren();
  }

  static setVisible(div, visible) {
    let style = div.style;

    if (visible) {
      style.visibility = "visible";
    } else {
      style.visibility = "hidden";
    }
  }

  static isVisible(div) {
    return div.style.visibility == "visible";
  }

  static setTextColor(div, uint24) {
    div.style.color = "#" + uint24.toString(16);
  }

}

exports.DivTool = DivTool;

/***/ }),

/***/ "c69e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// mouse or touch event

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

class MouseEvent extends EventBase_1.default {
  constructor() {
    super(); // 物体空间坐标

    this.lpos = new Vector3_1.default(); // 世界坐标

    this.wpos = new Vector3_1.default();
    /**
     * the direction on a ray line in the world space
     */

    this.raytv = new Vector3_1.default(1.0, 0.0, 0.0);
    /**
     * the point on a ray line in the world space
     */

    this.raypv = new Vector3_1.default(0.0, 0.0, 0.0); // 屏幕空间鼠标坐标,和gpu空间对齐

    this.mouseX = 0.0;
    this.mouseY = 0.0; // 屏幕空间页面鼠标坐标

    this.mouseViewX = 0.0;
    this.mouseViewY = 0.0; // 例如多点触摸的时候就会有这个数据

    this.posArray = null; // 鼠标滚轮速度

    this.wheelDeltaY = 0;
  }

  static GetMouseEvtTypeValueBase() {
    return 5001;
  }

  static GetMouseEvtTypeValuesTotal() {
    return 24;
  }

  getClassType() {
    return MouseEvent.EventClassType;
  }

}

MouseEvent.EventClassType = 1002;
MouseEvent.MOUSE_DOWN = 5001;
MouseEvent.MOUSE_UP = 5002;
MouseEvent.MOUSE_RIGHT_UP = 5003;
MouseEvent.MOUSE_RIGHT_DOWN = 5004;
MouseEvent.MOUSE_MOVE = 5005;
MouseEvent.MOUSE_WHEEL = 5006;
MouseEvent.MOUSE_OVER = 5007;
MouseEvent.MOUSE_OUT = 5008;
MouseEvent.MOUSE_CLICK = 5009;
MouseEvent.MOUSE_RIGHT_CLICK = 5010;
MouseEvent.MOUSE_DOUBLE_CLICK = 5011;
MouseEvent.MOUSE_CANCEL = 5012;
MouseEvent.MOUSE_MULTI_DOWN = 5013;
MouseEvent.MOUSE_MULTI_UP = 5014;
MouseEvent.MOUSE_MULTI_MOVE = 5015;
MouseEvent.MOUSE_BG_DOWN = 5016; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_UP = 5017; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_CLICK = 5018; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_MIDDLE_DOWN = 5019;
MouseEvent.MOUSE_MIDDLE_UP = 5020;
MouseEvent.MOUSE_BG_RIGHT_DOWN = 5021; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_RIGHT_UP = 5022; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_MIDDLE_DOWN = 5023; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_MIDDLE_UP = 5024; //  mouse up do not hit any 3d object, only in stage

exports.default = MouseEvent;

/***/ }),

/***/ "c6d1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const EulerOrder_1 = __webpack_require__("bd91");

const OrientationType_1 = __importDefault(__webpack_require__("cbb4"));

const MatrixUtils_1 = __webpack_require__("406a");

class Matrix4 {
  constructor(pfs32, index = 0) {
    this.mUid = -1;
    this.mIndex = 0;
    this.mIndex = index;

    if (pfs32) {
      this.mUid = Matrix4.sUid++;
      this.mFS32 = pfs32;
      this.mLocalFS32 = this.mFS32.subarray(index, index + 16);
    } else {
      this.mUid = Matrix4.sIsolatedUid++;
      this.mFS32 = new Float32Array(16);
      this.mFS32.set(MatrixUtils_1.IdentityMat4Data, 0);
      this.mLocalFS32 = this.mFS32;
    }
  }

  fromArray(array, offset = 0) {
    const fs = this.mLocalFS32;

    for (let i = 0; i < 16; i++) {
      fs[i] = array[i + offset];
    }

    return this;
  }

  setData(array16) {
    if (array16.length == 16) {
      this.mLocalFS32.set(array16);
    }

    return this;
  }

  getCapacity() {
    return 16;
  }

  GetMaxUid() {
    return Matrix4.sUid;
  }

  getUid() {
    return this.mUid;
  }

  getLocalFS32() {
    return this.mLocalFS32;
  }

  getFS32() {
    return this.mFS32;
  }

  getFSIndex() {
    return this.mIndex;
  }

  identity() {
    this.mLocalFS32.set(MatrixUtils_1.IdentityMat4Data, 0);
  }

  determinant() {
    let lfs = this.mLocalFS32;
    return (lfs[0] * lfs[5] - lfs[4] * lfs[1]) * (lfs[10] * lfs[15] - lfs[14] * lfs[11]) - (lfs[0] * lfs[9] - lfs[8] * lfs[1]) * (lfs[6] * lfs[15] - lfs[14] * lfs[7]) + (lfs[0] * lfs[13] - lfs[12] * lfs[1]) * (lfs[6] * lfs[11] - lfs[10] * lfs[7]) + (lfs[4] * lfs[9] - lfs[8] * lfs[5]) * (lfs[2] * lfs[15] - lfs[14] * lfs[3]) - (lfs[4] * lfs[13] - lfs[12] * lfs[5]) * (lfs[2] * lfs[11] - lfs[10] * lfs[3]) + (lfs[8] * lfs[13] - lfs[12] * lfs[9]) * (lfs[2] * lfs[7] - lfs[6] * lfs[3]);
  }

  multiplyMatrices(a, b) {
    const ae = a.getLocalFS32();
    const be = b.getLocalFS32();
    const fs = this.getLocalFS32();
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    fs[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    fs[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    fs[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    fs[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    fs[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    fs[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    fs[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    fs[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    fs[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    fs[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    fs[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    fs[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    fs[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    fs[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    fs[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    fs[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiply(ma, mb = null) {
    if (ma != null && mb != null) {
      return this.multiplyMatrices(ma, mb);
    } else if (ma != null) {
      return this.multiplyMatrices(this, ma);
    }

    return this;
  }

  premultiply(m) {
    if (m != this && m != null) {
      return this.multiplyMatrices(m, this);
    }

    return this;
  }

  append(lhs) {
    let lfs32 = lhs.getLocalFS32();
    let fs = this.mLocalFS32;
    let m111 = fs[0];
    let m121 = fs[4];
    let m131 = fs[8];
    let m141 = fs[12];
    let m112 = fs[1];
    let m122 = fs[5];
    let m132 = fs[9];
    let m142 = fs[13];
    let m113 = fs[2];
    let m123 = fs[6];
    let m133 = fs[10];
    let m143 = fs[14];
    let m114 = fs[3];
    let m124 = fs[7];
    let m134 = fs[11];
    let m144 = fs[15];
    let m211 = lfs32[0];
    let m221 = lfs32[4];
    let m231 = lfs32[8];
    let m241 = lfs32[12];
    let m212 = lfs32[1];
    let m222 = lfs32[5];
    let m232 = lfs32[9];
    let m242 = lfs32[13];
    let m213 = lfs32[2];
    let m223 = lfs32[6];
    let m233 = lfs32[10];
    let m243 = lfs32[14];
    let m214 = lfs32[3];
    let m224 = lfs32[7];
    let m234 = lfs32[11];
    let m244 = lfs32[15];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
    fs[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
    fs[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
    fs[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
    fs[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
    fs[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
    fs[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
    fs[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
  }

  append3x3(lhs) {
    let lfs32 = lhs.getLocalFS32();
    let fs = this.mLocalFS32;
    let m111 = fs[0];
    let m121 = fs[4];
    let m131 = fs[8];
    let m112 = fs[1];
    let m122 = fs[5];
    let m132 = fs[9];
    let m113 = fs[2];
    let m123 = fs[6];
    let m133 = fs[10];
    let m211 = lfs32[0];
    let m221 = lfs32[4];
    let m231 = lfs32[8];
    let m212 = lfs32[1];
    let m222 = lfs32[5];
    let m232 = lfs32[9];
    let m213 = lfs32[2];
    let m223 = lfs32[6];
    let m233 = lfs32[10];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233;
  }

  appendRotationPivot(radian, axis, pivotPoint = null) {
    if (pivotPoint == null) {
      pivotPoint = Vector3_1.default.Z_AXIS;
    }

    Matrix4.sTMat4.identity();
    Matrix4.sTMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    Matrix4.sTMat4.appendTranslationXYZ(pivotPoint.x, pivotPoint.y, pivotPoint.z);
    this.append(Matrix4.sTMat4);
  }

  appendRotation(radian, axis) {
    Matrix4.sTMat4.identity();
    Matrix4.sTMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    this.append(Matrix4.sTMat4);
  }

  appendRotationX(radian) {
    Matrix4.sTMat4.rotationX(radian);
    this.append3x3(Matrix4.sTMat4);
  }

  appendRotationY(radian) {
    Matrix4.sTMat4.rotationY(radian);
    this.append3x3(Matrix4.sTMat4);
  }

  appendRotationZ(radian) {
    Matrix4.sTMat4.rotationZ(radian);
    this.append3x3(Matrix4.sTMat4);
  } // 用欧拉角形式旋转(heading->pitch->bank) => (y->x->z)


  appendRotationEulerAngle(radianX, radianY, radianZ) {
    Matrix4.sTMat4.rotationY(radianY);
    this.append3x3(Matrix4.sTMat4);
    Matrix4.sTMat4.rotationX(radianX);
    this.append3x3(Matrix4.sTMat4);
    Matrix4.sTMat4.rotationZ(radianZ);
    this.append3x3(Matrix4.sTMat4);
  }

  setScale(v3) {
    let fs = this.mLocalFS32;
    fs[0] = v3.x;
    fs[5] = v3.y;
    fs[10] = v3.z;
    return this;
  }

  setScaleXYZ(xScale, yScale, zScale) {
    let fs = this.mLocalFS32;
    fs[0] = xScale;
    fs[5] = yScale;
    fs[10] = zScale;
  }

  getScale(outV3) {
    let fs = this.mLocalFS32;
    outV3.x = fs[0];
    outV3.y = fs[5];
    outV3.z = fs[10];
  }

  setRotationEulerAngle(radianX, radianY, radianZ) {
    let fs = this.mLocalFS32; //let sx:number = fs[0];
    //let sy:number = fs[5];
    //let sz:number = fs[10];

    let cosX = Math.cos(radianX);
    let sinX = Math.sin(radianX);
    let cosY = Math.cos(radianY);
    let sinY = Math.sin(radianY);
    let cosZ = Math.cos(radianZ);
    let sinZ = Math.sin(radianZ);
    let cosZsinY = cosZ * sinY;
    let sinZsinY = sinZ * sinY;
    let cosYscaleX = cosY * fs[0];
    let sinXscaleY = sinX * fs[5];
    let cosXscaleY = cosX * fs[5];
    let cosXscaleZ = cosX * fs[10];
    let sinXscaleZ = sinX * fs[10];
    fs[1] = sinZ * cosYscaleX;
    fs[2] = -sinY * fs[0];
    fs[0] = cosZ * cosYscaleX;
    fs[4] = cosZsinY * sinXscaleY - sinZ * cosXscaleY;
    fs[8] = cosZsinY * cosXscaleZ + sinZ * sinXscaleZ;
    fs[5] = sinZsinY * sinXscaleY + cosZ * cosXscaleY;
    fs[9] = sinZsinY * cosXscaleZ - cosZ * sinXscaleZ;
    fs[6] = cosY * sinXscaleY;
    fs[10] = cosY * cosXscaleZ;
  }

  setRotationEulerAngle2(cosX, sinX, cosY, sinY, cosZ, sinZ) {
    let fs = this.mLocalFS32; //let sx:number = fs[0];
    //let sy:number = fs[5];
    //let sz:number = fs[10];
    //	let cosX: number = Math.cos(radianX);
    //	let sinX:number = Math.sin(radianX);
    //	let cosY:number = Math.cos(radianY);
    //	let sinY:number = Math.sin(radianY);
    //	let cosZ:number = Math.cos(radianZ);
    //	let sinZ:number = Math.sin(radianZ);

    let cosZsinY = cosZ * sinY;
    let sinZsinY = sinZ * sinY;
    let cosYscaleX = cosY * fs[0];
    let sinXscaleY = sinX * fs[5];
    let cosXscaleY = cosX * fs[5];
    let cosXscaleZ = cosX * fs[10];
    let sinXscaleZ = sinX * fs[10];
    fs[1] = sinZ * cosYscaleX;
    fs[2] = -sinY * fs[0];
    fs[0] = cosZ * cosYscaleX;
    fs[4] = cosZsinY * sinXscaleY - sinZ * cosXscaleY;
    fs[8] = cosZsinY * cosXscaleZ + sinZ * sinXscaleZ;
    fs[5] = sinZsinY * sinXscaleY + cosZ * cosXscaleY;
    fs[9] = sinZsinY * cosXscaleZ - cosZ * sinXscaleZ;
    fs[6] = cosY * sinXscaleY;
    fs[10] = cosY * cosXscaleZ;
  }

  compose(position, quaternion, scale) {
    const fs = this.mLocalFS32;
    const x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    fs[0] = (1 - (yy + zz)) * sx;
    fs[1] = (xy + wz) * sx;
    fs[2] = (xz - wy) * sx;
    fs[3] = 0;
    fs[4] = (xy - wz) * sy;
    fs[5] = (1 - (xx + zz)) * sy;
    fs[6] = (yz + wx) * sy;
    fs[7] = 0;
    fs[8] = (xz + wy) * sz;
    fs[9] = (yz - wx) * sz;
    fs[10] = (1 - (xx + yy)) * sz;
    fs[11] = 0;
    fs[12] = position.x;
    fs[13] = position.y;
    fs[14] = position.z;
    fs[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(Vector3_1.default.ZERO, q, Vector3_1.default.ONE);
  }

  makeRotationFromEuler(euler) {
    if (euler == null) {
      console.error('Matrix4::makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    const fs = this.mLocalFS32;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === EulerOrder_1.EulerOrder.XYZ) {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      fs[0] = c * e;
      fs[4] = -c * f;
      fs[8] = d;
      fs[1] = af + be * d;
      fs[5] = ae - bf * d;
      fs[9] = -b * c;
      fs[2] = bf - ae * d;
      fs[6] = be + af * d;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.YXZ) {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      fs[0] = ce + df * b;
      fs[4] = de * b - cf;
      fs[8] = a * d;
      fs[1] = a * f;
      fs[5] = a * e;
      fs[9] = -b;
      fs[2] = cf * b - de;
      fs[6] = df + ce * b;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.ZXY) {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      fs[0] = ce - df * b;
      fs[4] = -a * f;
      fs[8] = de + cf * b;
      fs[1] = cf + de * b;
      fs[5] = a * e;
      fs[9] = df - ce * b;
      fs[2] = -a * d;
      fs[6] = b;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.ZYX) {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      fs[0] = c * e;
      fs[4] = be * d - af;
      fs[8] = ae * d + bf;
      fs[1] = c * f;
      fs[5] = bf * d + ae;
      fs[9] = af * d - be;
      fs[2] = -d;
      fs[6] = b * c;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.YZX) {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      fs[0] = c * e;
      fs[4] = bd - ac * f;
      fs[8] = bc * f + ad;
      fs[1] = f;
      fs[5] = a * e;
      fs[9] = -b * e;
      fs[2] = -d * e;
      fs[6] = ad * f + bc;
      fs[10] = ac - bd * f;
    } else if (euler.order === EulerOrder_1.EulerOrder.XZY) {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      fs[0] = c * e;
      fs[4] = -f;
      fs[8] = d * e;
      fs[1] = ac * f + bd;
      fs[5] = a * e;
      fs[9] = ad * f - bc;
      fs[2] = bc * f - ad;
      fs[6] = b * e;
      fs[10] = bd * f + ac;
    } // reset bottom row


    fs[3] = 0;
    fs[7] = 0;
    fs[11] = 0; // reset last column

    fs[12] = 0;
    fs[13] = 0;
    fs[14] = 0;
    fs[15] = 1;
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const fs = this.mLocalFS32;
    const me = m.getLocalFS32();
    const v3 = Matrix4.sV3;
    m.copyColumnTo(0, v3);
    const scaleX = 1.0 / v3.getLength();
    m.copyColumnTo(1, v3);
    const scaleY = 1.0 / v3.getLength();
    m.copyColumnTo(2, v3);
    const scaleZ = 1.0 / v3.getLength();
    fs[0] = me[0] * scaleX;
    fs[1] = me[1] * scaleX;
    fs[2] = me[2] * scaleX;
    fs[3] = 0;
    fs[4] = me[4] * scaleY;
    fs[5] = me[5] * scaleY;
    fs[6] = me[6] * scaleY;
    fs[7] = 0;
    fs[8] = me[8] * scaleZ;
    fs[9] = me[9] * scaleZ;
    fs[10] = me[10] * scaleZ;
    fs[11] = 0;
    fs[12] = 0;
    fs[13] = 0;
    fs[14] = 0;
    fs[15] = 1;
    return this;
  }

  copyTranslation(m) {
    const fs = this.mLocalFS32,
          me = m.getLocalFS32();
    fs[12] = me[12];
    fs[13] = me[13];
    fs[14] = me[14];
    return this;
  }

  setTranslationXYZ(px, py, pz) {
    this.mLocalFS32[12] = px;
    this.mLocalFS32[13] = py;
    this.mLocalFS32[14] = pz;
  }

  setTranslation(v3) {
    this.mLocalFS32[12] = v3.x;
    this.mLocalFS32[13] = v3.y;
    this.mLocalFS32[14] = v3.z;
  }

  appendScaleXYZ(xScale, yScale, zScale) {
    const fs = this.mLocalFS32;
    fs[0] *= xScale;
    fs[1] *= xScale;
    fs[2] *= xScale;
    fs[3] *= xScale;
    fs[4] *= yScale;
    fs[5] *= yScale;
    fs[6] *= yScale;
    fs[7] *= yScale;
    fs[8] *= zScale;
    fs[9] *= zScale;
    fs[10] *= zScale;
    fs[11] *= zScale;
  }

  appendScaleXY(xScale, yScale) {
    const fs = this.mLocalFS32;
    fs[0] *= xScale;
    fs[1] *= xScale;
    fs[2] *= xScale;
    fs[3] *= xScale;
    fs[4] *= yScale;
    fs[5] *= yScale;
    fs[6] *= yScale;
    fs[7] *= yScale;
  }

  appendTranslationXYZ(px, py, pz) {
    this.mLocalFS32[12] += px;
    this.mLocalFS32[13] += py;
    this.mLocalFS32[14] += pz;
  }

  appendTranslation(v3) {
    this.mLocalFS32[12] += v3.x;
    this.mLocalFS32[13] += v3.y;
    this.mLocalFS32[14] += v3.z;
  }

  copyColumnFrom(column_index, v3) {
    const fs = this.mLocalFS32;

    switch (column_index) {
      case 0:
        {
          fs[0] = v3.x;
          fs[1] = v3.y;
          fs[2] = v3.z;
          fs[3] = v3.w;
        }
        break;

      case 1:
        {
          fs[4] = v3.x;
          fs[5] = v3.y;
          fs[6] = v3.z;
          fs[7] = v3.w;
        }
        break;

      case 2:
        {
          fs[8] = v3.x;
          fs[9] = v3.y;
          fs[10] = v3.z;
          fs[11] = v3.w;
        }
        break;

      case 3:
        {
          fs[12] = v3.x;
          fs[13] = v3.y;
          fs[14] = v3.z;
          fs[15] = v3.w;
        }
        break;

      default:
        break;
    }
  }

  copyColumnTo(column_index, outV3) {
    const fs = this.mLocalFS32;
    column_index <<= 2;
    outV3.x = fs[column_index];
    outV3.y = fs[1 + column_index];
    outV3.z = fs[2 + column_index];
    outV3.w = fs[3 + column_index];
  }

  setF32ArrAndIndex(fs32Arr, index = 0) {
    if (fs32Arr != null && index >= 0) {
      this.mFS32 = fs32Arr;
      this.mIndex = index;
      this.mLocalFS32 = this.mFS32.subarray(index, index + 16);
    }
  }

  setF32ArrIndex(index = 0) {
    if (index >= 0) {
      this.mIndex = index;
      this.mLocalFS32 = this.mFS32.subarray(index, index + 16);
    }
  }

  setF32Arr(fs32Arr) {
    if (fs32Arr != null) {
      this.mFS32 = fs32Arr;
    }
  }

  copyFromF32Arr(fs32Arr, index = 0) {
    //let subArr:Float32Array = fs32Arr.subarray(index, index + 16);
    //this.mLocalFS32.set(fs32Arr.subarray(index, index + 16), 0);
    let i = 0;

    for (let end = index + 16; index < end; index++) {
      this.mLocalFS32[i] = fs32Arr[index];
      ++i;
    }
  }

  copyToF32Arr(fs32Arr, index = 0) {
    fs32Arr.set(this.mLocalFS32, index);
  }

  copy(smat) {
    this.mLocalFS32.set(smat.getLocalFS32(), 0);
    return this;
  }

  copyFrom(smat) {
    this.mLocalFS32.set(smat.getLocalFS32(), 0);
  }

  copyTo(dmat) {
    //dmat.copyFrom(this);
    dmat.getLocalFS32().set(this.getLocalFS32(), 0);
  }

  copyRawDataFrom(float_rawDataArr, rawDataLength = 16, index = 0, bool_tp = false) {
    if (bool_tp) this.transpose();
    rawDataLength = rawDataLength - index;
    let c = 0;

    while (c < rawDataLength) {
      this.mFS32[this.mIndex + c] = float_rawDataArr[c + index];
      ++c;
    }

    if (bool_tp) this.transpose();
  }

  copyRawDataTo(float_rawDataArr, rawDataLength = 16, index = 0, bool_tp = false) {
    if (bool_tp) this.transpose();
    let c = 0;

    while (c < rawDataLength) {
      float_rawDataArr[c + index] = this.mFS32[this.mIndex + c];
      ++c;
    }

    if (bool_tp) this.transpose();
  }

  copyRowFrom(row_index, v3) {
    const fs = this.mLocalFS32;

    switch (row_index) {
      case 0:
        {
          fs[0] = v3.x;
          fs[4] = v3.y;
          fs[8] = v3.z;
          fs[12] = v3.w;
        }
        break;

      case 1:
        {
          fs[1] = v3.x;
          fs[5] = v3.y;
          fs[9] = v3.z;
          fs[13] = v3.w;
        }
        break;

      case 2:
        {
          fs[2] = v3.x;
          fs[6] = v3.y;
          fs[10] = v3.z;
          fs[14] = v3.w;
        }
        break;

      case 3:
        {
          fs[3] = v3.x;
          fs[7] = v3.y;
          fs[11] = v3.z;
          fs[15] = v3.w;
        }
        break;

      default:
        break;
    }
  }

  copyRowTo(row_index, v3) {
    const fs = this.mLocalFS32;
    v3.x = fs[row_index];
    v3.y = fs[4 + row_index];
    v3.z = fs[8 + row_index];
    v3.w = fs[12 + row_index];
  }
  /**
   * @param orientationStyle the value example: OrientationType.EULER_ANGLES
   * @returns [position, rotation, scale]
   */


  decompose(orientationStyle = OrientationType_1.default.EULER_ANGLES) {
    // TODO: optimize after 4 lines
    let vec = [];
    let mr = Matrix4.sTMat4;
    let rfs = mr.getLocalFS32(); //let mrfsI = mr.getFSIndex();
    //std::memcpy(&mr, m_rawData, m_rawDataSize);

    mr.copyFrom(this); ///*

    let pos = new Vector3_1.default(rfs[12], rfs[13], rfs[14]);
    let scale = new Vector3_1.default();
    scale.x = Math.sqrt(rfs[0] * rfs[0] + rfs[1] * rfs[1] + rfs[2] * rfs[2]);
    scale.y = Math.sqrt(rfs[4] * rfs[4] + rfs[5] * rfs[5] + rfs[6] * rfs[6]);
    scale.z = Math.sqrt(rfs[8] * rfs[8] + rfs[9] * rfs[9] + rfs[10] * rfs[10]);
    if (rfs[0] * (rfs[5] * rfs[10] - rfs[6] * rfs[9]) - rfs[1] * (rfs[4] * rfs[10] - rfs[6] * rfs[8]) + rfs[2] * (rfs[4] * rfs[9] - rfs[5] * rfs[8]) < 0) scale.z = -scale.z;
    rfs[0] /= scale.x;
    rfs[1] /= scale.x;
    rfs[2] /= scale.x;
    rfs[4] /= scale.y;
    rfs[5] /= scale.y;
    rfs[6] /= scale.y;
    rfs[8] /= scale.z;
    rfs[9] /= scale.z;
    rfs[10] /= scale.z;
    let rot = new Vector3_1.default();

    switch (orientationStyle) {
      case OrientationType_1.default.AXIS_ANGLE:
        {
          rot.w = MathConst_1.default.SafeACos((rfs[0] + rfs[5] + rfs[10] - 1) / 2);
          let len = Math.sqrt((rfs[6] - rfs[9]) * (rfs[6] - rfs[9]) + (rfs[8] - rfs[2]) * (rfs[8] - rfs[2]) + (rfs[1] - rfs[4]) * (rfs[1] - rfs[4]));

          if (len > MathConst_1.default.MATH_MIN_POSITIVE) {
            rot.x = (rfs[6] - rfs[9]) / len;
            rot.y = (rfs[8] - rfs[2]) / len;
            rot.z = (rfs[1] - rfs[4]) / len;
          } else rot.x = rot.y = rot.z = 0;
        }
        break;

      case OrientationType_1.default.QUATERNION:
        {
          let tr = rfs[0] + rfs[5] + rfs[10];

          if (tr > 0) {
            rot.w = Math.sqrt(1 + tr) / 2;
            rot.x = (rfs[6] - rfs[9]) / (4 * rot.w);
            rot.y = (rfs[8] - rfs[2]) / (4 * rot.w);
            rot.z = (rfs[1] - rfs[4]) / (4 * rot.w);
          } else if (rfs[0] > rfs[5] && rfs[0] > rfs[10]) {
            rot.x = Math.sqrt(1 + rfs[0] - rfs[5] - rfs[10]) / 2;
            rot.w = (rfs[6] - rfs[9]) / (4 * rot.x);
            rot.y = (rfs[1] + rfs[4]) / (4 * rot.x);
            rot.z = (rfs[8] + rfs[2]) / (4 * rot.x);
          } else if (rfs[5] > rfs[10]) {
            rot.y = Math.sqrt(1 + rfs[5] - rfs[0] - rfs[10]) / 2;
            rot.x = (rfs[1] + rfs[4]) / (4 * rot.y);
            rot.w = (rfs[8] - rfs[2]) / (4 * rot.y);
            rot.z = (rfs[6] + rfs[9]) / (4 * rot.y);
          } else {
            rot.z = Math.sqrt(1 + rfs[10] - rfs[0] - rfs[5]) / 2;
            rot.x = (rfs[8] + rfs[2]) / (4 * rot.z);
            rot.y = (rfs[6] + rfs[9]) / (4 * rot.z);
            rot.w = (rfs[1] - rfs[4]) / (4 * rot.z);
          }
        }
        break;

      case OrientationType_1.default.EULER_ANGLES:
        {
          rot.y = Math.asin(-rfs[2]);

          if (rfs[2] != 1 && rfs[2] != -1) {
            rot.x = Math.atan2(rfs[6], rfs[10]);
            rot.z = Math.atan2(rfs[1], rfs[0]);
          } else {
            rot.z = 0;
            rot.x = Math.atan2(rfs[4], rfs[5]);
          }
        }
        break;

      default:
        break;
    }

    ;
    vec.push(pos);
    vec.push(rot);
    vec.push(scale);
    mr = null;
    return vec;
  }

  invert() {
    let d = this.determinant();
    let invertable = Math.abs(d) > MathConst_1.default.MATH_MIN_POSITIVE;

    if (invertable) {
      let fs = this.mLocalFS32;
      d = 1.0 / d;
      let m11 = fs[0];
      let m21 = fs[4];
      let m31 = fs[8];
      let m41 = fs[12];
      let m12 = fs[1];
      let m22 = fs[5];
      let m32 = fs[9];
      let m42 = fs[13];
      let m13 = fs[2];
      let m23 = fs[6];
      let m33 = fs[10];
      let m43 = fs[14];
      let m14 = fs[3];
      let m24 = fs[7];
      let m34 = fs[11];
      let m44 = fs[15];
      fs[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
      fs[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
      fs[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
      fs[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
      fs[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
      fs[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
      fs[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
      fs[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
      fs[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
      fs[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
      fs[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
      fs[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
      fs[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
      fs[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
      fs[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
      fs[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
    }

    ;
    return invertable;
  }

  invertThis() {
    this.invert();
    return this;
  }

  pointAt(pos, at, up) {
    //TODO: need optimize
    if (at == null) at = new Vector3_1.default(0.0, 0.0, -1.0);
    if (up == null) up = new Vector3_1.default(0.0, -1.0, 0.0);
    let dir = at.subtract(pos);
    let vup = up.clone(); //Vector3 right;

    dir.normalize();
    vup.normalize();
    let dir2 = dir.clone().scaleBy(vup.dot(dir));
    vup.subtractBy(dir2);
    if (vup.getLength() > MathConst_1.default.MATH_MIN_POSITIVE) vup.normalize();else if (dir.x != 0) vup.setXYZ(-dir.y, dir.x, 0);else vup.setXYZ(1, 0, 0);
    let right = vup.crossProduct(dir);
    right.normalize();
    let fs = this.mLocalFS32;
    fs[0] = right.x;
    fs[4] = right.y;
    fs[8] = right.z;
    fs[12] = 0.0;
    fs[1] = vup.x;
    fs[5] = vup.y;
    fs[9] = vup.z;
    fs[13] = 0.0;
    fs[2] = dir.x;
    fs[6] = dir.y;
    fs[10] = dir.z;
    fs[14] = 0.0;
    fs[3] = pos.x;
    fs[7] = pos.y;
    fs[11] = pos.z;
    fs[15] = 1.0;
  }

  prepend(rhs) {
    let rfs32 = rhs.getLocalFS32();
    let fs = this.mLocalFS32;
    let m111 = rfs32[0];
    let m121 = rfs32[4];
    let m131 = rfs32[8];
    let m141 = rfs32[12];
    let m112 = rfs32[1];
    let m122 = rfs32[5];
    let m132 = rfs32[9];
    let m142 = rfs32[13];
    let m113 = rfs32[2];
    let m123 = rfs32[6];
    let m133 = rfs32[10];
    let m143 = rfs32[14];
    let m114 = rfs32[3];
    let m124 = rfs32[7];
    let m134 = rfs32[11];
    let m144 = rfs32[15];
    let m211 = fs[0];
    let m221 = fs[4];
    let m231 = fs[8];
    let m241 = fs[12];
    let m212 = fs[1];
    let m222 = fs[5];
    let m232 = fs[9];
    let m242 = fs[13];
    let m213 = fs[2];
    let m223 = fs[6];
    let m233 = fs[10];
    let m243 = fs[14];
    let m214 = fs[3];
    let m224 = fs[7];
    let m234 = fs[11];
    let m244 = fs[15];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
    fs[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
    fs[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
    fs[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
    fs[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
    fs[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
    fs[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
    fs[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
  }

  prepend3x3(rhs) {
    let rfs32 = rhs.getLocalFS32();
    let fs = this.mLocalFS32;
    let m111 = rfs32[0];
    let m121 = rfs32[4];
    let m131 = rfs32[8];
    let m112 = rfs32[1];
    let m122 = rfs32[5];
    let m132 = rfs32[9];
    let m113 = rfs32[2];
    let m123 = rfs32[6];
    let m133 = rfs32[10];
    let m211 = fs[0];
    let m221 = fs[4];
    let m231 = fs[8];
    let m212 = fs[1];
    let m222 = fs[5];
    let m232 = fs[9];
    let m213 = fs[2];
    let m223 = fs[6];
    let m233 = fs[10];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233;
  }

  prependRotationPivot(radian, axis, pivotPoint) {
    Matrix4.sTMat4.identity();
    Matrix4.sTMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    Matrix4.sTMat4.appendTranslationXYZ(pivotPoint.x, pivotPoint.y, pivotPoint.z);
    this.prepend(Matrix4.sTMat4);
  }

  prependRotation(radian, axis) {
    Matrix4.sTMat4.identity();
    Matrix4.sTMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    this.prepend(Matrix4.sTMat4);
  }

  prependRotationX(radian) {
    //s_tempMat.identity();
    Matrix4.sTMat4.rotationX(radian);
    this.prepend3x3(Matrix4.sTMat4);
  }

  prependRotationY(radian) {
    //s_tempMat.identity();
    Matrix4.sTMat4.rotationY(radian);
    this.prepend3x3(Matrix4.sTMat4);
  }

  prependRotationZ(radian) {
    //s_tempMat.identity();
    Matrix4.sTMat4.rotationZ(radian);
    this.prepend3x3(Matrix4.sTMat4);
  } // 用欧拉角形式旋转(heading->pitch->bank) => (y->x->z)


  prependRotationEulerAngle(radianX, radianY, radianZ) {
    //s_tempMat.identity();
    Matrix4.sTMat4.rotationY(radianY);
    this.prepend3x3(Matrix4.sTMat4); //s_tempMat.identity();

    Matrix4.sTMat4.rotationX(radianX);
    this.prepend3x3(Matrix4.sTMat4); //s_tempMat.identity();

    Matrix4.sTMat4.rotationZ(radianZ);
    this.prepend3x3(Matrix4.sTMat4);
  }

  prependScale(xScale, yScale, zScale) {
    const fs = this.mLocalFS32;
    fs[0] *= xScale;
    fs[1] *= yScale;
    fs[2] *= zScale;
    fs[4] *= xScale;
    fs[5] *= yScale;
    fs[6] *= zScale;
    fs[8] *= xScale;
    fs[9] *= yScale;
    fs[10] *= zScale;
    fs[12] *= xScale;
    fs[13] *= yScale;
    fs[14] *= zScale;
  }

  prependScaleXY(xScale, yScale) {
    const fs = this.mLocalFS32;
    fs[0] *= xScale;
    fs[1] *= yScale;
    fs[4] *= xScale;
    fs[5] *= yScale;
    fs[8] *= xScale;
    fs[9] *= yScale;
    fs[12] *= xScale;
    fs[13] *= yScale;
  }

  prependTranslationXYZ(px, py, pz) {
    Matrix4.sTMat4.identity(); //Matrix4.sTMat4.setPositionXYZ(px, py, pz);

    this.prepend(Matrix4.sTMat4);
  }

  prependTranslation(v3) {
    Matrix4.sTMat4.identity(); //Matrix4.sTMat4.setPositionXYZ(v3.x, v3.y, v3.z);

    this.prepend(Matrix4.sTMat4);
  }

  recompose(components, orientationStyle) {
    if (components.length < 3 || components[2].x == 0 || components[2].y == 0 || components[2].z == 0) return false;
    this.identity();
    let scale = Matrix4.sTMat4.getFS32();
    scale[0] = scale[1] = scale[2] = components[2].x;
    scale[4] = scale[5] = scale[6] = components[2].y;
    scale[8] = scale[9] = scale[10] = components[2].z;
    let fs = this.mLocalFS32;

    switch (orientationStyle) {
      case OrientationType_1.default.EULER_ANGLES:
        {
          let cx = Math.cos(components[1].x);
          let cy = Math.cos(components[1].y);
          let cz = Math.cos(components[1].z);
          let sx = Math.sin(components[1].x);
          let sy = Math.sin(components[1].y);
          let sz = Math.sin(components[1].z);
          fs[0] = cy * cz * scale[0];
          fs[1] = cy * sz * scale[1];
          fs[2] = -sy * scale[2];
          fs[3] = 0;
          fs[4] = (sx * sy * cz - cx * sz) * scale[4];
          fs[5] = (sx * sy * sz + cx * cz) * scale[5];
          fs[6] = sx * cy * scale[6];
          fs[7] = 0;
          fs[8] = (cx * sy * cz + sx * sz) * scale[8];
          fs[9] = (cx * sy * sz - sx * cz) * scale[9];
          fs[10] = cx * cy * scale[10];
          fs[11] = 0;
          fs[12] = components[0].x;
          fs[13] = components[0].y;
          fs[14] = components[0].z;
          fs[15] = 1;
        }
        break;

      default:
        {
          let x = components[1].x;
          let y = components[1].y;
          let z = components[1].z;
          let w = components[1].w;

          if (orientationStyle == OrientationType_1.default.AXIS_ANGLE) {
            let halfW = 0.5 * w;
            x *= Math.sin(halfW);
            y *= Math.sin(halfW);
            z *= Math.sin(halfW);
            w = Math.cos(halfW);
          }

          ;
          fs[0] = (1 - 2 * y * y - 2 * z * z) * scale[0];
          fs[1] = (2 * x * y + 2 * w * z) * scale[1];
          fs[2] = (2 * x * z - 2 * w * y) * scale[2];
          fs[3] = 0;
          fs[4] = (2 * x * y - 2 * w * z) * scale[4];
          fs[5] = (1 - 2 * x * x - 2 * z * z) * scale[5];
          fs[6] = (2 * y * z + 2 * w * x) * scale[6];
          fs[7] = 0;
          fs[8] = (2 * x * z + 2 * w * y) * scale[8];
          fs[9] = (2 * y * z - 2 * w * x) * scale[9];
          fs[10] = (1 - 2 * x * x - 2 * y * y) * scale[10];
          fs[11] = 0;
          fs[12] = components[0].x;
          fs[13] = components[0].y;
          fs[14] = components[0].z;
          fs[15] = 1;
        }
        break;
    }

    ; //TODO: need thinking

    if (components[2].x == 0) this.mLocalFS32[0] = 0; // 1e-15;

    if (components[2].y == 0) this.mLocalFS32[5] = 0; // 1e-15;

    if (components[2].z == 0) this.mLocalFS32[10] = 0; // 1e-15;

    scale = null;
    return true;
  }

  setThreeAxes(x_axis, y_axis, z_axis) {
    let vs = this.mLocalFS32;
    vs[0] = x_axis.x;
    vs[1] = x_axis.y;
    vs[2] = x_axis.z;
    vs[4] = y_axis.x;
    vs[5] = y_axis.y;
    vs[6] = y_axis.z;
    vs[8] = z_axis.x;
    vs[9] = z_axis.y;
    vs[10] = z_axis.z;
  }

  deltaTransformVector(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    return new Vector3_1.default(x * this.mLocalFS32[0] + y * this.mLocalFS32[4] + z * this.mLocalFS32[8], x * this.mLocalFS32[1] + y * this.mLocalFS32[5] + z * this.mLocalFS32[9], x * this.mLocalFS32[2] + y * this.mLocalFS32[6] + z * this.mLocalFS32[10], 0.0);
  }

  deltaTransformVectorSelf(v3) {
    let fs = this.mLocalFS32;
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    v3.x = x * fs[0] + y * fs[4] + z * fs[8];
    v3.y = x * fs[1] + y * fs[5] + z * fs[9];
    v3.z = x * fs[2] + y * fs[6] + z * fs[10];
  }

  deltaTransformOutVector(v3, out_v3) {
    let fs = this.mLocalFS32;
    out_v3.x = v3.x * fs[0] + v3.y * fs[4] + v3.z * fs[8];
    out_v3.y = v3.x * fs[1] + v3.y * fs[5] + v3.z * fs[9];
    out_v3.z = v3.x * fs[2] + v3.y * fs[6] + v3.z * fs[10];
  }

  transformVector(v3) {
    let fs = this.mLocalFS32;
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    return new Vector3_1.default(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformOutVector(v3, out_v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.mLocalFS32;
    out_v3.setXYZW(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformOutVector3(v3, out_v3) {
    let fs = this.mLocalFS32;
    out_v3.x = v3.x * fs[0] + v3.y * fs[4] + v3.z * fs[8] + fs[12];
    out_v3.y = v3.x * fs[1] + v3.y * fs[5] + v3.z * fs[9] + fs[13];
    out_v3.z = v3.x * fs[2] + v3.y * fs[6] + v3.z * fs[10] + fs[14];
  }

  transformVector3Self(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.mLocalFS32;
    v3.x = x * fs[0] + y * fs[4] + z * fs[8] + fs[12];
    v3.y = x * fs[1] + y * fs[5] + z * fs[9] + fs[13];
    v3.z = x * fs[2] + y * fs[6] + z * fs[10] + fs[14];
  }

  transformVectorSelf(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.mLocalFS32;
    v3.setXYZW(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformVectors(float_vinArr, vinLength, float_voutArr) {
    let i = 0;
    let x, y, z;
    let pfs = this.mLocalFS32;
    vinLength -= 3;

    while (i <= vinLength) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_voutArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_voutArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_voutArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transformVectorsSelf(float_vinArr, vinLength) {
    let i = 0;
    let x, y, z;
    let pfs = this.mLocalFS32;
    vinLength -= 3;

    while (i <= vinLength) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_vinArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_vinArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_vinArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transformVectorsRangeSelf(float_vinArr, begin, end) {
    let i = begin;
    let x, y, z;
    let pfs = this.mLocalFS32;
    end -= 3;

    while (i <= end) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_vinArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_vinArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_vinArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transpose() {
    Matrix4.sTMat4.copyFrom(this);
    let fs32 = Matrix4.sTMat4.getFS32();
    let fs = this.mLocalFS32;
    fs[1] = fs32[4];
    fs[2] = fs32[8];
    fs[3] = fs32[12];
    fs[4] = fs32[1];
    fs[6] = fs32[9];
    fs[7] = fs32[13];
    fs[8] = fs32[2];
    fs[9] = fs32[6];
    fs[11] = fs32[14];
    fs[12] = fs32[3];
    fs[13] = fs32[7];
    fs[14] = fs32[11];
  }

  interpolateTo(toMat, float_percent) {
    let fs32 = toMat.getFS32();
    let fsI = toMat.getFSIndex();
    let _g = 0;
    let i = this.mIndex;

    while (_g < 16) {
      this.mFS32[i] += (fs32[fsI + _g] - this.mFS32[i]) * float_percent;
      ++i;
      ++_g;
    }
  }

  getAxisRotation(x, y, z, radian) {
    radian = -radian;
    let fs = this.mLocalFS32;
    let s = Math.sin(radian),
        c = Math.cos(radian);
    let t = 1.0 - c;
    fs[0] = c + x * x * t;
    fs[5] = c + y * y * t;
    fs[10] = c + z * z * t;
    let tmp1 = x * y * t;
    let tmp2 = z * s;
    fs[4] = tmp1 + tmp2;
    fs[1] = tmp1 - tmp2;
    tmp1 = x * z * t;
    tmp2 = y * s;
    fs[8] = tmp1 - tmp2;
    fs[2] = tmp1 + tmp2;
    tmp1 = y * z * t;
    tmp2 = x * s;
    fs[9] = tmp1 + tmp2;
    fs[6] = tmp1 - tmp2;
  }

  rotationX(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.mLocalFS32[0] = 1.0;
    this.mLocalFS32[1] = 0.0;
    this.mLocalFS32[2] = 0.0;
    this.mLocalFS32[4] = 0.0;
    this.mLocalFS32[5] = c;
    this.mLocalFS32[6] = s;
    this.mLocalFS32[8] = 0.0;
    this.mLocalFS32[9] = -s;
    this.mLocalFS32[10] = c;
  }

  rotationY(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.mLocalFS32[0] = c;
    this.mLocalFS32[1] = 0.0;
    this.mLocalFS32[2] = -s;
    this.mLocalFS32[4] = 0.0;
    this.mLocalFS32[5] = 1.0;
    this.mLocalFS32[6] = 0.0;
    this.mLocalFS32[8] = s;
    this.mLocalFS32[9] = 0.0;
    this.mLocalFS32[10] = c;
  }

  rotationZ(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.mLocalFS32[0] = c;
    this.mLocalFS32[1] = s;
    this.mLocalFS32[2] = 0.0;
    this.mLocalFS32[4] = -s;
    this.mLocalFS32[5] = c;
    this.mLocalFS32[6] = 0.0;
    this.mLocalFS32[8] = 0.0;
    this.mLocalFS32[9] = 0.0;
    this.mLocalFS32[10] = 1.0;
  } /////////////////////////////////////////////////////////////


  toString() {
    let str = "\n" + this.mLocalFS32[0] + "," + this.mLocalFS32[1] + "," + this.mLocalFS32[2] + "," + this.mLocalFS32[3] + "\n";
    str += this.mLocalFS32[4] + "," + this.mLocalFS32[5] + "," + this.mLocalFS32[6] + "," + this.mLocalFS32[7] + "\n";
    str += this.mLocalFS32[8] + "," + this.mLocalFS32[9] + "," + this.mLocalFS32[10] + "," + this.mLocalFS32[11] + "\n";
    str += this.mLocalFS32[12] + "," + this.mLocalFS32[13] + "," + this.mLocalFS32[14] + "," + this.mLocalFS32[15] + "\n";
    return str;
  }

  transformPerspV4Self(v4) {
    const fs = this.mLocalFS32;
    v4.w = v4.z;
    v4.x *= fs[0];
    v4.y *= fs[5];
    v4.z *= fs[10];
    v4.z += fs[14];
    v4.w *= fs[11];
    v4.w += fs[15];
  }

  clone() {
    let m = new Matrix4();
    m.copyFrom(this);
    return m;
  } ///////
  // view etc..
  ///////////////////////////////////////////


  perspectiveRH(fovy, aspect, zNear, zFar, zfactor = 1.0) {
    //assert(abs(aspect - std::numeric_limits<float>::epsilon()) > minFloatValue)
    const fs = this.mLocalFS32;
    let tanHalfFovy = Math.tan(fovy * 0.5);
    this.identity();
    fs[0] = 1.0 / (aspect * tanHalfFovy);
    fs[5] = 1.0 / tanHalfFovy;
    fs[10] = -zfactor * (zFar + zNear) / (zFar - zNear);
    fs[11] = -1.0;
    fs[14] = -zfactor * (2.0 * zFar * zNear) / (zFar - zNear);
  }

  perspectiveRH2(fovy, pw, ph, zNear, zFar) {
    let focalLength = pw / Math.tan(fovy * 0.5);
    let m0 = focalLength / pw;
    let m5 = focalLength / ph;
    let m10 = -zFar / (zFar - zNear);
    let m14 = -zNear * m10;
    this.identity();
    const fs = this.mLocalFS32;
    fs[0] = m0;
    fs[5] = m5;
    fs[10] = m10;
    fs[11] = -1.0;
    fs[14] = m14;
  }

  orthoRH(b, t, l, r, zNear, zFar, zfactor = 1.0) {
    this.identity();
    const fs = this.mLocalFS32;
    fs[0] = 2.0 / (r - l);
    fs[5] = 2.0 / (t - b);
    fs[10] = -zfactor * 2.0 / (zFar - zNear);
    fs[12] = -(r + l) / (r - l);
    fs[13] = -(t + b) / (t - b);
    fs[14] = -zfactor * (zFar + zNear) / (zFar - zNear);
    fs[15] = 1.0;
  }

  perspectiveLH(fovy, aspect, zNear, zFar, zfactor = 1.0) {
    //assert(abs(aspect - std::numeric_limits<float>::epsilon()) > minFloatValue)
    let tanHalfFovy = Math.tan(fovy * 0.5);
    this.identity();
    const fs = this.mLocalFS32;
    fs[0] = 1.0 / (aspect * tanHalfFovy);
    fs[5] = 1.0 / tanHalfFovy;
    fs[10] = zfactor * (zFar + zNear) / (zFar - zNear);
    fs[11] = 1.0;
    fs[14] = zfactor * (2.0 * zFar * zNear) / (zFar - zNear);
  }

  orthoLH(b, t, l, r, zNear, zFar, zfactor = 1.0) {
    this.identity();
    const fs = this.mLocalFS32;
    fs[0] = 2.0 / (r - l); // / (aspect * tanHalfFovy);

    fs[5] = 2.0 / (t - b); // / tanHalfFovy;

    fs[10] = zfactor * 2.0 / (zFar - zNear);
    fs[12] = -(r + l) / (r - l);
    fs[13] = -(t + b) / (t - b);
    fs[14] = -zfactor * (zFar + zNear) / (zFar - zNear);
    fs[15] = 1.0;
  }

  lookAtRH(eyePos, atPos, up) {
    this.identity();
    let f = atPos.subtract(eyePos);
    f.normalize();
    let s = f.crossProduct(up);
    s.normalize();
    let u = s.crossProduct(f);
    s.w = -s.dot(eyePos);
    u.w = -u.dot(eyePos);
    f.w = f.dot(eyePos);
    f.negate();
    this.copyRowFrom(0, s);
    this.copyRowFrom(1, u);
    this.copyRowFrom(2, f);
  }

  lookAtLH(eyePos, atPos, up) {
    this.identity();
    let f = atPos.subtract(eyePos);
    f.normalize();
    let s = f.crossProduct(up);
    s.normalize();
    let u = s.crossProduct(f);
    s.w = -s.dot(eyePos);
    u.w = -u.dot(eyePos);
    f.w = -f.dot(eyePos);
    this.copyRowFrom(0, s);
    this.copyRowFrom(1, u);
    this.copyRowFrom(2, f);
  }

  destroy() {
    this.mLocalFS32 = null;
    this.mFS32 = null;
    this.mIndex = -1;
  }

}

Matrix4.sV3 = new Vector3_1.default();
Matrix4.sUid = 0;
Matrix4.sIsolatedUid = 0x4ffff;
Matrix4.sTMat4 = new Matrix4();
exports.default = Matrix4;

/***/ }),

/***/ "c7cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const MathConst_1 = __importDefault(__webpack_require__("ec7b"));

let OR = [new Float32Array(3), new Float32Array(3), new Float32Array(3)];
let OAbsR = [new Float32Array(3), new Float32Array(3), new Float32Array(3)];

class OBB {
  constructor() {
    this.mPv = new Vector3_1.default();
    this.mPv1 = new Vector3_1.default();
    /**
     * three axes normalization 3d vectors
     */

    this.axes = [new Vector3_1.default(), new Vector3_1.default(), new Vector3_1.default()];
    this.extents = new Float32Array(3);
    /**
     * half length of these three axes
     */

    this.extent = new Vector3_1.default();
    this.center = new Vector3_1.default();
    this.version = -1;
    this.radius = 50;
    this.mts = [0, 0, 0];
  }

  reset() {}

  equals(ob) {
    if (ob != this && ob) {
      if (!this.center.equalsXYZ(ob.center)) return false;
      if (!this.extent.equalsXYZ(ob.extent)) return false;

      for (let i = 0; i < 3; ++i) {
        if (!this.axes[i].equalsXYZ(ob.axes[i])) return false;
      }

      return true;
    }

    return false;
  }

  update() {
    this.version++;

    for (let i = 0; i < 3; ++i) this.axes[i].normalize();

    let et = this.extent;
    this.radius = et.getLength();
    this.extents.set([et.x, et.y, et.z]);
  }

  getSize(v3) {
    if (!v3) {
      v3 = new Vector3_1.default();
    }

    return v3.copyFrom(this.extent).scaleBy(2.0);
  }
  /**
   * @param ob IAABB instance
   * @param transform IMatrix4 instance, the default is null
   */


  fromAABB(ob, transform = null) {
    const ls = this.axes;
    ls[0].setXYZ(1, 0, 0);
    ls[1].setXYZ(0, 1, 0);
    ls[2].setXYZ(0, 0, 1);
    const extent = this.extent;

    if (transform) {
      transform.deltaTransformVectorSelf(ls[0]);
      transform.deltaTransformVectorSelf(ls[1]);
      transform.deltaTransformVectorSelf(ls[2]);
      ls[0].normalize();
      ls[1].normalize();
      ls[2].normalize();
      const pv0 = this.center.copyFrom(ob.center);
      const pv1 = this.mPv.copyFrom(ob.max);
      transform.transformVector3Self(pv0);
      transform.transformVector3Self(pv1);
      pv1.subVecsTo(pv1, pv0);
      extent.setXYZ(ls[0].dot(pv1), ls[1].dot(pv1), ls[2].dot(pv1));
    } else {
      this.center.copyFrom(ob.center);
      extent.setXYZ(ob.getWidth() * 0.5, ob.getHeight() * 0.5, ob.getLong() * 0.5);
    }

    const et = this.extent;
    this.extents.set([et.x, et.y, et.z]);
    this.radius = et.getLength();
    this.version++;
  }

  getClosePosition(pv, result = null) {
    const et = this.extent;
    const axes = this.axes;
    const v0 = this.mPv.subVecsTo(pv, this.center);
    if (!result) result = new Vector3_1.default();
    result.copyFrom(this.center);
    const clamp = MathConst_1.default.Clamp;
    const v1 = this.mPv1;
    const x = clamp(v0.dot(v1.copyFrom(axes[0])), -et.x, et.x);
    result.add(v1.scaleBy(x));
    const y = clamp(v0.dot(v1.copyFrom(axes[1])), -et.y, et.y);
    result.add(v1.scaleBy(y));
    const z = clamp(v0.dot(v1.copyFrom(axes[2])), -et.z, et.z);
    result.add(v1.scaleBy(z));
    return result;
  }

  intersectAABB(ob, transform = null) {
    const obb = OBB.sOBB;
    obb.fromAABB(ob, transform);
    return this.intersect(obb);
  }

  intersectSphere(cv, radius) {
    const v1 = this.mPv1;
    this.getClosePosition(cv, v1);
    return v1.subtractBy(cv).getLengthSquared() <= radius * radius;
  }

  containsV(pv) {
    const v0 = this.mPv.subVecsTo(pv, this.center);
    const axes = this.axes;
    const abs = Math.abs;
    const et = this.extent;
    return abs(v0.dot(axes[0])) <= et.x && abs(v0.dot(axes[1])) <= et.y && abs(v0.dot(axes[2])) <= et.z;
  }

  intersectPlane(planeNV, planeDis) {
    const et = this.extent;
    const axes = this.axes; // compute the projection interval radius of this OBB onto L(t) = this.center + t * planeNV;

    const r = et.x * Math.abs(planeNV.dot(axes[0])) + et.y * Math.abs(planeNV.dot(axes[1])) + et.z * Math.abs(planeNV.dot(axes[2])); // compute distance of the OBB's center from the plane

    const d = planeNV.dot(this.center) - planeDis; // Intersection occurs when distance d falls within [-r,+r] interval

    return Math.abs(d) <= r;
  }

  intersect(a, b = null, epsilon = 1e-6) {
    if (!b) {
      b = a;
      a = this;
    }

    const abs = Math.abs; // 计算距离向量tv

    const tv = this.mPv.subVecsTo(b.center, a.center);

    if (tv.getLength() - (a.radius + b.radius) > epsilon) {
      return false;
    }

    let Avs = OAbsR;
    let Rvs = OR; // 计算旋转矩阵R

    for (let i = 0; i < 3; ++i) {
      for (let j = 0; j < 3; ++j) {
        Rvs[i][j] = a.axes[i].dot(b.axes[j]);
      }
    } // 应用距离向量tv


    const ts = this.mts;
    ts[0] = tv.dot(a.axes[0]);
    ts[1] = tv.dot(a.axes[1]);
    ts[2] = tv.dot(a.axes[2]); // 计算旋转矩阵R的绝对值AbsR

    for (let i = 0; i < 3; ++i) {
      for (let j = 0; j < 3; ++j) {
        Avs[i][j] = abs(Rvs[i][j]) + epsilon;
      }
    }

    const aets = a.extents;
    const bets = b.extents;
    let ra = 0;
    let rb = 0; // test axes(A0, A1, A2)

    for (let i = 0; i < 3; ++i) {
      ra = aets[i];
      rb = bets[0] * Avs[i][0] + bets[1] * Avs[i][1] + bets[2] * Avs[i][2];
      if (abs(ts[i]) > ra + rb) return false;
    } // test axes(B0, B1, B2)


    for (let i = 0; i < 3; ++i) {
      ra = aets[0] * Avs[0][i] + aets[1] * Avs[1][i] + aets[2] * Avs[2][i];
      rb = bets[i];
      if (abs(ts[0] * Rvs[0][i] + ts[1] * Rvs[1][i] + ts[2] * Rvs[2][i]) > ra + rb) return false;
    } // test axes L = A0 x B0


    ra = aets[1] * Avs[2][0] + aets[2] * Avs[1][0];
    rb = bets[1] * Avs[0][2] + bets[2] * Avs[0][1];
    if (abs(ts[2] * Rvs[1][0] - ts[1] * Rvs[2][0]) > ra + rb) return false; // test axes L = A0 x B1

    ra = aets[1] * Avs[2][1] + aets[2] * Avs[1][1];
    rb = bets[0] * Avs[0][2] + bets[2] * Avs[0][0];
    if (abs(ts[2] * Rvs[1][1] - ts[1] * Rvs[2][1]) > ra + rb) return false; // test axes L = A0 x B2

    ra = aets[1] * Avs[2][2] + aets[2] * Avs[1][2];
    rb = bets[0] * Avs[0][1] + bets[1] * Avs[0][0];
    if (abs(ts[2] * Rvs[1][2] - ts[1] * Rvs[2][2]) > ra + rb) return false; // --------------------------------------------------------------------------
    // test axes L = A1 x B0

    ra = aets[0] * Avs[2][0] + aets[2] * Avs[0][0];
    rb = bets[1] * Avs[1][2] + bets[2] * Avs[1][1];
    if (abs(ts[0] * Rvs[2][0] - ts[2] * Rvs[0][0]) > ra + rb) return false; // test axes L = A1 x B1

    ra = aets[0] * Avs[2][1] + aets[2] * Avs[0][1];
    rb = bets[0] * Avs[1][2] + bets[2] * Avs[1][0];
    if (abs(ts[0] * Rvs[2][1] - ts[2] * Rvs[0][1]) > ra + rb) return false; // test axes L = A1 x B2

    ra = aets[0] * Avs[2][2] + aets[2] * Avs[0][2];
    rb = bets[0] * Avs[1][1] + bets[1] * Avs[1][0];
    if (abs(ts[0] * Rvs[2][2] - ts[2] * Rvs[0][2]) > ra + rb) return false; // --------------------------------------------------------------------------
    // test axes L = A2 x B0

    ra = aets[0] * Avs[1][0] + aets[1] * Avs[0][0];
    rb = bets[1] * Avs[2][2] + bets[2] * Avs[2][1];
    if (abs(ts[1] * Rvs[0][0] - ts[0] * Rvs[1][0]) > ra + rb) return false; // test axes L = A2 x B1

    ra = aets[0] * Avs[1][1] + aets[1] * Avs[0][1];
    rb = bets[0] * Avs[2][2] + bets[2] * Avs[2][0];
    if (abs(ts[1] * Rvs[0][1] - ts[0] * Rvs[1][1]) > ra + rb) return false; // test axes L = A2 x B2

    ra = aets[0] * Avs[1][2] + aets[1] * Avs[0][2];
    rb = bets[0] * Avs[2][1] + bets[1] * Avs[2][0];
    if (abs(ts[1] * Rvs[0][2] - ts[0] * Rvs[1][2]) > ra + rb) return false;
    return true;
  }

}

OBB.sOBB = new OBB();
exports.default = OBB;

/***/ }),

/***/ "c812":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class GPURenderPipelineEmpty {
  getBindGroupLayout(index) {
    throw Error("illegal operations !!!");
    return {};
  }

}

exports.GPURenderPipelineEmpty = GPURenderPipelineEmpty;

/***/ }),

/***/ "c862":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const MouseInteraction_1 = __webpack_require__("213f");

const gameOfLifeSpherePBR_vert_wgsl_1 = __importDefault(__webpack_require__("bd7e"));

const gameOfLifeSpherePBR_frag_wgsl_1 = __importDefault(__webpack_require__("0d77"));

const WGCompMaterial_1 = __webpack_require__("19f9");

const WGMaterial_1 = __webpack_require__("943f");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const RenderStatusDisplay_1 = __importDefault(__webpack_require__("e58d"));

const CylinderEntity_1 = __webpack_require__("76e3");

const gridSize = 256;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;
@group(0) @binding(3) var<storage, read_write> lifeState: array<f32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, 		cell.y+1) +
							cellActive(cell.x+1, 	cell.y) +
							cellActive(cell.x+1, 	cell.y-1) +
							cellActive(cell.x, 		cell.y-1) +
							cellActive(cell.x-1, 	cell.y-1) +
							cellActive(cell.x-1, 	cell.y) +
							cellActive(cell.x-1, 	cell.y+1) +
							cellActive(cell.x, 		cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
			if(cellStateOut[i] > 0) {
				lifeState[i] += 0.05;
			} else {
				lifeState[i] -= 0.05;
			}
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
			lifeState[i] += 0.1;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
			lifeState[i] -= 0.05;
		}
	}
	lifeState[i] = max(lifeState[i], 0.01);
}`;

class GameOfLife3DPBR {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};

    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLife3DPBR::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new RenderStatusDisplay_1.default(this.mRscene, true);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.6 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    const lifeStateArray3 = new Float32Array(gridSize * gridSize);

    for (let i = 0; i < lifeStateArray3.length; i++) {
      lifeStateArray3[i] = 0.01;
    }

    const posisitonArray4 = new Float32Array(gridSize * gridSize * 4);
    let sizeV = new Vector3_1.default(40, 1, 40);
    let posV = new Vector3_1.default().copyFrom(sizeV);
    posV.scaleBy(gridSize);
    posV.scaleBy(-0.5);
    let k = 0;

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        let pv = new Vector3_1.default(j * sizeV.x, 0, i * sizeV.z).addBy(posV);
        posisitonArray4[k] = pv.x;
        posisitonArray4[k + 1] = pv.y;
        posisitonArray4[k + 2] = pv.z;
        k += 4;
      }
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0,
      shared
    };
    let sharedData1 = {
      data: cellStateArray1,
      shared
    };
    let sharedData3 = {
      data: lifeStateArray3,
      shared
    };
    let sharedData4 = {
      data: posisitonArray4,
      shared
    };
    const v0 = {
      data: gridsSizesArray,
      stride: 2,
      shared,
      layout: {
        visibility: 'all'
      }
    }; // build rendering uniforms

    const va1 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    };
    const vb1 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    };
    const vc1 = {
      storage: {
        bufData: sharedData3,
        stride: 1,
        shared,
        layout: {
          visibility: 'all'
        }
      }
    };
    const v4 = {
      storage: {
        bufData: sharedData4,
        stride: 3,
        shared,
        layout: {
          visibility: 'vert_comp'
        }
      }
    }; // build computing uniforms

    const compva1 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared,
        layout: {
          visibility: 'vert_comp'
        }
      }
    };
    const compva2 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared,
        layout: {
          visibility: 'comp'
        }
      }
    };
    const compvb1 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared,
        layout: {
          visibility: 'vert_comp'
        }
      }
    };
    const compvb2 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared,
        layout: {
          visibility: 'comp',
          access: "read_write"
        }
      }
    };
    const compv3 = {
      storage: {
        bufData: sharedData3,
        stride: 1,
        shared,
        layout: {
          visibility: 'comp',
          access: "read_write"
        }
      }
    };
    return [{
      ufvs0: [v0, va1, vc1, v4],
      ufvs1: [v0, vb1, vc1, v4]
    }, {
      ufvs0: [v0, compva1, compva2, compv3],
      ufvs1: [v0, compvb1, compvb2, compv3]
    }];
  }

  createMaterial(uniformValues) {
    const instanceCount = gridSize * gridSize;
    let shaderSrc = {
      vert: {
        code: gameOfLifeSpherePBR_vert_wgsl_1.default,
        uuid: "vert-gameOfLife"
      },
      frag: {
        code: gameOfLifeSpherePBR_frag_wgsl_1.default,
        uuid: "frag-gameOfLife"
      }
    };
    return new WGMaterial_1.WGMaterial({
      shadinguuid: 'rendering',
      shaderSrc,
      instanceCount,
      uniformValues,
      uniformAppend: false
    });
  }

  createCompMaterial(uniformValues) {
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    let shaderSrc = {
      code: compShdCode,
      uuid: "shader-computing"
    };
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid: 'computing',
      shaderSrc,
      uniformValues,
      uniformAppend: false,
      workcounts: [workgroupCount, workgroupCount]
    });
  }

  initScene() {
    const rc = this.mRscene;
    const ufvsObjs = this.createUniformValues(); // build ping-pong material rendering/computing process

    const materials = [this.createMaterial(ufvsObjs[0].ufvs0), this.createMaterial(ufvsObjs[0].ufvs1), this.createCompMaterial(ufvsObjs[1].ufvs1), this.createCompMaterial(ufvsObjs[1].ufvs0)];
    let entity = new CylinderEntity_1.CylinderEntity({
      radius: 20,
      height: 38,
      longitudeNumSegments: 10,
      latitudeNumSegments: 10,
      alignYRatio: 0.0,
      materials
    });
    rc.addEntity(entity);
    this.mEntity = entity;
  }

  run() {
    let flag = this.mEntity.isRendering();
    const ms = this.mEntity.materials;

    if (flag) {
      for (let i = 0; i < ms.length; i++) {
        ms[i].visible = (this.mStep % 2 + i) % 2 == 0;
      }

      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        flag = false;
      } else {
        this.mFrameDelay = 3;
        this.mStep++;
      }
    }

    if (!flag) {
      ms[2].visible = false;
      ms[3].visible = false;
    }

    this.mRscene.run();
  }

}

exports.GameOfLife3DPBR = GameOfLife3DPBR;

/***/ }),

/***/ "cae9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Camera_1 = __importDefault(__webpack_require__("68f4"));

const WebGPUContext_1 = __webpack_require__("6b10");

const WGRObjBuilder_1 = __webpack_require__("63d8");

const WGRenderPassBlock_1 = __webpack_require__("ddc9");

exports.WGRPipelineContextDefParam = WGRenderPassBlock_1.WGRPipelineContextDefParam;

const WGEntityNodeMana_1 = __webpack_require__("6130");

const WGRendererParam_1 = __webpack_require__("f5fb");

exports.WGRendererConfig = WGRendererParam_1.WGRendererConfig;

const WGRenderUnitBlock_1 = __webpack_require__("d5c3");

class WGRenderer {
  constructor(config) {
    this.___$$$$$$$Author = "VilyLei(vily313@126.com)";
    this.mUid = WGRenderer.sUid++;
    this.mInit = true;
    this.mRPBlocks = [];
    this.mROBuilder = new WGRObjBuilder_1.WGRObjBuilder();
    this.mEntityMana = new WGEntityNodeMana_1.WGEntityNodeMana();
    this.camera = new Camera_1.default();
    this.enabled = true;

    if (config) {
      this.initialize(config);
    }
  }

  initCamera(width, height) {
    let p = this.mConfig.camera;
    if (!p) p = {};
    p.viewWidth = width;
    p.viewHeight = height;
    this.camera.initialize(p);
  }

  get uid() {
    return 0;
  }

  getWGCtx() {
    return this.mWGCtx;
  }

  getStage3D() {
    return this.stage;
  }

  getCamera() {
    return this.camera;
  }

  getDiv() {
    return this.mDiv;
  }

  getCanvas() {
    return this.mWGCtx.canvas;
  }

  initialize(config) {
    if (this.mInit && !this.mWGCtx) {
      this.mInit = false;
      let wgctx = config ? config.ctx : null;

      if (wgctx) {
        // console.log("WGRenderer::initialize(), a 01");
        this.mDiv = config.div;
        this.mWGCtx = wgctx;
        const canvas = wgctx.canvas;
        this.mROBuilder.wgctx = wgctx;
        this.initCamera(canvas.width, canvas.height);
      } else {
        config = WGRendererParam_1.checkConfig(config);
        this.mDiv = config.div;
        wgctx = new WebGPUContext_1.WebGPUContext();
        wgctx.initialize(config.canvas, config.gpuCanvasCfg).then(() => {
          this.init();

          if (config && config.callback) {
            config.callback("renderer-init");
          }

          this.mROBuilder.wgctx = wgctx;
          const mana = this.mEntityMana;
          mana.wgctx = wgctx;
          mana.roBuilder = this.mROBuilder; // mana.callback = this.receiveNode;

          this.mEntityMana.updateToTarget();
        });
        this.mWGCtx = wgctx;
      }

      this.mConfig = config;
    }
  }

  intDefaultBlock() {
    if (this.mRPBlocks.length < 1) {
      let param = this.mConfig.rpassparam;

      if (!param) {
        param = {
          sampleCount: 4,
          multisampleEnabled: true,
          depthFormat: "depth24plus"
        };
      }

      this.createRenderBlock(param);
    }
  }

  init() {
    const ctx = this.mWGCtx;
    const canvas = this.mWGCtx.canvas;
    this.initCamera(canvas.width, canvas.height);
    const bs = this.mRPBlocks;

    for (let i = 0; i < bs.length; ++i) {
      bs[i].initialize(ctx);
    }
  }

  addEntity(entity, blockIndex = 0) {
    // console.log("Renderer::addEntity(), entity.isInRenderer(): ", entity.isInRenderer());
    const bs = this.mRPBlocks;

    if (bs.length < 1) {
      this.initialize();
      this.intDefaultBlock();
    }

    if (blockIndex < 0 || blockIndex >= bs.length) {
      throw Error("Illegal operation !!!");
    }

    const rb = bs[blockIndex];
    rb.addEntity(entity);
  }

  removeEntity(entity) {
    if (entity) {
      if (entity.isInRenderer()) {
        // const et = node.entity;
        const ls = entity.__$bids;

        if (ls) {
          // let bs = WGRenderUnitBlock.getBlockAt();
          let bs = new Array(ls.length);

          for (let i = 0; i < ls.length; ++i) {
            bs[i] = WGRenderUnitBlock_1.WGRenderUnitBlock.getBlockAt(ls[i]);
          }

          entity.__$bids = [];

          for (let i = 0; i < ls.length; ++i) {
            bs[i].removeEntity(entity);
          }
        }

        const st = entity.rstate;
        st.__$rever++;
        st.__$inRenderer = false;
        st.__$rendering = false;
        console.log("Renderer::removeEntity(), entity.isInRenderer(): ", entity.isInRenderer());
      }
    }
  }

  setPassNodeGraph(graph, blockIndex = 0) {
    this.intDefaultBlock();
    const len = this.mRPBlocks.length;

    if (blockIndex >= 0 && blockIndex < len) {
      this.mRPBlocks[blockIndex].setPassNodeGraph(graph);
    } else {
      throw Error("Illegal operations !!!");
    }
  }

  appendRenderPass(param, blockIndex = 0) {
    this.initialize();
    this.intDefaultBlock();
    const len = this.mRPBlocks.length;

    if (blockIndex >= 0 && blockIndex < len) {
      return this.mRPBlocks[blockIndex].appendRendererPass(param);
    }

    throw Error("Illegal operations !!!");
    return {
      index: -1
    };
  }

  createRenderPass(param, blockIndex = 0) {
    return this.appendRenderPass(param, blockIndex);
  }

  getRPBlockAt(i) {
    this.initialize();
    this.intDefaultBlock();
    return this.mRPBlocks[i];
  }

  createRenderBlock(param) {
    let bp = {
      entityMana: this.mEntityMana,
      roBuilder: this.mROBuilder,
      camera: this.camera
    };
    const rb = new WGRenderPassBlock_1.WGRenderPassBlock(this.mUid, bp, this.mWGCtx, param);
    rb.unitBlock = WGRenderUnitBlock_1.WGRenderUnitBlock.createBlock();
    this.mRPBlocks.push(rb);
    return rb;
  }

  isEnabled() {
    return this.enabled && this.mWGCtx && this.mWGCtx.enabled;
  }

  run(rendering = true) {
    if (this.enabled) {
      const ctx = this.mWGCtx;

      if (ctx && ctx.enabled) {
        this.mEntityMana.update();

        if (rendering) {
          const rbs = this.mRPBlocks;

          if (rbs.length > 0) {
            const rb = rbs[0];
            rb.runBegin();
            rb.run();
            rb.runEnd();
            const cmds = rb.rcommands;
            ctx.queue.submit(cmds);
          }
        }
      }
    }
  }

  destroy() {
    const ctx = this.mWGCtx;

    if (ctx && ctx.enabled) {}
  }

}

WGRenderer.sUid = 0;
exports.WGRenderer = WGRenderer;

/***/ }),

/***/ "cb24":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nfn reinhard(v: vec3<f32>) -> vec3<f32> {\r\n    return v / (vec3<f32>(1.0) + v);\r\n}\r\nfn calcColor(uv: vec2f) -> vec4f {\r\n\r\n    var result = textureSample(texture0, sampler0, uv) * param;\r\n\tresult = vec4f(reinhard( result.xyz ), 1.0);\r\n\t// gamma correct\r\n\tresult = vec4f(pow(result.xyz, vec3<f32>(1.0/2.2)), 1.0);\r\n\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "cbb4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class OrientationType {}

OrientationType.AXIS_ANGLE = 0;
OrientationType.QUATERNION = 1;
OrientationType.EULER_ANGLES = 2;
exports.default = OrientationType;

/***/ }),

/***/ "cc22":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureMixColor_frag_wgsl_1 = __importDefault(__webpack_require__("3f99"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class BlendTest {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    console.log("BlendTest::initialize() ...");
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureMixColor_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let materials = [this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")]), this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/default.jpg")], ["add"]), this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/xulie_08_61.png")], ["alpha_add"]), this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/blueTransparent.png")], ["add"])];

    for (let i = 0; i < materials.length; ++i) {
      this.createEntity([materials[i]], new Vector3_1.default(0, 0, -50 + i * 50), "et-" + i);
    }
  }

  createMaterial(shdSrc, texDatas, blendModes = ["solid"]) {
    let pipelineDefParam = {
      faceCullMode: "back",
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal + blendModes.toString(),
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials, pv, uuid) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSquare(600);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs,
      strides: [2]
    }).setIndices(rgd.ivs);
    const entity = new Entity3D_1.Entity3D({
      geometry,
      materials
    });
    entity.uuid = uuid;
    entity.transform.setPosition(pv);
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.renderer.run();
  }

}

exports.BlendTest = BlendTest;

/***/ }),

/***/ "cc97":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * pbr arms number data.
 * 		a: ao value.
 * 		r: roughness value.
 * 		m: metallic value.
 * 		s: specular value.
 */

class Arms {
  constructor(a = 1.0, r = 0.0, m = 1.0, s = 1.0) {
    this.a = a;
    this.r = r;
    this.m = m;
    this.s = s;
  }

  clone() {
    return new Arms(this.a, this.r, this.m, this.s);
  }

  setArms(color) {
    let v = color;

    if (v) {
      const c = this;
      const vs = v;

      if (vs.length !== undefined) {
        const len = vs.length;
        if (len > 0) c.a = vs[0];
        if (len > 1) c.r = vs[1];
        if (len > 2) c.m = vs[2];
        if (len > 3) c.s = vs[3];
      } else {
        const vo = v;
        if (vo.a !== undefined) c.s = vo.a;
        if (vo.r !== undefined) c.r = vo.r;
        if (vo.m !== undefined) c.m = vo.m;
        if (vo.s !== undefined) c.s = vo.s;
      }
    }

    return this;
  }

  fromArray4(arr, offset = 0) {
    this.a = arr[offset];
    this.r = arr[offset + 1];
    this.m = arr[offset + 2];
    this.s = arr[offset + 3];
    return this;
  }

  toArray4(arr, offset = 0) {
    arr[offset] = this.a;
    arr[offset + 1] = this.r;
    arr[offset + 2] = this.m;
    arr[offset + 3] = this.s;
    return this;
  }

  getArray4() {
    let arr = new Array(4);
    this.toArray4(arr);
    return arr;
  }

  getArray3() {
    let arr = new Array(3);
    this.toArray3(arr);
    return arr;
  }

  fromArray3(arr, offset = 0) {
    this.a = arr[offset];
    this.r = arr[offset + 1];
    this.m = arr[offset + 2];
    return this;
  }

  toArray3(arr, offset = 0) {
    arr[offset] = this.a;
    arr[offset + 1] = this.r;
    arr[offset + 2] = this.m;
    return this;
  }

  setARM3f(a, r, m) {
    this.a = a;
    this.r = r;
    this.m = m;
    return this;
  }

  setARM4f(a, r, m, s) {
    this.a = a;
    this.r = r;
    this.m = m;
    this.s = s;
    return this;
  }

  copyFrom(c) {
    this.a = c.a;
    this.r = c.r;
    this.m = c.m;
    this.s = c.s;
    return this;
  }

  copyFromARM(c) {
    this.a = c.a;
    this.r = c.r;
    this.m = c.m;
    return this;
  }

}

exports.default = Arms;

/***/ }),

/***/ "d0b3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var mySampler0: sampler;\r\n@group(0) @binding(4) var myTexture0: texture_2d<f32>;\r\n@group(0) @binding(5) var mySampler1: sampler;\r\n@group(0) @binding(6) var myTexture1: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n    @location(0) fragUV: vec2<f32>,\r\n    @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n    let factor: f32 = 0.5;\r\n    var color0: vec4<f32>;\r\n    var color1: vec4<f32>;\r\n    color0 = textureSample(myTexture0, mySampler0, fragUV) * fragPosition;\r\n    color1 = textureSample(myTexture1, mySampler1, fragUV) * fragPosition;\r\n    return color0 * vec4<f32>(1.0 - factor) + color1 * vec4<f32>(factor);\r\n}\r\n");

/***/ }),

/***/ "d36d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("struct VSOut {\r\n    @builtin(position) Position: vec4f,\r\n    @location(0) uv: vec2f,\r\n};\r\n\r\n@vertex\r\nfn main(@location(0) position: vec3f,\r\n        @location(1) uv: vec2f) -> VSOut {\r\n    var vsOut: VSOut;\r\n    vsOut.Position = vec4(position, 1.0);\r\n    vsOut.uv = uv;\r\n    return vsOut;\r\n}\r\n");

/***/ }),

/***/ "d3d0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> param: vec4f;\r\n@group(0) @binding(1) var sampler0: sampler;\r\n@group(0) @binding(2) var texture0: texture_2d<f32>;\r\n\r\nconst weight = array<f32, 5>(0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\r\nfn calcBlurColor(uv: vec2f) -> vec4f {\r\n    var dv = vec2f(param.z, 0.0) / param.xy;\r\n    let dx = dv.x;\r\n\r\n    var result = textureSample(texture0, sampler0, uv) * weight[0];\r\n\tfor (var i: i32 = 1; i < 5; i++)  {\r\n        dv.x = dx * f32(i);\r\n        result += textureSample(texture0, sampler0, uv + dv) * weight[i];\r\n        result += textureSample(texture0, sampler0, uv - dv) * weight[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n@fragment\r\nfn main(\r\n\t@location(0) uv: vec2f\r\n\t) -> @location(0) vec4f {\r\n\tvar color4 = calcBlurColor( uv );\r\n    return color4;\r\n}\r\n");

/***/ }),

/***/ "d463":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const FixScreenEntity_1 = __webpack_require__("f22d");

const RectPlaneGeometry_1 = __importDefault(__webpack_require__("0540"));

const WGGeometry_1 = __webpack_require__("746a");

const WGMaterial_1 = __webpack_require__("943f");

const WGRUniformValue_1 = __webpack_require__("7650");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const fixScreenPlane_frag_wgsl_1 = __importDefault(__webpack_require__("611e"));

const fixScreenPlaneTex_frag_wgsl_1 = __importDefault(__webpack_require__("1934"));

const Extent2_1 = __importDefault(__webpack_require__("f937"));

class FixScreenPlaneEntity extends FixScreenEntity_1.FixScreenEntity {
  constructor(param) {
    super(param);
    this.mColor = new Color4_1.default();
    this.mExtent = new Extent2_1.default();
    if (!param) param = {};

    if (!(param.building === false)) {
      this.createGeometry(param);
      this.createMaterial(param);
    }
  }

  setColor(c) {
    if (c && this.mColorV) {
      this.mColor.setColor(c).toArray4(this.mColorV.data);
      this.mColorV.version++;
    }

    return this;
  }

  set color(c) {
    this.setColor(c);
  }

  get color() {
    return this.mColor;
  }

  createGeometry(param) {
    if (param.geometry) {
      this.geometry = param.geometry;
    } else {
      let geom = new RectPlaneGeometry_1.default();
      geom.axisType = 0;
      geom.flipY = param.flipY === true;

      if (param.extent !== undefined) {
        const t = this.mExtent;
        t.setExtent(param.extent);
        geom.initialize(t.x, t.y, t.width, t.height);
      } else {
        geom.initialize(param.x === undefined ? -1 : param.x, param.y === undefined ? -1 : param.y, param.width === undefined ? 2 : param.width, param.height === undefined ? 2 : param.height);
      }

      this.geometry = new WGGeometry_1.WGGeometry().addAttribute({
        position: geom.getVS()
      }).addAttribute({
        uv: geom.getUVS()
      }).setIndices(geom.getIVS());
    }
  }

  createMaterial(param) {
    if (param.materials) {
      this.materials = param.materials;
    } else {
      if (!param.uniformValues) {
        this.mColorV = FixScreenEntity_1.getUniformValueFromParam("color", param, new WGRUniformValue_1.WGRUniformValue({
          data: new Float32Array([1, 1, 1, 1]),
          shdVarName: "color"
        }));
      }

      const texs = param.textures;
      const texTotal = texs ? texs.length : 0;
      let fragUuid = texTotal > 0 ? "fragTex" : "frag";
      const shaderSrc = param.shaderSrc ? param.shaderSrc : {
        vertShaderSrc: {
          code: fixScreenPlane_vert_wgsl_1.default,
          uuid: "fixScreenPlaneVertShdCode"
        },
        fragShaderSrc: {
          code: texTotal > 0 ? fixScreenPlaneTex_frag_wgsl_1.default : fixScreenPlane_frag_wgsl_1.default,
          uuid: "fixScreenPlaneShdCode" + fragUuid
        }
      };
      let b = param.depthWriteEnabled;
      b = b === undefined ? false : b;
      let f = param.faceCullMode;
      f = f ? f : "back";
      let bl = param.blendModes;
      bl = bl ? bl : ["solid"];
      let pipelineDefParam = {
        depthWriteEnabled: b,
        faceCullMode: f,
        blendModes: bl
      };
      let shadinguuid = param.shadinguuid !== undefined ? param.shadinguuid : "FixScreenPlaneEntity-material-tex" + texTotal;
      const material = new WGMaterial_1.WGMaterial({
        shadinguuid,
        shaderSrc,
        pipelineDefParam
      });
      material.addTextures(texs);

      if (param.instanceCount !== undefined) {
        material.instanceCount = param.instanceCount;
      }

      material.uniformValues = param.uniformValues ? param.uniformValues : [this.mColorV];

      if (material.uniformValues && material.uniformValues.length > 0) {
        this.mColorV = material.uniformValues[0];
      }

      this.materials = [material];
    }

    WGMaterial_1.checkMaterialRPasses(this.materials, param.rpasses); // const rpasses = param.rpasses;
    // if (rpasses) {
    // 	const ms = this.materials;
    // 	// 这里的实现需要优化, 因为一个material实际上可以加入到多个rpass中去
    // 	let len = Math.min(rpasses.length, ms.length);
    // 	for (let i = 0; i < len; ++i) {
    // 		const rpass = ms[i].rpass;
    // 		if (!rpass || !rpass.rpass.node) {
    // 			ms[i].rpass = rpasses[i];
    // 		}
    // 	}
    // }
  }

  destroy() {
    super.destroy();
  }

}

exports.FixScreenPlaneEntity = FixScreenPlaneEntity;

/***/ }),

/***/ "d493":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const SphereEntity_1 = __webpack_require__("9849");

const BoxEntity_1 = __webpack_require__("5009");

const CylinderEntity_1 = __webpack_require__("76e3");

const CubeEntity_1 = __webpack_require__("0069");

const TorusEntity_1 = __webpack_require__("5118");

const PlaneEntity_1 = __webpack_require__("7e70");

const ConeEntity_1 = __webpack_require__("97f2");

const AxisEntity_1 = __webpack_require__("603e");

class EntityCloneTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("EntityCloneTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    let axis = new AxisEntity_1.AxisEntity();
    rc.addEntity(axis);
    axis = axis.clone();
    axis.transform.setScaleAll(0.3).setXYZ(50, 0, 50);
    rc.addEntity(axis);
    let entities = [new SphereEntity_1.SphereEntity(), new BoxEntity_1.BoxEntity(), new CylinderEntity_1.CylinderEntity({
      alignYRatio: 0.0
    }), new CubeEntity_1.CubeEntity({
      cubeSize: 130
    }), new TorusEntity_1.TorusEntity({
      radius: 110,
      axisType: 1
    }), new PlaneEntity_1.PlaneEntity({
      axisType: 1,
      extent: [-80, -80, 160, 160],
      doubleFace: true
    }), new ConeEntity_1.ConeEntity({
      alignYRatio: 0.0
    })];
    let ls = entities;
    entities = []; // random sorting

    for (let i = 0, ln = ls.length; i < ln; ++i) {
      const k = Math.round(Math.random() * 888) % ls.length;
      entities.push(ls[k]);
      ls.splice(k, 1);
    }

    let radius = 300.0;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length;
      let entity = entities[i].setAlbedo(new Color4_1.default().randomRGB(1.5, 0.1));
      entity.arm = [1.1, Math.random() * 0.95 + 0.05, Math.random() * 0.9 + 0.1];
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]);
      rc.addEntity(entity);
    }

    radius += 200;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length + 0.4;
      let entity = entities[i].clone({
        doubleFace: true,
        wireframe: true
      });
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]).setScaleAll(0.7);
      rc.addEntity(entity);
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.EntityCloneTest = EntityCloneTest;

/***/ }),

/***/ "d5c3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGREntityNode_1 = __webpack_require__("4145");

const __$RUB = {
  uid: 0,
  blocks: []
};

class WGRenderUnitBlock {
  constructor() {
    this.mUid = __$RUB.uid++;
    this.mUnits = [];
    this.mENodeMap = new Map();
    this.mMaterialMap = new Map();
  }

  static createBlock() {
    const b = new WGRenderUnitBlock();

    __$RUB.blocks.push(b);

    return b;
  }

  static getBlockAt(i) {
    return __$RUB.blocks[i];
  }

  get uid() {
    return this.mUid;
  }

  hasMaterial(material) {
    if (material.uid !== undefined) {
      const map = this.mMaterialMap;

      if (map.has(material.uid)) {
        return true;
      }

      map.set(material.uid, material);
    }

    return false;
  }

  addEntityToBlock(entity, node) {
    entity.update();
    node.rstate.__$rever++;
    const runit = this.rbParam.roBuilder.createRUnit(entity, this.builder, node, this.uid);
    runit.etuuid = entity.uuid + '-[block(' + this.uid + ')]';
    this.addRUnit(runit);
  }

  addEntity(entity) {
    // console.log("Renderer::addEntity(), entity.isInRenderer(): ", entity.isInRenderer());
    if (entity) {
      const map = this.mENodeMap;
      const euid = entity.uid;

      if (!map.has(euid)) {
        let node = new WGREntityNode_1.WGREntityNode();
        node.entity = entity;
        node.entityid = euid;
        node.blockid = this.uid;

        entity.__$bids.push(node.blockid);

        map.set(euid, node);
        entity.rstate.__$inRenderer = true;
        entity.update(); // console.log("and a new entity into the unit bolck, entity: ", entity);
        // console.log("and a new entity into the unit bolck, entity.isInRenderer(): ", entity.isInRenderer());
        // console.log("and a new entity into the unit bolck, this.builder: ", this.builder);

        const wgctx = this.rbParam.roBuilder.wgctx;
        let flag = true;

        if (wgctx && wgctx.enabled) {
          if (entity.isREnabled()) {
            flag = false;
            this.addEntityToBlock(entity, node);
          }
        }

        if (flag) {
          this.rbParam.entityMana.addEntity({
            entity: entity,
            rever: node.rstate.__$rever,
            builder: this.builder,
            node,
            block: this
          });
        }
      } else {
        console.log("has exist the entity in the unit bolck...");
      }
    }
  }

  removeEntity(entity) {
    console.log("WGRenderUnitBlock::removeEntity(), entity.isInRenderer(): ", entity.isInRenderer());

    if (entity) {
      const map = this.mENodeMap;
      const euid = entity.uid;
      console.log("WGRenderUnitBlock::removeEntity(), map.has(euid): ", map.has(euid), ", euid: ", euid);

      if (map.has(euid)) {
        const node = map.get(euid);
        node.rstate.__$rever++;
        map.delete(euid);
        const et = node.entity;
        const ls = et.__$bids;

        if (ls) {
          const bid = this.uid;

          for (let i = 0; i < ls.length; ++i) {
            if (ls[i] == bid) {
              ls.splice(i, 1);
              break;
            }
          }
        }

        node.entity = null;
      }
    }
  }

  addRUnit(unit) {
    /**
     * 正式加入渲染器之前，对shader等的分析已经做好了
     */
    if (unit) {
      this.mUnits.push(unit);
    }
  }

  run() {
    const uts = this.mUnits;
    let utsLen = uts.length;

    for (let i = 0; i < utsLen;) {
      const ru = uts[i];

      if (ru.__$rever == ru.pst.__$rever) {
        if (ru.getRF()) {
          if (ru.passes) {
            const ls = ru.passes; // console.log("apply multi passes total", ls.length);

            for (let i = 0, ln = ls.length; i < ln; ++i) {
              ls[i].runBegin();
              ls[i].run();
            }
          } else {
            // console.log("apply single passes ...");
            ru.runBegin();
            ru.run();
          }
        }

        i++;
      } else {
        ru.destroy();
        uts.splice(i, 1);
        utsLen--;
        console.log("WGRenderUnitBlock::run(), remove a rendering runit.");
      }
    }
  }

  destroy() {
    const uts = this.mUnits;

    if (uts) {
      let utsLen = uts.length;

      for (let i = 0; i < utsLen; ++i) {
        const ru = uts[i];
        ru.destroy();
      }
    }
  }

}

exports.WGRenderUnitBlock = WGRenderUnitBlock;

/***/ }),

/***/ "d95d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const gameOfLife_wgsl_1 = __importDefault(__webpack_require__("32d5"));

const WGCompMaterial_1 = __webpack_require__("19f9");

const WGMaterial_1 = __webpack_require__("943f");

const gridSize = 64;
const shdWorkGroupSize = 8;
const compShdCode = `
@group(0) @binding(0) var<uniform> grid: vec2f;

@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

fn cellIndex(cell: vec2u) -> u32 {
	return (cell.y % u32(grid.y)) * u32(grid.x) +
		   (cell.x % u32(grid.x));
}

fn cellActive(x: u32, y: u32) -> u32 {
	return cellStateIn[cellIndex(vec2(x, y))];
}

@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
fn compMain(@builtin(global_invocation_id) cell: vec3u) {
	// Determine how many active neighbors this cell has.
	let activeNeighbors = cellActive(cell.x+1, 		cell.y+1) +
							cellActive(cell.x+1, 	cell.y) +
							cellActive(cell.x+1, 	cell.y-1) +
							cellActive(cell.x, 		cell.y-1) +
							cellActive(cell.x-1, 	cell.y-1) +
							cellActive(cell.x-1, 	cell.y) +
							cellActive(cell.x-1, 	cell.y+1) +
							cellActive(cell.x, 		cell.y+1);

	let i = cellIndex(cell.xy);

	// Conway's game of life rules:
	switch activeNeighbors {
		case 2: { // Active cells with 2 neighbors stay active.
			cellStateOut[i] = cellStateIn[i];
		}
		case 3: { // Cells with 3 neighbors become or stay active.
			cellStateOut[i] = 1;
		}
		default: { // Cells with < 2 or > 3 neighbors become inactive.
			cellStateOut[i] = 0;
		}
	}
}`;

class GameOfLifeMultiMaterialPass {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mStep = 0;
    this.mFrameDelay = 3;
  }

  initialize() {
    console.log("GameOfLifeMultiMaterialPass::initialize() ...");
    this.initScene();
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i++) {
      cellStateArray0[i] = Math.random() > 0.6 ? 1 : 0;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    }

    let shared = true;
    let sharedData0 = {
      data: cellStateArray0,
      shared
    };
    let sharedData1 = {
      data: cellStateArray1,
      shared
    };
    const v0 = {
      data: gridsSizesArray,
      stride: 2,
      shared,
      layout: {
        visibility: 'all'
      }
    }; // build rendering uniforms

    const va1 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    };
    const vb1 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    }; // build computing uniforms

    const compva1 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    };
    const compva2 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'comp',
        access: "read_write"
      }
    };
    const compvb1 = {
      storage: {
        bufData: sharedData1,
        stride: 1,
        shared
      },
      layout: {
        visibility: 'vert_comp'
      }
    };
    const compvb2 = {
      storage: {
        bufData: sharedData0,
        stride: 1,
        shared,
        layout: {
          visibility: 'comp',
          access: "read_write"
        }
      }
    };
    return [{
      ufvs0: [v0, va1],
      ufvs1: [v0, vb1]
    }, {
      ufvs0: [v0, compva1, compva2],
      ufvs1: [v0, compvb1, compvb2]
    }];
  }

  createMaterial(shaderSrc, uniformValues, shadinguuid, instanceCount) {
    return new WGMaterial_1.WGMaterial({
      shadinguuid,
      shaderSrc,
      instanceCount,
      uniformValues
    });
  }

  createCompMaterial(shaderSrc, uniformValues, shadinguuid, workgroupCount = 2) {
    return new WGCompMaterial_1.WGCompMaterial({
      shadinguuid,
      shaderSrc,
      uniformValues
    }).setWorkcounts(workgroupCount, workgroupCount);
  }

  initScene() {
    const rc = this.mRscene;
    const ufvsObjs = this.createUniformValues();
    const instanceCount = gridSize * gridSize;
    const workgroupCount = Math.ceil(gridSize / shdWorkGroupSize);
    let shaderSrc = {
      code: gameOfLife_wgsl_1.default,
      uuid: "shader-shading"
    };
    let compShaderSrc = {
      code: compShdCode,
      uuid: "shader-computing"
    };
    const materials = [// build ping-pong rendering process
    this.createMaterial(shaderSrc, ufvsObjs[0].ufvs0, "rshd0", instanceCount), this.createMaterial(shaderSrc, ufvsObjs[0].ufvs1, "rshd1", instanceCount), // build ping-pong computing process
    this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs1, "compshd0", workgroupCount), this.createCompMaterial(compShaderSrc, ufvsObjs[1].ufvs0, "compshd1", workgroupCount)];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent: [-0.8, -0.8, 1.6, 1.6],
      materials
    });
    rc.addEntity(entity);
    this.mEntity = entity;
  }

  run() {
    let rendering = this.mEntity.isRendering();

    if (rendering) {
      if (this.mFrameDelay > 0) {
        this.mFrameDelay--;
        return;
      }

      this.mFrameDelay = 3;
      const ms = this.mEntity.materials;

      for (let i = 0; i < ms.length; i++) {
        ms[i].visible = (this.mStep % 2 + i) % 2 == 0;
      }

      this.mStep++;
    }

    this.mRscene.run(rendering);
  }

}

exports.GameOfLifeMultiMaterialPass = GameOfLifeMultiMaterialPass;

/***/ }),

/***/ "d9d5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) wordPos: vec4<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>,\r\n  @location(3) camPos : vec3<f32>\r\n}\r\n\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) uv : vec2<f32>,\r\n  @location(2) normal : vec3<f32>\r\n) -> VertexOutput {\r\n\r\n  let wpos = objMat * vec4(position.xyz, 1.0);\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * wpos;\r\n  output.uv = uv;\r\n\r\n  let invMat33 = inverseM33( m44ToM33( objMat ) );\r\n  output.normal = normalize( normal * invMat33 );\r\n  output.camPos = (inverseM44(viewMat) * vec4<f32>(0.0,0.0,0.0, 1.0)).xyz;\r\n  output.wordPos = wpos;\r\n  return output;\r\n}\r\n\r\nfn inverseM33(m: mat3x3<f32>)-> mat3x3<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2];\r\n    let b01 = a22 * a11 - a12 * a21;\r\n    let b11 = -a22 * a10 + a12 * a20;\r\n    let b21 = a21 * a10 - a11 * a20;\r\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    return mat3x3<f32>(\r\n\t\tvec3<f32>(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11)) / det,\r\n                vec3<f32>(b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det,\r\n                vec3<f32>(b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det);\r\n}\r\nfn m44ToM33(m: mat4x4<f32>) -> mat3x3<f32> {\r\n\treturn mat3x3(m[0].xyz, m[1].xyz, m[2].xyz);\r\n}\r\n\r\nfn inverseM44(m: mat4x4<f32>)-> mat4x4<f32> {\r\n    let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];\r\n    let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];\r\n    let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];\r\n    let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];\r\n    let b00 = a00 * a11 - a01 * a10;\r\n    let b01 = a00 * a12 - a02 * a10;\r\n    let b02 = a00 * a13 - a03 * a10;\r\n    let b03 = a01 * a12 - a02 * a11;\r\n    let b04 = a01 * a13 - a03 * a11;\r\n    let b05 = a02 * a13 - a03 * a12;\r\n    let b06 = a20 * a31 - a21 * a30;\r\n    let b07 = a20 * a32 - a22 * a30;\r\n    let b08 = a20 * a33 - a23 * a30;\r\n    let b09 = a21 * a32 - a22 * a31;\r\n    let b10 = a21 * a33 - a23 * a31;\r\n    let b11 = a22 * a33 - a23 * a32;\r\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\treturn mat4x4<f32>(\r\n\t\tvec4<f32>(a11 * b11 - a12 * b10 + a13 * b09,\r\n\t\ta02 * b10 - a01 * b11 - a03 * b09,\r\n\t\ta31 * b05 - a32 * b04 + a33 * b03,\r\n\t\ta22 * b04 - a21 * b05 - a23 * b03) / det,\r\n\t\t\tvec4<f32>(a12 * b08 - a10 * b11 - a13 * b07,\r\n\t\ta00 * b11 - a02 * b08 + a03 * b07,\r\n\t\ta32 * b02 - a30 * b05 - a33 * b01,\r\n\t\ta20 * b05 - a22 * b02 + a23 * b01) / det,\r\n\t\tvec4<f32>(a10 * b10 - a11 * b08 + a13 * b06,\r\n\t\ta01 * b08 - a00 * b10 - a03 * b06,\r\n\t\ta30 * b04 - a31 * b02 + a33 * b00,\r\n\t\ta21 * b02 - a20 * b04 - a23 * b00) / det,\r\n\t\tvec4<f32>(a11 * b07 - a10 * b09 - a12 * b06,\r\n\t\ta00 * b09 - a01 * b07 + a02 * b06,\r\n\t\ta31 * b01 - a30 * b03 - a32 * b00,\r\n\t\ta20 * b03 - a21 * b01 + a22 * b00) / det);\r\n}");

/***/ }),

/***/ "dc4d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const CommonUtils_1 = __webpack_require__("fe0b");

class WGRBufferVisibility {
  constructor() {
    /**
     * A unique identifier for a resource binding within the GPUBindGroupLayout, corresponding to a GPUBindGroupEntry.
     * binding and a @binding attribute in the GPUShaderModule.
     */
    this.binding = 0;
    /**
     * A bitset of the members of GPUShaderStage.
     * Each set bit indicates that a GPUBindGroupLayoutEntry's resource will be accessible from the associated shader stage.
     * GPUShaderStage(GPUShaderStageFlags) values.
     * See: https://gpuweb.github.io/gpuweb/#typedefdef-gpushaderstageflags
     */

    this.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX;
  }

  toVisibleAll() {
    this.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
    return this;
  }

  toVisibleVertFrag() {
    this.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX;
    return this;
  }

  toVisibleVert() {
    this.visibility = GPUShaderStage.VERTEX;
    return this;
  }

  toVisibleVertComp() {
    this.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
    return this;
  }

  toVisibleFragComp() {
    this.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
    return this;
  }

  toVisibleFrag() {
    this.visibility = GPUShaderStage.FRAGMENT;
    return this;
  }

  toVisibleComp() {
    this.visibility = GPUShaderStage.COMPUTE;
    return this;
  }

  toBufferForUniform() {
    this.buffer = {
      type: 'uniform',
      hasDynamicOffset: false,
      minBindingSize: 0
    };
    return this;
  }

  toBufferForStorage() {
    this.buffer = {
      type: 'storage'
    };
    return this;
  }

  toBufferForReadOnlyStorage() {
    this.buffer = {
      type: 'read-only-storage'
    };
    return this;
  }

  toSamplerFiltering() {
    this.sampler = {
      type: 'filtering'
    };
    return this;
  }

  toTextureFloat(viewDimension) {
    viewDimension = viewDimension ? viewDimension : '2d';
    this.texture = {
      sampleType: 'float',
      viewDimension
    };
    return this;
  }

  clone() {
    const v = new WGRBufferVisibility();
    v.label = this.label;
    v.visibility = this.visibility;

    if (this.buffer) {
      v.buffer = {};
      CommonUtils_1.copyFromObjectValueWithKey(this.buffer, v.buffer);
    }

    if (this.sampler) {
      v.sampler = {};
      CommonUtils_1.copyFromObjectValueWithKey(this.sampler, v.sampler);
    }

    if (this.texture) {
      v.texture = {};
      CommonUtils_1.copyFromObjectValueWithKey(this.texture, v.texture);
    }

    return v;
  }

}

exports.WGRBufferVisibility = WGRBufferVisibility;

/***/ }),

/***/ "dca8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGCompMaterial_1 = __webpack_require__("19f9");

const Entity3D_1 = __webpack_require__("551f");

exports.Entity3DParam = Entity3D_1.Entity3DParam;
exports.getUniformValueFromParam = Entity3D_1.getUniformValueFromParam;

class ComputeEntity extends Entity3D_1.Entity3D {
  constructor(param) {
    param = param ? param : {
      transformEnabled: false
    };
    param.transformEnabled = false;
    super(param);
    this.cameraViewing = false;
    const wts = param.workcounts;

    if (wts) {
      this.setWorkcounts(wts[0], wts.length > 1 ? wts[1] : 0, wts.length > 2 ? wts[2] : 0);
    }

    this.createMaterial(param);
  }
  /**
   * @param x workgroupCountX
   * @param y workgroupCountY
   * @param z workgroupCountZ
   */


  setWorkcounts(x, y, z) {
    if (!this.workcounts) {
      this.workcounts = new Uint16Array([1, 1, 0, 0]);
    }

    const ts = this.workcounts;
    ts[0] = x;
    ts[1] = y !== undefined ? y : 0;
    ts[2] = z !== undefined ? z : 0;
    return this;
  }

  createMaterial(param) {
    if (!param) param = {};

    if (param.materials) {
      this.materials = param.materials;
    } else {
      const shaderSrc = param.shaderSrc;
      const material = new WGCompMaterial_1.WGCompMaterial({
        shadinguuid: param.shadinguuid !== undefined ? param.shadinguuid : "ComputeEntity-material",
        shaderSrc
      });

      if (param.instanceCount !== undefined) {
        material.instanceCount = param.instanceCount;
      }

      material.uniformValues = param.uniformValues;
      this.materials = [material];
    }
  }

  isREnabled() {
    return true;
  }

  update() {
    return this;
  }

}

exports.ComputeEntity = ComputeEntity;

/***/ }),

/***/ "ddc9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRendererPass_1 = __webpack_require__("0142");

exports.WGRPassParam = WGRendererPass_1.WGRPassParam;

const WGRPipelineCtxParams_1 = __webpack_require__("bf93");

exports.WGRPipelineContextDefParam = WGRPipelineCtxParams_1.WGRPipelineContextDefParam;

const WGRPassWrapper_1 = __webpack_require__("2258");

const WGRenderPassNode_1 = __webpack_require__("7751");

const WGRenderUnitBlock_1 = __webpack_require__("d5c3");

class WGRenderPassBlock {
  constructor(rendererUid, bp, wgCtx, param) {
    this.mRendererUid = 0;
    this.mCompPassNodes = [];
    this.mRPassNodes = [];
    this.mRSeparatePassNodes = [];
    this.mPassNodes = [];
    this.mPNodeFlags = [];
    this.enabled = true;
    this.mRendererUid = rendererUid;
    this.mRBParam = bp;
    this.camera = bp.camera;
    this.mrPassParam = param;
    this.initialize(wgCtx, param);
  }

  getWGCtx() {
    return this.mWGCtx;
  }

  initialize(wgCtx, param) {
    this.mrPassParam = param ? param : this.mrPassParam;

    if (wgCtx) {
      param = this.mrPassParam;

      if (!this.mWGCtx && wgCtx && wgCtx.enabled) {
        this.mWGCtx = wgCtx;

        for (let i = 0; i < this.mPassNodes.length; ++i) {
          this.mPassNodes[i].initialize(wgCtx);
        }
      }

      if (this.mPassNodes.length == 0 && param) {
        const passNode = new WGRenderPassNode_1.WGRenderPassNode(this.mRBParam);
        passNode.builder = this;
        passNode.initialize(wgCtx, param);
        this.mPassNodes.push(passNode);
        this.mPNodeFlags.push(1);
        this.mRPassNodes.push(passNode);
      }
    }
  }

  hasMaterial(material) {
    if (this.unitBlock) {
      return this.unitBlock.hasMaterial(material);
    }

    return false;
  }

  addEntity(entity) {
    // console.log("Renderer::addEntity(), entity.isInRenderer(): ", entity.isInRenderer());
    if (entity) {
      if (!this.unitBlock) {
        this.unitBlock = WGRenderUnitBlock_1.WGRenderUnitBlock.createBlock();
      }

      const ub = this.unitBlock;
      ub.rbParam = this.mRBParam;
      ub.builder = this;
      ub.addEntity(entity);
    }
  }

  getRenderPassAt(index) {
    const ls = this.mRPassNodes;
    const ln = ls.length;
    if (index < 0) index = 0;else if (index >= ln) index = ln;
    return {
      index,
      node: ls[index]
    };
  }

  getComptePassAt(index) {
    const ls = this.mCompPassNodes;
    const ln = ls.length;
    if (index < 0) index = 0;else if (index >= ln) index = ln;
    return {
      index,
      node: ls[index]
    };
  }

  appendRendererPass(param) {
    if (!param) param = {};
    const computing = param && param.computeEnabled === true;
    let index = -1;
    const passNode = new WGRenderPassNode_1.WGRenderPassNode(this.mRBParam, !computing);
    passNode.camera = this.camera;
    console.log("appendRendererPass(), create a new render pass, param: ", param);

    if (computing) {
      passNode.builder = this;
      passNode.name = "newcomppassnode-" + this.mPassNodes.length;
      passNode.initialize(this.mWGCtx, param);
      this.mCompPassNodes.push(passNode);
      index = this.mCompPassNodes.length - 1;
    } else {
      passNode.name = "newpassnode-" + this.mPassNodes.length;
      let prevNode;
      let prevPass = param.prevPass;
      let prevNodeParam;

      if (prevPass && prevPass.node !== undefined) {
        prevNode = prevPass.node;
        prevNodeParam = prevNode.param;
        param.multisampleEnabled = prevNodeParam.multisampleEnabled;
        param.depthFormat = prevNodeParam.depthFormat;
        passNode.builder = this;
        passNode.prevNode = prevNode;
        passNode.initialize(this.mWGCtx, param ? param : prevNode.param);
        const rpass = passNode.rpass;
        rpass.name = "newpass_type01";
        rpass.passColors[0].loadOp = "load";
        rpass.passDepthStencil.depthLoadOp = "load";
        this.mRPassNodes.push(passNode);
        index = this.mRPassNodes.length - 1;
      } else if (!(param.separate === true)) {
        prevNode = this.mRPassNodes[this.mRPassNodes.length - 1];
        prevNodeParam = prevNode.param;
        param.multisampleEnabled = prevNodeParam.multisampleEnabled;
        param.depthFormat = prevNodeParam.depthFormat;
        passNode.prevNode = prevNode;
        passNode.initialize(this.mWGCtx, param ? param : prevNode.param);
        const rpass = passNode.rpass;
        rpass.name = "newpass_type02";
        this.mRPassNodes.push(passNode);
        index = this.mRPassNodes.length - 1;
      } else {
        console.log("create a separate render pass.");
        const rpass = passNode.rpass;
        rpass.name = "newpass_type03(separate)";
        passNode.separate = rpass.separate = true;
        passNode.initialize(this.mWGCtx, param ? param : prevNode.param);
        this.mRSeparatePassNodes.push(passNode);
        index = -1;
      }
    }

    this.mPassNodes.push(passNode);
    this.mPNodeFlags.push(1);
    const ref = new WGRPassWrapper_1.WGRPassWrapper();
    ref.index = index;
    ref.node = passNode;
    return ref;
  }

  getPassNode(ref) {
    const nodes = this.mRPassNodes;
    let node = nodes[nodes.length - 1];

    if (ref) {
      if (ref.node) {
        return node;
      }

      if (ref.index !== undefined) {
        if (ref.index >= 0 && ref.index < nodes.length) {
          node = nodes[ref.index];
        }
      }
    }

    return node;
  }

  getPassNodeWithMaterial(material) {
    let node = this.getPassNode(material.rpass ? material.rpass.rpass : null);

    if (material.shaderSrc.compShaderSrc) {
      if (this.mCompPassNodes.length < 1) {
        this.appendRendererPass({
          computeEnabled: true
        });
      }

      node = this.mCompPassNodes[this.mCompPassNodes.length - 1];
    }

    return node;
  }

  createRenderPipelineCtxWithMaterial(material) {
    throw Error('Illegal operation !!!');
    return null;
  } // pipelineParam value likes {blendMode: "transparent", depthWriteEnabled: false, faceCullMode: "back"}


  createRenderPipelineCtx(shdSrc, pipelineVtxParam, pipelineParam, renderPassConfig) {
    const node = this.getPassNode(renderPassConfig);
    return node.createRenderPipelineCtx(shdSrc, pipelineVtxParam, pipelineParam);
  }

  createRenderPipeline(pipelineParams, vtxDesc, renderPassConfig) {
    const node = this.getPassNode(renderPassConfig);
    return node.createRenderPipeline(pipelineParams, vtxDesc);
  }

  setPassNodeGraph(graph) {
    this.mGraph = graph;

    if (graph) {
      let ps = graph.passes;

      for (let i = 0; i < ps.length; ++i) {
        const node = ps[i].node;
        node.mode = 1;
      }
    }
  }

  runBegin() {
    this.rcommands = [];

    if (this.enabled) {
      const graph = this.mGraph;

      if (graph) {
        // let ps = graph.passes;
        // for (let i = 0; i < ps.length; ++i) {
        // 	const node = ps[i].node;
        // 	node.rcommands = [];
        // }
        graph.runBegin();
      }

      const nodes = this.mPassNodes;

      for (let i = 0; i < nodes.length; ++i) {
        if (nodes[i].mode < 1) {
          nodes[i].runBegin();
        }
      }
    }
  }

  runEnd() {
    if (this.enabled) {
      const graph = this.mGraph;

      if (graph) {
        this.rcommands = this.rcommands.concat(graph.cmdWrapper.rcommands);
      }

      const nodes = this.mPassNodes; // console.log("this.mPassNodes: ", this.mPassNodes);

      for (let i = 0; i < nodes.length; ++i) {
        const node = nodes[i];

        if (node.mode < 1) {
          node.runEnd();
          this.rcommands = this.rcommands.concat(node.rcommands);
        }
      } // console.log("this.rcommands: ", this.rcommands);

    }
  }

  run() {
    if (this.enabled) {
      const graph = this.mGraph;

      if (graph) {
        graph.run();
      }

      const nodes = this.mPassNodes;

      for (let i = 0; i < nodes.length; ++i) {
        if (nodes[i].mode < 1) {
          nodes[i].run();
        }
      }

      if (this.unitBlock) {
        this.unitBlock.run();
      }
    }
  }

  destroy() {
    if (this.mWGCtx) {
      this.mWGCtx = null;
      this.mRPassNodes = [];
      this.mCompPassNodes = [];
      this.mPassNodes = [];
      this.mRBParam = null;
    }
  }

}

exports.WGRenderPassBlock = WGRenderPassBlock;

/***/ }),

/***/ "df0d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertOutput {\r\n\t@builtin(position) Position : vec4<f32>,\r\n\t@location(0) uv : vec2<f32>,\r\n\t@location(1) normal : vec3<f32>\r\n}\r\n@vertex\r\nfn main(\r\n\t@location(0) position : vec3<f32>,\r\n\t@location(1) uv : vec2<f32>,\r\n\t@location(2) normal : vec3<f32>\r\n\t) ->VertOutput {\r\n\t\tlet wpos = objMat * vec4(position.xyz, 1.0);\r\n\t\tvar output : VertOutput;\r\n\t\toutput.Position = projMat * viewMat * wpos;\r\n\t\toutput.uv = uv;\r\n\t\toutput.normal = normal;\r\n    return output;\r\n}\r\n");

/***/ }),

/***/ "dfa8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const __$RID = {
  uid: 0
};

function createNewWRGBufferViewUid() {
  return __$RID.uid++;
}

exports.createNewWRGBufferViewUid = createNewWRGBufferViewUid;

class WGRBufferView {
  constructor() {
    this.mUid = createNewWRGBufferViewUid();
    this.arrayStride = 1;
    this.usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
    this.byteOffset = 0;
    this.version = -1;
  }

  get byteLength() {
    return this.data.byteLength;
  }

  get uid() {
    return this.mUid;
  }

  setParam(param) {
    if (param) {
      if (param.data) this.data = param.data;
      if (param.buffer) this.buffer = param.buffer;
      if (param.mappedAtCreation !== undefined) this.mappedAtCreation = param.mappedAtCreation;
      if (param.shared !== undefined) this.shared = param.shared;
    }

    return this;
  }

}

exports.WGRBufferView = WGRBufferView;

/***/ }),

/***/ "e0de":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const sampleTextureColorParam_frag_wgsl_1 = __importDefault(__webpack_require__("0bc4"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRStorageValue_1 = __webpack_require__("e44f");

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class Entity3DVisibilityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mEntities = [];
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();

    this.mouseDown = evt => {
      let et = this.mEntities[0];
      et.rstate.visible = !et.rstate.visible;
      console.log("et.rstate.visible: ", et.rstate.visible);
    };

    this.mRotValue = 0.0;
  }

  initialize() {
    console.log("Entity3DVisibilityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createMaterial(shdSrc, texs, color, blendModes = ["solid"], faceCullMode = "back") {
    color = color ? color : new Color4_1.default();
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texs ? texs.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    let ufv = new WGRStorageValue_1.WGRStorageValue({
      data: new Float32Array([color.r, color.g, color.b, 1])
    });
    material.uniformValues = [ufv];
    material.addTextures(texs);
    return material;
  }

  createGeom(rgd, normalEnabled = false) {
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).addAttribute({
      uv: rgd.uvs
    }).setIndices(rgd.ivs);

    if (normalEnabled) {
      geometry.addAttribute({
        normal: rgd.nvs
      });
    }

    return geometry;
  }

  initScene() {
    const rc = this.mRscene;
    const geometry = this.createGeom(this.geomData.createCube(80));
    const shdSrc = {
      vert: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: sampleTextureColorParam_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let materials0 = [this.createMaterial(shdSrc, [{
      diffuse: {
        url: "static/assets/box.jpg"
      }
    }], new Color4_1.default(1.0))];
    let materials1 = [this.createMaterial(shdSrc, [{
      diffuse: {
        url: "static/assets/default.jpg"
      }
    }], new Color4_1.default(0.0, 1.0))];
    let entity = new Entity3D_1.Entity3D({
      geometry,
      materials: materials0
    });
    rc.addEntity(entity);
    this.mEntities.push(entity);
    entity = new Entity3D_1.Entity3D({
      geometry,
      materials: materials1
    });
    entity.transform.setXYZ(200, 0, 0);
    rc.addEntity(entity);
    this.mEntities.push(entity);
  }

  run() {
    this.mRotValue += 0.5;
    this.mRscene.run();
  }

}

exports.Entity3DVisibilityTest = Entity3DVisibilityTest;

/***/ }),

/***/ "e2cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function findShaderEntryPoint(keyStr, src) {
  let i = src.indexOf(keyStr);

  if (i < 0) {
    // throw Error("Illegal Operation !!!");
    return "";
  }

  i = src.indexOf('fn', i + keyStr.length) + 2;
  let j = src.indexOf('(', i);
  return src.slice(i, j).trim();
}

exports.findShaderEntryPoint = findShaderEntryPoint;

function createFragmentState(shaderModule, targetStates) {
  const st = {
    module: shaderModule,
    entryPoint: "main",
    targets: [{
      format: "bgra8unorm"
    }]
  };

  if (targetStates !== undefined && targetStates.length > 0) {
    st.targets = targetStates;
  }

  return st;
}

exports.createFragmentState = createFragmentState;

function createComputeState(shaderModule) {
  const st = {
    module: shaderModule,
    entryPoint: "main"
  };
  return st;
}

exports.createComputeState = createComputeState;

/***/ }),

/***/ "e315":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

const MouseEvent_1 = __importDefault(__webpack_require__("c69e")); // import { IShaderUniformProbe } from "../../vox/material/IShaderUniformProbe";


const MouseEvt3DDispatcher_1 = __importDefault(__webpack_require__("f5ff"));

class StageBase {
  constructor(rcuid) {
    this.m_rcuid = 0;
    this.m_viewX = 0.0;
    this.m_viewY = 0.0;
    this.m_viewW = 1.0;
    this.m_viewH = 1.0;
    this.m_stW = 800;
    this.m_stH = 600; // mouse event dispatcher

    this.m_dp = new MouseEvt3DDispatcher_1.default(); // 是否舞台尺寸和view自动同步一致

    this.m_autoSynViewAndStageSize = true;
    this.m_preStageWidth = 0;
    this.m_preStageHeight = 0;
    this.m_mouseEvt = new MouseEvent_1.default();
    this.m_baseEvt = new EventBase_1.default(); // uProbe: IShaderUniformProbe = null;

    this.pixelRatio = 1.0;
    this.stageX = 0;
    this.stageY = 0;
    this.stageWidth = 800;
    this.stageHeight = 600; // 实际宽高, 和gpu端对齐

    this.stageHalfWidth = 400;
    this.stageHalfHeight = 300;
    this.mouseX = 0;
    this.mouseY = 0; // sdiv页面实际占据的像素宽高

    this.viewWidth = 800;
    this.viewHeight = 600;
    this.mouseViewX = 0;
    this.mouseViewY = 0;
    this.m_rcuid = rcuid;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }

  getViewX() {
    return this.m_viewX;
  }

  getViewY() {
    return this.m_viewY;
  }

  getViewWidth() {
    return this.m_viewW;
  }

  getViewHeight() {
    return this.m_viewH;
  }

  dispatchMouseEvt(phase, tar = null) {
    const evt = this.m_mouseEvt;
    evt.mouseX = this.mouseX;
    evt.mouseY = this.mouseY;
    evt.target = tar == null ? this : tar;
    evt.phase = phase;
    this.m_dp.dispatchEvt(this.m_mouseEvt);
  }

  mouseDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseDoubleClick() {
    console.log("stage apply mouseDoubleClick()...");
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_DOUBLE_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseRightDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseRightUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseMiddleDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MIDDLE_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseMiddleUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MIDDLE_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseBgDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_UP;
    this.dispatchMouseEvt(1);
  }

  mouseBgClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseBgRightDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_RIGHT_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgRightUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_RIGHT_UP;
    this.dispatchMouseEvt(1);
  }

  mouseBgMiddleDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_MIDDLE_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgMiddleUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_MIDDLE_UP;
    this.dispatchMouseEvt(1);
  }

  mouseRightClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseMove() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MOVE;
    this.dispatchMouseEvt(1);
  }

  mouseWheel(evt) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_WHEEL;
    this.m_mouseEvt.wheelDeltaY = evt.wheelDeltaY;
    this.dispatchMouseEvt(1);
  } // 等同于 touchCancle


  mouseCancel() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_CANCEL;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiDown(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_DOWN;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiUp(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_UP;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiMove(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_MOVE;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  }

  mouseWindowUp(phase = 1) {}

  mouseWindowRightUp(phase = 1) {}

  addTarget(funcs, func) {
    let i = 0;

    for (i = funcs.length - 1; i >= 0; --i) {
      if (func === funcs[i]) {
        break;
      }
    }

    if (i < 0) {
      funcs.push(func);
    }
  }

  removeTarget(funcs, func) {
    for (let i = funcs.length - 1; i >= 0; --i) {
      if (func === funcs[i]) {
        funcs.splice(i, 1);
        break;
      }
    }
  }

}

exports.default = StageBase;

/***/ }),

/***/ "e38f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

class SurfaceNormalCalc {
  /**
  * calc a triangle's normal,cw is positive, right hand rule. there is calc result is positive.
  */
  static ClacTriNormal(va, vb, vc, resultNormal) {
    let calc = SurfaceNormalCalc;
    Vector3_1.default.Subtract(vb, va, calc.s_temp_vb);
    Vector3_1.default.Subtract(vc, vb, calc.s_temp_vc);
    Vector3_1.default.Cross(calc.s_temp_vb, calc.s_temp_vc, resultNormal);
    resultNormal.normalize();
  }
  /**
  * calc a triangle's normal,cw is positive, right hand rule. there is calc result is positive.
  * @param verteies			verteies's length is N multiple 9
  * @param triangleIndex		triangle index of triangles
  * @param resultNormal		result normalize Vector3 normal
  */


  static ClacTriNormalByVS(verteies, triangleIndex, resultNormal) {
    let calc = SurfaceNormalCalc;
    let i = triangleIndex * 9;
    calc.s_temp_va.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]);
    resultNormal.setXYZ(verteies[i + 3], verteies[i + 4], verteies[i + 5]);
    calc.s_temp_vc.setXYZ(verteies[i + 6], verteies[i + 7], verteies[i + 8]);
    resultNormal.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va); //vox::kernel::geom::Vector3::cross(vb, vc, resultNormal);

    resultNormal.crossBy(calc.s_temp_vc);
    resultNormal.normalize();
  }

  static ClacTriNormalByIVS(verteies, triangleIndex, indices, resultNormal) {
    let calc = SurfaceNormalCalc;
    let j = triangleIndex * 3;
    let i = indices[j] * 3;
    calc.s_temp_va.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 1] * 3;
    resultNormal.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 2] * 3;
    calc.s_temp_vc.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]); //trace(triangleIndex, ", v3a: ", SurfaceNormalCalc.s_temp_va, ", v3b: ", resultNormal, ", v3c: ", SurfaceNormalCalc.s_temp_vc);

    resultNormal.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va);
    resultNormal.crossBy(calc.s_temp_vc);
    resultNormal.normalize(); //trace("						normal: ", resultNormal);
  }

  static ClacTrisNormal(verteies, verteiesLength, numTriangles, indices, normals) {
    let calc = SurfaceNormalCalc;
    let v3 = new Vector3_1.default();
    let j = 0,
        k = 0,
        i = 0;

    for (i = 0; i < verteiesLength; ++i) {
      normals[i] = 0.0;
    }

    for (i = 0; i < numTriangles; ++i) {
      calc.ClacTriNormalByIVS(verteies, i, indices, v3);
      j = i * 3;
      k = indices[j] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
      k = indices[j + 1] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
      k = indices[j + 2] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
    }

    for (i = 0; i < verteiesLength; i += 3) {
      calc.s_temp_va.setXYZ(normals[i], normals[i + 1], normals[i + 2]);
      calc.s_temp_va.normalize();
      normals[i] = calc.s_temp_va.x;
      normals[i + 1] = calc.s_temp_va.y;
      normals[i + 2] = calc.s_temp_va.z;
    }
  }

  static ClacTriTangent(verteies, uvs, nvs, triangleIndex, indices, tangent, biTangent) {
    let calc = SurfaceNormalCalc;
    let j = triangleIndex * 3; // pos

    let i = indices[j] * 3;
    calc.s_temp_va.setXYZ(nvs[i], nvs[i + 1], nvs[i + 2]);
    calc.s_temp_va.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 1] * 3;
    calc.s_temp_vb.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 2] * 3;
    calc.s_temp_vc.setXYZ(verteies[i], verteies[i + 1], verteies[i + 2]); // uv

    i = indices[j] * 2;
    calc.s_temp_vd.setXYZ(uvs[i], uvs[i + 1], 0.0);
    i = indices[j + 1] * 2;
    calc.s_temp_ve.setXYZ(uvs[i], uvs[i + 1], 0.0);
    i = indices[j + 2] * 2;
    calc.s_temp_vf.setXYZ(uvs[i], uvs[i + 1], 0.0); // edges of pos

    calc.s_temp_vb.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va);
    calc.s_temp_ve.subtractBy(calc.s_temp_vd);
    calc.s_temp_vf.subtractBy(calc.s_temp_vd);
    let dt = 1.0 / (calc.s_temp_ve.x * calc.s_temp_vf.y - calc.s_temp_ve.y * calc.s_temp_vf.x);
    tangent.copyFrom(calc.s_temp_vb);
    tangent.scaleBy(calc.s_temp_vf.y);
    calc.s_temp_va.copyFrom(calc.s_temp_vc);
    calc.s_temp_va.scaleBy(calc.s_temp_ve.y);
    tangent.subtractBy(calc.s_temp_va);
    tangent.scaleBy(dt);
    tangent.normalize();
    biTangent.copyFrom(calc.s_temp_vc);
    biTangent.scaleBy(calc.s_temp_ve.x);
    calc.s_temp_va.copyFrom(calc.s_temp_vb);
    calc.s_temp_va.scaleBy(calc.s_temp_vf.x);
    biTangent.subtractBy(calc.s_temp_va);
    biTangent.scaleBy(dt);
    biTangent.normalize(); //*/
  }

  static ClacTrisTangent(verteies, verteiesLength, uvs, nvs, numTriangles, indices, tangent, biTangent) {
    let calc = SurfaceNormalCalc;
    let tv3 = new Vector3_1.default(),
        btv3 = new Vector3_1.default();
    let j = 0,
        k = 0,
        i = 0;

    for (i = 0; i < verteiesLength; ++i) {
      tangent[i] = 0.0;
      biTangent[i] = 0.0;
    }

    for (i = 0; i < numTriangles; ++i) {
      calc.ClacTriTangent(verteies, uvs, nvs, i, indices, tv3, btv3);
      j = i * 3;
      k = indices[j] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
      k = indices[j + 1] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
      k = indices[j + 2] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
    }

    for (i = 0; i < verteiesLength; i += 3) {
      calc.s_temp_vd.setXYZ(tangent[i], tangent[i + 1], tangent[i + 2]);
      calc.s_temp_vd.normalize();
      calc.s_temp_vb.setXYZ(biTangent[i], biTangent[i + 1], biTangent[i + 2]);
      calc.s_temp_vb.normalize();
      calc.s_temp_vc.setXYZ(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_va.copyFrom(calc.s_temp_vc);
      calc.s_temp_vc.scaleBy(calc.s_temp_vc.dot(calc.s_temp_vd));
      calc.s_temp_vd.subtractBy(calc.s_temp_vc);
      calc.s_temp_vd.normalize(); //b = b - n * dot( b, n )

      calc.s_temp_vc.setXYZ(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_vc.scaleBy(calc.s_temp_vb.dot(calc.s_temp_vc));
      calc.s_temp_vb.subtractBy(calc.s_temp_vc);
      calc.s_temp_vb.normalize();
      calc.s_temp_va.crossBy(calc.s_temp_vd);

      if (calc.s_temp_va.dot(calc.s_temp_vb) < 0.0) {
        calc.s_temp_vd.scaleBy(-1.0);
      }

      tangent[i] = calc.s_temp_vd.x;
      tangent[i + 1] = calc.s_temp_vd.y;
      tangent[i + 2] = calc.s_temp_vd.z;
      calc.s_temp_vb.setXYZ(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_vb.crossBy(calc.s_temp_vd);
      calc.s_temp_vb.normalize();
      biTangent[i] = calc.s_temp_vb.x;
      biTangent[i + 1] = calc.s_temp_vb.y;
      biTangent[i + 2] = calc.s_temp_vb.z;
    }
  }

}

SurfaceNormalCalc.s_temp_va = new Vector3_1.default();
SurfaceNormalCalc.s_temp_vb = new Vector3_1.default();
SurfaceNormalCalc.s_temp_vc = new Vector3_1.default();
SurfaceNormalCalc.s_temp_vd = new Vector3_1.default();
SurfaceNormalCalc.s_temp_ve = new Vector3_1.default();
SurfaceNormalCalc.s_temp_vf = new Vector3_1.default();
SurfaceNormalCalc.s_temp_vg = new Vector3_1.default();
exports.default = SurfaceNormalCalc;

/***/ }),

/***/ "e44f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRUniformValue_1 = __webpack_require__("7650");

class WGRStorageValue extends WGRUniformValue_1.WGRUniformValue {
  constructor(param) {
    super(param);
    this.toStorage();
    this.visibility.toBufferForReadOnlyStorage();
  }

  clone(data) {
    // const u = new WGRUniformValue({data: data, index: this.index});
    const u = new WGRUniformValue_1.WGRUniformValue({
      data: data
    });
    u.name = this.name;
    u.byteOffset = this.byteOffset;
    u.arrayStride = this.arrayStride;
    u.usage = this.usage;
    return u;
  }

}

exports.WGRStorageValue = WGRStorageValue;

/***/ }),

/***/ "e537":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

class EvtNode {
  constructor() {
    this.type = 0;
    this.m_listeners = [];
    this.m_phases = [];
  }

  createEvent(target = null, currentTarget = null) {
    let evt = new EventBase_1.default();
    evt.type = this.type;
    evt.target = target;
    evt.currentTarget = currentTarget;
    return evt;
  }

  addListener(func, phase = 0) {
    let i = this.m_listeners.length - 1;

    for (; i >= 0; --i) {
      if (func === this.m_listeners[i]) {
        break;
      }
    }

    if (i < 0) {
      this.m_listeners.push(func);
      this.m_phases.push(phase);
    }
  }

  removeListener(func) {
    let i = this.m_listeners.length - 1;

    for (; i >= 0; --i) {
      if (func === this.m_listeners[i]) {
        this.m_listeners.splice(i, 1);
        this.m_phases.splice(i, 1);
        break;
      }
    }
  } // @return      1 is send evt yes,0 is send evt no


  dispatch(evt) {
    let flag = 0;
    let len = this.m_listeners.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || evt.phase == this.m_phases[i]) {
        this.m_listeners[i](evt);
        flag = 1;
      }
    }

    return flag;
  } //@return if the evt can be dispatched in this node,it returns 1,otherwise it returns 0


  passTestEvt(evt) {
    let len = this.m_listeners.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || evt.phase == this.m_phases[i]) {
        return 1;
        break;
      }
    }

    return 0;
  }

  passTestPhase(phase) {
    let len = this.m_listeners.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || phase == this.m_phases[i]) {
        return 1;
        break;
      }
    }

    return 0;
  }

  destroy() {
    this.m_listeners = [];
    this.m_phases = [];
  }

}

exports.default = EvtNode;

/***/ }),

/***/ "e58d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("b1fa"));

class RenderStatusDisplay {
  constructor(rsc = null, auto = false) {
    this.m_lastTime = 0;
    this.m_fps = 60;
    this.m_canvas2D = null;
    this.m_ctx2D = null;
    this.m_delayTime = 10;
    this.m_preWidth = 128;
    this.m_width = 128;
    this.m_height = 70;
    this.m_auto = false;
    this.m_dcBoo = false;
    this.m_dtBoo = false;
    this.delayTime = 40;
    this.statusInfo = "";
    this.statusEnbled = true;

    this.enterFrame = evt => {
      this.updateDo(false);
    };

    this.m_timeoutId = -1;

    if (rsc != null) {
      this.initialize(rsc, auto);
    }
  }

  setParams(drawCallTimesEnabled, trisCountEnabled = false) {
    this.m_dcBoo = drawCallTimesEnabled;
    this.m_dtBoo = trisCountEnabled;
    return this;
  }

  initialize(rsc = null, auto = false) {
    if (this.m_canvas2D == null) {
      this.m_rsc = rsc;
      this.m_auto = auto;
      var pdocument = null;

      try {
        if (document != undefined) {
          pdocument = document;
        }
      } catch (err) {
        console.log("RenderStatusDisplay::initialize(), document is undefined.");
      }

      if (pdocument != null) {
        this.m_preWidth = window.innerWidth;
        let pwith = this.m_preWidth - 20;
        this.createCanvas(pwith);
      }

      if (rsc && this.m_auto) {
        this.m_rsc.addEventListener(EventBase_1.default.ENTER_FRAME, this.enterFrame);
        this.autoUpdate();
      }
    }
  }

  autoUpdate() {
    if (this.m_timeoutId > -1) {
      clearTimeout(this.m_timeoutId);
    }

    this.m_timeoutId = setTimeout(this.autoUpdate.bind(this), 50); // 20 fps

    this.renderDo();
  }

  createCanvas(width) {
    if (this.m_canvas2D == null) {
      this.m_canvas2D = document.createElement('canvas');
      document.body.appendChild(this.m_canvas2D);
      this.m_canvas2D.style.display = 'bolck';
      this.m_canvas2D.style.left = '0px';
      this.m_canvas2D.style.top = '0px';
      this.m_canvas2D.style.position = 'absolute';
      this.m_canvas2D.style.backgroundColor = 'transparent';
      this.m_canvas2D.style.pointerEvents = 'none';
      this.m_canvas2D.height = this.m_height;
    }

    width = width < 10 ? 10 : width;
    this.m_canvas2D.width = width;
    this.m_ctx2D = this.m_canvas2D.getContext("2d");
    this.m_ctx2D.font = "50px Verdana";
    this.m_ctx2D.fillStyle = "red";
    this.m_ctx2D.textAlign = "left";
    this.m_width = this.m_canvas2D.width;
  }

  getFPS() {
    return this.m_fps;
  }

  getFPSStr() {
    //return this.m_fps;
    if (this.m_fps > 60) {
      return "FPS: 60";
    } else if (this.m_fps < 10) {
      return "FPS: 0" + this.m_fps;
    }

    return "FPS: " + this.m_fps;
  }

  renderDo() {
    if (this.m_preWidth != window.innerWidth) {
      this.m_preWidth = window.innerWidth;
      let pwith = this.m_preWidth - 20;
      this.createCanvas(pwith);
    }

    if (this.statusEnbled) {
      this.m_ctx2D.clearRect(0, 0, this.m_width, this.m_height);
      let info = "";

      if (this.m_rsc) {
        // const st = this.m_rsc.getRenderProxy().status;
        // if(this.m_dcBoo) {
        //     info += "/" + st.drawCallTimes;
        // }
        // if(this.m_dtBoo) {
        //     info += "/" + st.drawTrisNumber;
        // }
        if (this.statusInfo != "") {
          if (info != "") {
            info += "/" + this.statusInfo;
          } else {
            info = this.statusInfo;
          }
        }
      }

      this.m_ctx2D.fillText(this.getFPSStr() + info, 5, 50); //  this.m_ctx2D.fillRect(0, 0, this.m_width, this.m_height);
    }
  }

  updateDo(immediaterender = true) {
    if (this.m_delayTime > 0) {
      --this.m_delayTime;
      this.m_lastTime = Date.now();
    } else {
      if (this.m_ctx2D != null) {
        let t = Date.now();

        if (this.m_lastTime > 0) {
          this.m_lastTime = t - this.m_lastTime;
          if (this.m_lastTime < 1) this.m_lastTime = 1;
          this.m_fps = Math.round(1000.0 / this.m_lastTime);

          if (immediaterender) {
            this.render();
          }
        }

        this.m_lastTime = t;
      }

      this.m_delayTime = this.delayTime;
    }
  }

  render() {
    if (!this.m_auto) {
      this.renderDo();
    }
  }

  update(immediaterender = true) {
    if (!this.m_auto) {
      this.updateDo(immediaterender);
    }
  }

}

exports.default = RenderStatusDisplay;

/***/ }),

/***/ "e594":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "e8b6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const ComputeEntity_1 = __webpack_require__("dca8");

const WGRBufferVisibility_1 = __webpack_require__("dc4d");

const gridSize = 32;
const shdWorkGroupSize = 8;
const compShdCode = `
			@group(0) @binding(0) var<uniform> grid: vec2f;
			@group(0) @binding(1) var<storage> cellStateIn: array<u32>;
			@group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;

			fn cellIndex(cell: vec2u) -> u32 {
				return cell.y * u32(grid.x) + cell.x;
			}

			@compute @workgroup_size(${shdWorkGroupSize}, ${shdWorkGroupSize})
			fn compMain(@builtin(global_invocation_id) cell: vec3u) {
				if (cellStateIn[cellIndex(cell.xy)] == 1) {
					cellStateOut[cellIndex(cell.xy)] = 0;
				} else {
					cellStateOut[cellIndex(cell.xy)] = 1;
				}
			}`;

class ComputeEntityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("ComputeEntityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  createUniformValues() {
    const gridsSizesArray = new Float32Array([gridSize, gridSize]);
    const cellStateArray0 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray0.length; i += 3) {
      cellStateArray0[i] = 1;
    }

    const cellStateArray1 = new Uint32Array(gridSize * gridSize);

    for (let i = 0; i < cellStateArray1.length; i++) {
      cellStateArray1[i] = i % 2;
    } // const v0 = new WGRUniformValue({data: gridsSizesArray, stride: 2}).toVisibleAll();
    // const v1 = new WGRStorageValue({data: cellStateArray0, stride: 1}).toVisibleVertComp();
    // const v2 = new WGRStorageValue({data: cellStateArray1, stride: 1}).toVisibleComp();
    // v2.toBufferForStorage();


    let visibility = new WGRBufferVisibility_1.WGRBufferVisibility().toVisibleAll();
    const v0 = {
      data: gridsSizesArray,
      stride: 2,
      visibility
    }; // const v0 = new WGRUniformValue({data: gridsSizesArray, stride: 2}).toVisibleAll();

    visibility = new WGRBufferVisibility_1.WGRBufferVisibility().toVisibleVertComp();
    const v1 = {
      storage: {
        data: cellStateArray0,
        stride: 1,
        visibility
      }
    };
    visibility = new WGRBufferVisibility_1.WGRBufferVisibility().toVisibleComp().toBufferForStorage();
    const v2 = {
      storage: {
        data: cellStateArray1,
        stride: 1,
        visibility
      }
    };
    return [v0, v1, v2];
  }

  initScene() {
    const rc = this.mRscene;
    let shaderSrc = {
      code: compShdCode,
      uuid: 'shader-computing'
    };
    let uniformValues = this.createUniformValues();
    let entity = new ComputeEntity_1.ComputeEntity({
      shaderSrc,
      uniformValues
    });
    rc.addEntity(entity);
  }

  run() {
    this.mRscene.run();
  }

}

exports.ComputeEntityTest = ComputeEntityTest;

/***/ }),

/***/ "e943":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ButtonDivItem_1 = __webpack_require__("8895");

const util_1 = __webpack_require__("9e6d");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

class DemoTagGroup {
  constructor() {}

  initialize(div, param) {
    this.createTags(div, param);
  }

  createTags(div, param) {
    let fontSize = 12;
    let demoNames = param.demoNames;
    let px = 10;
    let py = 10;
    let len = demoNames.length; // len = 0;

    let areaSize = {
      x: 0,
      y: 10,
      width: 0,
      height: 0
    };

    for (let i = 0; i < len; ++i) {
      let name = demoNames[i];
      areaSize = this.getTextSize(name, fontSize + 4);
      let tx = px + areaSize.x + areaSize.width + 10;

      if (tx > 512) {
        py += areaSize.height + 10;
        px = 10;
      }

      areaSize.x = px;
      areaSize.y = py;
      areaSize.height -= 4; // console.log("areaSize: ", areaSize);

      this.createTag(div, i, fontSize + 'px', name, areaSize);
      px = areaSize.x + areaSize.width + 10;
    } // let c = new Color4(0.9478580831418233,0.9789360746399547,0.6743519901760193).ceil();
    // console.log("### ### ### color: ", c);
    // console.log("c: ", c.r, c.g, c.b);

  }

  createTag(parentDiv, index, fontSize, name, area) {
    let cb = new Color4_1.default();
    cb.randomRGB(0.5, 0.2);
    let btn = new ButtonDivItem_1.ButtonDivItem(); // console.log("           >>> >>> area.x, area.y: ", area.x, area.y);

    let div = util_1.createDiv(area.x, area.y, area.width, area.height);
    parentDiv.appendChild(div);
    btn.setDeselectColors([cb.clone().scaleBy(0.7).getRGBUint24(), cb.clone().scaleBy(0.8).getRGBUint24(), cb.clone().getRGBUint24()]);
    btn.initialize(div, name, name); // div.style.cursor = "none";

    btn.setTextSize(fontSize);
    let c = new Color4_1.default().randomRGB(1.0, 0.4).clamp().ceil().clamp();
    btn.setTextColor(c.getRGBUint24());
    btn.setTextAlign('center');

    btn.onmouseup = () => {
      this.mana.gotoIndex(index);
      window.location.reload();
    };
  }

  getTextSize(chars, fontSize = 20, fixWidth = 0) {
    if (chars == null || chars == "" || fontSize < 8) {
      return null;
    }

    let width = fontSize + 4;
    let height = fontSize + 6;

    if (chars.length > 1) {
      width = fontSize * chars.length;
    }

    let canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height; // canvas.style.display = "bolck";
    // canvas.style.left = "0px";
    // canvas.style.top = "0px";
    // canvas.style.position = "absolute";

    canvas.style.backgroundColor = "transparent"; //canvas.style.pointerEvents = 'none';

    let ctx2D = canvas.getContext("2d");
    ctx2D.font = fontSize - 4 + "px Verdana"; //ctx2D.textBaseline = "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom";

    ctx2D.textBaseline = "top";
    var metrics = ctx2D.measureText(chars);
    let texWidth = metrics.width;

    if (chars.length > 1 || fixWidth > 0) {
      width = Math.round(texWidth + 8);

      if (fixWidth > 0 && width < fixWidth) {
        width = fixWidth;
      }

      canvas.width = width;
      ctx2D = canvas.getContext("2d");
      ctx2D.font = fontSize - 4 + "px Verdana";
      ctx2D.textBaseline = "top";
    }
    /*
    ctx2D.fillStyle = bgStyle;
    ctx2D.fillRect(0, 0, width, height);
    ctx2D.textAlign = "left";
    ctx2D.fillStyle = frontStyle;
      ctx2D.fillText(chars, Math.round((width - texWidth) * 0.5), 6);
    //*/


    return {
      x: 0,
      y: 0,
      width,
      height
    };
  }

}

exports.DemoTagGroup = DemoTagGroup;

/***/ }),

/***/ "e958":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("@group(0) @binding(3) var<uniform> param: vec4f;\r\n@group(0) @binding(4) var mySampler: sampler;\r\n@group(0) @binding(5) var myTexture: texture_2d<f32>;\r\n\r\n@fragment\r\nfn main(\r\n  @location(0) fragUV: vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n  var color4 = textureSample(myTexture, mySampler, fragUV) * fragPosition * param;\r\n  color4 = vec4(color4.xyz, 1.0);\r\n  return color4;\r\n}\r\n");

/***/ }),

/***/ "ebca":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const SurfaceNormalCalc_1 = __importDefault(__webpack_require__("e38f"));

const AABB_1 = __importDefault(__webpack_require__("3e40"));

const GeometryBase_1 = __importDefault(__webpack_require__("348f"));

const GeometryVertex_1 = __importDefault(__webpack_require__("98bb"));

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const Define_1 = __webpack_require__("af1b");

class ConeGeometry extends GeometryBase_1.default {
  constructor() {
    super();
    this.normalType = Define_1.WGRNormalType.GOURAND;
  }

  getVS() {
    return this.mvs;
  }

  getUVS() {
    return this.muvs;
  }

  getNVS() {
    return this.mnvs;
  }

  getIVS() {
    return this.mivs;
  }

  initialize(radius, height, longitudeNumSegments, alignYRatio = -0.5) {
    if (this.vtxTotal < 1) {
      if (radius < 0.01) radius = 0.01;
      if (longitudeNumSegments < 2) longitudeNumSegments = 2;
      let latitudeNumSegments = 2;
      let i = 1;
      let j = 0;
      let trisTot = 0;
      let yRad = 0.0;
      let px = 0.0;
      let py = 0.0;
      radius = Math.abs(radius);
      height = Math.abs(height);
      let minY = alignYRatio * height;
      let vtx = new GeometryVertex_1.default(0.0, minY, 0.0, trisTot);
      this.bounds = new AABB_1.default();
      this.bounds.min.setXYZ(-radius, minY, -radius);
      this.bounds.max.setXYZ(radius, minY + height, radius);
      this.bounds.updateFast(); // 计算绕 y轴 的纬度线上的点

      let vtxVec = [];
      let vtxRows = [];
      vtxRows.push([]);
      let vtxRow = vtxRows[0];
      vtx.f = 0;
      vtx.u = 0.5;
      vtx.v = 0.5;
      vtx.nx = 0.0;
      vtx.ny = -1.0;
      vtx.nz = 0.0;

      for (j = 0; j < 1; ++j) {
        vtx.index = trisTot;
        ++trisTot;
        vtxRow.push(vtx.cloneVertex());
        vtxVec.push(vtxRow[j]);
      }

      py = minY;
      let py2 = 0.499;
      let pos0 = new Vector3_1.default(0, minY + height, 0);
      let pos1 = new Vector3_1.default(0, minY + height, 0);
      let pos2 = new Vector3_1.default(0, minY + height, 0);

      for (; i < latitudeNumSegments; ++i) {
        yRad = Math.PI * i / latitudeNumSegments;
        vtx.y = py;
        vtxRows.push([]);
        let rowa = vtxRows[i];

        for (j = 0; j < longitudeNumSegments; ++j) {
          yRad = Math.PI * 2.0 * j / longitudeNumSegments;
          px = Math.sin(yRad);
          py = Math.cos(yRad);
          vtx.x = px * radius;
          vtx.z = py * radius;
          vtx.index = trisTot;
          ++trisTot; // calc uv

          px *= py2;
          py *= py2;
          vtx.u = 0.5 + px;
          vtx.v = 0.5 + py;
          vtx.f = 0;
          pos1.copyFrom(pos0);
          pos2.setXYZ(vtx.x, vtx.y, vtx.z);
          pos2.subtractBy(pos1);
          pos2.normalize();
          pos1.setXYZ(vtx.x, 0, vtx.z);
          pos1.normalize();
          pos1.addBy(pos2);
          pos1.normalize();
          vtx.nx = pos1.x;
          vtx.ny = pos1.y;
          vtx.nz = pos1.z;
          rowa.push(vtx.cloneVertex());
          vtxVec.push(rowa[j]);
        }

        rowa.push(rowa[0]);
      }

      vtxRows.push([]);
      let rowa = vtxRows[vtxRows.length - 1];
      let rowb = vtxRows[vtxRows.length - 2];

      for (j = 0; j < longitudeNumSegments; ++j) {
        let pv = rowb[j].cloneVertex();
        pv.f = 1;
        rowa.push(pv);
        rowa[j].index = trisTot;
        ++trisTot;
        vtxVec.push(rowa[j]);
        pv = rowb[j];
        pv.nx = 0.0;
        pv.ny = -1.0;
        pv.nz = 0.0;
      }

      rowa.push(rowa[0]);
      vtx.f = 0;
      vtx.x = 0.0;
      vtx.y = minY + height;
      vtx.z = 0.0;
      vtx.u = 0.5;
      vtx.v = 0.5;
      vtx.nx = 0.0;
      vtx.ny = 1.0;
      vtx.nz = 0.0;
      vtxRows.push([]);
      let lastRow = vtxRows[vtxRows.length - 1];

      for (j = 0; j < longitudeNumSegments; ++j) {
        vtx.index = trisTot;
        ++trisTot;
        lastRow.push(vtx.cloneVertex());
        vtxVec.push(lastRow[j]);
      }

      lastRow.push(lastRow[0]);
      let pvtx; ///////////////////////////   ///////////////////////////    ////////////////

      let pivs = [];
      i = 1;
      latitudeNumSegments += 1;

      for (; i <= latitudeNumSegments; ++i) {
        let rowa = vtxRows[i - 1];
        let rowb = vtxRows[i];

        for (j = 1; j <= longitudeNumSegments; ++j) {
          if (i == 1) {
            pivs.push(rowa[0].index);
            pivs.push(rowb[j].index);
            pivs.push(rowb[j - 1].index);
          } else if (i == latitudeNumSegments) {
            pivs.push(rowa[j].index);
            pivs.push(rowb[j].index);
            pivs.push(rowa[j - 1].index);
          }
        }
      }

      this.vtxTotal = vtxVec.length;
      this.mvs = new Float32Array(this.vtxTotal * 3);
      i = 0;

      for (j = 0; j < this.vtxTotal; ++j) {
        pvtx = vtxVec[j];
        this.mvs[i] = pvtx.x;
        this.mvs[i + 1] = pvtx.y;
        this.mvs[i + 2] = pvtx.z; //trace(pvtx.x+","+pvtx.y+","+pvtx.z);

        i += 3;
      }

      if (this.mTransMatrix != null) {
        this.mTransMatrix.transformVectorsSelf(this.mvs, this.mvs.length);
        this.bounds.addFloat32Arr(this.mvs);
        this.bounds.updateFast();
      }

      this.mivs = new Uint16Array(pivs);

      if (true) {
        this.muvs = new Float32Array(this.vtxTotal * 2);
        i = 0;

        for (j = 0; j < this.vtxTotal; ++j) {
          pvtx = vtxVec[j];
          this.muvs[i] = pvtx.u;
          this.muvs[i + 1] = pvtx.v;
          i += 2;
        }
      }

      if (true) {
        this.mnvs = new Float32Array(this.vtxTotal * 3);
        let trisNumber = this.mivs.length / 3;

        if (this.normalType == 0) {
          SurfaceNormalCalc_1.default.ClacTrisNormal(this.mvs, this.mvs.length, trisNumber, this.mivs, this.mnvs);
        } else {
          i = 0;

          for (j = 0; j < this.vtxTotal; ++j) {
            pvtx = vtxVec[j];
            this.mnvs[i] = pvtx.nx;
            this.mnvs[i + 1] = pvtx.ny;
            this.mnvs[i + 2] = pvtx.nz;
            i += 3;
          }
        }
      }

      this.vtCount = this.mivs.length;
      this.trisNumber = this.vtCount / 3;
    }
  }

  __$destroy() {
    if (this.mivs) {
      this.bounds = null;
      this.mvs = null;
      this.muvs = null;
      this.mnvs = null;

      super.__$destroy();
    }
  }

}

exports.default = ConeGeometry;

/***/ }),

/***/ "ec7b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class MathConst {
  // compute euclidean modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  static EuclideanModulo(n, m) {
    return (n % m + m) % m;
  }

  static Clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
  }

  static IsPowerOf2(value) {
    return (value & value - 1) == 0;
  }

  static CalcCeilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }

  static CalcNearestCeilPow2(int_n) {
    return Math.pow(2, Math.round(Math.log(int_n) / Math.LN2));
  }

  static CalcFloorCeilPow2(int_n) {
    return Math.pow(2, Math.floor(Math.log(int_n) / Math.LN2));
  }

  static DegreeToRadian(degree) {
    return MathConst.MATH_PI_OVER_180 * degree;
  }

  static Log2(f) {
    return Math.log(f) / Math.LN2;
  }

  static GetMaxMipMapLevel(width, height) {
    return Math.round(MathConst.Log2(Math.max(width, height)) + 1);
  }

  static ToDegree(radian) {
    return radian * MathConst.MATH_180_OVER_PI;
  }

  static ToRadian(degree) {
    return degree * MathConst.MATH_PI_OVER_180;
  }

  static SafeACos(x) {
    if (x <= -1.0) {
      return MathConst.MATH_PI;
    }

    if (x >= 1.0) {
      return 0.0;
    }

    return Math.acos(x);
  }

  static GetNearestCeilPow2(int_n) {
    let x = 1;

    while (x < int_n) {
      x <<= 1;
    }

    return x;
  } // ccw is positive


  static GetMinRadian(a1, a0) {
    a0 %= MathConst.MATH_2PI;
    a1 %= MathConst.MATH_2PI;

    if (a0 < a1) {
      a0 = MathConst.MATH_2PI - a1 + a0;
      if (a0 > MathConst.MATH_PI) return a0 - MathConst.MATH_2PI;
      return a0;
    } else if (a0 > a1) {
      a1 = MathConst.MATH_2PI - a0 + a1;
      if (a1 > MathConst.MATH_PI) return MathConst.MATH_2PI - a1;
      return -a1;
    }

    return 0.0;
  }
  /**
   * get the directional angle offset degree value: dst_angle_degree = src_angle_degree + directional_angle_offset_degree_value
   * @param a0 src angle degree
   * @param a1 dst angle degree
   * @returns directional angle offset degree value
   */


  static GetMinDegree(a0, a1) {
    let angle = 0;

    if (a1 >= 270 && a0 < 90) {
      angle = (a1 - (a0 + 360)) % 180;
    } else if (a1 <= 90 && a0 >= 270) {
      angle = (a1 + 360 - a0) % 180;
    } else {
      angle = a1 - a0; //  if (Math.abs(angle) > 180) {
      //      angle -= 360;
      //  }

      if (angle > 180) {
        angle -= 360;
        angle %= 360;
      } else if (angle < -180) {
        angle += 360;
        angle %= 360;
      }
    }

    return angle;
  }

  static GetDegreeByXY(dx, dy) {
    if (Math.abs(dx) < 0.00001) {
      if (dy >= 0) return 270;else return 90;
    }

    let angle = Math.atan(dy / dx) * 180 / Math.PI;

    if (dx >= 0) {
      return angle;
    } else {
      return 180 + angle;
    } //  if (dy > 0 && dx > 0) {
    //      return angle
    //  } else if (dy < 0 && dx >= 0) {
    //      return 360 + angle;
    //  } else {
    //      return dx > 0 ? angle : 180 + angle;
    //  }

  }

  static GetRadianByXY(dx, dy) {
    if (Math.abs(dx) < MathConst.MATH_MIN_POSITIVE) {
      if (dy >= 0) return MathConst.MATH_1PER2PI;else return MathConst.MATH_3PER2PI;
    }

    let rad = Math.atan(dy / dx);

    if (dx >= 0) {
      return rad;
    } else {
      return MathConst.MATH_PI + rad;
    }
  }

  static GetRadianByCos(cosv, dx, dy) {
    var rad = Math.acos(cosv); //Math.atan(dy/dx);

    if (dx >= 0) {
      return rad;
    } else {
      return MathConst.MATH_PI + rad;
    }
  }

}

MathConst.MATH_MIN_POSITIVE = 1e-5;
MathConst.MATH_MAX_NEGATIVE = -1e-5;
MathConst.MATH_MAX_POSITIVE = 0xffffffe;
MathConst.MATH_MIN_NEGATIVE = -0xffffffe;
MathConst.MATH_1_OVER_255 = 1.0 / 255.0;
MathConst.MATH_PI = Math.PI;
MathConst.MATH_2PI = MathConst.MATH_PI * 2.0;
MathConst.MATH_3PER2PI = MathConst.MATH_PI * 1.5;
MathConst.MATH_1PER2PI = MathConst.MATH_PI * 0.5;
MathConst.MATH_1_OVER_PI = 1.0 / MathConst.MATH_PI;
MathConst.MATH_1_OVER_360 = 1.0 / 360.0;
MathConst.MATH_1_OVER_180 = 1.0 / 180.0;
MathConst.MATH_180_OVER_PI = 180.0 / MathConst.MATH_PI;
MathConst.MATH_PI_OVER_180 = MathConst.MATH_PI / 180.0;
MathConst.MATH_LN2 = 0.6931471805599453;
exports.default = MathConst;

/***/ }),

/***/ "ed04":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const defaultEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f3f6"));

const defaultEntity_frag_wgsl_1 = __importDefault(__webpack_require__("7ce1"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

const WGTextureWrapper_1 = __webpack_require__("58c4");

const Vector3_1 = __importDefault(__webpack_require__("af80")); // import { WGRStorageValue } from "../render/uniform/WGRStorageValue";


class DefaultEntityTest {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
  }

  initialize() {
    console.log("DefaultEntityTest::initialize() ...");
    const shdSrc = {
      vertShaderSrc: {
        code: defaultEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      fragShaderSrc: {
        code: defaultEntity_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    let material = this.createMaterial(shdSrc, [new WGTextureWrapper_1.WGImage2DTextureData("static/assets/box.jpg")], ["solid"], "back"); // let material = this.createMaterial( shdSrc );

    this.mEntity = this.createEntity([material]);
  }

  createMaterial(shdSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc: shdSrc,
      pipelineDefParam
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials, pv) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D();
    entity.materials = materials;
    entity.geometry = geometry;
    entity.transform.setPosition(pv ? pv : new Vector3_1.default());
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.DefaultEntityTest = DefaultEntityTest;

/***/ }),

/***/ "ede0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const vertEntity_vert_wgsl_1 = __importDefault(__webpack_require__("f537"));

const vertEntity_frag_wgsl_1 = __importDefault(__webpack_require__("a3a5"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

class VertEntityTest {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
    this.mRotY = 0.0;
  }

  initialize() {
    console.log("VertEntityTest::initialize() ...");
    const shdSrc = {
      vert: {
        code: vertEntity_vert_wgsl_1.default,
        uuid: "vertShdCode"
      },
      frag: {
        code: vertEntity_frag_wgsl_1.default,
        uuid: "fragShdCode"
      }
    };
    const material = this.createMaterial(shdSrc);
    this.mEntity = this.createEntity([material]);
  }

  createMaterial(shaderSrc, texDatas, blendModes = [], faceCullMode = "back") {
    let pipelineDefParam = {
      depthWriteEnabled: true,
      faceCullMode,
      blendModes: []
    };
    pipelineDefParam.blendModes = blendModes;
    const texTotal = texDatas ? texDatas.length : 0;
    const material = new WGMaterial_1.WGMaterial({
      shadinguuid: "base-material-tex" + texTotal,
      shaderSrc,
      pipelineDefParam
    });
    material.addTextureWithDatas(texDatas);
    return material;
  }

  createEntity(materials) {
    const renderer = this.renderer;
    const rgd = this.geomData.createSphere(150, 30, 30);
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      shdVarName: "position",
      data: rgd.vs,
      strides: [3]
    }).addAttribute({
      shdVarName: "uv",
      data: rgd.uvs,
      strides: [2]
    }).setIndexBuffer({
      name: "geomIndex",
      data: rgd.ivs
    });
    const entity = new Entity3D_1.Entity3D({
      geometry,
      materials
    });
    renderer.addEntity(entity);
    return entity;
  }

  run() {
    this.mRotY += 0.5;
    this.mEntity.transform.setRotationXYZ(0, this.mRotY, this.mRotY + 0.5);
    this.mEntity.update();
    this.renderer.run();
  }

}

exports.VertEntityTest = VertEntityTest;

/***/ }),

/***/ "ee65":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const MouseInteraction_1 = __webpack_require__("213f");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const floatAndColorMRT_vert_wgsl_1 = __importDefault(__webpack_require__("df0d"));

const floatAndColorMRT_frag_wgsl_1 = __importDefault(__webpack_require__("821b"));

const floatNormalRead_frag_wgsl_1 = __importDefault(__webpack_require__("2c8d"));

const TorusEntity_1 = __webpack_require__("5118");

const colorRTTTex = {
  diffuse: {
    uuid: "colorRTT",
    rttTexture: {}
  }
};
const albedoRTTTex = {
  diffuse: {
    uuid: "albedoRTT",
    rttTexture: {}
  }
};
const floatRTTTex = {
  diffuse: {
    uuid: "floatRTT",
    rttTexture: {},
    format: 'rgba16float'
  }
};

class MRT {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mFlag = 6;

    this.mouseDown = evt => {
      this.mFlag = 1;
    };
  }

  initialize() {
    console.log("MRT::initialize() ...");
    let multisampleEnabled = true;
    let depthTestEnabled = true;
    let rpassparam = {
      multisampleEnabled,
      depthTestEnabled
    };
    this.mRscene.initialize({
      rpassparam
    });
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  applyMRTPass(extent) {
    let rs = this.mRscene;
    const attachment0 = {
      texture: colorRTTTex,
      clearValue: [0.15, 0.15, 0.15, 1.0]
    };
    const attachment1 = {
      texture: albedoRTTTex,
      clearValue: [0.15, 0.25, 0.25, 1.0]
    };
    const attachment2 = {
      texture: floatRTTTex,
      clearValue: [0.2, 0.25, 0.2, 1.0]
    };
    const colorAttachments = [attachment0, attachment1, attachment2];
    let rPass = rs.createRenderPass({
      separate: true,
      colorAttachments
    });
    const diffuseTex = {
      diffuse: {
        url: "static/assets/huluwa.jpg",
        flipY: true
      }
    };
    let shaderSrc = {
      vert: {
        code: floatAndColorMRT_vert_wgsl_1.default,
        uuid: "vertMRT"
      },
      frag: {
        code: floatAndColorMRT_frag_wgsl_1.default,
        uuid: "fragMRT"
      }
    };
    let uniformValues = [{
      data: new Float32Array([1, 1, 1, 1])
    }];
    let torus = new TorusEntity_1.TorusEntity({
      shaderSrc,
      textures: [diffuseTex],
      uniformValues
    });
    rPass.addEntity(torus); // display rendering result

    extent = [-0.8, -0.8, 1.6, 1.6];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [colorRTTTex]
    });
    rs.addEntity(entity);
    shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: floatNormalRead_frag_wgsl_1.default,
        uuid: "readNromal"
      }
    }; // display normal drawing result

    extent = [-0.7, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [floatRTTTex],
      shaderSrc,
      shadinguuid: "readNromal"
    });
    rs.addEntity(entity); // display albedo drawing result

    extent = [0.1, -0.95, 0.6, 0.6];
    entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      extent,
      textures: [albedoRTTTex]
    });
    rs.addEntity(entity);
  }

  initScene() {
    this.applyMRTPass([-1, -1, 2, 2]);
  }

  run() {
    this.mRscene.run();
  }

}

exports.MRT = MRT;

/***/ }),

/***/ "f083":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class WGRPassNodeGraph {
  constructor() {
    this.passes = null;
    this.cmdWrapper = {
      rcommands: []
    };
  }

  runBegin() {
    this.cmdWrapper.rcommands = [];
    const ps = this.passes;

    if (ps != null) {
      for (let i = 0; i < ps.length; ++i) {
        ps[i].cmdWrapper = this.cmdWrapper;
      }
    }
  }

  run() {}

}

exports.WGRPassNodeGraph = WGRPassNodeGraph;

/***/ }),

/***/ "f22d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Entity3D_1 = __webpack_require__("551f");

exports.Entity3DParam = Entity3D_1.Entity3DParam;
exports.getUniformValueFromParam = Entity3D_1.getUniformValueFromParam;

class FixScreenEntity extends Entity3D_1.Entity3D {
  constructor(param) {
    param = param ? param : {
      transformEnabled: false
    };
    param.transformEnabled = false;
    super(param);
    this.cameraViewing = false;
  }

  update() {
    return this;
  }

}

exports.FixScreenEntity = FixScreenEntity;

/***/ }),

/***/ "f3f6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\nfn invertedColor( color : vec4<f32>) -> vec4<f32> {\n   return vec4( 1.0 - color.rgb, color.a );\n}\n@vertex\nfn main(\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>\n) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = projMat * viewMat * objMat * vec4(position.xyz, 1.0);\n  output.fragUV = uv;\n  var pv: vec4<f32>;\n  pv = 0.5 * (vec4<f32>(normalize(position.xyz) * 2.0, 1.0) + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n  output.fragPosition = pv;\n  return output;\n}\n");

/***/ }),

/***/ "f522":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const GeometryData_1 = __importDefault(__webpack_require__("541b"));

class PipeGeometryData extends GeometryData_1.default {
  constructor() {
    super();
    this.m_longitudeNum = 0;
    this.m_latitudeNum = 0;
    this.uScale = 1.0;
    this.vScale = 1.0;
  }

  clone() {
    let geometry = new PipeGeometryData();
    geometry.m_longitudeNum = this.m_longitudeNum;
    geometry.m_latitudeNum = this.m_latitudeNum;
    geometry.uScale = this.uScale;
    geometry.vScale = this.vScale;
    geometry.copyFrom(this);
    return geometry;
  }

  getCenterAt(i, outV) {
    if (i >= 0 && i <= this.m_latitudeNum) {
      if (this.mvs != null) {
        outV.setXYZ(0.0, 0.0, 0.0);
        let pvs = this.mvs;
        let end = (i + 1) * (this.m_longitudeNum + 1) * 3;
        i = i * (this.m_longitudeNum + 1) * 3;
        end -= 3; //console.log("i: "+i,end);

        for (; i < end; i += 3) {
          outV.x += pvs[i];
          outV.y += pvs[i + 1];
          outV.z += pvs[i + 2];
        }

        outV.scaleBy(1.0 / this.m_longitudeNum);
      }
    }
  }

  transformAt(i, mat4) {
    if (i >= 0 && i <= this.m_latitudeNum) {
      const n = this.m_longitudeNum + 1;
      let pvs = this.mvs;
      let end = (i + 1) * n * 3;
      i = i * n * 3;
      mat4.transformVectorsRangeSelf(pvs, i, end);
    }
  }

  getRangeAt(i, segLen = 3) {
    if (i >= 0 && i <= this.m_latitudeNum) {
      let end = (i + 1) * (this.m_longitudeNum + 1) * segLen;
      i = i * (this.m_longitudeNum + 1) * segLen;
      return [i, end];
    }

    return [-1, -1];
  }

  getVSSegAt(i) {
    if (i >= 0 && i <= this.m_latitudeNum) {
      const n = this.m_longitudeNum + 1;
      let pvs = this.mvs;
      let end = (i + 1) * n * 3;
      i = i * n * 3;
      return pvs.subarray(i, end); //mat4.transformVectorsRangeSelf(pvs, i, end);
    }

    return null;
  }

  initialize(radius, height, longitudeNumSegments, latitudeNumSegments, uvType = 1, alignYRatio = -0.5) {
    let i = 0;
    let j = 0;
    if (radius < 0.01) radius = 0.01;
    if (longitudeNumSegments < 2) longitudeNumSegments = 2;
    if (latitudeNumSegments < 1) latitudeNumSegments = 1;
    this.m_longitudeNum = longitudeNumSegments;
    this.m_latitudeNum = latitudeNumSegments;
    let mRadius = Math.abs(radius);
    let ph = Math.abs(height);
    let yRad = 0;
    let px = 0;
    let py = 0;
    let minY = alignYRatio * ph;
    this.bounds.min.setXYZ(-radius, minY, -radius);
    this.bounds.max.setXYZ(radius, minY + ph, radius);
    this.bounds.updateFast();
    let vtx = new Vector3_1.default();
    let srcRow = [];
    let pv;
    let pi2 = Math.PI * 2;

    for (i = 0; i < 1; ++i) {
      for (j = 0; j < longitudeNumSegments; ++j) {
        yRad = pi2 * j / longitudeNumSegments;
        px = Math.sin(yRad);
        py = Math.cos(yRad);
        vtx.x = px * mRadius;
        vtx.z = py * mRadius;
        pv = new Vector3_1.default(vtx.x, vtx.y, vtx.z, 1.0);
        srcRow.push(pv);
      }

      srcRow.push(srcRow[0]);
    }

    this.vtxTotal = (longitudeNumSegments + 1) * (latitudeNumSegments + 1);
    this.mvs = new Float32Array(this.vtxTotal * 3);
    this.muvs = new Float32Array(this.vtxTotal * 2); // calc cylinder wall vertexes

    let tot = latitudeNumSegments;
    let k = 0;
    let l = 0;

    for (i = 0; i <= tot; ++i) {
      px = i / tot;
      py = minY + ph * px;

      for (j = 0; j <= longitudeNumSegments; ++j) {
        if (uvType < 1) {
          this.muvs[l++] = this.uScale * (j / longitudeNumSegments);
          this.muvs[l++] = this.uScale * px;
        } else {
          this.muvs[l++] = this.uScale * px;
          this.muvs[l++] = this.uScale * (j / longitudeNumSegments);
        }

        const vtx = srcRow[j];

        switch (this.axisType) {
          case 1:
            this.mvs[k++] = vtx.x;
            this.mvs[k++] = py;
            this.mvs[k++] = vtx.z;
            break;

          case 2:
            this.mvs[k++] = vtx.z;
            this.mvs[k++] = vtx.x;
            this.mvs[k++] = py;
            break;

          default:
            this.mvs[k++] = py;
            this.mvs[k++] = vtx.z;
            this.mvs[k++] = vtx.x;
            break;
        }
      }
    }

    let cn = longitudeNumSegments + 1;
    let a = 0;
    let b = 0;
    const size = tot * longitudeNumSegments * 6;
    this.mivs = size <= 56635 ? new Uint16Array(size) : new Uint32Array(size);
    k = 0;

    for (i = 0; i < tot; ++i) {
      a = i * cn;
      b = (i + 1) * cn;

      for (j = 1; j <= longitudeNumSegments; ++j) {
        this.mivs[k++] = a + j;
        this.mivs[k++] = b + j - 1;
        this.mivs[k++] = a + j - 1;
        this.mivs[k++] = a + j;
        this.mivs[k++] = b + j;
        this.mivs[k++] = b + j - 1;
      }
    }

    this.vtCount = this.mivs.length;
    this.trisNumber = this.vtCount / 3;
  }

}

exports.default = PipeGeometryData;

/***/ }),

/***/ "f537":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\r\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fragUV : vec2<f32>,\r\n  @location(1) fragPosition: vec4<f32>,\r\n}\r\nfn invertedColor( color : vec4<f32>) -> vec4<f32> {\r\n   return vec4( 1.0 - color.rgb, color.a );\r\n}\r\n@vertex\r\nfn main(\r\n  @location(0) position : vec3<f32>,\r\n  @location(1) uv : vec2<f32>\r\n) -> VertexOutput {\r\n  var output : VertexOutput;\r\n  output.Position = projMat * viewMat * objMat * vec4(position.xyz, 1.0);\r\n  output.fragUV = uv;\r\n  var pv: vec4<f32>;\r\n  pv = 0.5 * (vec4<f32>(normalize(position.xyz) * 2.0, 1.0) + vec4<f32>(1.0, 1.0, 1.0, 1.0));\r\n  output.fragPosition = pv;\r\n  return output;\r\n}\r\n");

/***/ }),

/***/ "f5fb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const WGRenderPassBlock_1 = __webpack_require__("ddc9");

exports.WGRPipelineContextDefParam = WGRenderPassBlock_1.WGRPipelineContextDefParam;

class RPassInfoParam {
  constructor() {
    this.blockIndex = 0;
  }

}

exports.RPassInfoParam = RPassInfoParam;

function checkConfig(config) {
  let canvasCFG = {
    alphaMode: "premultiplied"
  };
  let canvas;
  let div;

  if (config) {
    canvas = config.canvas;
    div = config.div;

    if (config.gpuCanvasCfg) {
      canvasCFG = config.gpuCanvasCfg;
    }
  } else {
    config = {
      canvas: null
    };
  }

  let width = 512;
  let height = 512;

  if (!div) {
    div = document.createElement("div");
    document.body.appendChild(div);
    const style = div.style;
    style.display = "bolck";
    style.position = "absolute";

    if (style.left == "") {
      style.left = "0px";
      style.top = "0px";
    }

    div.style.width = width + "px";
    div.style.height = height + "px";
  }

  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    div.appendChild(canvas);
  }

  config.canvas = canvas;
  config.div = div;
  config.gpuCanvasCfg = canvasCFG;
  return config;
}

exports.checkConfig = checkConfig;

/***/ }),

/***/ "f5ff":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const EvtNode_1 = __importDefault(__webpack_require__("e537"));

class MouseEvt3DDispatcher {
  constructor() {
    this.m_evtNodes = null;
    this.m_evtNodesLen = 24;
    this.uuid = "";
    this.data = null;
    this.currentTarget = null;
    this.enabled = true;
    this.m_evtNodesLen = MouseEvent_1.default.GetMouseEvtTypeValuesTotal();
    this.m_evtNodes = new Array(this.m_evtNodesLen);
  }

  getClassType() {
    return MouseEvent_1.default.EventClassType;
  }

  destroy() {
    // console.log("VVVVVVVVVV this.m_evtNodesLen: ", this.m_evtNodesLen);
    for (let i = 0; i < this.m_evtNodesLen; ++i) {
      if (this.m_evtNodes[i] != null) {
        this.m_evtNodes[i].destroy();
      }
    }

    this.data = null;
    this.currentTarget = null;
  } // @return      1 is send evt yes,0 is send evt no


  dispatchEvt(evt) {
    if (this.enabled && evt != null) {
      if (this.uuid != "") evt.uuid = this.uuid;
      if (this.data != null) evt.data = this.data;
      if (this.currentTarget != null) evt.currentTarget = this.currentTarget;
      let t = evt.type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        if (this.m_evtNodes[t] != null) return this.m_evtNodes[t].dispatch(evt);
      } else {
        console.log("MouseEvt3DDispatcher::dispatchEvt(), Warn: undefined Event type.");
      }
    }

    return 0;
  } //@return if the evt can be dispatched in this node,it returns 1,otherwise it returns 0


  passTestEvt(evt) {
    if (evt != null) {
      let t = evt.type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        return this.m_evtNodes[t].passTestEvt(evt);
      }
    }

    return 0;
  } //@return if the evt phase is in this node,it returns 1,otherwise it returns 0


  passTestPhase(phase) {
    let len = MouseEvent_1.default.GetMouseEvtTypeValuesTotal();

    for (let i = 0; i < len; ++i) {
      if (this.m_evtNodes[i] != null && this.m_evtNodes[i].passTestPhase(phase) == 1) {
        return 1;
      }
    }

    return 0;
  } // 注意: 一个 target 只能有一个回调函授对应一个类型的事件


  addEventListener(type, func, captureEnabled = true, bubbleEnabled = false) {
    if (func) {
      let t = type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        //(capture phase),2(bubble phase)
        let phase = 0;

        if (captureEnabled != bubbleEnabled) {
          if (captureEnabled) {
            phase = 1;
          } else {
            phase = 2;
          }
        }

        if (this.m_evtNodes[t] != null) {
          this.m_evtNodes[t].addListener(func, phase);
        } else {
          this.m_evtNodes[t] = new EvtNode_1.default();
          this.m_evtNodes[t].addListener(func, phase);
        }
      } else {
        console.log("MouseEvt3DDispatcher::addEventListener(), Warn: undefined Event type.");
      }
    }
  }

  removeEventListener(type, func) {
    if (func) {
      let t = type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        if (this.m_evtNodes[t] != null) {
          this.m_evtNodes[t].removeListener(func);
        }
      } //  else
      //  {
      //      console.log("MouseEvt3DDispatcher::removeEventListener(), Warn: undefined Event type.");
      //  }

    }
  }

}

exports.default = MouseEvt3DDispatcher;

/***/ }),

/***/ "f73a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\r\n@group(0) @binding(0) var<uniform> objMat : mat4x4<f32>;\r\n@group(0) @binding(1) var<uniform> viewMat : mat4x4<f32>;\r\n@group(0) @binding(2) var<uniform> projMat : mat4x4<f32>;\r\n\r\n@group(0) @binding(3) var<uniform> grid: vec2f;\r\n@group(0) @binding(4) var<storage> cellState: array<u32>;\r\n@group(0) @binding(5) var<storage> lifeState: array<f32>;\r\n@group(0) @binding(6) var<storage> wpositions: array<vec4f>;\r\n\r\nstruct VertexInput {\r\n\t@location(0) pos: vec3f,\r\n  \t@location(1) uv : vec2f,\r\n\t@builtin(instance_index) instance: u32\r\n};\r\n\r\nstruct VertexOutput {\r\n\t@builtin(position) pos: vec4f,\r\n\t@location(0) cell: vec2f,\r\n\t@location(1) uv: vec2f,\r\n\t@location(2) factor: f32,\r\n};\r\nconst scales = array<f32, 2>(0.1, 0.5);\r\n@vertex\r\nfn vertMain(input: VertexInput) -> VertexOutput {\r\n\r\n\tlet i = input.instance;\r\n    // var state = f32(cellState[i]);\r\n\r\n\tlet f = clamp((lifeState[ input.instance ])/100.0, 0.0005, 1.0);\r\n\tvar baseScale = scales[ cellState[i] ];\r\n\r\n\r\n    var wpos = objMat * vec4f(input.pos.xyz * (f * 0.5 + baseScale), 1.0);\r\n\twpos = vec4f(wpos.xyz + wpositions[ input.instance ].xyz, wpos.w);\r\n\r\n    let fi = f32(i);\r\n    let cell = vec2f(fi % grid.x, floor(fi / grid.x));\r\n\r\n\r\n    var output: VertexOutput;\r\n\r\n    var projPos = projMat * viewMat * wpos;\r\n\t// if(state < 1.0) {\r\n\t// \tprojPos = vec4f(projPos.xyz, -1.0);\r\n\t// }\r\n    output.pos = projPos;\r\n\r\n    output.cell = cell;\r\n    output.uv = input.uv;\r\n\r\n    output.factor = f;\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fragMain(input: VertexOutput) -> @location(0) vec4f {\r\n    let c = input.cell / grid;\r\n\tvar dis = length(input.uv - vec2<f32>(0.5, 0.5));\r\n\tdis = min(dis/0.51, 1.0);\r\n\tlet f = input.factor;\r\n\tdis = (1.0 - pow(dis, 50.0)) * (1.0 - f) + f;\r\n\tvar c3 = vec3f(c, (1.0 - c.x) * (1.0 - f) + f) * dis;\r\n    return vec4f(c3, 1.0);\r\n}");

/***/ }),

/***/ "f78a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererScene_1 = __webpack_require__("4ad2");

const FixScreenPlaneEntity_1 = __webpack_require__("d463");

const fixScreenPlane_vert_wgsl_1 = __importDefault(__webpack_require__("d36d"));

const screenPostEffect1_frag_wgsl_1 = __importDefault(__webpack_require__("87b6"));

class ScreenPostEffect {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();
    this.mColorV = {
      data: new Float32Array([1.0, 0.1, 0.2, 1.0])
    };
    this.mParamsV = {
      storage: {
        data: new Float32Array(4 * 3),
        stride: 4,
        version: 0
      }
    };
    this.mTime = 0;
  }

  initialize() {
    console.log("ScreenPostEffect::initialize() ...");
    this.initScene();
  }

  initScene() {
    const rc = this.mRscene;
    const data = this.mParamsV.storage.data;
    data.set([1.0, 1.0, 1.0, 1.0]);
    data.set([0.5, 0.5, 512.0, 512.0], 4);
    let shaderSrc = {
      vert: {
        code: fixScreenPlane_vert_wgsl_1.default,
        uuid: "vert"
      },
      frag: {
        code: screenPostEffect1_frag_wgsl_1.default,
        uuid: "frag"
      }
    };
    let uniformValues = [this.mColorV, this.mParamsV];
    let entity = new FixScreenPlaneEntity_1.FixScreenPlaneEntity({
      shaderSrc,
      uniformValues
    });
    rc.addEntity(entity);
  }

  run() {
    let vs = this.mParamsV.storage.data;
    vs[8] += 0.01;
    vs[4] = Math.cos(this.mTime) * 0.5 + 0.5;
    this.mTime += 0.01;
    this.mParamsV.storage.version++;
    this.mRscene.run();
  }

}

exports.ScreenPostEffect = ScreenPostEffect;

/***/ }),

/***/ "f937":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2023 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class Extent2 {
  constructor(extent) {
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.setExtent(extent);
  }

  clone() {
    return new Extent2(this);
  }

  setXYWH(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    return this;
  }

  setExtent(extent) {
    let v = extent;

    if (v) {
      const c = this;
      const vs = v;

      if (vs.length !== undefined) {
        const len = vs.length;
        if (len > 0) c.x = vs[0];
        if (len > 1) c.y = vs[1];
        if (len > 2) c.height = vs[2];
        if (len > 3) c.width = vs[3];
      } else {
        const vo = v;
        if (vo.x !== undefined) c.x = vo.x;
        if (vo.y !== undefined) c.y = vo.y;
        if (vo.width !== undefined) c.width = vo.width;
        if (vo.height !== undefined) c.height = vo.height;
      }
    }

    return this;
  }

  fromArray4(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.width = arr[offset + 2];
    this.height = arr[offset + 3];
    return this;
  }

  toArray4(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.width;
    arr[offset + 3] = this.height;
    return this;
  }

  getArray4() {
    let arr = new Array(4);
    this.toArray4(arr);
    return arr;
  }

  getArray3() {
    let arr = new Array(3);
    this.toArray3(arr);
    return arr;
  }

  fromArray3(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.width = arr[offset + 2];
    return this;
  }

  toArray3(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.width;
    return this;
  }

  copyFrom(c) {
    this.x = c.x;
    this.y = c.y;
    this.width = c.width;
    this.height = c.height;
    return this;
  }

  scaleBy(s) {
    this.x *= s;
    this.y *= s;
    this.width *= s;
    this.height *= s;
    return this;
  }

  update() {}

}

exports.default = Extent2;

/***/ }),

/***/ "fa6e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3_1 = __importDefault(__webpack_require__("af80"));

const BoxGeometry_1 = __importDefault(__webpack_require__("a229"));

const RectPlaneGeometry_1 = __importDefault(__webpack_require__("0540"));

const SphereGeometry_1 = __importDefault(__webpack_require__("9243"));

const CylinderGeometry_1 = __importDefault(__webpack_require__("4255"));

const TorusGeometry_1 = __importDefault(__webpack_require__("bd36"));

class GeomDataBuilder {
  constructor(wgCtx) {
    if (wgCtx) {
      this.initialize(wgCtx);
    }
  }

  initialize(wgCtx) {
    this.mWGCtx = wgCtx;
  }

  createTorus(ringRadius, axisRadius = 20, longitudeNumSegments = 20, latitudeNumSegments = 20) {
    let geom = new TorusGeometry_1.default();
    geom.setBufSortFormat(0xfffffff);
    geom.initialize(ringRadius, axisRadius, longitudeNumSegments, latitudeNumSegments);
    let vbufs;
    let ibuf;
    let vs = geom.getVS();
    let uvs = geom.getUVS();
    let nvs = geom.getNVS();
    let ivs = geom.getIVS();
    let vtTotal = vs.length / 3;
    let vsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(vs, 0, [3]) : null;
    let uvsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(uvs, 0, [uvs.length / vtTotal]) : null;
    vbufs = [vsBuf, uvsBuf];
    ibuf = this.mWGCtx ? this.mWGCtx.buffer.createIndexBuffer(ivs) : null;
    const vtxDescParam = {
      vertex: {
        buffers: vbufs,
        attributeIndicesArray: [[0], [0]]
      }
    };
    return {
      ivs,
      vs,
      uvs,
      nvs,
      vbufs: vbufs,
      ibuf: ibuf,
      vtxDescParam: vtxDescParam,
      bounds: geom.bounds
    };
  }

  createCylinder(radius, height = 200, longitudeNumSegments = 20, latitudeNumSegments = 20) {
    let geom = new CylinderGeometry_1.default();
    geom.setBufSortFormat(0xfffffff);
    geom.initialize(radius, height, longitudeNumSegments, latitudeNumSegments);
    let vbufs;
    let ibuf;
    let vs = geom.getVS();
    let uvs = geom.getUVS();
    let nvs = geom.getNVS();
    let ivs = geom.getIVS();
    let vtTotal = vs.length / 3;
    let vsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(vs, 0, [3]) : null;
    let uvsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(uvs, 0, [uvs.length / vtTotal]) : null;
    vbufs = [vsBuf, uvsBuf];
    ibuf = this.mWGCtx ? this.mWGCtx.buffer.createIndexBuffer(ivs) : null;
    const vtxDescParam = {
      vertex: {
        buffers: vbufs,
        attributeIndicesArray: [[0], [0]]
      }
    };
    return {
      ivs,
      vs,
      uvs,
      nvs,
      vbufs: vbufs,
      ibuf: ibuf,
      vtxDescParam: vtxDescParam,
      bounds: geom.bounds
    };
  }

  createSphere(radius, longitudeNumSegments = 20, latitudeNumSegments = 20) {
    let geom = new SphereGeometry_1.default();
    geom.setBufSortFormat(0xfffffff);
    geom.initialize(radius, longitudeNumSegments, latitudeNumSegments, false);
    let vbufs;
    let ibuf;
    let vs = geom.getVS();
    let uvs = geom.getUVS();
    let nvs = geom.getNVS();
    let ivs = geom.getIVS();
    let vtTotal = vs.length / 3;
    let vsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(vs, 0, [3]) : null;
    let uvsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(uvs, 0, [uvs.length / vtTotal]) : null;
    vbufs = [vsBuf, uvsBuf];
    ibuf = this.mWGCtx ? this.mWGCtx.buffer.createIndexBuffer(ivs) : null;
    const vtxDescParam = {
      vertex: {
        buffers: vbufs,
        attributeIndicesArray: [[0], [0]]
      }
    };
    return {
      ivs,
      vs,
      uvs,
      nvs,
      vbufs: vbufs,
      ibuf: ibuf,
      vtxDescParam: vtxDescParam,
      bounds: geom.bounds
    };
  }

  createCube(size) {
    size *= 0.5;
    let minV = new Vector3_1.default(-size, -size, -size);
    let maxV = minV.clone().scaleBy(-1);
    return this.createBox(minV, maxV);
  }

  createBox(minV, maxV) {
    let geom = new BoxGeometry_1.default();
    geom.setBufSortFormat(0xfffffff);
    geom.initialize(minV, maxV);
    let vbufs;
    let ibuf;
    let vs = geom.getVS();
    let uvs = geom.getUVS();
    let nvs = geom.getNVS();
    let ivs = geom.getIVS();
    let vtTotal = vs.length / 3;
    let vsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(vs, 0, [3]) : null;
    let uvsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(uvs, 0, [uvs.length / vtTotal]) : null;
    vbufs = [vsBuf, uvsBuf];
    ibuf = this.mWGCtx ? this.mWGCtx.buffer.createIndexBuffer(ivs) : null;
    const vtxDescParam = {
      vertex: {
        buffers: vbufs,
        attributeIndicesArray: [[0], [0]]
      }
    };
    return {
      ivs,
      vs,
      uvs,
      nvs,
      vbufs: vbufs,
      ibuf: ibuf,
      vtxDescParam: vtxDescParam,
      bounds: geom.bounds
    };
  }

  createSquare(size, axisFlag = 0) {
    return this.createRect(-0.5 * size, -0.5 * size, size, size, axisFlag);
  }

  createRect(px, py, pw, ph, axisType = 0) {
    let geom = new RectPlaneGeometry_1.default();
    geom.axisType = axisType;
    geom.setBufSortFormat(0xfffffff);
    geom.initialize(px, py, pw, ph);
    let vbufs;
    let ibuf;
    let vs = geom.getVS();
    let uvs = geom.getUVS();
    let nvs = geom.getNVS();
    let ivs = geom.getIVS(); // console.log("vs: ", vs);
    // console.log("uvs: ", uvs);
    // console.log("ivs: ", ivs);

    let vsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(vs, 0, [3]) : null;
    let uvsBuf = this.mWGCtx ? this.mWGCtx.buffer.createVertexBuffer(uvs, 0, [2]) : null;
    vbufs = [vsBuf, uvsBuf];
    ibuf = this.mWGCtx ? this.mWGCtx.buffer.createIndexBuffer(ivs) : null;
    const vtxDescParam = {
      vertex: {
        buffers: vbufs,
        attributeIndicesArray: [[0], [0]]
      }
    };
    return {
      ivs,
      vs,
      uvs,
      nvs,
      vbufs: vbufs,
      ibuf: ibuf,
      vtxDescParam: vtxDescParam,
      bounds: geom.bounds
    };
  }

}

exports.GeomDataBuilder = GeomDataBuilder;

/***/ }),

/***/ "fa7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const PackedLoader_1 = __webpack_require__("560a");

class ModuleLoader extends PackedLoader_1.PackedLoader {
  /**
   * @param times 记录总共需要的加载完成操作的响应次数。这个次数可能是由load直接产生，也可能是由于别的地方驱动。
   * @param callback 完成所有响应的之后的回调
   * @param urlChecker url 转换与检查
   */
  constructor(times, callback = null, urlChecker = null) {
    super(times, callback, urlChecker);
  }

  loadData(url) {
    let req = new XMLHttpRequest();
    req.open("GET", url, true);

    req.onerror = function (err) {
      console.error("load error: ", err);
    }; // req.onprogress = e => { };


    req.onload = evt => {
      this.loadedData(req.response, url);
      this.loadedUrl(url);
    };

    req.send(null);
  }

  loadedData(data, url) {
    console.log("ModuleLoader::loadedData(), module js file loaded, url: ", url);
    let scriptEle = document.createElement("script");

    scriptEle.onerror = evt => {
      console.error("module script onerror, e: ", evt);
    };

    scriptEle.type = "text/javascript";

    try {
      scriptEle.innerHTML = data;
      document.head.appendChild(scriptEle);
    } catch (e) {
      console.error("ModuleLoader::loadedData() apply script ele error.");
      throw e;
    }
  }

}

exports.ModuleLoader = ModuleLoader;

/***/ }),

/***/ "fae3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setPublicPath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1eb2");
/* harmony import */ var _entry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b6ed");
/* harmony import */ var _entry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_entry__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _entry__WEBPACK_IMPORTED_MODULE_1__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _entry__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));




/***/ }),

/***/ "fba9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("c69e"));

const RendererScene_1 = __webpack_require__("4ad2");

const MouseInteraction_1 = __webpack_require__("213f");

const Color4_1 = __importDefault(__webpack_require__("2c77"));

const SphereEntity_1 = __webpack_require__("9849");

const BoxEntity_1 = __webpack_require__("5009");

const CylinderEntity_1 = __webpack_require__("76e3");

const CubeEntity_1 = __webpack_require__("0069");

const TorusEntity_1 = __webpack_require__("5118");

const PlaneEntity_1 = __webpack_require__("7e70");

const ConeEntity_1 = __webpack_require__("97f2");

const AxisEntity_1 = __webpack_require__("603e");

const ModelEntity_1 = __webpack_require__("c29f");

class ModelEntityTest {
  constructor() {
    this.mRscene = new RendererScene_1.RendererScene();

    this.mouseDown = evt => {};
  }

  initialize() {
    console.log("ModelEntityTest::initialize() ...");
    this.initEvent();
    this.initScene();
  }

  initEvent() {
    const rc = this.mRscene;
    rc.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this.mouseDown);
    new MouseInteraction_1.MouseInteraction().initialize(rc, 0, false).setAutoRunning(true);
  }

  initScene() {
    const rc = this.mRscene;
    let axis = new AxisEntity_1.AxisEntity();
    rc.addEntity(axis);
    let modelUrl = 'static/assets/obj/monkey.obj';
    let modelEntity = new ModelEntity_1.ModelEntity({
      modelUrl,
      transform: {
        scale: [100, 100, 100],
        position: [0, 0, 200]
      }
    });
    rc.addEntity(modelEntity);
    return;
    axis = axis.clone();
    axis.transform.setScaleAll(0.3).setXYZ(50, 0, 50);
    rc.addEntity(axis);
    let entities = [new SphereEntity_1.SphereEntity(), new BoxEntity_1.BoxEntity(), new CylinderEntity_1.CylinderEntity({
      alignYRatio: 0.0
    }), new CubeEntity_1.CubeEntity({
      cubeSize: 130
    }), new TorusEntity_1.TorusEntity({
      radius: 110,
      axisType: 1
    }), new PlaneEntity_1.PlaneEntity({
      axisType: 1,
      extent: [-80, -80, 160, 160],
      doubleFace: true
    }), new ConeEntity_1.ConeEntity({
      alignYRatio: 0.0
    })];
    let ls = entities;
    entities = []; // random sorting

    for (let i = 0, ln = ls.length; i < ln; ++i) {
      const k = Math.round(Math.random() * 888) % ls.length;
      entities.push(ls[k]);
      ls.splice(k, 1);
    }

    let radius = 300.0;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length;
      let entity = entities[i].setAlbedo(new Color4_1.default().randomRGB(1.5, 0.1));
      entity.arm = [1.1, Math.random() * 0.95 + 0.05, Math.random() * 0.9 + 0.1];
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]);
      rc.addEntity(entity);
    }

    radius += 200;

    for (let i = 0; i < entities.length; ++i) {
      let rad = 2.0 * Math.PI * i / entities.length + 0.4;
      let entity = entities[i].clone({
        doubleFace: true,
        wireframe: true
      });
      entity.transform.setPosition([radius * Math.cos(rad), 0, radius * Math.sin(rad)]).setScaleAll(0.7);
      rc.addEntity(entity);
    }
  }

  run() {
    this.mRscene.run();
  }

}

exports.ModelEntityTest = ModelEntityTest;

/***/ }),

/***/ "fd5e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeomDataBuilder_1 = __webpack_require__("fa6e");

const vertEntityOnlyVtx_vert_wgsl_1 = __importDefault(__webpack_require__("4ca8"));

const vertEntityOnlyVtx_frag_wgsl_1 = __importDefault(__webpack_require__("993b"));

const WGMaterial_1 = __webpack_require__("943f");

const WGGeometry_1 = __webpack_require__("746a");

const Entity3D_1 = __webpack_require__("551f");

const WGRenderer_1 = __webpack_require__("cae9");

class VertColorCube {
  constructor() {
    this.geomData = new GeomDataBuilder_1.GeomDataBuilder();
    this.renderer = new WGRenderer_1.WGRenderer();
  }

  initialize() {
    console.log("VertColorCube::initialize() ...");
    const renderer = this.renderer;
    const rgd = this.geomData.createCube(200);
    const shaderSrc = {
      vert: {
        code: vertEntityOnlyVtx_vert_wgsl_1.default
      },
      frag: {
        code: vertEntityOnlyVtx_frag_wgsl_1.default
      }
    };
    const materials = [new WGMaterial_1.WGMaterial({
      shadinguuid: "shapeMaterial",
      shaderSrc
    })];
    const geometry = new WGGeometry_1.WGGeometry().addAttribute({
      position: rgd.vs
    }).setIndices(rgd.ivs);
    renderer.addEntity(new Entity3D_1.Entity3D({
      geometry,
      materials
    }));
  }

  run() {
    this.renderer.run();
  }

}

exports.VertColorCube = VertColorCube;

/***/ }),

/***/ "fe0b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function copyFromObjectValueWithKey(src, dst) {
  for (var k in src) {
    if (src[k] != undefined) {
      dst[k] = src[k];
    }
  }
}

exports.copyFromObjectValueWithKey = copyFromObjectValueWithKey;

function createIndexArrayWithSize(size) {
  return size > 65536 ? new Uint32Array(size) : new Uint16Array(size);
}

exports.createIndexArrayWithSize = createIndexArrayWithSize;

function createIndexArray(array) {
  return array.length > 65536 ? new Uint32Array(array) : new Uint16Array(array);
}

exports.createIndexArray = createIndexArray;
/**
 * Determines the number of mip levels needed for a full mip chain given the width and height of texture level 0.
 *
 * @param {number} width of texture level 0.
 * @param {number} height of texture level 0.
 * @returns {number} Ideal number of mip levels.
 */

function calculateMipLevels(width, height) {
  return Math.floor(Math.log2(Math.max(width, height))) + 1;
}

exports.calculateMipLevels = calculateMipLevels; // thanks: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript
// thanks: https://esdiscuss.org/topic/float16array

const toFloat16 = function () {
  const floatView = new Float32Array(1);
  const int32View = new Int32Array(floatView.buffer);
  /* This method is faster than the OpenEXR implementation (very often
   * used, eg. in Ogre), with the additional benefit of rounding, inspired
   * by James Tursa?s half-precision code. */

  return function toHalf(val) {
    floatView[0] = val;
    let x = int32View[0];
    let bits = x >> 16 & 0x8000;
    /* Get the sign */

    let m = x >> 12 & 0x07ff;
    /* Keep one extra bit for rounding */

    let e = x >> 23 & 0xff;
    /* Using int is faster here */

    /* If zero, or denormal, or exponent underflows too much for a denormal
     * half, return signed zero. */

    if (e < 103) {
      return bits;
    }
    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */


    if (e > 142) {
      bits |= 0x7c00;
      /* If exponent was 0xff and one mantissa bit was set, it means NaN,
       * not Inf, so make sure we set one mantissa bit too. */

      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
      return bits;
    }
    /* If exponent underflows but not too much, return a denormal */


    if (e < 113) {
      m |= 0x0800;
      /* Extra rounding may overflow and set mantissa to 0 and exponent
       * to 1, which is OK. */

      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }

    bits |= e - 112 << 10 | m >> 1;
    /* Extra rounding. An overflow will set mantissa to 0 and increment
     * the exponent, which is OK. */

    bits += m & 1;
    return bits;
  };
}();

exports.toFloat16 = toFloat16; // webgpu hdr usage: https://stackoverflow.com/questions/77032862/load-hdr-10-bit-avif-image-into-a-rgba16float-texture-in-webgpu

function createSolidColorTexture(r, g, b, a) {
  let rc;
  let wgctx = rc.getWGCtx();
  const data = new Uint8Array([r * 255, g * 255, b * 255, a * 255]);
  const texture = wgctx.device.createTexture({
    size: {
      width: 1,
      height: 1
    },
    format: "rgba8unorm",
    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
  });
  wgctx.device.queue.writeTexture({
    texture
  }, data, {}, {
    width: 1,
    height: 1
  });
  return texture;
}

function createFloatColorTexture(width, height) {
  let rc;
  let wgctx = rc.getWGCtx();
  let data = new Uint16Array(width * height * 4);
  let scale = 10.0;
  let k = 0;

  for (let i = 0; i < height; ++i) {
    for (let j = 0; j < width; ++j) {
      k = (width * i + j) * 4;
      data[k] = toFloat16(scale * (j / width));
      data[k + 1] = toFloat16(scale * (0.5 + 0.5 * Math.sin(10.0 * (1.0 - j / width))));
      data[k + 2] = toFloat16(scale * (1.0 - i * j / (width * height)));
      data[k + 3] = toFloat16(scale * 1.0);
    }
  }

  const texture = wgctx.device.createTexture({
    size: {
      width,
      height
    },
    format: "rgba16float",
    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
  });
  wgctx.device.queue.writeTexture({
    texture
  }, data, {
    bytesPerRow: width * 8,
    rowsPerImage: height
  }, {
    width,
    height
  });
  return texture;
}

/***/ })

/******/ });
});