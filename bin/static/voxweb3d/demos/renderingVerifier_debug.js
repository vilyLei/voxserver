(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CoSpace"] = factory();
	else
		root["CoSpace"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fae3");
/******/ })
/************************************************************************/
/******/ ({

/***/ "0063":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * thanks for threejs LoaderUtils module.
 */

class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    let s = '';

    for (let i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }

    try {
      // merges multi-byte utf-8 characters.
      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358
      return s;
    }
  }

  static extractUrlBase(url) {
    const index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }

  static resolveURL(url, path) {
    // Invalid URL
    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
    } // Absolute URL http://,https://,//


    if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

    if (/^blob:.*$/i.test(url)) return url; // Relative URL

    return path + url;
  }

}

exports.LoaderUtils = LoaderUtils;

/***/ }),

/***/ "015b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderMaterial_1 = __importDefault(__webpack_require__("131b"));

class NormalCheckMaterial {
  constructor() {
    this.m_data = new Float32Array([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0]);
    this.material = null;
  }

  setNormalScale(s) {
    this.m_data[6] = s;
  }

  setRGB3f(pr, pg, pb) {
    this.m_data[0] = pr;
    this.m_data[1] = pg;
    this.m_data[2] = pb;
  }

  getRGB3f(color) {
    let ds = this.m_data;
    color.setRGB3f(ds[0], ds[1], ds[2]);
  }

  getRGBA4f(color) {
    color.fromArray(this.m_data);
  }

  setLength(length) {
    this.m_data[3] = length;
  }

  getLegnth() {
    return this.m_data[3];
  }

  setColor(color) {
    color.toArray3(this.m_data);
  }

  getColor(color) {
    color.fromArray3(this.m_data);
  }

  applyLocalNormal() {
    // console.log("apply local normal..., dif: ", this.m_data[5]);
    this.m_data[7] = 0.0;
  }

  applyGlobalNormal() {
    // console.log("apply global normal..., dif: ", this.m_data[5]);
    this.m_data[7] = 1.0;
  }

  applyModelColor() {
    this.m_data[4] = 1.0; // console.log("apply model color..., dif: ", this.m_data[5]);
  }

  applyNormalColor() {
    this.m_data[4] = 0.0; // console.log("apply normal color..., dif: ", this.m_data[5]);
  }

  applyDifference(boo = true) {
    this.m_data[5] = boo ? 1.0 : 0.0; // console.log("apply diff boo: ", boo);
  }
  /**
   * @param textureEnabled the default value is false
   */


  create() {
    if (this.material == null) {
      let textureEnabled = false;
      let material = new ShaderMaterial_1.default("normal_check_material"); // let material = CoRScene.createShaderMaterial("normal_entity_material");

      material.addUniformDataAt("u_params", this.m_data);
      material.setShaderBuilder(coderBuilder => {
        let coder = coderBuilder.getShaderCodeBuilder();
        coder.addVertLayout("vec3", "a_uvs");
        coder.addVertLayout("vec3", "a_nvs");
        coder.addVertUniform("vec4", "u_params", 2);
        coder.addFragUniform("vec4", "u_params", 2);
        coder.addVarying("vec4", "v_nv");
        coder.addVarying("vec3", "v_vnv");
        coder.addVarying("vec3", "v_dv");
        coder.addFragOutputHighp("vec4", "FragColor0");
        coder.addFragHeadCode(`
				const vec3 gama = vec3(1.0/2.2);
				const vec3 direc0 = normalize(vec3(-0.3,-0.6,0.9));
				const vec3 direc1 = normalize(vec3(0.3,0.6,0.9));
					`);
        coder.addFragMainCode(`
			bool facing = gl_FrontFacing;
    		vec2 dv = fract(gl_FragCoord.xy/vec2(5.0)) - vec2(0.5);
    		vec2 f2 = sign(dv);
    
    		vec3 nv = normalize(v_nv.xyz);
    		vec3 color = pow(nv, gama);

			float nDotL0 = max(dot(v_vnv.xyz, direc0), 0.1);
			float nDotL1 = max(dot(v_vnv.xyz, direc1), 0.1);
			nDotL0 = 0.7 * (nDotL0 + nDotL1);
			vec3 modelColor = u_params[0].xyz * vec3(nDotL0);
			vec4 param = u_params[1];

    		vec3 frontColor = param.x > 0.5 ? modelColor : color.xyz;
    		vec3 backColor = param.y > 0.5 ? vec3(sign(f2.x * f2.y), 1.0, 1.0) : frontColor;
    		vec3 dstColor = facing ? frontColor : backColor;
			
			frontColor = param.y > 0.5 ? dstColor : modelColor;
			dstColor = param.x > 0.5 ? frontColor : dstColor;
			
			float f = v_dv.x;
			f = f < 0.8 ? 1.0 : 0.0;
			// vec3 diffColor = vec3(1.0, 0.0, 0.0) * f + dstColor * (1.0 - f);
			float s = sign(f2.x * f2.y);
			vec3 diffColor = vec3(1.0, s, s) * f + dstColor * (1.0 - f);
			dstColor = param.y > 0.5 ? diffColor : dstColor;

    		FragColor0 = vec4(dstColor, 1.0);
    		// FragColor0 = vec4(u_params[0].xyz, 1.0);
					`);
        coder.addVertMainCode(`
			mat4 vmat = u_viewMat * u_objMat;
			viewPosition = vmat * vec4(a_vs,1.0);
			vec3 puvs = a_uvs;
			vec3 pnv = u_params[1].zzz * a_nvs;
			v_dv = vec3(dot(normalize(a_uvs), normalize( pnv )));
			vec4 pv = u_projMat * viewPosition;			
			gl_Position = pv;
			v_vnv = normalize(pnv * inverse(mat3(vmat)));
			pnv = u_params[1].w < 0.5 ? pnv : normalize(pnv * inverse(mat3(u_objMat)));
			v_nv = vec4(pnv, 1.0);
					`);
      });
      material.initializeByCodeBuf(textureEnabled);
      this.material = material;
    }

    return this.material;
  }

}

exports.NormalCheckMaterial = NormalCheckMaterial;

/***/ }),

/***/ "0236":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("a996"));

const KeyboardEvent_1 = __importDefault(__webpack_require__("7045"));

const StageBase_1 = __importDefault(__webpack_require__("7b29"));

class SubStage3D extends StageBase_1.default {
  constructor(rcuid, pdocument) {
    super(rcuid);
    this.m_enterFrame_listener = [];
    this.m_enterFrame_ers = [];
    this.m_enterFrameEvt = new EventBase_1.default();
  }

  enterFrame() {
    this.m_enterFrameEvt.type = EventBase_1.default.ENTER_FRAME;
    let len = this.m_enterFrame_listener.length;

    for (var i = 0; i < len; ++i) {
      this.m_enterFrame_listener[i].call(this.m_enterFrame_ers[i], this.m_enterFrameEvt);
    }
  }

  setViewPort(px, py, pw, ph) {
    this.m_autoSynViewAndStageSize = false;
    this.m_viewX = px;
    this.m_viewY = py;

    if (pw != this.m_viewW || ph != this.m_viewH) {
      this.m_viewW = pw;
      this.m_viewH = ph;
      this.updateViewUData();
    }
  }

  updateViewUData() {
    this.uProbe.setVec4Data(2.0 / (this.m_viewW * this.pixelRatio), 2.0 / (this.m_viewH * this.pixelRatio), this.m_viewW * this.pixelRatio, this.m_viewH * this.pixelRatio);
    this.uProbe.update();
    this.m_preStageWidth = this.m_viewW;
    this.m_preStageHeight = this.m_viewH;
  }

  update() {
    if (this.m_preStageWidth != this.stageWidth || this.m_preStageHeight != this.stageHeight) {
      if (this.m_autoSynViewAndStageSize) {
        this.m_viewW = this.stageWidth;
        this.m_viewH = this.stageHeight;
        this.updateViewUData();
      }

      this.stageHalfWidth = 0.5 * this.stageWidth;
      this.stageHalfHeight = 0.5 * this.stageHeight;
    }
  }

  addEventListener(type, target, func, captureEnabled = true, bubbleEnabled = true) {
    if (func != null && target != null) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          console.warn("addEventListener EventBase.RESIZE invalid operation.");
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.addTarget(this.m_enterFrame_listener, this.m_enterFrame_ers, target, func);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          console.warn("addEventListener KeyboardEvent.KEY_DOWN invalid operation.");
          break;

        case KeyboardEvent_1.default.KEY_UP:
          console.warn("addEventListener KeyboardEvent.KEY_UP invalid operation.");
          break;

        default:
          this.m_dp.addEventListener(type, target, func, captureEnabled, bubbleEnabled);
          break;
      }
    }
  }

  removeEventListener(type, target, func) {
    if (func != null && target != null) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          // this.removeTarget(this.m_resize_listener, this.m_resize_ers, target);
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.removeTarget(this.m_enterFrame_listener, this.m_enterFrame_ers, target);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          // this.removeTarget(this.m_keyDown_listener, this.m_keyDown_ers, target);
          break;

        case KeyboardEvent_1.default.KEY_UP:
          // this.removeTarget(this.m_keyUp_listener, this.m_keyUp_ers, target);
          break;

        default:
          this.m_dp.removeEventListener(type, target, func);
          break;
      }
    }
  }

}

exports.default = SubStage3D;

/***/ }),

/***/ "026b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const Utils_1 = __webpack_require__("f689");

const Utils_2 = __webpack_require__("f689");

const BufferBinaryParser_1 = __webpack_require__("937b");

const TextParser_1 = __webpack_require__("9259");

const FBXTreeBufferParser_1 = __webpack_require__("8b17");

class FBXBufferLoader {
  constructor() {
    this.m_loader = new HttpFileLoader_1.HttpFileLoader();
    this.m_parseOnLoad = null;
    this.m_parseIndex = 0;
    this.m_url = "";
    this.m_tidGeom = -1;
    this.m_tidBin = -1;
  }

  load(url, onLoad, onProgress = null, onError = null) {
    this.m_loader.load(url, (buf, url) => {
      let modelMap = new Map();
      let bufferMap = this.parseGeometry(buf, url); // console.log("###XXX bufferMap: ", bufferMap);

      for (let [key, value] of bufferMap) {
        modelMap.set(key, value.toGeometryModel());
      }

      if (onLoad != null) {
        onLoad(modelMap, url);
      }
    }, onProgress, (status, url) => {
      console.error("load fbx data error, url: ", url);

      if (onError != null) {
        onError(status, url);
      }
    });
  }

  parseGeometry(buffer, path) {
    // console.log("FBXBufferLoader::parseGeomdtry(), buffer.byteLength: ", buffer.byteLength);
    // console.log("FBXBufferLoader::parseGeomdtry(), isFbxFormatBinary( buffer ): ", isFbxFormatBinary( buffer ));
    let fbxTree;

    if (Utils_2.isFbxFormatBinary(buffer)) {
      this.m_binParser = new BufferBinaryParser_1.BufferBinaryParser();
      fbxTree = this.m_binParser.parse(buffer);
    } else {
      const FBXText = Utils_1.convertArrayBufferToString(buffer);

      if (!Utils_1.isFbxFormatASCII(FBXText)) {
        throw new Error('FBXBufferLoader: Unknown format.');
      }

      if (Utils_1.getFbxVersion(FBXText) < 7000) {
        throw new Error('FBXBufferLoader: FBX version not supported, FileVersion: ' + Utils_1.getFbxVersion(FBXText));
      }

      fbxTree = new TextParser_1.TextParser().parse(FBXText);
    }

    this.m_fbxTreeBufParser = new FBXTreeBufferParser_1.FBXTreeBufferParser();
    return this.m_fbxTreeBufParser.parse(fbxTree, this.m_binParser.getReader());
  }

  loadBySteps(url, onLoad, onProgress = null, onError = null) {
    if (this.m_fbxTreeBufParser == null) {
      this.m_loader.load(url, (buf, url) => {
        this.m_parseOnLoad = onLoad;
        this.m_parseIndex = 0;
        this.m_url = url;
        this.parseGeometryBySteps(buf, url);
      }, onProgress, (status, url) => {
        console.error("load fbx data error, url: ", url);

        if (onError != null) {
          onError(status, url);
        }
      });
    } else {
      console.error("正在解析中，请稍后");
    }
  }

  parseBufBySteps(buf, url, onLoad) {
    this.m_parseOnLoad = onLoad;
    this.m_parseIndex = 0;
    this.m_url = url;
    this.parseGeometryBySteps(buf, url);
  }

  updateGeomParse() {
    let delay = 50; // 20 fps

    if (this.m_tidGeom > -1) {
      clearTimeout(this.m_tidGeom);
    }

    if (this.m_fbxTreeBufParser != null && this.m_fbxTreeBufParser.isParsing()) {
      let id = this.m_fbxTreeBufParser.getGeomBufId();
      let model = this.m_fbxTreeBufParser.parseGeomBufNext();
      this.m_parseIndex++;
      let tot = this.m_fbxTreeBufParser.getParseTotal();
      let onLoad = this.m_parseOnLoad;

      if (this.m_parseIndex < this.m_fbxTreeBufParser.getParseTotal()) {
        this.m_tidGeom = setTimeout(this.updateGeomParse.bind(this), delay);
      } else {
        this.m_parseOnLoad = null;
        this.m_fbxTreeBufParser = null;
      }

      onLoad(model.toGeometryModel(), model, this.m_parseIndex - 1, tot, this.m_url);
    }
  }

  startupParseGeom() {
    // console.log("FBXBufferLoader::startupParseGeom()...");
    this.m_tidGeom = setTimeout(this.updateGeomParse.bind(this), 30); // let model = this.m_fbxTreeBufParser.parseGeomBufAt( 7 );
    // this.m_parseIndex++;
    // let tot = this.m_fbxTreeBufParser.getParseTotal();
    // let onLoad = this.m_parseOnLoad;
    // onLoad(model.toGeometryModel(), model, this.m_parseIndex-1, tot, this.m_url);
  }

  parseModelAt(i) {// let model = this.m_fbxTreeBufParser.parseGeomBufAt( i );
    // this.m_parseIndex++;
    // let tot = this.m_fbxTreeBufParser.getParseTotal();
    // let onLoad = this.m_parseOnLoad;
    // onLoad(model.toGeometryModel(), model, this.m_parseIndex-1, tot, this.m_url);
  }

  updateBinParse() {
    if (this.m_tidBin > -1) {
      clearTimeout(this.m_tidBin);
    }

    let delay = 20; // 50 fps

    if (this.m_binParser != null) {
      this.m_binParser.parseNext();

      if (this.m_binParser.isParsing()) {
        this.m_tidBin = setTimeout(this.updateBinParse.bind(this), delay);
      } else {
        this.m_fbxTreeBufParser = new FBXTreeBufferParser_1.FBXTreeBufferParser();
        this.m_fbxTreeBufParser.parseBegin(this.m_binParser.getFBXTree(), this.m_binParser.getReader());

        if (this.m_fbxTreeBufParser != null) {
          this.startupParseGeom();
        } // console.log("##$$$ ############ parse bin end, totalBP: ", this.m_binParser.totalBP, this.m_binParser.totalBPTime);


        this.m_binParser = null;
      }
    }
  }

  parseGeometryBySteps(buffer, path) {
    // console.log("FBXBufferLoader::parseGeomdtry(), buffer.byteLength: ", buffer.byteLength);
    // console.log("FBXBufferLoader::parseGeomdtry(), isFbxFormatBinary( buffer ): ", isFbxFormatBinary( buffer ));
    let fbxTree;

    if (Utils_2.isFbxFormatBinary(buffer)) {
      this.m_binParser = new BufferBinaryParser_1.BufferBinaryParser();
      this.m_binParser.parseBegin(buffer);
      this.m_tidBin = setTimeout(this.updateBinParse.bind(this), 18);
    } else {
      const FBXText = Utils_1.convertArrayBufferToString(buffer);

      if (!Utils_1.isFbxFormatASCII(FBXText)) {
        throw new Error('FBXBufferLoader: Unknown format.');
      }

      if (Utils_1.getFbxVersion(FBXText) < 7000) {
        throw new Error('FBXBufferLoader: FBX version not supported, FileVersion: ' + Utils_1.getFbxVersion(FBXText));
      }

      fbxTree = new TextParser_1.TextParser().parse(FBXText);
      this.m_fbxTreeBufParser = new FBXTreeBufferParser_1.FBXTreeBufferParser();
      this.m_fbxTreeBufParser.parseBegin(fbxTree, null);
    }
  }

}

exports.FBXBufferLoader = FBXBufferLoader;

/***/ }),

/***/ "030e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// renderer context Extensions

class RCExtension {
  static Initialize(webVer, gl) {
    let selfT = this;

    if (webVer == 1) {
      //#extension OES_standard_derivatives : enable
      selfT.OES_standard_derivatives = gl.getExtension('OES_standard_derivatives');
      if (selfT.OES_standard_derivatives != null) console.log("Use OES_standard_derivatives Extension success!");else console.log("OES_standard_derivatives Extension can not support!"); //#extension GL_EXT_shader_texture_lod : enable, for example: textureCubeLodEXT(envMap, dir, mipLv)
      // vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod)
      // vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod)
      // vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod)
      // vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod)
      // vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy)
      // vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy)
      // vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy)
      // vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy)

      selfT.EXT_shader_texture_lod = gl.getExtension('EXT_shader_texture_lod');
      if (selfT.EXT_shader_texture_lod != null) console.log("Use EXT_shader_texture_lod Extension success!");else console.log("EXT_shader_texture_lod Extension can not support!");
      /*
      <script type="x-shader/x-fragment">
      #extension GL_EXT_shader_texture_lod : enable
      #extension GL_OES_standard_derivatives : enable
      
      uniform sampler2D myTexture;
      varying vec2 texcoord;
      
      void main(){
        gl_FragColor = texture2DGradEXT(myTexture, mod(texcoord, vec2(0.1, 0.5)),
                                        dFdx(texcoord), dFdy(texcoord));
      }
      </script>
      */

      selfT.WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');
      if (selfT.WEBGL_draw_buffers != null) console.log("Use WEBGL_draw_buffers Extension success!");else console.log("WEBGL_draw_buffers Extension can not support!"); //DivLog.ShowLog("selfT.WEBGL_draw_buffers != null: "+(selfT.WEBGL_draw_buffers != null));

      selfT.OES_vertex_array_object = gl.getExtension('OES_vertex_array_object');
      if (selfT.OES_vertex_array_object != null) console.log("Use OES_vertex_array_object Extension success!");else console.log("OES_vertex_array_object Extension can not support!");
      selfT.ANGLE_instanced_arrays = gl.getExtension('ANGLE_instanced_arrays');
      if (selfT.ANGLE_instanced_arrays != null) console.log("Use ANGLE_instanced_arrays Extension success!");else console.log("ANGLE_instanced_arrays Extension can not support!");
      selfT.EXT_color_buffer_float = gl.getExtension('EXT_color_buffer_float');
      if (selfT.EXT_color_buffer_float != null) console.log("Use EXT_color_buffer_float Extension success!");else console.log("EXT_color_buffer_float Extension can not support!");
      selfT.EXT_color_buffer_half_float = gl.getExtension('EXT_color_buffer_half_float');
      if (selfT.EXT_color_buffer_half_float != null) console.log("Use EXT_color_buffer_half_float Extension success!");else console.log("EXT_color_buffer_half_float Extension can not support!");
      selfT.OES_texture_half_float = gl.getExtension('OES_texture_half_float');
      if (selfT.OES_texture_half_float != null) console.log("Use OES_texture_half_float Extension success!");else console.log("OES_texture_half_float Extension can not support!");
      selfT.OES_texture_half_float_linear = gl.getExtension('OES_texture_half_float_linear');
      if (selfT.OES_texture_half_float_linear != null) console.log("Use OES_texture_half_float_linear Extension success!");else console.log("OES_texture_half_float_linear Extension can not support!");
      selfT.OES_texture_float = gl.getExtension('OES_texture_float');
      if (selfT.OES_texture_float != null) console.log("Use OES_texture_float Extension success!");else console.log("OES_texture_float Extension can not support!"); //

      selfT.OES_element_index_uint = gl.getExtension('OES_element_index_uint');
      if (selfT.OES_element_index_uint != null) console.log("Use OES_element_index_uint Extension success!");else console.log("OES_element_index_uint Extension can not support!"); //EXT_blend_minmax

      selfT.EXT_blend_minmax = gl.getExtension('EXT_blend_minmax');
      if (selfT.EXT_blend_minmax != null) console.log("Use EXT_blend_minmax Extension success!");else console.log("EXT_blend_minmax Extension can not support!");
    } else {
      //  selfT.OES_standard_derivatives = gl.getExtension('OES_standard_derivatives');
      //  if(selfT.OES_standard_derivatives != null)
      //  console.log("Use OES_standard_derivatives Extension success!");
      //  else
      //  console.log("OES_standard_derivatives Extension can not support!");
      selfT.EXT_shader_texture_lod = gl.getExtension('EXT_shader_texture_lod');
      if (selfT.EXT_shader_texture_lod != null) console.log("Use EXT_shader_texture_lod Extension success!");else console.log("EXT_shader_texture_lod Extension can not support!");
      selfT.EXT_color_buffer_half_float = gl.getExtension('EXT_color_buffer_half_float');
      if (selfT.EXT_color_buffer_half_float != null) console.log("Use EXT_color_buffer_half_float Extension success!");else console.log("EXT_color_buffer_half_float Extension can not support!");
      selfT.OES_texture_half_float_linear = gl.getExtension('OES_texture_half_float_linear');
      if (selfT.OES_texture_half_float_linear != null) console.log("Use OES_texture_half_float_linear Extension success!");else console.log("OES_texture_half_float_linear Extension can not support!");
      selfT.EXT_color_buffer_float = gl.getExtension('EXT_color_buffer_float');
      if (selfT.EXT_color_buffer_float != null) console.log("Use EXT_color_buffer_float Extension success!");else console.log("EXT_color_buffer_float Extension can not support!");
    }

    selfT.OES_texture_float_linear = gl.getExtension('OES_texture_float_linear');
    if (selfT.OES_texture_float_linear != null) console.log("Use OES_texture_float_linear Extension success!");else console.log("OES_texture_float_linear Extension can not support!");
    selfT.WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');
    if (selfT.WEBGL_depth_texture != null) console.log("Use WEBGL_depth_texture Extension success!");else console.log("WEBGL_depth_texture Extension can not support!");
    selfT.WEBGL_debug_renderer_info = gl.getExtension('WEBGL_debug_renderer_info');
    if (selfT.WEBGL_debug_renderer_info != null) console.log("Use WEBGL_debug_renderer_info Extension success!");else console.log("WEBGL_debug_renderer_info Extension can not support!"); //
    //console.log("RCExtension.WEBGL_depth_texture: ",RCExtension.WEBGL_depth_texture);
  }

}

RCExtension.OES_standard_derivatives = null;
RCExtension.EXT_shader_texture_lod = null;
RCExtension.WEBGL_draw_buffers = null;
RCExtension.OES_vertex_array_object = null;
RCExtension.ANGLE_instanced_arrays = null;
RCExtension.EXT_color_buffer_float = null;
RCExtension.EXT_color_buffer_half_float = null;
RCExtension.OES_texture_float_linear = null;
RCExtension.OES_texture_half_float_linear = null;
RCExtension.OES_texture_half_float = null;
RCExtension.OES_texture_float = null;
RCExtension.OES_element_index_uint = null;
RCExtension.EXT_blend_minmax = null;
RCExtension.WEBGL_depth_texture = null;
RCExtension.WEBGL_debug_renderer_info = null;
exports.default = RCExtension;

/***/ }),

/***/ "070b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RenderColorMask {
  //private m_state: number = 0;
  constructor(rBoo, gBoo, bBoo, aBoo) {
    this.m_uid = -1;
    this.m_rBoo = true;
    this.m_gBoo = true;
    this.m_bBoo = true;
    this.m_aBoo = true;
    this.m_uid = RenderColorMask.s_uid++;
    this.m_rBoo = rBoo;
    this.m_gBoo = gBoo;
    this.m_bBoo = bBoo;
    this.m_aBoo = aBoo;
  }

  getUid() {
    return this.m_uid;
  }

  getR() {
    return this.m_rBoo;
  }

  getG() {
    return this.m_gBoo;
  }

  getB() {
    return this.m_bBoo;
  }

  getA() {
    return this.m_aBoo;
  }

  use() {
    if (RenderColorMask.s_state != this.m_uid) {
      RenderColorMask.Rstate.setColorMask(this.m_rBoo, this.m_gBoo, this.m_bBoo, this.m_aBoo);
      RenderColorMask.s_state = this.m_uid;
    }
  }

  static Create(objName, rBoo, gBoo, bBoo, aBoo) {
    if (RenderColorMask.s_stsNameMap.has(objName)) {
      let po = RenderColorMask.s_stsNameMap.get(objName);
      return po.getUid();
    }

    let key = (rBoo ? 1 << 6 : 1 << 5) | (gBoo ? 1 << 4 : 1 << 3) | (bBoo ? 1 << 2 : 1 << 1) | (aBoo ? 1 : 0);

    if (RenderColorMask.s_stsMap.has(key)) {
      let po = RenderColorMask.s_stsMap.get(key);
      key = po.getUid();
    } else {
      let po = new RenderColorMask(rBoo, gBoo, bBoo, aBoo);
      key = po.getUid();
      RenderColorMask.s_stsMap.set(key, po);
      RenderColorMask.s_stsNameMap.set(objName, po);
      RenderColorMask.s_states.push(po);
      ++RenderColorMask.s_statesLen;
    }

    return key;
  }

  static GetColorMaskByName(objName) {
    if (RenderColorMask.s_stsNameMap.has(objName)) {
      let po = RenderColorMask.s_stsNameMap.get(objName);
      return po.getUid();
    }

    return -1;
  } // @param           state come from RODisp::renderState


  static UseRenderState(state) {
    if (RenderColorMask.s_unlocked && RenderColorMask.Rstate.roColorMask != state) {
      if (state > -1 && state < RenderColorMask.s_statesLen) {
        RenderColorMask.s_states[state].use();
      }
    }
  }

  static UseColorMaskByName(stateName) {
    let state = RenderColorMask.GetColorMaskByName(stateName); //trace("state: "+state+", stateName: "+stateName);

    if (RenderColorMask.s_unlocked && RenderColorMask.Rstate.roColorMask != state) {
      if (state > -1 && state < RenderColorMask.s_statesLen) {
        RenderColorMask.s_states[state].use();
      }
    }
  }

  static Lock() {
    RenderColorMask.s_unlocked = false;
  }

  static Unlock() {
    RenderColorMask.s_unlocked = true;
  }

  static Reset() {
    RenderColorMask.s_state = -1;
  }

}

RenderColorMask.s_uid = 0;
RenderColorMask.s_state = -1;
RenderColorMask.s_states = [];
RenderColorMask.s_statesLen = 1;
RenderColorMask.s_stsMap = new Map();
RenderColorMask.s_stsNameMap = new Map();
RenderColorMask.s_unlocked = true;
RenderColorMask.ALL_TRUE_COLOR_MASK = 0;
RenderColorMask.ALL_FALSE_COLOR_MASK = 1;
RenderColorMask.Rstate = null;
exports.RenderColorMask = RenderColorMask;

/***/ }),

/***/ "0817":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ModuleFileType_1 = __webpack_require__("a401");

class TaskCodeModuleParam {
  constructor(url, name, type = ModuleFileType_1.ModuleFileType.JS) {
    this.url = url;
    this.name = name;
    this.type = type;
  }

}

exports.TaskCodeModuleParam = TaskCodeModuleParam;

/***/ }),

/***/ "0851":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const TextureResSlot_1 = __importDefault(__webpack_require__("da6a"));
/**
 * Texture cpu memory data object
 */


class TextureProxy {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    this.m_uid = -1; // 自身的引用计数器

    this.m_attachCount = 0;
    this.m_renderProxy = null;
    this.m_slot = null;
    this.m_miplevel = -1;
    this.m_texWidth = 128;
    this.m_texHeight = 128;
    this.m_texBufW = 128;
    this.m_texBufH = 128;
    this.m_texTarget = TextureTarget_1.default.TEXTURE_2D; // The fragment processor texture sampler type.

    this.m_sampler = -1; // have render useable data

    this.m_haveRData = false;
    this.m_type = TextureProxyType_1.TextureProxyType.Default;
    this.m_generateMipmap = true;
    this.name = "TextureProxy";
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.dataType = TextureDataType_1.default.UNSIGNED_BYTE;
    this.wrap_s = TextureConst_1.default.WRAP_CLAMP_TO_EDGE;
    this.wrap_t = TextureConst_1.default.WRAP_CLAMP_TO_EDGE;
    this.wrap_r = TextureConst_1.default.WRAP_CLAMP_TO_EDGE;
    this.mipmapEnabled = false;
    this.flipY = false;
    this.premultiplyAlpha = false;
    /**
     * the value contains (1,2,4,8)
     */

    this.unpackAlignment = 4;
    this.minFilter = TextureConst_1.default.LINEAR_MIPMAP_LINEAR; // webgl1环境下,这个参数值为LINEAR会报错:
    // [.WebGL-0BC70EE8]RENDER WARNING: texture bound to texture unit 1 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering.

    this.magFilter = TextureConst_1.default.LINEAR; // 用于记录自身变换的版本号，例如数据变换

    this.version = 0;
    this.m_slot = TextureResSlot_1.default.GetInstance();
    this.m_uid = this.m_slot.getFreeUid();
    if (texWidth < 1) texWidth = 128;
    if (texHeight < 1) texHeight = 128;

    if (powerof2Boo) {
      this.m_texWidth = MathConst_1.default.CalcNearestCeilPow2(texWidth);
      this.m_texHeight = MathConst_1.default.CalcNearestCeilPow2(texHeight);
    } else {
      this.m_texWidth = texWidth;
      this.m_texHeight = texHeight;
    }

    this.m_slot.__$$addTexture(this);
  }
  /**
   * This function only be be called by the renderer inner system.
   */


  __$$use(resTex) {
    resTex.bindToGpu(this.getResUid());
  }

  __$setRenderProxy(rc) {
    if (this.m_slot != null) {
      this.m_renderProxy = rc;
    } else {
      // 这样处理可能有错误
      this.m_slot = TextureResSlot_1.default.GetInstance();
      this.m_uid = this.m_slot.getFreeUid();

      this.m_slot.__$$addTexture(this);

      this.m_renderProxy = rc;
    }
  }
  /**
   * 被引用计数加一
   */


  __$attachThis() {
    if (this.m_attachCount == -1) {
      this.m_slot.removeFreeUid(this.getUid());
      this.m_attachCount = 0;
    }

    ++this.m_attachCount; //console.log("TextureProxy::__$attachThis() this(uid="+this.getUid()+").attachCount: "+this.m_attachCount);
  }
  /**
   * 被引用计数减一
   */


  __$detachThis() {
    if (this.m_attachCount > 0) {
      --this.m_attachCount; //console.log("TextureProxy::__$detachThis() this(uid="+this.getUid()+").attachCount: "+this.m_attachCount);

      if (this.m_attachCount < 1) {
        this.m_attachCount = -1;
        this.m_slot.addFreeUid(this.getUid()); //console.log("TextureProxy::__$detachThis() this.m_attachCount value is 0.");
      }
    }
  }
  /**
   * @returns 获得引用计数值
   */


  getAttachCount() {
    return this.m_attachCount;
  }
  /**
   * @returns 返回true, 表示当前纹理对象是渲染直接使用其对应的显存资源的对象
   *          返回false, 表示不能直接使用对应的显存资源
   */


  isDirect() {
    return true;
  }
  /**
   * @returns 返回自己的纹理类型(value: TextureProxyType)
   */


  getType() {
    return this.m_type;
  }
  /**
   * @returns 返回自己的 纹理资源 unique id, 这个id会被对应的资源管理器使用, 此方法子类可以依据需求覆盖
   */


  getResUid() {
    return this.m_uid;
  }
  /**
   * @returns 返回自己的 unique id, 此方法不允许子类覆盖
   */


  getUid() {
    return this.m_uid;
  }

  setWrap(wrap) {
    this.wrap_s = this.wrap_t = this.wrap_r = wrap;
  }
  /**
   * 注意，这个返回值在多 renderer instance的时候，如果renderer instance 共享了这个texture，则此返回值和TextureSlot相关
   * @returns the texture gpu resource is enabled or not.
   */


  isGpuEnabled() {
    return this.m_renderProxy != null && this.m_renderProxy.Texture.hasResUid(this.getResUid());
  }
  /**
   * @returns The fragment processor texture sampler type.
   */


  getSampler() {
    return this.m_sampler;
  }
  /**
   * @returns return value is TextureConst.TEXTURE_2D or TextureConst.TEXTURE_CUBE or TextureConst.TEXTURE_3D
   */


  getTargetType() {
    return this.m_texTarget;
  } // gpu texture buf size


  getBufWidth() {
    return this.m_texBufW;
  }

  getBufHeight() {
    return this.m_texBufH;
  } // logic texture size


  getWidth() {
    return this.m_texWidth;
  }

  getHeight() {
    return this.m_texHeight;
  }
  /**
   * @returns the texture data is enough or not.
   */


  isDataEnough() {
    return this.m_haveRData;
  }

  uploadFromFbo(texResource, fboWidth, fboHeight) {
    throw Error("Illegal operation !!!");
  }

  __$buildParam(gl) {
    this.m_texBufW = this.m_texWidth;
    this.m_texBufH = this.m_texHeight; // texture wrap

    gl.texParameteri(this.m_sampler, gl.TEXTURE_WRAP_S, TextureConst_1.default.GetConst(gl, this.wrap_s));
    gl.texParameteri(this.m_sampler, gl.TEXTURE_WRAP_T, TextureConst_1.default.GetConst(gl, this.wrap_t)); // texture filter

    gl.texParameteri(this.m_sampler, gl.TEXTURE_MIN_FILTER, TextureConst_1.default.GetConst(gl, this.minFilter));
    gl.texParameteri(this.m_sampler, gl.TEXTURE_MAG_FILTER, TextureConst_1.default.GetConst(gl, this.magFilter)); //      //gl.DONT_CARE
    //      //gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
    //      //gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);

    if (this.m_texTarget == TextureTarget_1.default.TEXTURE_3D) {
      gl.texParameteri(this.m_sampler, gl.TEXTURE_WRAP_R, TextureConst_1.default.GetConst(gl, this.wrap_r));
      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_BASE_LEVEL, 0);
      gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAX_LEVEL, Math.log2(this.m_texWidth));
    }

    if (this.mipmapEnabled && this.m_generateMipmap) {
      gl.generateMipmap(this.m_sampler);
    }
  }

  enableMipmap() {}

  disableMipmap() {}

  generateMipmap(texRes) {
    if (this.mipmapEnabled && this.m_generateMipmap) {
      let gl = texRes.getRC();
      texRes.bindToGpu(this.getResUid()); //gl.generateMipmap(this.m_sampler);

      this.__$buildParam(gl);
    }
  } // sub class override


  uploadData(texRes) {} // sub class override


  __$updateToGpu(texRes) {}
  /**
   * 准备将数据更新到当前的 Gpu context,这是一个异步过程，在渲染运行时才会真正的提交给gpu
   * 这个函数由用户主动调用
   * 这个函数不能被子类覆盖
   */


  updateDataToGpu(rc = null, deferred = true) {
    if (rc != null) this.m_renderProxy = rc;

    if (this.m_renderProxy != null) {
      this.m_renderProxy.MaterialUpdater.updateTextureData(this, deferred);
    }
  }

  createTexBuf(texResource) {
    if (!texResource.hasResUid(this.getResUid())) {
      this.m_sampler = TextureTarget_1.default.GetValue(texResource.getRC(), this.m_texTarget);
      texResource.createResByParams3(this.getResUid(), this.getWidth(), this.getHeight(), this.m_sampler);
      return true;
    }

    return false;
  }
  /**
   * This function only be be called by the renderer inner system.
   * if sub class override this function, it must does call this function.
   */


  __$$upload(texRes) {
    if (this.m_haveRData && this.m_slot != null) {
      let buildStatus = this.createTexBuf(texRes); //console.log("Tex __$$upload buildStatus: ",buildStatus, ",resUid: ", this.getResUid());

      if (buildStatus) {
        this.__$updateToGpuBegin(texRes);

        this.uploadData(texRes);

        this.__$buildParam(texRes.getRC());

        this.m_generateMipmap = true;
      }
    }
  }
  /**
   * sub class can not override!!!!
   */


  dataUploadToGpu(gl, texData, texDatas, force = false) {
    this.version = 0;
    let interType = TextureFormat_1.default.ToGL(gl, this.internalFormat);
    let format = TextureFormat_1.default.ToGL(gl, this.srcFormat);
    let type = TextureDataType_1.default.ToGL(gl, this.dataType);
    let d = texData;

    if (texDatas == null) {
      if (d.status > -1 || force) d.updateToGpu(gl, this.m_sampler, interType, format, type, force);
    } else {
      let ds = texDatas;

      for (let i = 0, len = ds.length; i < len; ++i) {
        d = ds[i];

        if (d != null) {
          if (d.status > -1 || force) d.updateToGpu(gl, this.m_sampler, interType, format, type, force);
        }
      }

      this.m_generateMipmap = false;
    }
  }

  __$updateToGpuBegin(texRes) {
    let gl = texRes.getRC();
    texRes.bindToGpu(this.getResUid());
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment);
  }

  __$updateToGpuEnd(gl) {}
  /**
   * @returns This textureProxy instance has been destroyed.
   */


  isDestroyed() {
    return this.m_attachCount < -1;
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      this.m_attachCount = -2;
      this.m_haveRData = false;
      this.m_texWidth = 1;
      this.m_texHeight = 1;
      this.m_renderProxy = null; //console.log("TextureProxy::destroy(), destroy a textureProxy instance(uid="+this.getUid()+")...");
    }
  }
  /**
   * 移除之后则不能再正常使用了
   */


  __$$removeFromSlot() {
    if (this.m_slot != null && this.getAttachCount() == -2) {
      // this.m_slot.__$$removeTexture(this);
      // this.m_slot 不能随便等于null,因为当前textureProxy实例还会通过this.m_slot来重复使用
      // 如果 this.m_slot 要等于 null, 则这个textureProxy实例及其uid需要回收
      console.log("TextureProxy::RemoveFromSlot(), destroy a textureProxy instance(uid=" + this.getUid() + ")...");
      this.m_slot = null;
      this.m_renderProxy = null;
      this.m_uid = -1;
    }
  }

  toString() {
    return "[TextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.TextureProxy = TextureProxy;
exports.default = TextureProxy;

/***/ }),

/***/ "0890":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

const CameraDragSwinger_1 = __webpack_require__("bcac");

class CameraStageDragSwinger {
  constructor() {
    this.m_stage3D = null;
    this.m_dragSwinger = new CameraDragSwinger_1.CameraDragSwinger();
    this.m_enabled = true;
    /**
     * the value contains 0(mouse down), 1(mouse middle), 2(mouse right)
     */

    this.buttonType = 0;
    this.bgEventEnabled = false;
  }

  setAutoRotationEnabled(enabled) {
    this.m_dragSwinger.autoRotationEnabled = enabled;
  }

  initialize(stage3D, camera) {
    if (this.m_stage3D == null) {
      this.m_stage3D = stage3D;
      this.m_dragSwinger.initialize(stage3D, camera); // if(bgMouseDown) {
      //     stage3D.addEventListener(MouseEvent.MOUSE_BG_DOWN, this, this.mouseDownListener, true, false);
      // }
      // else {
      //     stage3D.addEventListener(MouseEvent.MOUSE_DOWN, this, this.mouseDownListener, true, false);
      // }
      // stage3D.addEventListener(MouseEvent.MOUSE_UP, this, this.mouseUpListener, true, true);

      const ME = MouseEvent_1.default;
      let downType = ME.MOUSE_DOWN;

      if (this.bgEventEnabled) {
        downType = ME.MOUSE_BG_DOWN;
      }

      let upType = ME.MOUSE_UP;

      if (this.buttonType == 1) {
        if (this.bgEventEnabled) {
          downType = ME.MOUSE_BG_MIDDLE_DOWN;
        } else {
          downType = ME.MOUSE_MIDDLE_DOWN;
        }

        upType = ME.MOUSE_MIDDLE_UP;
      } else if (this.buttonType == 2) {
        if (this.bgEventEnabled) {
          downType = ME.MOUSE_BG_RIGHT_DOWN;
        } else {
          downType = ME.MOUSE_RIGHT_DOWN;
        }

        upType = ME.MOUSE_RIGHT_UP;
      }

      stage3D.addEventListener(downType, this, this.mouseDownListener, true, false);
      stage3D.addEventListener(upType, this, this.mouseUpListener, false, true);
    }
  }

  mouseDownListener(evt) {
    if (this.m_enabled) {
      this.m_dragSwinger.attach();
    }
  }

  mouseUpListener(evt) {
    this.m_dragSwinger.detach();
  }

  setEnabled(enabled) {
    this.m_enabled = enabled;
  }

  detach() {
    this.m_dragSwinger.detach();
  }

  runWithYAxis() {
    this.m_dragSwinger.runWithYAxis();
  }

  runWithZAxis() {
    this.m_dragSwinger.runWithZAxis();
  }

  runWithCameraAxis() {
    this.m_dragSwinger.runWithCameraAxis();
  }

}

exports.default = CameraStageDragSwinger;

/***/ }),

/***/ "08aa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class VerifierParam {
  constructor() {
    this.demoName = "";
    this.threadsTotal = 3;
    this.demoType = "";
    this.hostUrl = "";
    this.m_urls = null;
  }

  initialize() {
    let hostUrl = window.location.href;
    let i = hostUrl.indexOf("?");

    if (i > 0) {
      this.hostUrl = hostUrl.slice(0, i);
      let paramStr = hostUrl.slice(i + 1);
      this.initParam(paramStr);

      if (this.demoType != "") {
        switch (this.demoType) {
          case "fbx":
            this.iniFBXDemo();
            break;

          case "ctm":
            this.initCTMDemo();
            break;

          default:
            break;
        }
      }
    }

    console.log(i, ", verifierParam: ", this);
    console.log("hostUrl: ", hostUrl);
  }

  getUrls() {
    return this.m_urls;
  }

  initParam(paramsStr) {
    if (paramsStr.indexOf("&") > 0) {
      // rvdemo=box&demoType=fbx&thrn=3
      console.log("paramsStr: ", paramsStr);
      let list = paramsStr.split("&");

      for (let i = 0; i < list.length; ++i) {
        const subList = list[i].split("=");

        switch (subList[0]) {
          case "rvdemo":
            this.demoName = subList[1];
            break;

          case "thrn":
            let n = parseInt(subList[1]);

            if (isNaN(n)) {
              n = 1;
            }

            if (n < 1) {
              n = 1;
            } else if (n > 3) {
              n = 3;
            }

            this.threadsTotal = n;
            break;

          case "demoType":
            this.demoType = subList[1];
            break;

          default:
            break;
        }
      }
    }
  }

  iniFBXDemo() {
    let url = "static/private/fbx/" + this.demoName + ".fbx";
    this.m_urls = [url];
  }

  initCTMDemo() {
    // let size = 107375616;
    let ns = this.demoName;
    let baseUrl = "static/private/ctm/";
    let urls = [];

    for (let i = 0; i <= 26; ++i) {
      urls.push(baseUrl + ns + "/" + ns + "_" + i + ".ctm");
    }

    this.m_urls = urls;
  }

}

exports.VerifierParam = VerifierParam;

/***/ }),

/***/ "090c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RCExtension_1 = __importDefault(__webpack_require__("030e"));

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const RViewElement_1 = __importDefault(__webpack_require__("b0ef"));

const ContextMouseEvtDispatcher_1 = __importDefault(__webpack_require__("0c85"));

const RenderConst_1 = __webpack_require__("e08e");

const AABB2D_1 = __importDefault(__webpack_require__("e2fe"));

class RAdapterContext {
  constructor() {
    this.m_mouseEvtDisplather = new ContextMouseEvtDispatcher_1.default();
    this.m_div = null;
    this.m_canvas = null;
    this.m_scissorEnabled = false;
    this.m_depthTestEnabled = true;
    this.m_stencilTestEnabled = true;
    this.m_offcanvas = null;
    this.m_gl = null;
    this.m_stage = null;
    this.m_viewPortRect = new AABB2D_1.default(0, 0, 800, 600);
    this.m_maxWebGLVersion = 2;
    this.m_webGLVersion = 2;
    this.m_devicePixelRatio = 1.0;
    this.m_viewEle = new RViewElement_1.default(); // display 3d view buf size auto sync window size

    this.autoSyncRenderBufferAndWindowSize = true;
    this.offscreenRenderEnabled = false;
    this.m_resizeFlag = true;
    this.m_WEBGL_lose_context = null;
    this.m_displayWidth = 0;
    this.m_displayHeight = 0;
    this.m_rcanvasWidth = 0;
    this.m_rcanvasHeight = 0;
    this.m_resizeCallback = null;
  }

  contextrestoredHandler(evt) {
    console.log("webglcontextrestored...!!!");
    console.log(evt);
  }

  contextlostHandler(evt) {
    console.log("webglcontextlost...!!!");
    console.log(evt);
  }

  setWebGLMaxVersion(webgl_ver) {
    if (webgl_ver == 1 || webgl_ver == 2) {
      this.m_maxWebGLVersion = webgl_ver;
    }
  }

  getWebGLVersion() {
    return this.m_webGLVersion;
  }

  getDiv() {
    return this.m_div;
  }

  setDivStyleLeftAndTop(px, py) {
    this.m_viewEle.setDivStyleLeftAndTop(px, py);
  }

  setDivStyleSize(pw, ph) {
    this.m_viewEle.setDivStyleSize(pw, ph);
  }

  getCanvas() {
    return this.m_canvas;
  }

  isDepthTestEnabled() {
    return this.m_depthTestEnabled;
  }

  isStencilTestEnabled() {
    return this.m_stencilTestEnabled;
  }

  initialize(rcuid, stage, div, rattr = null) {
    this.m_stage = stage;
    var pdocument = null;
    var pwindow = null;

    try {
      if (document != undefined) {
        pdocument = document;
        pwindow = window;
      }
    } catch (err) {
      console.log("RAdapterContext::initialize(), document is undefined.");
    }

    if (pdocument != null) {
      this.m_devicePixelRatio = window.devicePixelRatio;
      RendererDevice_1.default.SetDevicePixelRatio(this.m_devicePixelRatio);
      this.m_viewEle.setDiv(div);
      this.m_viewEle.createViewEle(pdocument, this.autoSyncRenderBufferAndWindowSize);
      this.m_div = div = this.m_viewEle.getDiv();
      let canvas = this.m_canvas = this.m_viewEle.getCanvas();
      this.m_devicePixelRatio = window.devicePixelRatio;
      this.m_mouseEvtDisplather.dpr = this.m_devicePixelRatio;
      let attr = rattr;

      if (rattr == null) {
        attr = {
          depth: this.m_depthTestEnabled,
          premultipliedAlpha: false,
          alpha: true,
          antialias: false,
          stencil: this.m_stencilTestEnabled,
          preserveDrawingBuffer: true,
          powerPreference: "default"
        };
      } else {
        this.m_depthTestEnabled = attr.depth;
        this.m_stencilTestEnabled = attr.stencil;
      }

      console.log("this.m_devicePixelRatio: " + this.m_devicePixelRatio + ",rattr == null: " + (rattr == null));
      console.log("depthTestEnabled: " + attr.depth);
      console.log("stencilTestEnabled: " + attr.stencil);
      console.log("antialiasEnabled: " + attr.antialias);
      console.log("alphaEnabled: " + attr.alpha);
      let offscreen = null;

      if (this.offscreenRenderEnabled) {
        offscreen = canvas.transferControlToOffscreen();
      }

      this.m_offcanvas = offscreen;

      if (this.m_maxWebGLVersion == 2) {
        this.m_gl = offscreen == null ? canvas.getContext('webgl2', attr) : offscreen.getContext('webgl2', attr);

        if (this.m_gl != null) {
          console.log("Use WebGL2 success!");
          this.m_webGLVersion = 2;
        } else {
          console.log("WebGL2 can not support!");
        }
      }

      if (this.m_gl == null) {
        if (offscreen == null) {
          this.m_gl = canvas.getContext('webgl', attr) || canvas.getContext("experimental-webgl", attr);
        } else {
          this.m_gl = offscreen.getContext('webgl', attr) || offscreen.getContext("experimental-webgl", attr);
        }

        if (this.m_gl != null) {
          console.log("Use WebGL1 success!");
          this.m_webGLVersion = 1;
        } else {
          console.log("WebGL1 can not support!");
        }
      }

      if (!this.m_gl) {
        this.m_webGLVersion = -1;
        alert('Unable to initialize WebGL. Your browser or machine may not support it.');
        throw Error("WebGL initialization failure.");
        return;
      }

      let gl = this.m_gl;
      gl.rcuid = rcuid;
      let glStencilFunc = RenderConst_1.GLStencilFunc;
      glStencilFunc.NEVER = gl.NEVER;
      glStencilFunc.LESS = gl.LESS;
      glStencilFunc.EQUAL = gl.EQUAL;
      glStencilFunc.GREATER = gl.GREATER;
      glStencilFunc.NOTEQUAL = gl.NOTEQUAL;
      glStencilFunc.GEQUAL = gl.GEQUAL;
      glStencilFunc.ALWAYS = gl.ALWAYS;
      let stendilOp = RenderConst_1.GLStencilOp;
      stendilOp.KEEP = gl.KEEP;
      stendilOp.ZERO = gl.ZERO;
      stendilOp.REPLACE = gl.REPLACE;
      stendilOp.INCR = gl.INCR;
      stendilOp.INCR_WRAP = gl.INCR_WRAP;
      stendilOp.DECR = gl.DECR;
      stendilOp.DECR_WRAP = gl.DECR_WRAP;
      stendilOp.INVERT = gl.INVERT;
      let glBlendMode = RenderConst_1.GLBlendMode;
      glBlendMode.ZERO = gl.ZERO;
      glBlendMode.ONE = gl.ONE;
      glBlendMode.SRC_COLOR = gl.SRC_COLOR;
      glBlendMode.DST_COLOR = gl.DST_COLOR;
      glBlendMode.SRC_ALPHA = gl.SRC_ALPHA;
      glBlendMode.DST_ALPHA = gl.DST_ALPHA;
      glBlendMode.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
      let glBlendEq = RenderConst_1.GLBlendEquation;
      glBlendEq.FUNC_ADD = gl.FUNC_ADD;
      glBlendEq.FUNC_SUBTRACT = gl.FUNC_SUBTRACT;
      glBlendEq.FUNC_REVERSE_SUBTRACT = gl.FUNC_REVERSE_SUBTRACT;
      glBlendEq.MIN_EXT = gl.MIN_EXT;
      glBlendEq.MAX_EXT = gl.MAX_EXT;
      glBlendEq.MIN = gl.MIN;
      glBlendEq.MAX = gl.MAX;
      let glFaceCull = RenderConst_1.CullFaceMode;
      glFaceCull.BACK = gl.BACK;
      glFaceCull.FRONT = gl.FRONT;
      glFaceCull.FRONT_AND_BACK = gl.FRONT_AND_BACK;
      let device = RendererDevice_1.default; //MAX_RENDERBUFFER_SIZE

      device.MAX_TEXTURE_SIZE = this.m_gl.getParameter(this.m_gl.MAX_TEXTURE_SIZE);
      device.MAX_RENDERBUFFER_SIZE = this.m_gl.getParameter(this.m_gl.MAX_RENDERBUFFER_SIZE);
      let viewPortIMS = this.m_gl.getParameter(this.m_gl.MAX_VIEWPORT_DIMS);
      device.MAX_VIEWPORT_WIDTH = viewPortIMS[0];
      device.MAX_VIEWPORT_HEIGHT = viewPortIMS[1];
      RCExtension_1.default.Initialize(this.m_webGLVersion, this.m_gl);
      RendererDevice_1.default.Initialize([this.m_webGLVersion]);
      console.log("RadapterContext stage: ", stage);
      if (stage != null) this.m_mouseEvtDisplather.initialize(canvas, div, stage); //  console.log("viewPortIMS: ",viewPortIMS);

      console.log("MAX_TEXTURE_SIZE: ", RendererDevice_1.default.MAX_TEXTURE_SIZE);
      console.log("IsMobileWeb: ", RendererDevice_1.default.IsMobileWeb());
      console.log("IsAndroidOS: ", RendererDevice_1.default.IsAndroidOS());
      console.log("IsIOS: ", RendererDevice_1.default.IsIOS()); //  console.log("MAX_RENDERBUFFER_SIZE: ",RendererDevice.MAX_RENDERBUFFER_SIZE);
      //  console.log("MAX_VIEWPORT_WIDTH: ",RendererDevice.MAX_VIEWPORT_WIDTH);
      //  console.log("MAX_VIEWPORT_HEIGHT: ",RendererDevice.MAX_VIEWPORT_HEIGHT);
      //  DivLog.ShowLogOnce("MAX_TEXTURE_SIZE: "+RendererDevice.MAX_TEXTURE_SIZE);
      //  DivLog.ShowLog("MAX_RENDERBUFFER_SIZE: "+RendererDevice.MAX_RENDERBUFFER_SIZE);
      //  DivLog.ShowLog("MAX_VIEWPORT_WIDTH: "+RendererDevice.MAX_VIEWPORT_WIDTH);
      //  DivLog.ShowLog("MAX_VIEWPORT_HEIGHT: "+RendererDevice.MAX_VIEWPORT_HEIGHT);
      //  let rc_vendor:any = this.m_gl.getParameter(this.m_gl.VENDOR);
      //  let rc_renderer:any = this.m_gl.getParameter(this.m_gl.RENDERER);
      //  console.log("rc_vendor: ",rc_vendor);
      //  console.log("rc_renderer: ",rc_renderer);

      let debugInfo = RCExtension_1.default.WEBGL_debug_renderer_info;

      if (debugInfo != null) {
        let webgl_vendor = this.m_gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
        let webgl_renderer = this.m_gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        device.GPU_VENDOR = webgl_vendor;
        device.GPU_RENDERER = webgl_renderer;
        console.log("webgl_vendor: ", webgl_vendor);
        console.log("webgl_renderer: ", webgl_renderer);

        if (!RendererDevice_1.default.IsWinExternalVideoCard()) {
          console.warn("当前浏览器没有使用独立显卡");
        } // DivLog.ShowLog("webgl_vendor: " + webgl_vendor);
        // DivLog.ShowLog("webgl_renderer: " + webgl_renderer);

      }

      pwindow.onresize = evt => {
        if (this.autoSyncRenderBufferAndWindowSize) {
          this.m_resizeFlag = true;
          this.updateRenderBufferSize();
        }
      };

      canvas.addEventListener('webglcontextrestored', this.contextrestoredHandler, false);
      canvas.addEventListener('webglcontextlost', this.contextlostHandler, false);
      this.updateRenderBufferSize();
    } else {
      console.log("initialize WebGL failure!");
    }
  }

  loseContext() {
    if (this.m_WEBGL_lose_context == null) {
      this.m_WEBGL_lose_context = this.m_gl.getExtension('WEBGL_lose_context');
    }

    if (this.m_WEBGL_lose_context == null) {
      this.m_WEBGL_lose_context.loseContext();
    }
  }
  /**
   * @returns return gpu context lost status
   */


  isContextLost() {
    return this.m_gl.isContextLost();
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_gl;
  }

  setScissorEnabled(boo) {
    if (boo) {
      if (!this.m_scissorEnabled) {
        this.m_scissorEnabled = true;
        this.m_gl.enable(this.m_gl.SCISSOR_TEST);
      }
    } else {
      if (this.m_scissorEnabled) {
        this.m_scissorEnabled = false;
        this.m_gl.disable(this.m_gl.SCISSOR_TEST);
      }
    }
  }

  setScissorRect(px, py, pw, ph) {
    //this.m_gl.scissor(Math.floor(px*this.m_devicePixelRatio),Math.floor(py*this.m_devicePixelRatio), pw,ph);
    this.m_gl.scissor(px, py, pw, ph);
  }

  setResizeCallback(resizeCallback) {
    this.m_resizeCallback = resizeCallback;
  }

  getDevicePixelRatio() {
    return this.m_devicePixelRatio;
  }

  resizeBufferSize(pw, ph) {
    pw = Math.floor(pw);
    ph = Math.floor(ph);
    let k = window.devicePixelRatio;
    let dprChanged = Math.abs(k - this.m_devicePixelRatio) > 0.01 || this.m_resizeFlag;
    this.m_devicePixelRatio = k;
    this.m_mouseEvtDisplather.dpr = k;
    RendererDevice_1.default.SetDevicePixelRatio(this.m_devicePixelRatio); // console.log("this.m_devicePixelRatio: "+this.m_devicePixelRatio);

    this.m_resizeFlag = false;

    if (this.m_displayWidth != pw || this.m_displayHeight != ph || dprChanged) {
      this.m_displayWidth = pw;
      this.m_displayHeight = ph;
      this.m_rcanvasWidth = Math.floor(pw * k);
      this.m_rcanvasHeight = Math.floor(ph * k);

      if (this.m_offcanvas == null) {
        this.m_canvas.width = this.m_rcanvasWidth;
        this.m_canvas.height = this.m_rcanvasHeight;
      } else {
        this.m_offcanvas.width = this.m_rcanvasWidth;
        this.m_offcanvas.height = this.m_rcanvasHeight;
      }

      this.m_canvas.style.width = this.m_displayWidth + 'px';
      this.m_canvas.style.height = this.m_displayHeight + 'px';

      if (this.m_stage != null) {
        this.m_stage.stageWidth = this.m_rcanvasWidth;
        this.m_stage.stageHeight = this.m_rcanvasHeight;
        this.m_stage.viewWidth = this.m_displayWidth;
        this.m_stage.viewHeight = this.m_displayHeight;
        this.m_stage.pixelRatio = k;
        console.log("size to stage size: ", this.m_stage.stageWidth, this.m_stage.stageHeight);
        console.log("size to view size: ", this.m_stage.viewWidth, this.m_stage.viewHeight); //  DivLog.ShowLogOnce("stageSize: "+this.m_stage.stageWidth+","+this.m_stage.stageHeight);
        //  DivLog.ShowLog("canvasSize: "+this.m_canvas.width+","+this.m_canvas.height);
        //  DivLog.ShowLog("dispSize: "+this.m_displayWidth+","+this.m_displayHeight);
        //  DivLog.ShowLog("pixelRatio:"+this.m_devicePixelRatio);
        //  console.log("display size: "+this.m_displayWidth+","+this.m_displayHeight);
        //  console.log("RAdapterContext::resize(), canvas.width:"+this.m_canvas.width+", canvas.height:"+this.m_canvas.height);
        //  console.log("RAdapterContext::resize(), stageWidth:"+this.m_stage.stageWidth+", stageHeight:"+this.m_stage.stageHeight);
        //  console.log("RAdapterContext::resize(), m_rcanvasWidth:"+this.m_rcanvasWidth+", m_rcanvasHeight:"+this.m_rcanvasHeight);
        //  console.log("RAdapterContext::resize(), stw:"+this.m_stage.stageWidth+", sth:"+this.m_stage.stageHeight);

        this.m_stage.update();
      }

      if (this.m_resizeCallback != null) {
        this.m_resizeCallback();
      }
    }
  }

  getStage() {
    return this.m_stage;
  }

  getStageWidth() {
    return this.m_stage.stageWidth;
  }

  getStageHeight() {
    return this.m_stage.stageHeight;
  }

  getDisplayWidth() {
    return this.m_displayWidth;
  }

  getDisplayHeight() {
    return this.m_displayHeight;
  }

  setViewport(px, py, pw, ph) {
    this.m_viewPortRect.setTo(px, py, pw, ph);
  }

  setViewportSize(pw, ph) {
    this.m_viewPortRect.setSize(pw, ph);
  }

  testViewPortChanged(px, py, pw, ph) {
    return this.m_viewPortRect.testEqualWithParams(px, py, pw, ph);
  }

  getViewportX() {
    return this.m_viewPortRect.x;
  }

  getViewportY() {
    return this.m_viewPortRect.y;
  }

  getViewportWidth() {
    return this.m_viewPortRect.width;
  }

  getViewportHeight() {
    return this.m_viewPortRect.height;
  }

  getViewPortSize() {
    return this.m_viewPortRect;
  }

  getFBOWidth() {
    return this.m_viewPortRect.width < RendererDevice_1.default.MAX_RENDERBUFFER_SIZE ? this.m_viewPortRect.width : RendererDevice_1.default.MAX_RENDERBUFFER_SIZE;
  }

  getFBOHeight() {
    return this.m_viewPortRect.height < RendererDevice_1.default.MAX_RENDERBUFFER_SIZE ? this.m_viewPortRect.height : RendererDevice_1.default.MAX_RENDERBUFFER_SIZE;
  }

  getRCanvasWidth() {
    return this.m_rcanvasWidth;
  }

  getRCanvasHeight() {
    return this.m_rcanvasHeight;
  }

  updateRenderBufferSize() {
    let rect = this.m_div.getBoundingClientRect();
    console.log("updateRenderBufferSize() rect.width, rect.height: ", rect.width, rect.height);
    this.m_canvas.style.width = Math.floor(rect.width) + 'px';
    this.m_canvas.style.height = Math.floor(rect.height) + 'px';
    rect = this.m_div.getBoundingClientRect();
    this.resizeBufferSize(rect.width, rect.height);
  }

}

exports.default = RAdapterContext;

/***/ }),

/***/ "0929":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 只是用transform 和一个 ROTransform 一一对应, 只是记录transform的最终形态

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Matrix4Pool_1 = __importDefault(__webpack_require__("2139"));

class ROTransform {
  constructor(fs32 = null) {
    this.m_uid = 0;
    this.m_fs32 = null; // It is a flag that need inverted mat yes or no

    this.m_invMatEnabled = false;
    this.m_rotFlag = false;
    this.m_dt = 0;
    this.version = -1;
    this.updatedStatus = ROTransform.UPDATE_POSITION;
    this.updateStatus = ROTransform.UPDATE_TRANSFORM; // local to world spcae matrix

    this.m_omat = null;
    this.m_localMat = null;
    this.m_parentMat = null;
    this.m_toParentMat = null;
    this.m_toParentMatFlag = true; // word to local matrix

    this.m_invOmat = null;
    this.m_uid = ROTransform.s_uid++;
    this.m_dt = fs32 != null ? 1 : 0;
    this.m_fs32 = fs32 != null ? fs32 : new Float32Array(16);
  }

  getUid() {
    return this.m_uid;
  }

  getFS32Data() {
    return this.m_fs32;
  }
  /**
   * 防止因为共享 fs32 数据带来的逻辑错误
   */


  rebuildFS32Data() {
    if (this.m_dt > 0) {
      this.m_dt = 0;
      this.m_fs32 = new Float32Array(16);
    }
  }

  getRotationFlag() {
    return this.m_rotFlag;
  }

  getX() {
    return this.m_fs32[12];
  }

  getY() {
    return this.m_fs32[13];
  }

  getZ() {
    return this.m_fs32[14];
  }

  setX(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.m_fs32[12] = p;
  }

  setY(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.m_fs32[13] = p;
  }

  setZ(p) {
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
    this.m_fs32[14] = p;
  }

  setXYZ(px, py, pz) {
    this.m_fs32[12] = px;
    this.m_fs32[13] = py;
    this.m_fs32[14] = pz;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
  }

  offsetPosition(pv) {
    this.m_fs32[12] += pv.x;
    this.m_fs32[13] += pv.y;
    this.m_fs32[14] += pv.z;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
  }

  setPosition(pv) {
    this.m_fs32[12] = pv.x;
    this.m_fs32[13] = pv.y;
    this.m_fs32[14] = pv.z;
    this.updateStatus |= 1;
    this.updatedStatus |= 1;
  }

  getPosition(pv) {
    pv.x = this.m_fs32[12];
    pv.y = this.m_fs32[13];
    pv.z = this.m_fs32[14];
  }

  copyPositionFrom(t) {
    if (t != null) {
      this.m_fs32[12] = t.m_fs32[12];
      this.m_fs32[13] = t.m_fs32[13];
      this.m_fs32[14] = t.m_fs32[14];
      this.updateStatus |= ROTransform.UPDATE_POSITION;
      this.updatedStatus |= ROTransform.UPDATE_POSITION;
    }
  }

  getRotationX() {
    return this.m_fs32[1];
  }

  getRotationY() {
    return this.m_fs32[6];
  }

  getRotationZ() {
    return this.m_fs32[9];
  }

  setRotationX(degrees) {
    this.m_fs32[1] = degrees;
    this.m_rotFlag = true;
    this.updateStatus |= ROTransform.UPDATE_ROTATION;
    this.updatedStatus |= ROTransform.UPDATE_ROTATION;
  }

  setRotationY(degrees) {
    this.m_fs32[6] = degrees;
    this.m_rotFlag = true;
    this.updateStatus |= ROTransform.UPDATE_ROTATION;
    this.updatedStatus |= ROTransform.UPDATE_ROTATION;
  }

  setRotationZ(degrees) {
    this.m_fs32[9] = degrees;
    this.m_rotFlag = true;
    this.updateStatus |= ROTransform.UPDATE_ROTATION;
    this.updatedStatus |= ROTransform.UPDATE_ROTATION;
  }

  setRotationXYZ(rx, ry, rz) {
    this.m_fs32[1] = rx;
    this.m_fs32[6] = ry;
    this.m_fs32[9] = rz;
    this.updateStatus |= ROTransform.UPDATE_ROTATION;
    this.updatedStatus |= ROTransform.UPDATE_ROTATION;
    this.m_rotFlag = true;
  }

  getScaleX() {
    return this.m_fs32[0];
  }

  getScaleY() {
    return this.m_fs32[5];
  }

  getScaleZ() {
    return this.m_fs32[10];
  }

  setScaleX(p) {
    this.m_fs32[0] = p;
    this.updateStatus |= ROTransform.UPDATE_SCALE;
    this.updatedStatus |= ROTransform.UPDATE_SCALE;
  }

  setScaleY(p) {
    this.m_fs32[5] = p;
    this.updateStatus |= ROTransform.UPDATE_SCALE;
    this.updatedStatus |= ROTransform.UPDATE_SCALE;
  }

  setScaleZ(p) {
    this.m_fs32[10] = p;
    this.updateStatus |= ROTransform.UPDATE_SCALE;
    this.updatedStatus |= ROTransform.UPDATE_SCALE;
  }

  setScaleXYZ(sx, sy, sz) {
    this.m_fs32[0] = sx;
    this.m_fs32[5] = sy;
    this.m_fs32[10] = sz;
    this.updateStatus |= ROTransform.UPDATE_SCALE;
    this.updatedStatus |= ROTransform.UPDATE_SCALE;
  }

  setScale(s) {
    this.m_fs32[0] = s;
    this.m_fs32[5] = s;
    this.m_fs32[10] = s;
    this.updateStatus |= ROTransform.UPDATE_SCALE;
    this.updatedStatus |= ROTransform.UPDATE_SCALE;
  }

  getRotationXYZ(pv) {
    pv.x = this.m_fs32[1];
    pv.y = this.m_fs32[6];
    pv.z = this.m_fs32[9];
  }

  getScaleXYZ(pv) {
    pv.x = this.m_fs32[0];
    pv.y = this.m_fs32[5];
    pv.z = this.m_fs32[10];
  }

  localToGlobal(pv) {
    this.getMatrix().transformVectorSelf(pv);
  }

  globalToLocal(pv) {
    this.getInvMatrix().transformVectorSelf(pv);
  } // maybe need call update function


  getInvMatrix() {
    if (this.m_invOmat != null) {
      if (this.m_invMatEnabled) {
        this.m_invOmat.copyFrom(this.m_omat);
        this.m_invOmat.invert();
      }
    } else {
      this.m_invOmat = Matrix4Pool_1.default.GetMatrix();
      this.m_invOmat.copyFrom(this.m_omat);
      this.m_invOmat.invert();
    }

    this.m_invMatEnabled = false;
    return this.m_invOmat;
  }

  getLocalMatrix() {
    if (this.updateStatus > 0) {
      this.update();
    }

    return this.m_localMat;
  } // get local to world matrix, maybe need call update function


  getMatrix(flag = true) {
    if (this.updateStatus > 0 && flag) {
      this.update();
    }

    return this.m_omat;
  } // get local to parent space matrix, maybe need call update function


  getToParentMatrix() {
    if (this.m_toParentMat != null) {
      //  if(this.m_toParentMatFlag)
      //  {
      //      console.log("....");
      //      this.m_toParentMat.invert();
      //  }
      return this.m_toParentMat;
    }

    return this.m_omat;
  } // local to world matrix, 使用的时候注意数据安全->防止多个显示对象拥有而出现多次修改的问题,因此此函数尽量不要用


  setParentMatrix(matrix) {
    //  console.log("sTOTransform::etParentMatrix(), this.m_parentMat != matrix: ",(this.m_parentMat != matrix),this.m_uid);
    this.m_parentMat = matrix;
    this.m_invMatEnabled = true;

    if (this.m_parentMat != null) {
      if (this.m_localMat == this.m_omat) {
        this.updateStatus = ROTransform.UPDATE_TRANSFORM;
        this.updatedStatus = this.updateStatus;
        this.m_localMat = Matrix4Pool_1.default.GetMatrix();
      } else {
        this.updateStatus |= ROTransform.UPDATE_PARENT_MAT;
        this.updatedStatus = this.updateStatus;
      }
    }
  }

  getParentMatrix() {
    return this.m_parentMat;
  }

  updateMatrixData(matrix) {
    if (matrix != null) {
      this.updateStatus = ROTransform.UPDATE_NONE;
      this.m_invMatEnabled = true;
      this.m_omat.copyFrom(matrix);
    }
  }

  __$setMatrix(matrix) {
    if (matrix != null) {
      this.updateStatus = ROTransform.UPDATE_NONE;
      this.m_invMatEnabled = true;

      if (this.m_localMat == this.m_omat) {
        this.m_localMat = matrix;
      }

      if (this.m_omat != null) {
        // ROTransPool.RemoveTransUniform(this.m_omat);
        Matrix4Pool_1.default.RetrieveMatrix(this.m_omat);
      }

      this.m_omat = matrix;
    }
  }

  destroy() {
    // 当自身被完全移出RenderWorld之后才能执行自身的destroy
    if (this.m_invOmat != null) Matrix4Pool_1.default.RetrieveMatrix(this.m_invOmat);

    if (this.m_localMat != null) {
      // if (this.m_omat == this.m_localMat) {
      //     ROTransPool.RemoveTransUniform(this.m_omat);
      // }
      Matrix4Pool_1.default.RetrieveMatrix(this.m_localMat);
    }

    if (this.m_omat != null && this.m_omat != this.m_localMat) {
      // ROTransPool.RemoveTransUniform(this.m_omat);
      Matrix4Pool_1.default.RetrieveMatrix(this.m_omat);
    }

    this.m_invOmat = null;
    this.m_localMat = null;
    this.m_omat = null;
    this.m_parentMat = null;
    this.updateStatus = ROTransform.UPDATE_TRANSFORM;
    this.m_fs32 = null;
  }

  copyFrom(src) {
    this.m_fs32.set(src.m_fs32, 0);
    this.updatedStatus |= 1;
    this.updateStatus |= ROTransform.UPDATE_TRANSFORM;
    this.m_rotFlag = src.m_rotFlag;
  }

  forceUpdate() {
    this.updateStatus |= ROTransform.UPDATE_TRANSFORM;
    this.update();
  }

  update() {
    if (this.updateStatus > 0) {
      this.m_invMatEnabled = true;
      this.updateStatus = this.updateStatus | this.updatedStatus;

      if ((this.updateStatus & ROTransform.UPDATE_TRANSFORM) > 0) {
        this.m_localMat.getLocalFS32().set(this.m_fs32, 0);

        if (this.m_rotFlag) {
          this.m_localMat.setRotationEulerAngle(this.m_fs32[1] * MathConst_1.default.MATH_PI_OVER_180, this.m_fs32[6] * MathConst_1.default.MATH_PI_OVER_180, this.m_fs32[9] * MathConst_1.default.MATH_PI_OVER_180);
        }

        if (this.m_parentMat != null) {
          this.updateStatus = this.updateStatus | ROTransform.UPDATE_PARENT_MAT;
        }
      }

      if (this.m_omat != this.m_localMat) {
        this.m_omat.copyFrom(this.m_localMat);
      }

      if ((this.updateStatus & ROTransform.UPDATE_PARENT_MAT) == ROTransform.UPDATE_PARENT_MAT) {
        if (this.m_toParentMat != null) {
          this.m_toParentMat.copyFrom(this.m_omat);
        } else {
          this.m_toParentMat = Matrix4Pool_1.default.GetMatrix();
          this.m_toParentMat.copyFrom(this.m_omat);
        }

        this.m_toParentMatFlag = true;
        this.m_omat.append(this.m_parentMat);
      }

      this.updateStatus = ROTransform.UPDATE_NONE;
      this.version++;
    }
  }

  getMatrixFS32() {
    return this.getMatrix().getLocalFS32();
  }

  toString() {
    return "[ROTransform(uid = " + this.m_uid + ")]";
  }

  static GetFreeId() {
    if (ROTransform.m_freeIdList.length > 0) {
      return ROTransform.m_freeIdList.pop();
    }

    return -1;
  }

  static Create(matrix = null, fs32 = null) {
    let unit = null;
    let index = fs32 != null ? -1 : ROTransform.GetFreeId();

    if (index >= 0) {
      unit = ROTransform.m_unitList[index];
      ROTransform.m_unitFlagList[index] = ROTransform.s_FLAG_BUSY;
      unit.rebuildFS32Data();
    } else {
      unit = new ROTransform(fs32);
      ROTransform.m_unitList.push(unit);
      ROTransform.m_unitFlagList.push(ROTransform.s_FLAG_BUSY);
      ROTransform.m_unitListLen++;
    }

    if (matrix == null) {
      unit.m_omat = Matrix4Pool_1.default.GetMatrix();
    } else {
      unit.m_omat = matrix;
    }

    unit.m_localMat = unit.m_omat;

    if (fs32 == null) {
      unit.m_fs32.set(ROTransform.s_initData, 0);
    }

    return unit;
  }

  static Restore(pt) {
    if (pt != null && ROTransform.m_unitFlagList[pt.getUid()] == ROTransform.s_FLAG_BUSY) {
      let uid = pt.getUid();
      ROTransform.m_freeIdList.push(uid);
      ROTransform.m_unitFlagList[uid] = ROTransform.s_FLAG_FREE;
      pt.destroy();
    }
  }

}

ROTransform.s_uid = 0;
ROTransform.s_initData = new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);
ROTransform.UPDATE_NONE = 0;
ROTransform.UPDATE_POSITION = 1;
ROTransform.UPDATE_ROTATION = 2;
ROTransform.UPDATE_SCALE = 4;
ROTransform.UPDATE_TRANSFORM = 7;
ROTransform.UPDATE_PARENT_MAT = 8;
ROTransform.s_FLAG_BUSY = 1;
ROTransform.s_FLAG_FREE = 0;
ROTransform.m_unitFlagList = [];
ROTransform.m_unitListLen = 0;
ROTransform.m_unitList = [];
ROTransform.m_freeIdList = [];
exports.default = ROTransform;

/***/ }),

/***/ "0c85":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

class ContextMouseEvtDispatcher {
  constructor() {
    this.m_singleDown = false;
    this.m_mouseX = 0;
    this.m_mouseY = 0;
    this.m_mouseClickTime = 0;
    this.dpr = 1.0;
  }

  initMobile(canvas, div, stage) {
    var pdocument = null;

    try {
      if (document != undefined) {
        pdocument = document;
      }
    } catch (err) {
      console.log("ContextMouseEvtDispatcher::initMobile(), document is undefined.");
    }

    if (pdocument != null) {
      let selfT = this;
      div.addEventListener('touchstart', evt => {
        /*
        e.touches：当前位于屏幕上的所有手指的列表
        e.targetTouches：位于当前DOM元素上手指的列表
        e.changedTouches：涉及当前事件手指的列表
        */
        //获取手指的位置
        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (list.length < 2) {
          px = 0 | this.dpr * evt.targetTouches[0].pageX;
          py = 0 | this.dpr * evt.targetTouches[0].pageY;
          stage.mouseX = px;
          stage.mouseY = stage.stageHeight - py;
          stage.mouseViewX = px;
          stage.mouseViewY = py;
          this.m_singleDown = true;
          this.m_mouseX = stage.mouseX;
          this.m_mouseY = stage.mouseY;
          this.m_mouseClickTime = Date.now();
          stage.mouseDown(1);
        } else {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiDown(posArray);
          this.m_singleDown = false;
        }

        evt.preventDefault();
        evt.stopPropagation();
      }, false);
      div.addEventListener('touchend', evt => {
        //获取手指的位置
        this.m_singleDown = false;
        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (list.length < 1) {
          stage.mouseUp(1);
          this.m_mouseClickTime = Date.now() - this.m_mouseClickTime;

          if (Math.abs(this.m_mouseX - stage.mouseX) < 3 && Math.abs(this.m_mouseY - stage.mouseY) < 3 && this.m_mouseClickTime < 900) {
            this.m_mouseX = stage.mouseX;
            this.m_mouseY = stage.mouseY;
            stage.mouseClick();
          }
        } else {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiUp(posArray);
        }

        evt.preventDefault();
      }, false);
      div.addEventListener('touchcancel', e => {
        //获取手指的位置
        selfT.m_singleDown = false;
        let list = e.targetTouches;
        stage.mouseCancel();
        e.preventDefault();
      }, false);
      div.addEventListener('touchmove', evt => {
        evt.preventDefault(); //阻止屏幕滚动的默认行为

        let list = evt.targetTouches;
        let px = 0;
        let py = 0;

        if (this.m_singleDown) {
          px = 0 | this.dpr * list[0].pageX;
          py = 0 | this.dpr * list[0].pageY;
          stage.mouseViewX = px;
          stage.mouseViewY = py;
          stage.mouseX = px;
          stage.mouseY = stage.stageHeight - py;
          stage.mouseMove();
        }

        if (list.length > 1) {
          let posArray = [];

          for (let i = 0; i < list.length; ++i) {
            px = 0 | this.dpr * evt.targetTouches[i].pageX;
            py = 0 | this.dpr * evt.targetTouches[i].pageY;
            posArray.push({
              x: px,
              y: py
            });
          }

          stage.mouseMultiMove(posArray);
        } //DivLog.ShowLog("touchmove "+list.length+", px,py: "+(px|0)+","+(0|py));

      }, {
        passive: false
      }, false);

      if (RendererDevice_1.default.IsIpadOS()) {
        let meta = document.createElement('meta');
        meta.name = "viewport";
        meta.content = "width=device-width,initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no";
        document.getElementsByTagName('head')[0].appendChild(meta);
      }
    }
  }

  initialize(canvas, div, stage) {
    if (RendererDevice_1.default.IsMobileWeb() || RendererDevice_1.default.IsIpadOS()) {
      this.initMobile(canvas, div, stage);
    } else {
      this.initPC(canvas, div, stage);
      this.initMobile(canvas, div, stage);
    }
  }

  initPC(canvas, div, stage) {
    var pdocument = null;

    try {
      if (document != undefined) {
        pdocument = document;
      }
    } catch (err) {
      console.log("ContextMouseEvtDispatcher::initPC(), document is undefined.");
    }

    if (pdocument != null) {
      if (canvas.onmousewheel == undefined && canvas.addEventListener != undefined) {
        //use firefox browser mousewheel evt
        let func = function (evt) {
          evt.wheelDeltaY = -evt.detail;
          stage.mouseWheel(evt);
        };

        canvas.addEventListener('DOMMouseScroll', func, false);
      }

      canvas.onmousewheel = evt => {
        evt.preventDefault();
        evt.stopPropagation();
        stage.mouseWheel(evt);
      };

      canvas.onmousedown = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        this.m_mouseX = stage.mouseX;
        this.m_mouseY = stage.mouseY;
        this.m_mouseClickTime = Date.now(); // console.log("ContextMouseEvtDispatcher::onmousedown(),evt.button: ", evt.button);

        if (evt.button == 0) {
          stage.mouseDown(1);
        } else if (evt.button == 1) {
          stage.mouseMiddleDown();
        } else if (evt.button == 2) {
          stage.mouseRightDown(1);
        }
      };

      canvas.onmouseup = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py; // console.log("ContextMouseEvtDispatcher::onmouseup(),evt.button: ", evt.button);

        if (evt.button == 0) {
          stage.mouseUp(1);
        } else if (evt.button == 1) {
          stage.mouseMiddleUp();
        } else if (evt.button == 2) {
          stage.mouseRightUp(1);
        }
      };

      document.onmouseup = evt => {
        if (evt.button == 0) {
          stage.mouseWindowUp(1);
        } else if (evt.button == 1) {// stage.mouseMiddleUp();
        } else if (evt.button == 2) {
          stage.mouseWindowRightUp(1);
        }
      };

      canvas.onmousemove = evt => {
        // console.log("ContextMouseEvtDispatcher::onmouseMove"+evt.pageX+","+evt.pageY);
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        stage.mouseMove();
      };

      canvas.onclick = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py;
        this.m_mouseClickTime = Date.now() - this.m_mouseClickTime;

        if (Math.abs(this.m_mouseX - stage.mouseX) < 3 && Math.abs(this.m_mouseY - stage.mouseY) < 3 && this.m_mouseClickTime < 900) {
          this.m_mouseX = stage.mouseX;
          this.m_mouseY = stage.mouseY; //console.log("ContextMouseEvtDispatcher::onclick()," + stage.mouseViewX + "," + stage.mouseViewY + ",evt.button: " + evt.button);

          if (evt.button == 0) {
            stage.mouseClick();
          } else if (evt.button == 2) {
            stage.mouseRightClick();
          }
        }
      };

      canvas.ondblclick = evt => {
        let rect = div.getBoundingClientRect();
        let px = 0 | this.dpr * (evt.clientX - rect.left);
        let py = 0 | this.dpr * (evt.clientY - rect.top);
        stage.mouseX = px;
        stage.mouseY = stage.stageHeight - py;
        stage.mouseViewX = px;
        stage.mouseViewY = py; // console.log("ContextMouseEvtDispatcher::ondoubleclick()," + stage.mouseViewX + "," + stage.mouseViewY + ",evt.button: " + evt.button);

        if (evt.button == 0) {
          stage.mouseDoubleClick();
        } else if (evt.button == 2) {//stage.mouseRightDoubleClick();
        }
      };
    }
  }

}

exports.default = ContextMouseEvtDispatcher;

/***/ }),

/***/ "0e01":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const FrameBufferType_1 = __importDefault(__webpack_require__("baae"));

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const RenderMaterialProxy_1 = __importDefault(__webpack_require__("7499"));

const RenderProxy_1 = __webpack_require__("de9d");

class RendererInstanceContextParam {
  constructor() {
    this.camera = null;
    this.stage = null;
    this.builder = null;
    this.vtxBuilder = null;
    this.uniformContext = null;
    this.shaderProgramBuilder = null;
  }

}

exports.RendererInstanceContextParam = RendererInstanceContextParam;
/**
 * 渲染器实例上下文
 */

class RendererInstanceContext {
  constructor(rcuid) {
    this.m_adapter = null;
    this.m_renderProxy = null;
    this.m_materialProxy = null;
    this.m_cameraNear = 0.1;
    this.m_cameraFar = 5000.0;
    this.m_cameraFov = 45.0;
    this.m_rcuid = 0;
    this.m_rcuid = rcuid;
    this.m_renderProxy = new RenderProxy_1.RenderProxy(rcuid);
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  getDiv() {
    return this.m_adapter.getDiv();
  }

  getCanvas() {
    return this.m_adapter.getCanvas();
  }

  getRenderAdapter() {
    return this.m_adapter;
  }

  getRenderMaterialProxy() {
    return this.m_materialProxy;
  }

  getRenderProxy() {
    return this.m_renderProxy;
  }

  getTextureResTotal() {
    return this.m_renderProxy.Texture.getTextureResTotal();
  }

  getTextureAttachTotal() {
    return this.m_renderProxy.Texture.getAttachTotal();
  }

  getDevicePixelRatio() {
    return this.m_adapter.getDevicePixelRatio();
  }

  getStage3D() {
    return this.m_renderProxy.getStage3D();
  }

  getCamera() {
    if (this.m_renderProxy != null) {
      return this.m_renderProxy.getCamera();
    }

    return null;
  }

  cameraLock() {
    this.m_renderProxy.cameraLock();
  }

  cameraUnlock() {
    this.m_renderProxy.cameraUnlock();
  }

  updateCamera() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCamera();
    }
  }

  updateCameraDataFromCamera(cam) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCameraDataFromCamera(cam);
    }
  }

  lockRenderColorMask() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.lockRenderColorMask();
    }
  }

  unlockRendererColorMask() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderState();
    }
  }

  useGlobalRenderColorMask(colorMask) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderColorMask();
      this.m_renderProxy.useRenderColorMask(colorMask);
      this.m_renderProxy.lockRenderColorMask();
    }
  }

  useGlobalRenderColorMaskByName(colorMaskNS) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderColorMask();
      this.m_renderProxy.useRenderColorMask(RendererState_1.default.GetRenderColorMaskByName(colorMaskNS));
      this.m_renderProxy.lockRenderColorMask();
    }
  }

  getRenderColorMaskByName(scolorMaskNS) {
    return RendererState_1.default.GetRenderColorMaskByName(scolorMaskNS);
  }

  lockRenderState() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.lockRenderState();
    }
  }

  unlockRenderState() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderState();
    }
  }

  useGlobalRenderState(state) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderState();
      this.m_renderProxy.useRenderState(state);
      this.m_renderProxy.lockRenderState();
    }
  }

  useGlobalRenderStateByName(stateNS) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.unlockRenderState();
      this.m_renderProxy.useRenderState(RendererState_1.default.GetRenderStateByName(stateNS));
      this.m_renderProxy.lockRenderState();
    }
  }

  getRenderStateByName(stateNS) {
    return RendererState_1.default.GetRenderStateByName(stateNS);
  }

  lockMaterial() {
    if (this.m_materialProxy != null) {
      this.m_materialProxy.lockMaterial();
    }
  }

  unlockMaterial() {
    if (this.m_materialProxy != null) {
      this.m_materialProxy.unlockMaterial();
    }
  }

  isUnlockMaterial() {
    return this.m_materialProxy.isUnlockMatrial();
  }

  useGlobalMaterial(material, texUnlock = false, materialUniformUpdate = false) {
    if (this.m_materialProxy != null) {
      this.m_materialProxy.unlockMaterial();

      if (texUnlock) {
        this.m_materialProxy.unlockTexture();
      } else {
        this.m_materialProxy.lockTexture();
      }

      this.m_materialProxy.useGlobalMaterial(material, materialUniformUpdate);
      this.m_materialProxy.lockMaterial();
    }
  }

  updateMaterialUniform(material) {
    this.m_materialProxy.updateMaterialUniform(material);
  }

  clearBackBuffer() {
    this.m_renderProxy.clearBackBuffer();
  }

  setScissorRect(px, py, pw, ph) {
    this.m_adapter.setScissorRect(px, py, pw, ph);
  }

  setScissorEnabled(enabled) {
    this.m_adapter.setScissorEnabled(enabled);
  }

  setViewPort(px, py, pw, ph) {
    this.m_renderProxy.setViewPort(px, py, pw, ph);
  }

  synFBOSizeWithViewport() {
    this.m_adapter.synFBOSizeWithViewport();
  }

  asynFBOSizeWithViewport() {
    this.m_adapter.asynFBOSizeWithViewport();
  } // if synFBOSizeWithViewport is true, fbo size = factor * view port size;


  setFBOSizeFactorWithViewPort(factor) {
    this.m_adapter.setFBOSizeFactorWithViewPort(factor);
  }

  createFBOAt(index, fboType, pw, ph, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    this.m_adapter.createFBOAt(index, fboType, pw, ph, enableDepth, enableStencil, multisampleLevel);
  }

  bindFBOAt(index, fboType) {
    this.m_adapter.bindFBOAt(index, fboType);
  }
  /**
   * bind a texture to fbo attachment by attachment index
   * @param texProxy  RTTTextureProxy instance
   * @param enableDepth  enable depth buffer yes or no
   * @param enableStencil  enable stencil buffer yes or no
   * @param attachmentIndex  fbo attachment index
   */


  setRenderToTexture(texProxy, enableDepth = false, enableStencil = false, attachmentIndex = 0) {
    this.m_adapter.setRenderToTexture(texProxy, enableDepth, enableStencil, attachmentIndex);
  }

  useFBO(clearColorBoo = false, clearDepthBoo = false, clearStencilBoo = false) {
    this.m_adapter.useFBO(clearColorBoo, clearDepthBoo, clearStencilBoo);
  }

  resetFBOAttachmentMask(boo) {
    this.m_adapter.resetFBOAttachmentMask(boo);
  }

  setFBOAttachmentMaskAt(index, boo) {
    this.m_adapter.setFBOAttachmentMaskAt(index, boo);
  }

  setRenderToBackBuffer() {
    if (this.m_adapter != null) {
      this.m_adapter.setRenderToBackBuffer(FrameBufferType_1.default.FRAMEBUFFER);
      this.m_materialProxy.renderBegin();
    }
  }

  lockViewport() {
    this.m_adapter.lockViewport();
  }

  unlockViewport() {
    this.m_adapter.unlockViewport();
  }

  setClearDepth(depth) {
    this.m_adapter.setClearDepth(depth);
  }

  getClearDepth() {
    return this.m_adapter.getClearDepth();
  }

  getViewportX() {
    return this.m_adapter.getViewportX();
  }

  getViewportY() {
    return this.m_adapter.getViewportY();
  }

  getViewportWidth() {
    return this.m_adapter.getViewportWidth();
  }

  getViewportHeight() {
    return this.m_adapter.getViewportHeight();
  }
  /**
   * 设置用于3D绘制的canvas的宽高尺寸,如果调用了此函数，则不会自动匹配窗口尺寸改变，默认是自动匹配窗口尺寸改变的
   * @param       pw 像素宽度
   * @param       ph 像素高度
  */


  setContextViewSize(pw, ph) {
    this.m_adapter.setContextViewSize(pw, ph);
  }

  setCameraParam(fov, near, far) {
    this.m_cameraFov = fov;
    this.m_cameraNear = near;
    this.m_cameraFar = far;

    if (this.m_renderProxy != null) {
      this.m_renderProxy.setCameraParam(fov, near, far);
    }
  }

  initialize(param, camera, contextParam) {
    if (this.m_adapter == null) {
      this.m_renderProxy.setCameraParam(this.m_cameraFov, this.m_cameraNear, this.m_cameraFar);
      this.m_renderProxy.setWebGLMaxVersion(param.maxWebGLVersion);
      let proxyParam = new RenderProxy_1.RenderProxyParam();
      proxyParam.uniformContext = contextParam.uniformContext;
      proxyParam.vtxBufUpdater = contextParam.builder;
      proxyParam.materialUpdater = contextParam.builder;
      proxyParam.vtxBuilder = contextParam.vtxBuilder;
      this.m_renderProxy.initialize(param, camera, contextParam.stage, proxyParam);
      this.m_rcuid = this.m_renderProxy.getRCUid();
      contextParam.vtxBuilder.initialize(this.m_rcuid, this.m_renderProxy.getRC(), this.m_renderProxy.getGLVersion());
      this.m_adapter = this.m_renderProxy.getRenderAdapter();
      let context = this.m_renderProxy.getContext();
      context.setViewport(0, 0, context.getRCanvasWidth(), context.getRCanvasHeight());
    }
  }

  initManager(builder) {
    if (this.m_materialProxy == null) {
      this.m_materialProxy = new RenderMaterialProxy_1.default();
      this.m_materialProxy.setDispBuilder(builder);
    }
  }

  setClearRGBColor3f(pr, pg, pb) {
    this.m_renderProxy.setClearRGBColor3f(pr, pg, pb);
  }

  setClearRGBAColor4f(pr, pg, pb, pa) {
    this.m_renderProxy.setClearRGBAColor4f(pr, pg, pb, pa);
  }

  getClearRGBAColor4f(color4) {
    color4.fromArray(this.m_adapter.bgColor);
  }

  updateRenderBufferSize() {
    this.m_adapter.updateRenderBufferSize();
  }

  vertexRenderBegin() {
    this.m_renderProxy.Vertex.renderBegin();
  }
  /**
   * the function resets the renderer instance rendering status.
   * you should use it on the frame starting time.
   */


  renderBegin(cameraDataUpdate = true) {
    if (this.m_adapter != null) {
      this.m_adapter.unlockViewport(); //this.m_adapter.resetPolygonOffset();

      this.m_adapter.setClearDepth(1.0);
      this.m_renderProxy.Vertex.renderBegin();
      this.m_materialProxy.renderBegin();
      this.m_adapter.update();
      this.m_adapter.setClearMaskClearAll();
      this.m_adapter.renderBegin();
      this.m_renderProxy.status.reset();
      RendererState_1.default.Reset(this.m_renderProxy.getRenderContext());

      if (cameraDataUpdate) {
        this.m_renderProxy.useCameraData();
        this.m_renderProxy.updateCameraDataFromCamera(this.m_renderProxy.getCamera());
      }
    }
  }

  resetState() {
    RendererState_1.default.ResetState();
    this.m_materialProxy.renderBegin();
  }

  resetmaterial() {
    this.m_materialProxy.renderBegin();
  }

  resetUniform() {
    this.m_materialProxy.resetUniform();
  }

  runEnd() {}

}

exports.RendererInstanceContext = RendererInstanceContext;
exports.default = RendererInstanceContext;

/***/ }),

/***/ "0fc4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MaterialResource_1 = __importDefault(__webpack_require__("9666"));

const ShaderCodeBuffer_1 = __importDefault(__webpack_require__("faa5"));

class MaterialBase {
  constructor() {
    this.m_shduns = "";
    this.m_shdData = null;
    this.m_polygonOffset = null;
    this.m_sharedUniforms = null;
    this.m_shaderUniformData = null;
    this.m_pipeLine = null;
    this.m_uniqueShaderName = ""; // tex list unique hash value

    this.__$troMid = -1;
    this.__$uniform = null;
    /**
     * pipes type list for material pipeline
     */

    this.pipeTypes = null;
    this.m_texList = null;
    this.m_texListLen = 0;
    this.m_texDataEnabled = false;
    this.m_attachCount = 0;
  }
  /*
   * specifies the scale factors and units to calculate depth values.
   * @param factor the value is a GLfloat which sets the scale factor for the variable depth offset for each polygon. The default value is 0.
   * @param units the value is a which sets the multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. The default value is 0.
   */


  setPolygonOffset(factor, units = 0.0) {
    if (this.m_polygonOffset == null) {
      this.m_polygonOffset = [factor, units];
    } else {
      this.m_polygonOffset[0] = factor;
      this.m_polygonOffset[1] = units;
    }
  }

  getPolygonOffset() {
    return this.m_polygonOffset;
  }
  /**
   * 设置深度偏移量
   * @param offset the value range: [-2.0 -> 2.0]
   */


  setDepthOffset(offset) {}

  setMaterialPipeline(pipeline) {
    this.m_pipeLine = pipeline;
  }

  getMaterialPipeline() {
    return this.m_pipeLine;
  }

  getShdUniqueName() {
    return this.m_shduns;
  } // get a shader code buf instance, for sub class override


  getCodeBuf() {
    throw Error("Illgel operation !!!");
    return null;
  }

  hasShaderData() {
    if (this.m_shdData != null) {
      return this.m_shdData.haveTexture() ? this.texDataEnabled() : true; // if (this.m_shdData.haveTexture()) {
      //     return this.texDataEnabled();
      // }
      // else {
      //     return true;
      // }
    }

    return false;
  }

  initializeByRenderer(texEnabled = false) {
    this.initializeByCodeBuf(texEnabled);
  }

  initializeByCodeBuf(texEnabled = false) {
    texEnabled = texEnabled || this.getTextureTotal() > 0;

    if (this.m_shdData == null) {
      let buf = this.getCodeBuf();

      if (buf != null) {
        buf.reset();
        buf.pipeline = this.m_pipeLine;
        buf.pipeTypes = this.pipeTypes;
        if (buf.pipeline != null) buf.pipeline.reset();
        this.buildBuf();
        let shdData;
        let shdCode_uniqueName = this.m_uniqueShaderName;

        if (shdCode_uniqueName != "") {
          shdData = MaterialResource_1.default.FindData(shdCode_uniqueName);
          this.m_shduns = shdCode_uniqueName;
        }

        if (shdData == null) {
          texEnabled = texEnabled || this.getTextureTotal() > 0;
          buf.initialize(texEnabled);
          shdCode_uniqueName = buf.getUniqueShaderName() + buf.keysString + buf.getShaderCodeBuilder().getUniqueNSKeyString();
          this.m_shduns = shdCode_uniqueName;

          this.__$initShd(this.m_shduns);

          shdData = MaterialResource_1.default.FindData(shdCode_uniqueName);
          this.m_uniqueShaderName = this.m_shduns;
        } else {
          texEnabled = texEnabled || this.getTextureTotal() > 0;
          buf.initialize(texEnabled);
        }

        if (shdData == null) {
          if (buf.pipeline == null) {
            if (buf.getShaderCodeObject() != null) {
              buf.getShaderCodeBuilder().addShaderObject(buf.getShaderCodeObject());
            }
          }

          buf.buildShader();
          buf.buildDefine();

          if (buf.pipeline != null) {
            if (buf.getShaderCodeObject() != null) {
              buf.pipeline.addShaderCode(buf.getShaderCodeObject(), false);
            } else {
              buf.pipeline.addShaderCodeWithUUID(buf.getShaderCodeObjectUUID(), false);
            }

            buf.pipeline.build(buf.getShaderCodeBuilder());
          }

          let fshd = buf.getFragShaderCode();
          let vshd = buf.getVertShaderCode();
          shdData = MaterialResource_1.default.CreateShdData(shdCode_uniqueName, vshd, fshd, buf.adaptationShaderVersion, ShaderCodeBuffer_1.default.GetPreCompileInfo());
        }

        if (this.m_pipeLine != null) {
          this.m_sharedUniforms = this.m_pipeLine.getSharedUniforms();
        }

        this.m_shdData = shdData;
      }
    }
  }

  buildBuf() {}

  __$initShd(pshduns) {}

  getShaderData() {
    return this.m_shdData;
  }
  /**
   * set TextuerProxy instances
   * @param texList [tex0,tex1,...]
   */


  setTextureList(texList) {
    if (this.m_texList != texList) {
      this.m_texDataEnabled = false;

      if (texList != null) {
        this.m_texListLen = texList.length;
      } else {
        this.m_texListLen = 0;
      }

      let i = 0;

      if (this.m_texList != null) {
        for (; i < this.m_texList.length; ++i) {
          this.m_texList[i].__$detachThis();
        }
      }

      this.m_texDataEnabled = true;
      this.m_texList = texList;

      if (this.m_texList != null) {
        let key = 31;

        for (i = 0; i < this.m_texList.length; ++i) {
          key = key * 131 + this.m_texList[i].getUid();

          this.m_texList[i].__$attachThis();

          if (!this.m_texList[i].isDataEnough()) {
            this.m_texDataEnabled = false;
          }
        }

        this.__$troMid = key;
      }
    }
  }

  setTextureAt(index, tex) {
    if (index >= 0 && tex != null) {
      let texList = this.m_texList;
      let len = texList.length;

      if (texList != null && texList[index] != tex && index < len && len > 0) {
        texList = texList.slice(0);

        texList[index].__$detachThis();

        texList[index] = tex;
        this.m_texDataEnabled = tex.isDataEnough();

        tex.__$attachThis();

        let key = 31;

        for (let i = 0; i < len; ++i) {
          key = key * 131 + texList[i].getUid();
        }

        this.__$troMid = key;
        this.m_texList = texList;
      }
    }
  }

  getTextureList() {
    return this.m_texList;
  }

  getTextureAt(index) {
    return this.m_texList[index];
  }

  getTextureTotal() {
    return this.m_texListLen;
  }

  getShdTexTotal() {
    if (this.m_shdData != null) {
      return this.m_shdData.getTexTotal();
    }

    return 0;
  }

  texDataEnabled() {
    if (this.m_texList != null) {
      if (this.m_texDataEnabled) {
        return true;
      }

      let boo = true;
      let texList = this.m_texList;

      for (let i = 0; i < this.m_texListLen; ++i) {
        if (!texList[i].isDataEnough()) {
          boo = false;
          break;
        }
      }

      this.m_texDataEnabled = boo;
      return boo;
    } else {
      if (this.m_shdData != null && this.m_shdData.getTexTotal() > 0) {
        console.warn("this material(" + this.m_shdData.getUniqueShaderName() + ") texList is null, need " + this.m_shdData.getTexTotal() + " textures.");
      }
    }

    return false;
  }

  createSharedUniforms() {
    return this.m_sharedUniforms;
  }

  createSharedUniformsData() {
    return null;
  }

  createSelfUniformData() {
    return this.m_shaderUniformData;
  } //synchronism ubo data or other displayEntity data


  updateSelfData(ro) {}

  hasTexture() {
    return this.m_shdData.haveTexture();
  }

  getBufSortFormat() {
    return this.m_shdData != null ? this.m_shdData.getLayoutBit() : 0x0;
  }

  getBufTypeList() {
    return this.m_shdData != null ? this.m_shdData.getLocationTypes() : null;
  }

  getBufSizeList() {
    return this.m_shdData != null ? this.m_shdData.getAttriSizeList() : null;
  }

  __$attachThis() {
    ++this.m_attachCount; // console.log("MaterialBase::__$attachThis() this.m_attachCount: "+this.m_attachCount);
  }

  __$detachThis() {
    --this.m_attachCount; // console.log("MaterialBase::__$detachThis() this.m_attachCount: "+this.m_attachCount);

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0;
    }
  }

  getAttachCount() {
    return this.m_attachCount;
  }

  destroy() {
    this.m_sharedUniforms = null;
    this.m_shaderUniformData = null;
    this.pipeTypes = null;

    if (this.getAttachCount() < 1) {
      if (this.m_texList != null) {
        for (let i = 0; i < this.m_texList.length; ++i) {
          this.m_texList[i].__$detachThis();
        }
      }

      this.m_shdData = null;
      this.m_texList = null;
      this.m_texDataEnabled = false;
      this.__$troMid = 0;

      if (this.__$uniform != null) {
        this.__$uniform.destroy();

        this.__$uniform = null;
      }
    }
  }

  toString() {
    return "[MaterialBase()]";
  }

}

exports.default = MaterialBase;

/***/ }),

/***/ "1173":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * (引擎)数据/资源协同空间系统模块
 */

class CoSystem {
  constructor() {}
  /**
   */


  initialize() {}

  destroy() {}

}

exports.CoSystem = CoSystem;

/***/ }),

/***/ "11e6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RSEntityFlag {
  static AddContainerFlag(flag) {
    //return flag | RSEntityFlag.CONTAINER_FLAG;
    return flag | 0x80000000;
  }

  static RemoveContainerFlag(flag) {
    //return flag & RSEntityFlag.CONTAINER_NOT_FLAG;
    return flag & -0x80000001;
  }

  static AddSpaceUid(flag, rawUid) {
    return flag & -0x100000 | rawUid;
  }

  static RemoveSpaceUid(flag) {
    //return flag & RSEntityFlag.SPACE_NOT_FLAG;
    return flag & -0x100000;
  }

  static GetSpaceUid(flag) {
    //return flag & RSEntityFlag.SPACE_FLAG;
    return flag & 0xFFFFF;
  }

  static AddRendererUid(flag, rawUid) {
    return flag & -0x7f00001 | rawUid << 20;
  }

  static RemoveRendererUid(flag) {
    //return flag | RSEntityFlag.RENDERER_UID_FLAG;
    return flag | 0x7F00000;
  }

  static GetRendererUid(flag) {
    //return (flag & RSEntityFlag.RENDERER_UID_FLAG)>>20;
    flag = (flag & 0x7F00000) >> 20;
    return flag < 127 ? flag : -1;
  }

  static TestRendererUid(flag) {
    //return (flag & RSEntityFlag.RENDERER_UID_FLAG)>>20;
    flag = (flag & 0x7F00000) >> 20;
    return flag < 127;
  }

  static AddSortEnabled(flag) {
    //return flag | RSEntityFlag.SORT_FLAG;
    return flag | 0x40000000;
  }

  static RemoveSortEnabled(flag) {
    //return flag & RSEntityFlag.SORT_NOT_FLAG;
    return flag & -0x40000001;
  }

  static TestSortEnabled(flag) {
    //return (flag & RSEntityFlag.SORT_FLAG) == RSEntityFlag.SORT_FLAG;
    return (flag & 0x40000000) == 0x40000000;
  }

  static AddRendererLoad(flag) {
    //return flag | RSEntityFlag.RENDERER_LOAD_FLAG;
    return flag | 0x30000000;
  }

  static RemoveRendererLoad(flag) {
    //return flag & RSEntityFlag.RENDERER_LOAD_NOT_FLAG;
    return flag & -0x30000001;
  }

  static TestSpaceContains(flag) {
    return (0xFFFFF & flag) > 0;
  }

  static TestSpaceEnabled(flag) {
    return (0xFFFFF & flag) < 1;
  }

  static TestSpaceEnabled2(flag) {
    return (0xFFFFF & flag) < 1 && (0x80000000 & flag) != 0x80000000;
  }

  static TestContainerEnabled(flag) {
    //return (RSEntityFlag.RENDERER_UID_FLAG & flag) == RSEntityFlag.RENDERER_UID_FLAG && (RSEntityFlag.CONTAINER_FLAG & flag) != RSEntityFlag.CONTAINER_FLAG;
    return (0x7F00000 & flag) == 0x7F00000 && (0x80000000 & flag) != 0x80000000;
  }

  static TestRendererEnabled(flag) {
    //return (RSEntityFlag.RENDERER_ADN_LOAD_FLAG & flag) == RSEntityFlag.RENDERER_UID_FLAG && (RSEntityFlag.CONTAINER_FLAG & flag) != RSEntityFlag.CONTAINER_FLAG;
    return (0x37F00000 & flag) == 0x7F00000 && (0x80000000 & flag) != 0x80000000;
  }

}

RSEntityFlag.DEFAULT = 0x7f00000; // 第27位存放是否在container里面
// 在 container 内

RSEntityFlag.CONTAINER_FLAG = 0x80000000; // (1<<27)
// 没在 container 内

RSEntityFlag.CONTAINER_NOT_FLAG = -0x80000001; //~(0x80000000), ~(1<<27)
// 第0位到第19位总共20位存放自身在space中的 index id(1 到 1048575(0xFFFFF), 但是不会包含0xFFFFF)

RSEntityFlag.SPACE_FLAG = 0xFFFFF;
RSEntityFlag.SPACE_NOT_FLAG = -0x100000; // ~0xFFFFF;
// 第20位开始到26位为总共7位止存放在renderer中的状态数据(renderer unique id and others),
// 最多可以支持同时构建64个renderer instance

RSEntityFlag.RENDERER_UID_FLAG = 0x7F00000; // (1<<20 | 1<<21 | 1<<22 | 1<<23 | 1<<24 | 1<<25 | 1<<26);

RSEntityFlag.RENDERER_UID_NOT_FLAG = -0x7f00001; // ~0x7F00000;

RSEntityFlag.RENDERER_UID_INVALID = 127; // ~0x7F00000;
//0x40000000
// 第30位存放 是否渲染运行时排序(rendering sort enabled) 的相关信息

RSEntityFlag.SORT_FLAG = 0x40000000; // (1<<30);

RSEntityFlag.SORT_NOT_FLAG = -0x40000001; // ~0x40000000;
// 第28位开始到29位总共2位存放renderer 载入状态 的相关信息

RSEntityFlag.RENDERER_LOAD_FLAG = 0x30000000; // (1<<28 | 1<<29);

RSEntityFlag.RENDERER_LOAD_NOT_FLAG = -0x30000001; // ~0x30000000;

RSEntityFlag.RENDERER_ADN_LOAD_FLAG = 0x37F00000; // 0x7f00000 | 0x30000000;

exports.default = RSEntityFlag;

/***/ }),

/***/ "1216":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const FrameBufferType_1 = __importDefault(__webpack_require__("baae"));

const RenderFilter_1 = __importDefault(__webpack_require__("722e"));

const RenderMaskBitfield_1 = __importDefault(__webpack_require__("8333"));

const FrameBufferObject_1 = __importDefault(__webpack_require__("6d49"));

const RenderConst_1 = __webpack_require__("e08e");

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RenderColorMask_1 = __webpack_require__("070b");

const RenderStateObject_1 = __webpack_require__("a5ba");

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const AABB2D_1 = __importDefault(__webpack_require__("e2fe"));

class RenderAdapter {
  constructor(rcuid, texResource) {
    // renderer context uid
    this.m_rcuid = 0;
    this.m_texResource = null;
    this.m_gl = null;
    this.m_fontFaceFlipped = false; // default ccw

    this.m_colorMask = {
      mr: true,
      mg: true,
      mb: true,
      ma: true
    };
    this.m_rcontext = null;
    this.m_clearMask = 0x0;
    this.m_fboBuf = null;
    this.m_fboIndex = 0;
    this.m_fboType = FrameBufferType_1.default.FRAMEBUFFER;
    this.m_fboBufList = [null, null, null, null, null, null, null, null];
    this.m_fboClearBoo = true;
    this.m_fboViewportRectBoo = false;
    this.m_polygonOffsetFlag = false;
    this.m_polygonOffset = false;
    this.m_clearDepth = 1.0;
    this.m_preDepth = 0.0;
    this.m_viewPortRect = new AABB2D_1.default(0, 0, 800, 600);
    this.m_fboViewportRect = new AABB2D_1.default(0, 0, 800, 600);
    this.m_fboSizeFactor = 1.0;
    this.m_clearStencil = 0x0;
    this.m_fboBiltRectData = new Uint16Array(8);
    this.m_fboViewportRectData = new Uint16Array(4);
    this.m_activeAttachmentTotal = 1;
    this.m_scissorEnabled = false;
    this.m_rState = null;
    this.m_webglVer = 2;
    this.bgColor = new Float32Array([0, 0, 0, 1]);
    this.uViewProbe = null;
    this.m_devPRatio = 1.0;
    this.m_viewportUnlock = true;
    this.m_synFBOSizeWithViewport = false;
    this.m_texResource = texResource;
    this.m_rcuid = rcuid;
  }

  initialize(context, param, rState, uViewProbe) {
    if (this.m_rcontext == null) {
      this.m_webglVer = context.getWebGLVersion();
      this.m_rState = rState;
      this.m_rcontext = context;
      this.m_gl = context.getRC();
      this.m_gl.disable(this.m_gl.SCISSOR_TEST);
      if (context.isDepthTestEnabled()) this.m_gl.enable(this.m_gl.DEPTH_TEST);else this.m_gl.disable(this.m_gl.DEPTH_TEST);

      if (context.isStencilTestEnabled()) {
        this.m_gl.enable(this.m_gl.STENCIL_TEST);
      } else {
        console.warn("STENCIL_TEST disable !!!");
        this.m_gl.disable(this.m_gl.STENCIL_TEST);
      }

      if (param.getPolygonOffsetEanbled()) this.enabledPolygonOffset();else this.disabledPolygonOffset();
      this.m_gl.enable(this.m_gl.CULL_FACE);
      this.m_gl.cullFace(this.m_gl.BACK);
      this.m_gl.enable(this.m_gl.BLEND);
      if (param.getDitherEanbled()) this.m_gl.enable(this.m_gl.DITHER);else this.m_gl.disable(this.m_gl.DITHER);
      this.m_gl.frontFace(this.m_gl.CCW); //m_gl.hint(m_gl.PERSPECTIVE_CORRECTION_HINT, m_gl.NICEST);	// Really Nice Perspective Calculations

      this.m_clearMask = this.m_gl.COLOR_BUFFER_BIT | this.m_gl.DEPTH_BUFFER_BIT | this.m_gl.STENCIL_BUFFER_BIT; //
      //this.m_rState = context.getRenderState();
      //console.log("RenderAdapter::initialize() finish...");

      if (this.uViewProbe == null) {
        let size = this.m_viewPortRect;
        let self = this;
        self.uViewProbe = uViewProbe;
        this.uViewProbe.setVec4DataWithArr4([size.x, size.y, size.width, size.height]);
      }
    }
  }
  /**
   * @param faceFlipped the value is true, frontFace is CW. the value is false, frontFace is CCW.
   */


  setFrontFaceFlipped(faceFlipped) {
    if (this.m_fontFaceFlipped != faceFlipped) {
      if (faceFlipped) {
        this.m_gl.frontFace(this.m_gl.CW);
      } else {
        this.m_gl.frontFace(this.m_gl.CCW);
      }

      this.m_fontFaceFlipped = faceFlipped;
    }
  }

  enabledPolygonOffset() {
    if (!this.m_polygonOffset) {
      this.m_polygonOffset = true;
      console.warn("POLYGON_OFFSET_FILL enable !!!");
      this.m_gl.enable(this.m_gl.POLYGON_OFFSET_FILL);
    }
  }

  disabledPolygonOffset() {
    if (this.m_polygonOffset) {
      this.m_polygonOffset = false;
      console.warn("POLYGON_OFFSET_FILL disable !!!");
      this.m_gl.disable(this.m_gl.POLYGON_OFFSET_FILL);
    }
  }
  /*
   * specifies the scale factors and units to calculate depth values.
   * @param factor the value is a GLfloat which sets the scale factor for the variable depth offset for each polygon. The default value is 0.
   * @param units the value is a which sets the multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. The default value is 0.
   */


  setPolygonOffset(factor, units = 0.0) {
    this.m_gl.polygonOffset(factor, units);
    this.m_polygonOffsetFlag = true;
  }
  /*
   * reset the scale factors and units value is default value(0.0).
   */


  resetPolygonOffset() {
    if (this.m_polygonOffsetFlag) {
      this.m_gl.polygonOffset(0.0, 0.0);
      this.m_polygonOffsetFlag = false;
    }
  }

  getDiv() {
    return this.m_rcontext.getDiv();
  }

  getCanvas() {
    return this.m_rcontext.getCanvas();
  }

  setClearDepth(depth) {
    this.m_clearDepth = depth;
  }

  getClearDepth() {
    return this.m_clearDepth;
  }

  setContextViewSize(pw, ph) {
    this.m_rcontext.autoSyncRenderBufferAndWindowSize = false;
    this.m_rcontext.resizeBufferSize(pw, ph);
  }

  getViewportX() {
    return this.m_rcontext.getViewportX();
  }

  getViewportY() {
    return this.m_rcontext.getViewportY();
  }

  getViewportWidth() {
    return this.m_rcontext.getViewportWidth();
  }

  getViewportHeight() {
    return this.m_rcontext.getViewportHeight();
  }

  getFBOFitWidth() {
    return this.m_rcontext.getFBOWidth();
  }

  getFBOFitHeight() {
    return this.m_rcontext.getFBOHeight();
  }

  getRCanvasWidth() {
    return this.m_rcontext.getRCanvasWidth();
  }

  getRCanvasHeight() {
    return this.m_rcontext.getRCanvasHeight();
  }

  setColorMask(mr, mg, mb, ma) {
    this.m_colorMask.mr = mr;
    this.m_colorMask.mg = mg;
    this.m_colorMask.mb = mb;
    this.m_colorMask.ma = ma;
  }

  setClearMaskClearAll() {
    this.m_clearMask = this.m_gl.COLOR_BUFFER_BIT | this.m_gl.DEPTH_BUFFER_BIT | this.m_gl.STENCIL_BUFFER_BIT;
  }

  setClearMaskClearOnlyColor() {
    this.m_clearMask = this.m_gl.COLOR_BUFFER_BIT;
  }

  setClearMaskClearOnlyDepthAndStencil() {
    this.m_clearMask = this.m_gl.DEPTH_BUFFER_BIT | this.m_gl.STENCIL_BUFFER_BIT;
  }

  setScissorRect(px, py, pw, ph) {
    if (this.m_scissorEnabled) {
      this.m_gl.scissor(px, py, pw, ph);
    }
  }

  setScissorEnabled(enabled) {
    if (enabled) {
      if (!this.m_scissorEnabled) {
        this.m_scissorEnabled = true;
        this.m_gl.enable(this.m_gl.SCISSOR_TEST);
      }
    } else if (this.m_scissorEnabled) {
      this.m_scissorEnabled = false;
      this.m_gl.disable(this.m_gl.SCISSOR_TEST);
    }
  }
  /**
   * only clear up depth buffer
   * @param depth depth buffer depth value
   */


  clearDepth(depth = 1.0) {
    let mode = this.m_rState.getDepthTestMode();
    this.m_rState.setDepthTestMode(RenderConst_1.DepthTestMode.OPAQUE);
    this.m_clearDepth = depth;

    if (this.m_preDepth !== this.m_clearDepth) {
      this.m_preDepth = this.m_clearDepth;
      this.m_gl.clearDepth(this.m_clearDepth);
    }

    this.m_gl.clear(this.m_gl.DEPTH_BUFFER_BIT);
    this.m_rState.setDepthTestMode(mode);
  }
  /**
   * only clear up color buffer
   * @param color color data
   */


  clearColor(color) {
    this.m_gl.clearColor(color.r, color.g, color.b, color.a);
    this.m_gl.clear(this.m_gl.COLOR_BUFFER_BIT);
  }

  clear() {
    // console.log("clear back buffer.");
    // let mode = this.m_rState.getDepthTestMode();
    // this.m_rState.setDepthTestMode(DepthTestMode.OPAQUE);
    if (this.m_preDepth !== this.m_clearDepth) {
      this.m_preDepth = this.m_clearDepth;
      this.m_gl.clearDepth(this.m_clearDepth);
    }

    if (this.m_rcontext.isStencilTestEnabled()) {
      this.m_gl.clearStencil(this.m_clearStencil);
    }

    let cvs = this.bgColor;
    this.m_gl.clearColor(cvs[0], cvs[1], cvs[2], cvs[3]);
    this.m_gl.clear(this.m_clearMask); // this.m_rState.setDepthTestMode(mode);
    //	if (this.m_rcontext.isStencilTestEnabled()) {
    //		this.m_gl.stencilMask(0x0);
    //	}
  }

  reset() {
    this.m_rState.setCullFaceMode(RenderConst_1.CullFaceMode.BACK);
    this.m_rState.setDepthTestMode(RenderConst_1.DepthTestMode.OPAQUE);
    RendererState_1.default.Reset(this.m_rcontext);
  }

  getRenderContext() {
    return this.m_rcontext;
  }

  renderBegin() {
    if (this.m_rcontext != null) {
      this.m_fboSizeFactor = 1.0;
      this.reseizeViewPort();
      RenderStateObject_1.RenderStateObject.Unlock();
      RenderStateObject_1.RenderStateObject.UseRenderState(RendererState_1.default.NORMAL_STATE);
      RenderColorMask_1.RenderColorMask.Unlock();
      RenderColorMask_1.RenderColorMask.UseRenderState(RenderColorMask_1.RenderColorMask.ALL_TRUE_COLOR_MASK); // for back buffer
      //this.m_gl.clearDepth(1.0);

      this.clear();
    }
  }

  updateViewPort() {
    let size = this.m_viewPortRect;
    this.uViewProbe.setVec4Data(size.x, size.y, size.width, size.height);
    this.uViewProbe.update(); //DivLog.ShowLog("reseizeFBOViewPort: " + this.m_viewX + "," + this.m_viewY + "," + this.m_viewWidth + "," + this.m_viewHeight);
    //console.log("reseizeFBOViewPort: "+this.m_viewX+","+this.m_viewY+","+this.m_viewWidth+","+this.m_viewHeight);

    this.m_gl.viewport(size.x, size.y, size.width, size.height);
  }

  checkViewPort(dstSize) {
    let srcSize = this.m_viewPortRect;
    let k = this.m_rcontext.getDevicePixelRatio();
    let boo = srcSize.testEqual(dstSize);
    boo = boo || Math.abs(this.m_devPRatio - k) > 0.01;

    if (boo) {
      this.m_devPRatio = k;
      srcSize.copyFrom(dstSize);
      this.updateViewPort();
    }
  }

  reseizeViewPort() {
    if (this.m_viewportUnlock) {
      this.checkViewPort(this.m_rcontext.getViewPortSize());
    }
  }

  reseizeFBOViewPort() {
    if (this.m_viewportUnlock) {
      this.checkViewPort(this.m_fboViewportRect);
    }
  }

  setViewProbeValue(x, y, width, height) {
    this.uViewProbe.setVec4Data(x, y, width, height);
    this.uViewProbe.update();
  }

  lockViewport() {
    this.m_viewportUnlock = false;
  }

  unlockViewport() {
    this.m_viewportUnlock = true;
  }

  renderEnd() {}

  update() {}

  updateRenderBufferSize() {
    this.m_rcontext.updateRenderBufferSize();
  }

  destroy() {
    this.m_rcontext = null;
    this.m_rState = null;
  }

  getDevicePixelRatio() {
    return this.m_rcontext.getDevicePixelRatio();
  }

  loseContext() {
    this.m_rcontext.loseContext();
  }
  /**
   * @returns return gpu context lost status
   */


  isContextLost() {
    return this.m_rcontext.isContextLost();
  } // read data format include float or unsigned byte ,etc.


  readPixels(px, py, width, height, format, dataType, pixels) {
    this.m_gl.readPixels(px, py, width, height, TextureFormat_1.default.ToGL(this.m_gl, format), TextureDataType_1.default.ToGL(this.m_gl, dataType), pixels);
  }

  setFBOViewportRect(px, py, pw, ph) {
    this.m_fboViewportRectData[0] = px;
    this.m_fboViewportRectData[1] = py;
    this.m_fboViewportRectData[2] = pw;
    this.m_fboViewportRectData[3] = ph;
    this.m_fboViewportRectBoo = true;
  }

  createFBOAt(index, fboType, pw, ph, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (this.m_fboBufList[index] == null) {
      if (index > 7) {
        index = 7;
      }

      this.m_fboType = fboType;
      this.m_fboBuf = new FrameBufferObject_1.default(this.m_rcuid, this.m_texResource, this.m_fboType);
      this.m_fboBuf.multisampleEnabled = multisampleLevel > 0;
      this.m_fboBuf.multisampleLevel = multisampleLevel;
      this.m_fboBuf.writeDepthEnabled = enableDepth;
      this.m_fboBuf.writeStencilEnabled = enableStencil;
      this.m_fboBuf.initialize(this.m_gl, pw, ph);
      this.m_fboBufList[index] = this.m_fboBuf;
      this.m_fboBuf.sizeFixed = true;
    }
  }

  resizeFBOAt(index, pw, ph) {
    if (index > 7) {
      index = 7;
    } else if (index < 0) {
      index = 0;
    }

    if (this.m_fboBufList[index] != null) {
      this.m_fboBufList[index].resize(pw, ph);
    }
  }

  getFBOWidthAt(index) {
    if (this.m_fboBufList[index] != null) {
      return this.m_fboBufList[index].getWidth();
    }

    return 0;
  }

  getFBOHeightAt(index) {
    if (this.m_fboBufList[index] != null) {
      return this.m_fboBufList[index].getHeight();
    }

    return 0;
  }

  synFBOSizeWithViewport() {
    this.m_synFBOSizeWithViewport = true;
  }

  asynFBOSizeWithViewport() {
    this.m_synFBOSizeWithViewport = false;
  } // 

  /**
   * if synFBOSizeWithViewport is true, fbo size = factor * view port size;
   * @param factor exmple: the value of factor is 0.5
   */


  setFBOSizeFactorWithViewPort(factor) {
    this.m_fboSizeFactor = factor;
  }

  bindFBOAt(index, fboType) {
    if (index > 7) {
      index = 7;
    } else if (index < 0) {
      index = 0;
    }

    this.m_fboBuf = this.m_fboBufList[index];

    if (this.m_fboBuf != null) {
      this.m_fboIndex = index;
      this.m_fboType = fboType;
      this.m_fboBuf.bind(fboType);
      this.m_fboClearBoo = true;
    } else {
      throw Error("Fatal Error!!! this.m_fboBuf == null.");
    }
  }

  clearFBODepthAt(index, clearDepth = 1.0) {
    let fboBuf = this.m_fboBufList[index];

    if (fboBuf != null) {
      fboBuf.clearOnlyDepth(clearDepth);
    }
  }

  resetFBOAttachmentMask(boo) {
    if (this.m_fboBuf != null) {
      this.m_fboBuf.resetAttachmentMask(boo);
    }
  }

  setFBOAttachmentMaskAt(index, boo) {
    if (this.m_fboBuf != null) {
      this.m_fboBuf.setAttachmentMaskAt(index, boo);
    }
  }

  getFBOAttachmentTotal() {
    if (this.m_fboBuf != null) {
      return this.m_fboBuf.getAttachmentTotal();
    }

    return 0;
  }
  /**
   * bind a texture to fbo attachment by attachment index
   * @param texProxy  IRenderTexture instance
   * @param enableDepth  enable depth buffer yes or no
   * @param enableStencil  enable stencil buffer yes or no
   * @param attachmentIndex  fbo attachment index
   */


  setRenderToTexture(texProxy, enableDepth = false, enableStencil = false, attachmentIndex = 0) {
    if (attachmentIndex < 0 || attachmentIndex >= 8) {
      attachmentIndex = 0;
    } //console.log("attachmentIndex: ",attachmentIndex);


    if (texProxy == null && attachmentIndex == 0) {
      this.setRenderToBackBuffer(FrameBufferType_1.default.FRAMEBUFFER);
    } else {
      if (attachmentIndex == 0) {
        if (this.m_fboBuf != null) {
          if (this.m_synFBOSizeWithViewport) {
            this.m_fboBuf.initialize(this.m_gl, Math.floor(this.m_rcontext.getFBOWidth() * this.m_fboSizeFactor), Math.floor(this.m_rcontext.getFBOHeight() * this.m_fboSizeFactor));
          } else {
            if (this.m_fboViewportRectBoo) {
              this.m_fboBuf.initialize(this.m_gl, this.m_fboViewportRectData[2], this.m_fboViewportRectData[3]);
            } else if (!this.m_fboBuf.sizeFixed) {
              this.m_fboBuf.initialize(this.m_gl, texProxy.getWidth(), texProxy.getHeight());
            }
          }
        }

        if (this.m_fboIndex >= 0) {
          if (this.m_fboBuf == null) {
            this.m_fboBuf = new FrameBufferObject_1.default(this.m_rcuid, this.m_texResource, this.m_fboType);
            this.m_fboBufList[this.m_fboIndex] = this.m_fboBuf;
            this.m_fboBuf.writeDepthEnabled = enableDepth;
            this.m_fboBuf.writeStencilEnabled = enableStencil;

            if (this.m_synFBOSizeWithViewport) {
              this.m_fboBuf.initialize(this.m_gl, Math.floor(this.m_rcontext.getFBOWidth() * this.m_fboSizeFactor), Math.floor(this.m_rcontext.getFBOHeight() * this.m_fboSizeFactor));
            } else {
              if (this.m_fboViewportRectBoo) {
                this.m_fboBuf.initialize(this.m_gl, this.m_fboViewportRectData[2], this.m_fboViewportRectData[3]);
              } else {
                this.m_fboBuf.initialize(this.m_gl, texProxy.getWidth(), texProxy.getHeight());
              }
            }
          }
        }
      }

      if (this.m_fboBuf != null) {
        this.m_fboBuf.renderToTexAt(this.m_gl, texProxy, attachmentIndex); //console.log("RenderProxy::setRenderToTexture(), fbo: ",this.m_fboBuf.getFBO());
      }

      this.m_fboClearBoo = true;
    }
  }

  getActiveAttachmentTotal() {
    return this.m_activeAttachmentTotal;
  }

  getAttachmentTotal() {
    return this.m_activeAttachmentTotal;
  }

  useFBO(clearColorBoo = false, clearDepthBoo = false, clearStencilBoo = false) {
    if (this.m_fboBuf != null) {
      if (this.m_fboClearBoo) {
        this.m_fboClearBoo = false;
        this.m_fboBuf.use(this.m_gl);
        this.m_activeAttachmentTotal = this.m_fboBuf.getActiveAttachmentTotal();

        if (clearColorBoo) {
          this.m_fboBuf.clearOnlyColor(this.bgColor);
        }

        if (this.m_fboBuf.writeDepthEnabled) {
          if (this.m_fboBuf.writeStencilEnabled) {
            if (clearDepthBoo && clearStencilBoo) {
              this.m_fboBuf.clearOnlyDepthAndStencil(this.m_clearDepth, 0xffffffff);
            } else if (clearDepthBoo) {
              this.m_fboBuf.clearOnlyDepth(this.m_clearDepth);
            } else if (clearStencilBoo) {
              this.m_fboBuf.clearOnlyStencil(0xff);
            }
          } else if (clearDepthBoo) {
            this.m_fboBuf.clearOnlyDepth(this.m_clearDepth);
          }
        } else if (clearStencilBoo && this.m_fboBuf.writeStencilEnabled) {
          this.m_fboBuf.clearOnlyStencil(0xff);
        }

        if (this.m_webglVer == 1) {
          // m_gl.colorMask(m_colorMask.mr,m_colorMask.mg,m_colorMask.mb,m_colorMask.ma);
          this.m_gl.clear(this.m_clearMask);
        }

        let size = this.m_viewPortRect;
        this.m_fboBiltRectData[4] = this.m_fboBiltRectData[0] = size.x;
        this.m_fboBiltRectData[5] = this.m_fboBiltRectData[1] = size.y;
        this.m_fboBiltRectData[6] = this.m_fboBiltRectData[2] = size.getRight();
        this.m_fboBiltRectData[7] = this.m_fboBiltRectData[3] = size.getTop();

        if (this.m_fboViewportRectBoo) {
          this.m_fboViewportRectBoo = false;
          this.m_fboViewportRect.setTo(this.m_fboViewportRectData[0], this.m_fboViewportRectData[1], this.m_fboViewportRectData[2], this.m_fboViewportRectData[3]);
          this.reseizeFBOViewPort();
        } else {
          if (this.m_synFBOSizeWithViewport) {
            //console.log("this.m_fboSizeFactor: "+this.m_fboSizeFactor);
            this.m_fboViewportRect.setTo(0, 0, Math.floor(this.m_rcontext.getFBOWidth() * this.m_fboSizeFactor), Math.floor(this.m_rcontext.getFBOHeight() * this.m_fboSizeFactor));
          } else {
            if (this.m_fboBuf.isSizeChanged()) {
              this.m_fboBuf.initialize(this.m_gl, this.m_fboBuf.getWidth(), this.m_fboBuf.getHeight());
            }

            this.m_fboViewportRect.setTo(0, 0, this.m_fboBuf.getWidth(), this.m_fboBuf.getHeight());
          }

          this.reseizeFBOViewPort();
        }
      }
    }
  }

  setRenderToBackBuffer(frameBufferType = FrameBufferType_1.default.FRAMEBUFFER) {
    this.m_activeAttachmentTotal = 1;
    FrameBufferObject_1.default.BindToBackbuffer(this.m_gl, frameBufferType);
    this.reseizeViewPort();
  }

  bindFBOToDraw() {
    if (this.m_fboBuf != null) {
      this.m_fboBuf.bind(FrameBufferType_1.default.DRAW_FRAMEBUFFER);
    }
  }

  bindFBOToWrite() {
    if (this.m_fboBuf != null) {
      this.m_fboBuf.bind(FrameBufferType_1.default.READ_FRAMEBUFFER);
    }
  }

  setBlitFboSrcRect(px, py, pw, ph) {
    this.m_fboBiltRectData[0] = px;
    this.m_fboBiltRectData[1] = py;
    this.m_fboBiltRectData[2] = px + pw;
    this.m_fboBiltRectData[3] = py + ph;
  }

  setBlitFboDstRect(px, py, pw, ph) {
    this.m_fboBiltRectData[4] = px;
    this.m_fboBiltRectData[5] = py;
    this.m_fboBiltRectData[6] = px + pw;
    this.m_fboBiltRectData[7] = py + ph;
  }
  /**
   * @oaram			clearType, it is RenderProxy.COLOR or RenderProxy.DEPTH or RenderProxy.STENCIL or RenderProxy.DEPTH_STENCIL
  */


  blitFBO(readFBOIndex = 0, writeFBOIndex = 0, mask_bitfiled = RenderMaskBitfield_1.default.COLOR_BUFFER_BIT, filter = RenderFilter_1.default.NEAREST, clearType = 0, clearIndex = 0, dataArr = null) {
    if (readFBOIndex > 7) {
      readFBOIndex = 7;
    }

    if (writeFBOIndex > 7) {
      writeFBOIndex = 7;
    }

    if (readFBOIndex >= 0 && this.m_fboBufList[readFBOIndex] != null) {
      this.m_fboBufList[readFBOIndex].bind(FrameBufferType_1.default.READ_FRAMEBUFFER);
    } else {
      FrameBufferObject_1.default.BindToBackbuffer(this.m_gl, FrameBufferType_1.default.READ_FRAMEBUFFER);
    }

    if (writeFBOIndex >= 0 && this.m_fboBufList[writeFBOIndex] != null) {
      this.m_fboBufList[writeFBOIndex].bind(FrameBufferType_1.default.DRAW_FRAMEBUFFER);
    } else {
      FrameBufferObject_1.default.BindToBackbuffer(this.m_gl, FrameBufferType_1.default.DRAW_FRAMEBUFFER);
    }

    if (clearType > 0) {
      if (clearIndex < 0) {
        clearIndex = 0;
      } // clearType 默认是 gl.COLOR
      // clearIndex 默认是0
      // dataArr 默认值是 [0.0, 0.0, 0.0, 1.0]


      if (dataArr == null) {
        dataArr = [0.0, 0.0, 0.0, 1.0];
      }

      this.m_gl.clearBufferfv(clearType, clearIndex, dataArr);
    }

    let fs = this.m_fboBiltRectData; //copyTexSubImage2D 可以在gles2中代替下面的函数

    this.m_gl.blitFramebuffer(fs[0], fs[1], fs[2], fs[3], fs[4], fs[5], fs[6], fs[7], mask_bitfiled, filter);
  }

}

exports.default = RenderAdapter;

/***/ }),

/***/ "1264":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("11e6"));

const RenderConst_1 = __webpack_require__("e08e");

const RPOUnitBuilder_1 = __webpack_require__("eca0");

class DispEntity3DManager {
  constructor(rendererUid, RODataBuilder, rpoUnitBuilder, processBuider) {
    this.m_rpoUnitBuilder = null;
    this.m_dataBuilder = null;
    this.m_processBuider = null;
    this.m_waitList = [];
    this.m_processUidList = [];
    this.m_rendererUid = -1;
    this.m_existencetotal = 0;
    this.m_rprocess = null;
    this.m_entityManaListener = null;
    this.version = 0;
    this.m_rendererUid = rendererUid;
    this.m_dataBuilder = RODataBuilder;
    this.m_rpoUnitBuilder = rpoUnitBuilder;
    this.m_processBuider = processBuider;
  }

  setListener(entityManaListener) {
    this.m_entityManaListener = entityManaListener;
  }

  isEmpty() {
    return this.m_existencetotal < 1;
  }

  isHaveEntity() {
    return this.m_existencetotal > 0;
  }

  removeEntity(entity) {
    this.m_existencetotal--; // 从所有相关process中移除这个display

    let display = entity.getDisplay();

    if (display != null && display.__$$runit != null) {
      let puid = display.__$ruid;
      let po = this.m_rpoUnitBuilder.getRCRPObj(puid);

      if (po != null) {
        if (po.count > 0) {
          if (po.count < 2) {
            if (po.rprocessUid > -1) {
              this.m_rprocess = this.m_processBuider.getNodeByUid(po.rprocessUid);
              this.m_rprocess.removeDisp(display);
              po.rprocessUid = -1;
            }
          } else {
            let len = RPOUnitBuilder_1.RCRPObj.RenerProcessMaxTotal;

            for (let i = 0; i < len; ++i) {
              if ((po.idsFlag & 1 << i) > 0) {
                // the value of list[i] is the uid of a node;
                this.m_rprocess = this.m_processBuider.getNodeByUid(i);
                this.m_rprocess.removeDisp(display);
              }
            }
          }
        }
      } else {
        this.m_rprocess = this.m_processBuider.getNodeByUid(display.__$$runit.getRPROUid());
        this.m_rprocess.removeDisp(display);
      }

      if (po.count == 0) {
        //console.log("DispEntity3DManager::removeEntity(), remove a entity from all processes.");
        if (display.__$$rsign != RenderConst_1.DisplayRenderSign.LIVE_IN_RENDERER) {
          // error!!!
          console.error("DispEntity3DManager::removeEntity(), Error: display.__$$rsign != RODisplay.LIVE_IN_RENDERER.");
        }

        display.__$$rsign = RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER; // 准备移除和当前 display 对应的 RPOUnit

        this.m_rpoUnitBuilder.restoreByUid(puid);
      } else {
        console.warn("Error: DispEntity3DManager::removeEntity(), remove a entity from all processes failed.");
      }

      this.version++;
    }

    entity.__$rseFlag = RSEntityFlag_1.default.RemoveRendererUid(entity.__$rseFlag);
    entity.__$rseFlag = RSEntityFlag_1.default.RemoveRendererLoad(entity.__$rseFlag);
    entity.__$rseFlag = RSEntityFlag_1.default.RemoveSortEnabled(entity.__$rseFlag);

    if (this.m_entityManaListener != null) {
      this.m_entityManaListener.removeFromRenderer(entity, this.m_rendererUid, -1);
    }
  }

  addEntity(entity, processUid, deferred = false) {
    if (entity != null) {
      //console.log("add entity into entity 3d manager.");
      let disp = entity.getDisplay();

      if (disp != null) {
        if (disp.__$$rsign == RenderConst_1.DisplayRenderSign.LIVE_IN_RENDERER) {
          if (!this.m_rpoUnitBuilder.testRPNodeNotExists(disp.__$ruid, processUid)) {
            //console.log("DispEntity3DManager::addEntity(), A, this display("+disp.__$ruid+") has existed in processid("+processUid+").");
            return;
          }
        }

        this.m_rprocess = this.m_processBuider.getNodeByUid(processUid);
        entity.__$rseFlag = this.m_rprocess.getSortEnabled() ? RSEntityFlag_1.default.AddSortEnabled(entity.__$rseFlag) : RSEntityFlag_1.default.RemoveSortEnabled(entity.__$rseFlag);

        if (deferred) {
          if (disp.__$$rsign == RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER) {
            disp.__$$rsign = RenderConst_1.DisplayRenderSign.GO_TO_RENDERER;
          }

          entity.__$rseFlag = RSEntityFlag_1.default.AddRendererLoad(entity.__$rseFlag);
          entity.__$rseFlag = RSEntityFlag_1.default.AddRendererUid(entity.__$rseFlag, this.m_rendererUid);
          this.m_waitList.push(entity);
          this.m_processUidList.push(processUid); //console.log("DispEntity3DManager::addEntity(), B, this display("+disp+") has existed in processid("+processUid+").");
        } else {
          // 检查数据完整性
          if (this.testValidData(entity)) {
            this.ensureAdd(entity, disp, processUid);
          } else {
            //console.log("DispEntity3DManager::addEntity(), add a ready ok entity to process.");
            if (disp.__$$rsign == RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER) {
              disp.__$$rsign = RenderConst_1.DisplayRenderSign.GO_TO_RENDERER;
            }

            entity.__$rseFlag = RSEntityFlag_1.default.AddRendererLoad(entity.__$rseFlag);
            this.m_waitList.push(entity);
            this.m_processUidList.push(processUid);
          }
        }
      } else {
        entity.__$rseFlag = RSEntityFlag_1.default.AddRendererUid(entity.__$rseFlag, this.m_rendererUid);
      }
    }

    return false;
  }

  testValidData(entity) {
    if (entity.getMaterial() != null && entity.hasMesh()) {
      if (entity.getMaterial().hasShaderData()) {
        return true;
      } else if (entity.getMaterial().getCodeBuf() != null) {
        entity.activeDisplay();
      }
    }

    return false;
  }

  ensureAdd(entity, disp, processUid) {
    entity.update();
    entity.__$rseFlag = RSEntityFlag_1.default.AddRendererUid(entity.__$rseFlag, this.m_rendererUid);
    entity.__$rseFlag = RSEntityFlag_1.default.RemoveRendererLoad(entity.__$rseFlag);

    entity.__$setRenderProxy(this.m_dataBuilder.getRenderProxy());

    this.m_existencetotal++;

    if (disp.__$$rsign == RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER) {
      disp.__$$rsign = RenderConst_1.DisplayRenderSign.GO_TO_RENDERER;
    }

    this.m_rprocess = this.m_processBuider.getNodeByUid(processUid); //console.log("DispEntity3DManager::addEntity(), add a ready ok entity to process.");

    if (disp.__$ruid > -1) {
      this.m_rprocess.addDisp(disp);
    } else {
      if (this.m_dataBuilder.buildGpuDisp(disp)) {
        this.m_rprocess.addDisp(disp);
      }
    }

    if (this.m_entityManaListener != null) {
      this.m_entityManaListener.addToRenderer(entity, this.m_rendererUid, processUid);
    }

    if (entity.getGlobalBounds() != null) {
      disp.__$$runit.bounds = entity.getGlobalBounds();
      disp.__$$runit.pos = disp.__$$runit.bounds.center;
    }

    this.version++;
  }

  updateWaitList() {
    let len = this.m_waitList.length;
    let entity = null;
    let disp = null;

    for (let i = 0; i < len; ++i) {
      entity = this.m_waitList[i];

      if ((RSEntityFlag_1.default.RENDERER_LOAD_FLAG & entity.__$rseFlag) == RSEntityFlag_1.default.RENDERER_LOAD_FLAG) {
        if (this.testValidData(entity)) {
          disp = entity.getDisplay();

          if (disp.__$$rsign == RenderConst_1.DisplayRenderSign.LIVE_IN_RENDERER) {
            if (!this.m_rpoUnitBuilder.testRPNodeNotExists(disp.__$ruid, this.m_processUidList[i])) {
              //console.log("DispEntity3DManager::update(), this display("+disp.__$ruid+") has existed in processid("+m_processUidList[i]+").");
              this.m_waitList.splice(i, 1);
              this.m_processUidList.splice(i, 1);
              --len;
              --i;
              continue;
            }
          }

          this.ensureAdd(entity, disp, this.m_processUidList[i]);
          this.m_waitList.splice(i, 1);
          this.m_processUidList.splice(i, 1);
          --len;
          --i;
        }
      } else {
        disp = entity.getDisplay();

        if (disp != null && disp.__$$rsign == RenderConst_1.DisplayRenderSign.GO_TO_RENDERER) {
          disp.__$$rsign = RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER;
        } //console.log("DispEntity3DManager::update(), remove a ready entity.");


        entity.__$rseFlag = RSEntityFlag_1.default.RemoveRendererLoad(entity.__$rseFlag);
        entity.__$rseFlag = RSEntityFlag_1.default.RemoveRendererUid(entity.__$rseFlag);
        entity.__$rseFlag = RSEntityFlag_1.default.RemoveSortEnabled(entity.__$rseFlag);
        this.m_waitList.splice(i, 1);
        this.m_processUidList.splice(i, 1);
        --len;
        --i;

        if (this.m_entityManaListener != null) {
          this.m_entityManaListener.removeFromRenderer(entity, this.m_rendererUid, -1);
        }
      }
    }
  }

  update() {
    if (this.m_waitList.length > 0) {
      this.updateWaitList();
    }

    this.m_dataBuilder.update();
  }

}

exports.default = DispEntity3DManager;

/***/ }),

/***/ "1280":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Utils_1 = __webpack_require__("f689");

const FBXBufferObject_1 = __webpack_require__("8310");

const ElementGeomData_1 = __webpack_require__("5ab6");

const BufPropertyParser_1 = __webpack_require__("c758"); // parse Geometry data from FBXTree and return map of BufferGeometries


class GeometryBufferParser {
  constructor() {
    this.m_parseTotal = 0;
    this.m_reader = null;
    this.m_bufPpt = new BufPropertyParser_1.BufPropertyParser();
    this.m_egd = new ElementGeomData_1.ElementGeomData();
  }

  setReader(reader) {
    this.m_reader = reader;
  }

  parseGeomBuf(deformers, fbxTree, connections, immediate = true) {
    const geometryMap = new Map();

    if ('Geometry' in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      let id = 0;
      let idLst = [];
      let nodeIDList = [];
      this.m_idLst = idLst;
      this.m_nodeIDList = nodeIDList; // for ( const nodeID in geoNodes ) {
      // 	id = parseInt( nodeID );
      // 	const relationships = connections.get( id );
      // 	const geoBuf = this.parseGeometryBuffer( relationships, geoNodes[ nodeID ], deformers, fbxTree );
      // 	geometryMap.set( id, geoBuf );
      // }

      for (const nodeID in geoNodes) {
        idLst.push(parseInt(nodeID));
        nodeIDList.push(nodeID);
      }

      for (let i = 0; i < idLst.length; ++i) {
        id = idLst[i];
        const relationships = connections.get(id);
        const geoBuf = this.parseGeometryBuffer(relationships, geoNodes[nodeIDList[i]], deformers, fbxTree);
        geometryMap.set(id, geoBuf);
      } // console.log("geoInfo.vertexIndices.length: ", geoInfo.vertexIndices.length);
      // console.log("geometryMap: ",geometryMap);

    }

    return geometryMap;
  }

  parseGeomBufBegin(deformers, fbxTree, connections) {
    //const geometryMap: Map<number, FBXBufferObject> = new Map();
    if ('Geometry' in fbxTree.Objects) {
      this.m_deformers = deformers;
      this.m_fbxTree = fbxTree;
      this.m_connections = connections;
      this.m_idLst = [];
      this.m_nodeIDList = [];
      const geoNodes = fbxTree.Objects.Geometry;

      for (const nodeID in geoNodes) {
        let geoNode = geoNodes[nodeID]; // if(geoNode.attrType != "NurbsCurve") {

        if (geoNode.attrType == "Mesh") {
          this.m_idLst.push(parseInt(nodeID));
          this.m_nodeIDList.push(nodeID);
        }
      }

      this.m_parseTotal = this.m_idLst.length;
    } //return geometryMap;

  }

  getGeomBufId() {
    if (this.isParsing()) {
      return this.m_idLst[this.m_idLst.length - 1];
    }

    return -1;
  }

  parseGeomBufNext() {
    // console.log("GeometryBufferParser::parseGeomBufNext(), this.isParsing(): ",this.isParsing());
    if (this.isParsing()) {
      const geoNodes = this.m_fbxTree.Objects.Geometry;
      let id = this.m_idLst.pop();
      let ID = this.m_nodeIDList.pop(); // let geoNode = geoNodes[ ID ];
      // console.log("GeometryBufferParser::parseGeomBufNext(), ID: ",ID, geoNodes[ ID ]);

      const relationships = this.m_connections.get(id);
      let obj = this.parseGeometryBuffer(relationships, geoNodes[ID], this.m_deformers, this.m_fbxTree); // if(geoNode.attrType == "NurbsCurve") {
      // 	//console.log();
      // }

      if (obj != null) {
        obj.ID = ID;
        obj.id = id;
      }

      if (!this.isParsing()) {
        this.m_reader = null;
      }

      return obj;
    }

    return null;
  }

  parseGeomBufAt(i) {
    if (i >= 0 && i < this.m_idLst.length) {
      if (this.isParsing()) {
        const geoNodes = this.m_fbxTree.Objects.Geometry;
        let id = this.m_idLst[i];
        let ID = this.m_nodeIDList[i];
        const relationships = this.m_connections.get(id);
        let obj = this.parseGeometryBuffer(relationships, geoNodes[ID], this.m_deformers, this.m_fbxTree);

        if (obj != null) {
          obj.ID = ID;
          obj.id = id;
        }

        if (!this.isParsing()) {
          this.m_reader = null;
        }

        return obj;
      }
    }

    return null;
  }

  isParsing() {
    return this.m_idLst != null && this.m_idLst.length > 0;
  }

  getParseTotal() {
    return this.m_parseTotal;
  } // Parse single node in FBXTree.Objects.Geometry


  parseGeometryBuffer(relationships, geoNode, deformers, fbxTree) {
    switch (geoNode.attrType) {
      case 'Mesh':
        return this.parseMeshGeometryBuffer(relationships, geoNode, deformers, fbxTree);
        break;

      case 'NurbsCurve':
        return this.parseNurbsGeometry(geoNode);
        break;
    }
  } // Parse single node mesh geometry in FBXTree.Objects.Geometry


  parseMeshGeometryBuffer(relationships, geoNode, deformers, fbxTree) {
    //console.log("GeometryBufferParser::genGeometryBuffers(), skeleton: ",skeleton);
    // let time = Date.now();
    const geoInfo = this.parseGeoNode(geoNode); // let lossTime: number = Date.now() - time;
    // console.log("XXX geoInfo lossTime: ", lossTime);

    const obj = this.getBufObj(geoInfo); // console.log("GeometryBufferParser::genGeometryBuffers(), buffers: ",buffers);

    return obj;
  }

  parseGeoNode(geoNode) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []; // if ( geoNode.LayerElementColor ) {
    // 	geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );
    // }
    // if ( geoNode.LayerElementMaterial ) {
    // 	geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );
    // }

    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }

    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i = 0;

      while (geoNode.LayerElementUV[i]) {
        if (geoNode.LayerElementUV[i].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
        }

        i++;
      }
    }

    geoInfo.weightTable = {};
    return geoInfo;
  }

  parseData(params) {
    return this.m_bufPpt.parseDirec(this.m_reader, params);
  }

  getBufObj(geoInfo) {
    let polygonIndex = 0;
    let faceLength = 0;
    let facePositionIndexes = new Array(36);
    let faceNormals = new Array(36);
    let faceColors = new Array(36);
    let faceUVs = null;
    let faceWeights = [];
    let faceWeightIndices = [];
    let uvList = geoInfo.uv;
    let advancedModel = geoInfo.vertexPositions.length == 5;

    if (advancedModel) {
      geoInfo.vertexIndices = this.parseData(geoInfo.vertexIndices);
      geoInfo.vertexPositions = this.parseData(geoInfo.vertexPositions);

      if (geoInfo.normal != null || geoInfo.normal != undefined) {
        geoInfo.normal.buffer = this.parseData(geoInfo.normal.buffer);
        geoInfo.normal.indices = this.parseData(geoInfo.normal.indices);
      } else {
        geoInfo.normal = null;
      }

      if (uvList != null && uvList.length > 0) {
        uvList[0].buffer = this.parseData(uvList[0].buffer);
      } // console.log("A0 geoInfo: ", geoInfo);


      return this.m_egd.createBufObject(geoInfo);
    } // console.log("A1 geoInfo: ", geoInfo);


    console.log("VVV-XXX advancedModel is False.");
    const bufObj = new FBXBufferObject_1.FBXBufferObject();
    bufObj.isEntity = true;
    let vivs = geoInfo.vertexIndices; // let vvs = geoInfo.vertexPositions;
    // console.log("geoInfo.vertexIndices: ", geoInfo.vertexIndices);
    // console.log("geoInfo.vertexPositions: ", vvs);
    // console.log("geoInfo normal: ", geoInfo.normal.buffer);
    // console.log("geoInfo uv[0]: ", geoInfo.uv[0].buffer);
    // console.log("geoInfo.vertexIndices.length: ", geoInfo.vertexIndices.length);
    // let normalData: number[] = new Array(vvs.length);

    let oivsLen = geoInfo.vertexIndices.length; //console.log("XXX oivsLen: ",oivsLen);

    let time = Date.now();
    let materialIndex = 0; // let miBoo = geoInfo.material && geoInfo.material.mappingType !== 'AllSame';

    let trisTotal = 0;

    for (let i = 0; i < oivsLen; ++i) {
      faceLength++;

      if (vivs[i] < 0) {
        trisTotal += faceLength - 2;
        faceLength = 0;
      }
    }

    let vsLen = trisTotal * 9;
    bufObj.vertex = new Float32Array(vsLen);
    bufObj.normal = new Float32Array(vsLen);
    let uvs = bufObj.uvs;
    let guvLen = 0;
    let guv = null;

    if (geoInfo.uv) {
      guvLen = geoInfo.uv.length;
      guv = geoInfo.uv;
      faceUVs = [];

      for (let j = 0; j < guvLen; ++j) {
        faceUVs.push(new Array(36));
        uvs[j] = new Float32Array(trisTotal * 6);
      }

      bufObj.uvs = uvs;
    }

    let lossTimeA = Date.now() - time;
    faceLength = 0;

    for (let i = 0; i < oivsLen; ++i) {
      let endOfFace = false;
      let vertexIndex = vivs[i];

      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1

        endOfFace = true;
      }

      let fi = faceLength * 3;
      const a = vertexIndex * 3; // facePositionIndexes.push( a, a + 1, a + 2 );

      facePositionIndexes[fi] = a;
      facePositionIndexes[fi + 1] = a + 1;
      facePositionIndexes[fi + 2] = a + 2; // if ( geoInfo.color ) {
      // 	const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );
      // 	//faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );
      // faceColors[fi] = data[0];
      // faceColors[fi+1] = data[1];
      // faceColors[fi+2] = data[2];
      // }

      if (geoInfo.normal) {
        //console.log("calc normal: ",geoInfo.normal.mappingType);
        const data = Utils_1.getData(i, polygonIndex, vertexIndex, geoInfo.normal); // faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

        faceNormals[fi] = data[0];
        faceNormals[fi + 1] = data[1];
        faceNormals[fi + 2] = data[2]; // normalData[a] = data[0];
        // normalData[a+1] = data[1];
        // normalData[a+2] = data[2];
      }

      if (guv != null) {
        fi = faceLength * 2;

        for (let j = 0; j < guvLen; ++j) {
          const data = Utils_1.getData(i, polygonIndex, vertexIndex, guv[j]);
          faceUVs[j][fi] = data[0];
          faceUVs[j][fi + 1] = data[1];
        }
      }

      faceLength++;

      if (endOfFace) {
        // console.log("facePositionIndexes: ",facePositionIndexes);
        this.genFace(bufObj, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0; // faceWeights = [];
        // faceWeightIndices = [];
      }
    }

    ;
    let lossTime = Date.now() - time; // console.log("XXX normalData: ",normalData);

    console.log("XXX lossTime: ", lossTime, ",preCompute lossTime: ", lossTimeA);
    console.log("XXX vertex.length:", bufObj.vertex.length, ", vsLen:", vsLen, ", oivsLen:", oivsLen);

    if (oivsLen > 2000000) {
      console.log("XXX larger geom vertices total.....");
    } // buffers.indices = indices;
    // //pvs
    // buffers.indices = pvs.length <= 65535 ? new Uint16Array(pvs) : new Uint32Array(pvs);


    return bufObj;
  } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris


  genFace(bufObj, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    let vps = geoInfo.vertexPositions;
    let vs = bufObj.vertex;
    let nvs = bufObj.normal;
    let uvs = bufObj.uvs;
    let i3 = bufObj.i3;
    let i2 = bufObj.i2; // let colorBoo = geoInfo.color != null;

    let normalBoo = geoInfo.normal != null;
    let uvBoo = geoInfo.uv != null; // let miBoo = geoInfo.material && geoInfo.material.mappingType !== 'AllSame';

    for (let i = 2; i < faceLength; i++) {
      vs[i3] = vps[facePositionIndexes[0]];
      vs[i3 + 1] = vps[facePositionIndexes[1]];
      vs[i3 + 2] = vps[facePositionIndexes[2]];
      vs[i3 + 3] = vps[facePositionIndexes[(i - 1) * 3]];
      vs[i3 + 4] = vps[facePositionIndexes[(i - 1) * 3 + 1]];
      vs[i3 + 5] = vps[facePositionIndexes[(i - 1) * 3 + 2]];
      vs[i3 + 6] = vps[facePositionIndexes[i * 3]];
      vs[i3 + 7] = vps[facePositionIndexes[i * 3 + 1]];
      vs[i3 + 8] = vps[facePositionIndexes[i * 3 + 2]]; // if ( colorBoo ) {
      // 	bufObj.colors.push( faceColors[ 0 ] );
      // 	bufObj.colors.push( faceColors[ 1 ] );
      // 	bufObj.colors.push( faceColors[ 2 ] );
      // 	bufObj.colors.push( faceColors[ ( i - 1 ) * 3 ] );
      // 	bufObj.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );
      // 	bufObj.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );
      // 	bufObj.colors.push( faceColors[ i * 3 ] );
      // 	bufObj.colors.push( faceColors[ i * 3 + 1 ] );
      // 	bufObj.colors.push( faceColors[ i * 3 + 2 ] );
      // }

      if (normalBoo) {
        nvs[i3] = faceNormals[0];
        nvs[i3 + 1] = faceNormals[1];
        nvs[i3 + 2] = faceNormals[2];
        nvs[i3 + 3] = faceNormals[(i - 1) * 3];
        nvs[i3 + 4] = faceNormals[(i - 1) * 3 + 1];
        nvs[i3 + 5] = faceNormals[(i - 1) * 3 + 2];
        nvs[i3 + 6] = faceNormals[i * 3];
        nvs[i3 + 7] = faceNormals[i * 3 + 1];
        nvs[i3 + 8] = faceNormals[i * 3 + 2];
      }

      if (uvBoo) {
        const guv = geoInfo.uv;

        for (let j = 0, jl = guv.length; j < jl; j++) {
          const fuvs = faceUVs[j];
          const puvs = uvs[j];
          puvs[i2] = fuvs[0];
          puvs[i2 + 1] = fuvs[1];
          puvs[i2 + 2] = fuvs[(i - 1) * 2];
          puvs[i2 + 3] = fuvs[(i - 1) * 2 + 1];
          puvs[i2 + 4] = fuvs[i * 2];
          puvs[i2 + 5] = fuvs[i * 2 + 1];
        }
      }

      i3 += 9;
      i2 += 6;
    }

    bufObj.i3 = i3;
    bufObj.i2 = i2;
  } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists


  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];

    if (referenceType === 'IndexToDirect') {
      if ('NormalIndex' in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ('NormalsIndex' in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }

    return {
      dataSize: 3,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };
  } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists


  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];

    if (referenceType === 'IndexToDirect') {
      indexBuffer = UVNode.UVIndex.a;
    } // console.log("parseUVs(), buffer: ", buffer);


    return {
      dataSize: 2,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };
  } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists


  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];

    if (referenceType === 'IndexToDirect') {
      indexBuffer = ColorNode.ColorIndex.a;
    }

    return {
      dataSize: 4,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType
    };
  } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists


  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;

    if (mappingType === 'NoMappingInformation') {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: 'AllSame',
        referenceType: referenceType
      };
    }

    const materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
    // we expect.So we create an intermediate buffer that points to the index in the buffer,
    // for conforming with the other functions we've written for other data.

    const materialIndices = [];

    for (let i = 0; i < materialIndexBuffer.length; ++i) {
      materialIndices.push(i);
    }

    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType: mappingType,
      referenceType: referenceType
    };
  } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry


  parseNurbsGeometry(geoNode) {
    return null;
  }

}

exports.GeometryBufferParser = GeometryBufferParser;

/***/ }),

/***/ "131b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderCodeBuffer_1 = __importDefault(__webpack_require__("faa5"));

const ShaderUniformData_1 = __importDefault(__webpack_require__("b3bd"));

const MaterialBase_1 = __importDefault(__webpack_require__("0fc4"));

class RawCodeShaderBuffer extends ShaderCodeBuffer_1.default {
  constructor() {
    super();
    this.m_uniqueName = "";
    this.m_fragCode = "";
    this.m_vtxCode = "";
    this.m_flag = true;
    this.shaderBuilder = null;
  }

  initialize(texEnabled) {
    super.initialize(texEnabled);
    this.adaptationShaderVersion = false;
  }

  buildShader() {
    this.m_flag = this.shaderBuilder != null;

    if (this.m_flag) {
      this.shaderBuilder(this);
      this.shaderBuilder = null;
    }
  }

  setUniqueName(uniqueName) {
    this.m_uniqueName = uniqueName;
  }

  setFragShaderCode(codeStr) {
    this.m_fragCode = codeStr;
  }

  getFragShaderCode() {
    if (this.m_flag) return this.m_coder.buildFragCode();
    return this.m_fragCode;
  }

  setVtxShaderCode(codeStr) {
    this.m_vtxCode = codeStr;
  }

  getVertShaderCode() {
    if (this.m_flag) return this.m_coder.buildVertCode();
    return this.m_vtxCode;
  }

  getUniqueShaderName() {
    //console.log("H ########################### this.m_uniqueName: "+this.m_uniqueName);
    return this.m_uniqueName;
  }

  toString() {
    return "[RawCodeShaderBuffer()]";
  }

}

class ShaderMaterial extends MaterialBase_1.default {
  constructor(shd_uniqueName) {
    super();
    this.m_buffer = new RawCodeShaderBuffer();
    this.m_uniformData = null;
    this.m_shaderBuilder = null;
    this.vertColorEnabled = false;
    this.premultiplyAlpha = false;
    this.shadowReceiveEnabled = false;
    this.lightEnabled = false;
    this.fogEnabled = false;
    this.envAmbientLightEnabled = false;
    this.brightnessOverlayEnabeld = false;
    this.glossinessEnabeld = true;
    this.m_buffer.setUniqueName(shd_uniqueName);
  }

  buildBuf() {
    let buf = this.m_buffer;
    buf.shaderBuilder = this.m_shaderBuilder;
    buf.vertColorEnabled = this.vertColorEnabled;
    buf.premultiplyAlpha = this.premultiplyAlpha;
    buf.shadowReceiveEnabled = this.shadowReceiveEnabled;
    buf.lightEnabled = this.lightEnabled;
    buf.fogEnabled = this.fogEnabled;
    buf.envAmbientLightEnabled = this.envAmbientLightEnabled;
    buf.brightnessOverlayEnabeld = this.brightnessOverlayEnabeld;
    buf.glossinessEnabeld = this.glossinessEnabeld;
  }

  setShaderBuilder(shaderBuilder) {
    this.m_shaderBuilder = shaderBuilder;
  }

  setFragShaderCode(codeStr) {
    this.m_buffer.shaderBuilder = null;
    this.m_buffer.setFragShaderCode(codeStr);
  }

  setVtxShaderCode(codeStr) {
    this.m_buffer.shaderBuilder = null;
    this.m_buffer.setVtxShaderCode(codeStr);
  }
  /**
   * @param           uniform_name        the name of a uniform in the shader.
   * @param           data                Float32Array type data stream,for example: vec4(Float32Array(4)),mat4(Float32Array(16))
   */


  addUniformDataAt(uniform_name, data) {
    if (data != null) {
      if (this.m_uniformData == null) {
        this.m_uniformData = new ShaderUniformData_1.default();
        this.m_uniformData.uniformNameList = [];
        this.m_uniformData.dataList = [];
      }

      this.m_uniformData.uniformNameList.push(uniform_name);
      this.m_uniformData.dataList.push(data);
    }
  }

  getCodeBuf() {
    return this.m_buffer;
  }

  createSelfUniformData() {
    return this.m_uniformData;
  }

  destroy() {
    this.m_shaderBuilder = null;
  }

}

exports.default = ShaderMaterial;

/***/ }),

/***/ "1710":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// mouse or touch event

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const EventBase_1 = __importDefault(__webpack_require__("a996"));

class MouseEvent extends EventBase_1.default {
  constructor() {
    super(); // 物体空间坐标

    this.lpos = new Vector3D_1.default(); // 世界坐标

    this.wpos = new Vector3D_1.default();
    /**
     * the direction on a ray line in the world space
     */

    this.raytv = new Vector3D_1.default(1.0, 0.0, 0.0);
    /**
     * the point on a ray line in the world space
     */

    this.raypv = new Vector3D_1.default(0.0, 0.0, 0.0); // 屏幕空间鼠标坐标,和gpu空间对齐

    this.mouseX = 0.0;
    this.mouseY = 0.0; // 屏幕空间页面鼠标坐标

    this.mouseViewX = 0.0;
    this.mouseViewY = 0.0; // 例如多点触摸的时候就会有这个数据

    this.posArray = null; // 鼠标滚轮速度

    this.wheelDeltaY = 0;
  }

  static GetMouseEvtTypeValueBase() {
    return 5001;
  }

  static GetMouseEvtTypeValuesTotal() {
    return 24;
  }

  getClassType() {
    return MouseEvent.EventClassType;
  }

  toString() {
    return "[MouseEvent]";
  }

}

MouseEvent.EventClassType = 1002;
MouseEvent.MOUSE_DOWN = 5001;
MouseEvent.MOUSE_UP = 5002;
MouseEvent.MOUSE_RIGHT_UP = 5003;
MouseEvent.MOUSE_RIGHT_DOWN = 5004;
MouseEvent.MOUSE_MOVE = 5005;
MouseEvent.MOUSE_WHEEL = 5006;
MouseEvent.MOUSE_OVER = 5007;
MouseEvent.MOUSE_OUT = 5008;
MouseEvent.MOUSE_CLICK = 5009;
MouseEvent.MOUSE_RIGHT_CLICK = 5010;
MouseEvent.MOUSE_DOUBLE_CLICK = 5011;
MouseEvent.MOUSE_CANCEL = 5012;
MouseEvent.MOUSE_MULTI_DOWN = 5013;
MouseEvent.MOUSE_MULTI_UP = 5014;
MouseEvent.MOUSE_MULTI_MOVE = 5015;
MouseEvent.MOUSE_BG_DOWN = 5016; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_UP = 5017; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_CLICK = 5018; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_MIDDLE_DOWN = 5019;
MouseEvent.MOUSE_MIDDLE_UP = 5020;
MouseEvent.MOUSE_BG_RIGHT_DOWN = 5021; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_RIGHT_UP = 5022; //  mouse up do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_MIDDLE_DOWN = 5023; //  mouse down do not hit any 3d object, only in stage

MouseEvent.MOUSE_BG_MIDDLE_UP = 5024; //  mouse up do not hit any 3d object, only in stage

exports.default = MouseEvent;

/***/ }),

/***/ "18c7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const EulerOrder_1 = __webpack_require__("cc7a");

const OrientationType_1 = __importDefault(__webpack_require__("abdb"));

class Matrix4 {
  constructor(pfs32 = null, index = 0) {
    this.m_uid = -1;
    this._mvx = new Vector3D_1.default();
    this._mvy = new Vector3D_1.default();
    this._mvz = new Vector3D_1.default();
    this.m_index = 0;
    this.m_fs32 = null;
    this.m_localFS32 = null;
    this.m_index = index;

    if (pfs32 != null) {
      this.m_uid = Matrix4.s_uid++;
      this.m_fs32 = pfs32;
      this.m_localFS32 = this.m_fs32.subarray(index, index + 16);
    } else {
      this.m_uid = Matrix4.s_isolatedUid++;
      this.m_fs32 = new Float32Array(16);
      this.m_fs32.set(Matrix4.s_InitData, 0);
      this.m_localFS32 = this.m_fs32;
    }
  }

  setData(data) {
    if (data.length == 16) {
      this.m_localFS32.set(data);
    }
  }

  getCapacity() {
    return 16;
  }

  GetMaxUid() {
    return Matrix4.s_uid;
  }

  getUid() {
    return this.m_uid;
  }

  getLocalFS32() {
    return this.m_localFS32;
  }

  getFS32() {
    return this.m_fs32;
  }

  getFSIndex() {
    return this.m_index;
  }

  identity() {
    this.m_localFS32.set(Matrix4.s_InitData, 0);
  }

  determinant() {
    let lfs = this.m_localFS32;
    return (lfs[0] * lfs[5] - lfs[4] * lfs[1]) * (lfs[10] * lfs[15] - lfs[14] * lfs[11]) - (lfs[0] * lfs[9] - lfs[8] * lfs[1]) * (lfs[6] * lfs[15] - lfs[14] * lfs[7]) + (lfs[0] * lfs[13] - lfs[12] * lfs[1]) * (lfs[6] * lfs[11] - lfs[10] * lfs[7]) + (lfs[4] * lfs[9] - lfs[8] * lfs[5]) * (lfs[2] * lfs[15] - lfs[14] * lfs[3]) - (lfs[4] * lfs[13] - lfs[12] * lfs[5]) * (lfs[2] * lfs[11] - lfs[10] * lfs[3]) + (lfs[8] * lfs[13] - lfs[12] * lfs[9]) * (lfs[2] * lfs[7] - lfs[6] * lfs[3]);
  }

  multiplyMatrices(a, b) {
    const ae = a.getLocalFS32();
    const be = b.getLocalFS32();
    const fs = this.getLocalFS32();
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    fs[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    fs[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    fs[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    fs[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    fs[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    fs[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    fs[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    fs[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    fs[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    fs[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    fs[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    fs[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    fs[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    fs[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    fs[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    fs[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiply(ma, mb = null) {
    if (ma != null && mb != null) {
      return this.multiplyMatrices(ma, mb);
    } else if (ma != null) {
      return this.multiplyMatrices(this, ma);
    }

    return this;
  }

  premultiply(m) {
    if (m != this && m != null) {
      return this.multiplyMatrices(m, this);
    }

    return this;
  }

  append(lhs) {
    let lfs32 = lhs.getLocalFS32();
    let fs = this.m_localFS32;
    let m111 = fs[0];
    let m121 = fs[4];
    let m131 = fs[8];
    let m141 = fs[12];
    let m112 = fs[1];
    let m122 = fs[5];
    let m132 = fs[9];
    let m142 = fs[13];
    let m113 = fs[2];
    let m123 = fs[6];
    let m133 = fs[10];
    let m143 = fs[14];
    let m114 = fs[3];
    let m124 = fs[7];
    let m134 = fs[11];
    let m144 = fs[15];
    let m211 = lfs32[0];
    let m221 = lfs32[4];
    let m231 = lfs32[8];
    let m241 = lfs32[12];
    let m212 = lfs32[1];
    let m222 = lfs32[5];
    let m232 = lfs32[9];
    let m242 = lfs32[13];
    let m213 = lfs32[2];
    let m223 = lfs32[6];
    let m233 = lfs32[10];
    let m243 = lfs32[14];
    let m214 = lfs32[3];
    let m224 = lfs32[7];
    let m234 = lfs32[11];
    let m244 = lfs32[15];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
    fs[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
    fs[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
    fs[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
    fs[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
    fs[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
    fs[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
    fs[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
  }

  append3x3(lhs) {
    let lfs32 = lhs.getLocalFS32();
    let fs = this.m_localFS32;
    let m111 = fs[0];
    let m121 = fs[4];
    let m131 = fs[8];
    let m112 = fs[1];
    let m122 = fs[5];
    let m132 = fs[9];
    let m113 = fs[2];
    let m123 = fs[6];
    let m133 = fs[10];
    let m211 = lfs32[0];
    let m221 = lfs32[4];
    let m231 = lfs32[8];
    let m212 = lfs32[1];
    let m222 = lfs32[5];
    let m232 = lfs32[9];
    let m213 = lfs32[2];
    let m223 = lfs32[6];
    let m233 = lfs32[10];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233;
  }

  appendRotationPivot(radian, axis, pivotPoint = null) {
    if (pivotPoint == null) {
      pivotPoint = Vector3D_1.default.Z_AXIS;
    }

    Matrix4.s_tMat4.identity();
    Matrix4.s_tMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    Matrix4.s_tMat4.appendTranslationXYZ(pivotPoint.x, pivotPoint.y, pivotPoint.z);
    this.append(Matrix4.s_tMat4);
  }

  appendRotation(radian, axis) {
    Matrix4.s_tMat4.identity();
    Matrix4.s_tMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    this.append(Matrix4.s_tMat4);
  }

  appendRotationX(radian) {
    Matrix4.s_tMat4.rotationX(radian);
    this.append3x3(Matrix4.s_tMat4);
  }

  appendRotationY(radian) {
    Matrix4.s_tMat4.rotationY(radian);
    this.append3x3(Matrix4.s_tMat4);
  }

  appendRotationZ(radian) {
    Matrix4.s_tMat4.rotationZ(radian);
    this.append3x3(Matrix4.s_tMat4);
  } // 用欧拉角形式旋转(heading->pitch->bank) => (y->x->z)


  appendRotationEulerAngle(radianX, radianY, radianZ) {
    Matrix4.s_tMat4.rotationY(radianY);
    this.append3x3(Matrix4.s_tMat4);
    Matrix4.s_tMat4.rotationX(radianX);
    this.append3x3(Matrix4.s_tMat4);
    Matrix4.s_tMat4.rotationZ(radianZ);
    this.append3x3(Matrix4.s_tMat4);
  }

  setScale(v3) {
    let fs = this.m_localFS32;
    fs[0] = v3.x;
    fs[5] = v3.y;
    fs[10] = v3.z;
    return this;
  }

  setScaleXYZ(xScale, yScale, zScale) {
    let fs = this.m_localFS32;
    fs[0] = xScale;
    fs[5] = yScale;
    fs[10] = zScale;
  }

  getScale(outV3) {
    let fs = this.m_localFS32;
    outV3.x = fs[0];
    outV3.y = fs[5];
    outV3.z = fs[10];
  }

  setRotationEulerAngle(radianX, radianY, radianZ) {
    let fs = this.m_localFS32; //let sx:number = fs[0];
    //let sy:number = fs[5];
    //let sz:number = fs[10];

    let cosX = Math.cos(radianX);
    let sinX = Math.sin(radianX);
    let cosY = Math.cos(radianY);
    let sinY = Math.sin(radianY);
    let cosZ = Math.cos(radianZ);
    let sinZ = Math.sin(radianZ);
    let cosZsinY = cosZ * sinY;
    let sinZsinY = sinZ * sinY;
    let cosYscaleX = cosY * fs[0];
    let sinXscaleY = sinX * fs[5];
    let cosXscaleY = cosX * fs[5];
    let cosXscaleZ = cosX * fs[10];
    let sinXscaleZ = sinX * fs[10];
    fs[1] = sinZ * cosYscaleX;
    fs[2] = -sinY * fs[0];
    fs[0] = cosZ * cosYscaleX;
    fs[4] = cosZsinY * sinXscaleY - sinZ * cosXscaleY;
    fs[8] = cosZsinY * cosXscaleZ + sinZ * sinXscaleZ;
    fs[5] = sinZsinY * sinXscaleY + cosZ * cosXscaleY;
    fs[9] = sinZsinY * cosXscaleZ - cosZ * sinXscaleZ;
    fs[6] = cosY * sinXscaleY;
    fs[10] = cosY * cosXscaleZ;
  }

  setRotationEulerAngle2(cosX, sinX, cosY, sinY, cosZ, sinZ) {
    let fs = this.m_localFS32; //let sx:number = fs[0];
    //let sy:number = fs[5];
    //let sz:number = fs[10];
    //	let cosX: number = Math.cos(radianX);
    //	let sinX:number = Math.sin(radianX);
    //	let cosY:number = Math.cos(radianY);
    //	let sinY:number = Math.sin(radianY);
    //	let cosZ:number = Math.cos(radianZ);
    //	let sinZ:number = Math.sin(radianZ);

    let cosZsinY = cosZ * sinY;
    let sinZsinY = sinZ * sinY;
    let cosYscaleX = cosY * fs[0];
    let sinXscaleY = sinX * fs[5];
    let cosXscaleY = cosX * fs[5];
    let cosXscaleZ = cosX * fs[10];
    let sinXscaleZ = sinX * fs[10];
    fs[1] = sinZ * cosYscaleX;
    fs[2] = -sinY * fs[0];
    fs[0] = cosZ * cosYscaleX;
    fs[4] = cosZsinY * sinXscaleY - sinZ * cosXscaleY;
    fs[8] = cosZsinY * cosXscaleZ + sinZ * sinXscaleZ;
    fs[5] = sinZsinY * sinXscaleY + cosZ * cosXscaleY;
    fs[9] = sinZsinY * cosXscaleZ - cosZ * sinXscaleZ;
    fs[6] = cosY * sinXscaleY;
    fs[10] = cosY * cosXscaleZ;
  }

  compose(position, quaternion, scale) {
    const fs = this.m_localFS32;
    const x = quaternion.x,
          y = quaternion.y,
          z = quaternion.z,
          w = quaternion.w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    fs[0] = (1 - (yy + zz)) * sx;
    fs[1] = (xy + wz) * sx;
    fs[2] = (xz - wy) * sx;
    fs[3] = 0;
    fs[4] = (xy - wz) * sy;
    fs[5] = (1 - (xx + zz)) * sy;
    fs[6] = (yz + wx) * sy;
    fs[7] = 0;
    fs[8] = (xz + wy) * sz;
    fs[9] = (yz - wx) * sz;
    fs[10] = (1 - (xx + yy)) * sz;
    fs[11] = 0;
    fs[12] = position.x;
    fs[13] = position.y;
    fs[14] = position.z;
    fs[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(Vector3D_1.default.ZERO, q, Vector3D_1.default.ONE);
  }

  makeRotationFromEuler(euler) {
    if (euler == null) {
      console.error('Matrix4::makeRotationFromEuler() now expects a Euler rotation rather than a Vector3D and order.');
    }

    const fs = this.m_localFS32;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === EulerOrder_1.EulerOrder.XYZ) {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      fs[0] = c * e;
      fs[4] = -c * f;
      fs[8] = d;
      fs[1] = af + be * d;
      fs[5] = ae - bf * d;
      fs[9] = -b * c;
      fs[2] = bf - ae * d;
      fs[6] = be + af * d;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.YXZ) {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      fs[0] = ce + df * b;
      fs[4] = de * b - cf;
      fs[8] = a * d;
      fs[1] = a * f;
      fs[5] = a * e;
      fs[9] = -b;
      fs[2] = cf * b - de;
      fs[6] = df + ce * b;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.ZXY) {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      fs[0] = ce - df * b;
      fs[4] = -a * f;
      fs[8] = de + cf * b;
      fs[1] = cf + de * b;
      fs[5] = a * e;
      fs[9] = df - ce * b;
      fs[2] = -a * d;
      fs[6] = b;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.ZYX) {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      fs[0] = c * e;
      fs[4] = be * d - af;
      fs[8] = ae * d + bf;
      fs[1] = c * f;
      fs[5] = bf * d + ae;
      fs[9] = af * d - be;
      fs[2] = -d;
      fs[6] = b * c;
      fs[10] = a * c;
    } else if (euler.order === EulerOrder_1.EulerOrder.YZX) {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      fs[0] = c * e;
      fs[4] = bd - ac * f;
      fs[8] = bc * f + ad;
      fs[1] = f;
      fs[5] = a * e;
      fs[9] = -b * e;
      fs[2] = -d * e;
      fs[6] = ad * f + bc;
      fs[10] = ac - bd * f;
    } else if (euler.order === EulerOrder_1.EulerOrder.XZY) {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      fs[0] = c * e;
      fs[4] = -f;
      fs[8] = d * e;
      fs[1] = ac * f + bd;
      fs[5] = a * e;
      fs[9] = ad * f - bc;
      fs[2] = bc * f - ad;
      fs[6] = b * e;
      fs[10] = bd * f + ac;
    } // reset bottom row


    fs[3] = 0;
    fs[7] = 0;
    fs[11] = 0; // reset last column

    fs[12] = 0;
    fs[13] = 0;
    fs[14] = 0;
    fs[15] = 1;
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const fs = this.m_localFS32;
    const me = m.getLocalFS32();
    const v3 = Matrix4.m_v3;
    m.copyColumnTo(0, v3);
    const scaleX = 1.0 / v3.getLength();
    m.copyColumnTo(1, v3);
    const scaleY = 1.0 / v3.getLength();
    m.copyColumnTo(2, v3);
    const scaleZ = 1.0 / v3.getLength();
    fs[0] = me[0] * scaleX;
    fs[1] = me[1] * scaleX;
    fs[2] = me[2] * scaleX;
    fs[3] = 0;
    fs[4] = me[4] * scaleY;
    fs[5] = me[5] * scaleY;
    fs[6] = me[6] * scaleY;
    fs[7] = 0;
    fs[8] = me[8] * scaleZ;
    fs[9] = me[9] * scaleZ;
    fs[10] = me[10] * scaleZ;
    fs[11] = 0;
    fs[12] = 0;
    fs[13] = 0;
    fs[14] = 0;
    fs[15] = 1;
    return this;
  }

  copyTranslation(m) {
    const fs = this.m_localFS32,
          me = m.getLocalFS32();
    fs[12] = me[12];
    fs[13] = me[13];
    fs[14] = me[14];
    return this;
  }

  setTranslationXYZ(px, py, pz) {
    this.m_localFS32[12] = px;
    this.m_localFS32[13] = py;
    this.m_localFS32[14] = pz;
  }

  setTranslation(v3) {
    this.m_localFS32[12] = v3.x;
    this.m_localFS32[13] = v3.y;
    this.m_localFS32[14] = v3.z;
  }

  appendScaleXYZ(xScale, yScale, zScale) {
    const fs = this.m_localFS32;
    fs[0] *= xScale;
    fs[1] *= xScale;
    fs[2] *= xScale;
    fs[3] *= xScale;
    fs[4] *= yScale;
    fs[5] *= yScale;
    fs[6] *= yScale;
    fs[7] *= yScale;
    fs[8] *= zScale;
    fs[9] *= zScale;
    fs[10] *= zScale;
    fs[11] *= zScale;
  }

  appendScaleXY(xScale, yScale) {
    const fs = this.m_localFS32;
    fs[0] *= xScale;
    fs[1] *= xScale;
    fs[2] *= xScale;
    fs[3] *= xScale;
    fs[4] *= yScale;
    fs[5] *= yScale;
    fs[6] *= yScale;
    fs[7] *= yScale;
  }

  appendTranslationXYZ(px, py, pz) {
    this.m_localFS32[12] += px;
    this.m_localFS32[13] += py;
    this.m_localFS32[14] += pz;
  }

  appendTranslation(v3) {
    this.m_localFS32[12] += v3.x;
    this.m_localFS32[13] += v3.y;
    this.m_localFS32[14] += v3.z;
  }

  copyColumnFrom(column_index, v3) {
    const fs = this.m_localFS32;

    switch (column_index) {
      case 0:
        {
          fs[0] = v3.x;
          fs[1] = v3.y;
          fs[2] = v3.z;
          fs[3] = v3.w;
        }
        break;

      case 1:
        {
          fs[4] = v3.x;
          fs[5] = v3.y;
          fs[6] = v3.z;
          fs[7] = v3.w;
        }
        break;

      case 2:
        {
          fs[8] = v3.x;
          fs[9] = v3.y;
          fs[10] = v3.z;
          fs[11] = v3.w;
        }
        break;

      case 3:
        {
          fs[12] = v3.x;
          fs[13] = v3.y;
          fs[14] = v3.z;
          fs[15] = v3.w;
        }
        break;

      default:
        break;
    }
  }

  copyColumnTo(column_index, outV3) {
    const fs = this.m_localFS32;
    column_index <<= 2;
    outV3.x = fs[column_index];
    outV3.y = fs[1 + column_index];
    outV3.z = fs[2 + column_index];
    outV3.w = fs[3 + column_index];
  }

  setF32ArrAndIndex(fs32Arr, index = 0) {
    if (fs32Arr != null && index >= 0) {
      this.m_fs32 = fs32Arr;
      this.m_index = index;
      this.m_localFS32 = this.m_fs32.subarray(index, index + 16);
    }
  }

  setF32ArrIndex(index = 0) {
    if (index >= 0) {
      this.m_index = index;
      this.m_localFS32 = this.m_fs32.subarray(index, index + 16);
    }
  }

  setF32Arr(fs32Arr) {
    if (fs32Arr != null) {
      this.m_fs32 = fs32Arr;
    }
  }

  copyFromF32Arr(fs32Arr, index = 0) {
    //let subArr:Float32Array = fs32Arr.subarray(index, index + 16);
    //this.m_localFS32.set(fs32Arr.subarray(index, index + 16), 0);
    let i = 0;

    for (let end = index + 16; index < end; index++) {
      this.m_localFS32[i] = fs32Arr[index];
      ++i;
    }
  }

  copyToF32Arr(fs32Arr, index = 0) {
    fs32Arr.set(this.m_localFS32, index);
  }

  copy(smat) {
    this.m_localFS32.set(smat.getLocalFS32(), 0);
    return this;
  }

  copyFrom(smat) {
    this.m_localFS32.set(smat.getLocalFS32(), 0);
  }

  copyTo(dmat) {
    //dmat.copyFrom(this);
    dmat.getLocalFS32().set(this.getLocalFS32(), 0);
  }

  copyRawDataFrom(float_rawDataArr, rawDataLength = 16, index = 0, bool_tp = false) {
    if (bool_tp) this.transpose();
    rawDataLength = rawDataLength - index;
    let c = 0;

    while (c < rawDataLength) {
      this.m_fs32[this.m_index + c] = float_rawDataArr[c + index];
      ++c;
    }

    if (bool_tp) this.transpose();
  }

  copyRawDataTo(float_rawDataArr, rawDataLength = 16, index = 0, bool_tp = false) {
    if (bool_tp) this.transpose();
    let c = 0;

    while (c < rawDataLength) {
      float_rawDataArr[c + index] = this.m_fs32[this.m_index + c];
      ++c;
    }

    if (bool_tp) this.transpose();
  }

  copyRowFrom(row_index, v3) {
    const fs = this.m_localFS32;

    switch (row_index) {
      case 0:
        {
          fs[0] = v3.x;
          fs[4] = v3.y;
          fs[8] = v3.z;
          fs[12] = v3.w;
        }
        break;

      case 1:
        {
          fs[1] = v3.x;
          fs[5] = v3.y;
          fs[9] = v3.z;
          fs[13] = v3.w;
        }
        break;

      case 2:
        {
          fs[2] = v3.x;
          fs[6] = v3.y;
          fs[10] = v3.z;
          fs[14] = v3.w;
        }
        break;

      case 3:
        {
          fs[3] = v3.x;
          fs[7] = v3.y;
          fs[11] = v3.z;
          fs[15] = v3.w;
        }
        break;

      default:
        break;
    }
  }

  copyRowTo(row_index, v3) {
    const fs = this.m_localFS32;
    v3.x = fs[row_index];
    v3.y = fs[4 + row_index];
    v3.z = fs[8 + row_index];
    v3.w = fs[12 + row_index];
  }
  /**
   * @param orientationStyle the value example: OrientationType.EULER_ANGLES
   * @returns [position, rotation, scale]
   */


  decompose(orientationStyle) {
    // TODO: optimize after 4 lines
    let vec = [];
    let mr = Matrix4.s_tMat4;
    let rfs = mr.getLocalFS32(); //let mrfsI = mr.getFSIndex();
    //std::memcpy(&mr, m_rawData, m_rawDataSize);

    mr.copyFrom(this); ///*

    let pos = new Vector3D_1.default(rfs[12], rfs[13], rfs[14]);
    let scale = new Vector3D_1.default();
    scale.x = Math.sqrt(rfs[0] * rfs[0] + rfs[1] * rfs[1] + rfs[2] * rfs[2]);
    scale.y = Math.sqrt(rfs[4] * rfs[4] + rfs[5] * rfs[5] + rfs[6] * rfs[6]);
    scale.z = Math.sqrt(rfs[8] * rfs[8] + rfs[9] * rfs[9] + rfs[10] * rfs[10]);
    if (rfs[0] * (rfs[5] * rfs[10] - rfs[6] * rfs[9]) - rfs[1] * (rfs[4] * rfs[10] - rfs[6] * rfs[8]) + rfs[2] * (rfs[4] * rfs[9] - rfs[5] * rfs[8]) < 0) scale.z = -scale.z;
    rfs[0] /= scale.x;
    rfs[1] /= scale.x;
    rfs[2] /= scale.x;
    rfs[4] /= scale.y;
    rfs[5] /= scale.y;
    rfs[6] /= scale.y;
    rfs[8] /= scale.z;
    rfs[9] /= scale.z;
    rfs[10] /= scale.z;
    let rot = new Vector3D_1.default();

    switch (orientationStyle) {
      case OrientationType_1.default.AXIS_ANGLE:
        {
          rot.w = MathConst_1.default.SafeACos((rfs[0] + rfs[5] + rfs[10] - 1) / 2);
          let len = Math.sqrt((rfs[6] - rfs[9]) * (rfs[6] - rfs[9]) + (rfs[8] - rfs[2]) * (rfs[8] - rfs[2]) + (rfs[1] - rfs[4]) * (rfs[1] - rfs[4]));

          if (len > MathConst_1.default.MATH_MIN_POSITIVE) {
            rot.x = (rfs[6] - rfs[9]) / len;
            rot.y = (rfs[8] - rfs[2]) / len;
            rot.z = (rfs[1] - rfs[4]) / len;
          } else rot.x = rot.y = rot.z = 0;
        }
        break;

      case OrientationType_1.default.QUATERNION:
        {
          let tr = rfs[0] + rfs[5] + rfs[10];

          if (tr > 0) {
            rot.w = Math.sqrt(1 + tr) / 2;
            rot.x = (rfs[6] - rfs[9]) / (4 * rot.w);
            rot.y = (rfs[8] - rfs[2]) / (4 * rot.w);
            rot.z = (rfs[1] - rfs[4]) / (4 * rot.w);
          } else if (rfs[0] > rfs[5] && rfs[0] > rfs[10]) {
            rot.x = Math.sqrt(1 + rfs[0] - rfs[5] - rfs[10]) / 2;
            rot.w = (rfs[6] - rfs[9]) / (4 * rot.x);
            rot.y = (rfs[1] + rfs[4]) / (4 * rot.x);
            rot.z = (rfs[8] + rfs[2]) / (4 * rot.x);
          } else if (rfs[5] > rfs[10]) {
            rot.y = Math.sqrt(1 + rfs[5] - rfs[0] - rfs[10]) / 2;
            rot.x = (rfs[1] + rfs[4]) / (4 * rot.y);
            rot.w = (rfs[8] - rfs[2]) / (4 * rot.y);
            rot.z = (rfs[6] + rfs[9]) / (4 * rot.y);
          } else {
            rot.z = Math.sqrt(1 + rfs[10] - rfs[0] - rfs[5]) / 2;
            rot.x = (rfs[8] + rfs[2]) / (4 * rot.z);
            rot.y = (rfs[6] + rfs[9]) / (4 * rot.z);
            rot.w = (rfs[1] - rfs[4]) / (4 * rot.z);
          }
        }
        break;

      case OrientationType_1.default.EULER_ANGLES:
        {
          rot.y = Math.asin(-rfs[2]);

          if (rfs[2] != 1 && rfs[2] != -1) {
            rot.x = Math.atan2(rfs[6], rfs[10]);
            rot.z = Math.atan2(rfs[1], rfs[0]);
          } else {
            rot.z = 0;
            rot.x = Math.atan2(rfs[4], rfs[5]);
          }
        }
        break;

      default:
        break;
    }

    ;
    vec.push(pos);
    vec.push(rot);
    vec.push(scale);
    mr = null;
    return vec;
  }

  invert() {
    let d = this.determinant();
    let invertable = Math.abs(d) > MathConst_1.default.MATH_MIN_POSITIVE;

    if (invertable) {
      let fs = this.m_localFS32;
      d = 1.0 / d;
      let m11 = fs[0];
      let m21 = fs[4];
      let m31 = fs[8];
      let m41 = fs[12];
      let m12 = fs[1];
      let m22 = fs[5];
      let m32 = fs[9];
      let m42 = fs[13];
      let m13 = fs[2];
      let m23 = fs[6];
      let m33 = fs[10];
      let m43 = fs[14];
      let m14 = fs[3];
      let m24 = fs[7];
      let m34 = fs[11];
      let m44 = fs[15];
      fs[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
      fs[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
      fs[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
      fs[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
      fs[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
      fs[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
      fs[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
      fs[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
      fs[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
      fs[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
      fs[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
      fs[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
      fs[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
      fs[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
      fs[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
      fs[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
    }

    ;
    return invertable;
  }

  invertThis() {
    this.invert();
    return this;
  }

  pointAt(pos, at, up) {
    //TODO: need optimize
    if (at == null) at = new Vector3D_1.default(0.0, 0.0, -1.0);
    if (up == null) up = new Vector3D_1.default(0.0, -1.0, 0.0);
    let dir = at.subtract(pos);
    let vup = up.clone(); //Vector3D right;

    dir.normalize();
    vup.normalize();
    let dir2 = dir.clone().scaleBy(vup.dot(dir));
    vup.subtractBy(dir2);
    if (vup.getLength() > MathConst_1.default.MATH_MIN_POSITIVE) vup.normalize();else if (dir.x != 0) vup.setTo(-dir.y, dir.x, 0);else vup.setTo(1, 0, 0);
    let right = vup.crossProduct(dir);
    right.normalize();
    let fs = this.m_localFS32;
    fs[0] = right.x;
    fs[4] = right.y;
    fs[8] = right.z;
    fs[12] = 0.0;
    fs[1] = vup.x;
    fs[5] = vup.y;
    fs[9] = vup.z;
    fs[13] = 0.0;
    fs[2] = dir.x;
    fs[6] = dir.y;
    fs[10] = dir.z;
    fs[14] = 0.0;
    fs[3] = pos.x;
    fs[7] = pos.y;
    fs[11] = pos.z;
    fs[15] = 1.0;
  }

  prepend(rhs) {
    let rfs32 = rhs.getLocalFS32();
    let fs = this.m_localFS32;
    let m111 = rfs32[0];
    let m121 = rfs32[4];
    let m131 = rfs32[8];
    let m141 = rfs32[12];
    let m112 = rfs32[1];
    let m122 = rfs32[5];
    let m132 = rfs32[9];
    let m142 = rfs32[13];
    let m113 = rfs32[2];
    let m123 = rfs32[6];
    let m133 = rfs32[10];
    let m143 = rfs32[14];
    let m114 = rfs32[3];
    let m124 = rfs32[7];
    let m134 = rfs32[11];
    let m144 = rfs32[15];
    let m211 = fs[0];
    let m221 = fs[4];
    let m231 = fs[8];
    let m241 = fs[12];
    let m212 = fs[1];
    let m222 = fs[5];
    let m232 = fs[9];
    let m242 = fs[13];
    let m213 = fs[2];
    let m223 = fs[6];
    let m233 = fs[10];
    let m243 = fs[14];
    let m214 = fs[3];
    let m224 = fs[7];
    let m234 = fs[11];
    let m244 = fs[15];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
    fs[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
    fs[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
    fs[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
    fs[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
    fs[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
    fs[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
    fs[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
  }

  prepend3x3(rhs) {
    let rfs32 = rhs.getLocalFS32();
    let fs = this.m_localFS32;
    let m111 = rfs32[0];
    let m121 = rfs32[4];
    let m131 = rfs32[8];
    let m112 = rfs32[1];
    let m122 = rfs32[5];
    let m132 = rfs32[9];
    let m113 = rfs32[2];
    let m123 = rfs32[6];
    let m133 = rfs32[10];
    let m211 = fs[0];
    let m221 = fs[4];
    let m231 = fs[8];
    let m212 = fs[1];
    let m222 = fs[5];
    let m232 = fs[9];
    let m213 = fs[2];
    let m223 = fs[6];
    let m233 = fs[10];
    fs[0] = m111 * m211 + m112 * m221 + m113 * m231;
    fs[1] = m111 * m212 + m112 * m222 + m113 * m232;
    fs[2] = m111 * m213 + m112 * m223 + m113 * m233;
    fs[4] = m121 * m211 + m122 * m221 + m123 * m231;
    fs[5] = m121 * m212 + m122 * m222 + m123 * m232;
    fs[6] = m121 * m213 + m122 * m223 + m123 * m233;
    fs[8] = m131 * m211 + m132 * m221 + m133 * m231;
    fs[9] = m131 * m212 + m132 * m222 + m133 * m232;
    fs[10] = m131 * m213 + m132 * m223 + m133 * m233;
  }

  prependRotationPivot(radian, axis, pivotPoint) {
    Matrix4.s_tMat4.identity();
    Matrix4.s_tMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    Matrix4.s_tMat4.appendTranslationXYZ(pivotPoint.x, pivotPoint.y, pivotPoint.z);
    this.prepend(Matrix4.s_tMat4);
  }

  prependRotation(radian, axis) {
    Matrix4.s_tMat4.identity();
    Matrix4.s_tMat4.getAxisRotation(axis.x, axis.y, axis.z, radian);
    this.prepend(Matrix4.s_tMat4);
  }

  prependRotationX(radian) {
    //s_tempMat.identity();
    Matrix4.s_tMat4.rotationX(radian);
    this.prepend3x3(Matrix4.s_tMat4);
  }

  prependRotationY(radian) {
    //s_tempMat.identity();
    Matrix4.s_tMat4.rotationY(radian);
    this.prepend3x3(Matrix4.s_tMat4);
  }

  prependRotationZ(radian) {
    //s_tempMat.identity();
    Matrix4.s_tMat4.rotationZ(radian);
    this.prepend3x3(Matrix4.s_tMat4);
  } // 用欧拉角形式旋转(heading->pitch->bank) => (y->x->z)


  prependRotationEulerAngle(radianX, radianY, radianZ) {
    //s_tempMat.identity();
    Matrix4.s_tMat4.rotationY(radianY);
    this.prepend3x3(Matrix4.s_tMat4); //s_tempMat.identity();

    Matrix4.s_tMat4.rotationX(radianX);
    this.prepend3x3(Matrix4.s_tMat4); //s_tempMat.identity();

    Matrix4.s_tMat4.rotationZ(radianZ);
    this.prepend3x3(Matrix4.s_tMat4);
  }

  prependScale(xScale, yScale, zScale) {
    const fs = this.m_localFS32;
    fs[0] *= xScale;
    fs[1] *= yScale;
    fs[2] *= zScale;
    fs[4] *= xScale;
    fs[5] *= yScale;
    fs[6] *= zScale;
    fs[8] *= xScale;
    fs[9] *= yScale;
    fs[10] *= zScale;
    fs[12] *= xScale;
    fs[13] *= yScale;
    fs[14] *= zScale;
  }

  prependScaleXY(xScale, yScale) {
    const fs = this.m_localFS32;
    fs[0] *= xScale;
    fs[1] *= yScale;
    fs[4] *= xScale;
    fs[5] *= yScale;
    fs[8] *= xScale;
    fs[9] *= yScale;
    fs[12] *= xScale;
    fs[13] *= yScale;
  }

  prependTranslationXYZ(px, py, pz) {
    Matrix4.s_tMat4.identity(); //Matrix4.s_tMat4.setPositionXYZ(px, py, pz);

    this.prepend(Matrix4.s_tMat4);
  }

  prependTranslation(v3) {
    Matrix4.s_tMat4.identity(); //Matrix4.s_tMat4.setPositionXYZ(v3.x, v3.y, v3.z);

    this.prepend(Matrix4.s_tMat4);
  }

  recompose(components, orientationStyle) {
    if (components.length < 3 || components[2].x == 0 || components[2].y == 0 || components[2].z == 0) return false;
    this.identity();
    let scale = Matrix4.s_tMat4.getFS32();
    scale[0] = scale[1] = scale[2] = components[2].x;
    scale[4] = scale[5] = scale[6] = components[2].y;
    scale[8] = scale[9] = scale[10] = components[2].z;
    let fs = this.m_localFS32;

    switch (orientationStyle) {
      case OrientationType_1.default.EULER_ANGLES:
        {
          let cx = Math.cos(components[1].x);
          let cy = Math.cos(components[1].y);
          let cz = Math.cos(components[1].z);
          let sx = Math.sin(components[1].x);
          let sy = Math.sin(components[1].y);
          let sz = Math.sin(components[1].z);
          fs[0] = cy * cz * scale[0];
          fs[1] = cy * sz * scale[1];
          fs[2] = -sy * scale[2];
          fs[3] = 0;
          fs[4] = (sx * sy * cz - cx * sz) * scale[4];
          fs[5] = (sx * sy * sz + cx * cz) * scale[5];
          fs[6] = sx * cy * scale[6];
          fs[7] = 0;
          fs[8] = (cx * sy * cz + sx * sz) * scale[8];
          fs[9] = (cx * sy * sz - sx * cz) * scale[9];
          fs[10] = cx * cy * scale[10];
          fs[11] = 0;
          fs[12] = components[0].x;
          fs[13] = components[0].y;
          fs[14] = components[0].z;
          fs[15] = 1;
        }
        break;

      default:
        {
          let x = components[1].x;
          let y = components[1].y;
          let z = components[1].z;
          let w = components[1].w;

          if (orientationStyle == OrientationType_1.default.AXIS_ANGLE) {
            let halfW = 0.5 * w;
            x *= Math.sin(halfW);
            y *= Math.sin(halfW);
            z *= Math.sin(halfW);
            w = Math.cos(halfW);
          }

          ;
          fs[0] = (1 - 2 * y * y - 2 * z * z) * scale[0];
          fs[1] = (2 * x * y + 2 * w * z) * scale[1];
          fs[2] = (2 * x * z - 2 * w * y) * scale[2];
          fs[3] = 0;
          fs[4] = (2 * x * y - 2 * w * z) * scale[4];
          fs[5] = (1 - 2 * x * x - 2 * z * z) * scale[5];
          fs[6] = (2 * y * z + 2 * w * x) * scale[6];
          fs[7] = 0;
          fs[8] = (2 * x * z + 2 * w * y) * scale[8];
          fs[9] = (2 * y * z - 2 * w * x) * scale[9];
          fs[10] = (1 - 2 * x * x - 2 * y * y) * scale[10];
          fs[11] = 0;
          fs[12] = components[0].x;
          fs[13] = components[0].y;
          fs[14] = components[0].z;
          fs[15] = 1;
        }
        break;
    }

    ; //TODO: need thinking

    if (components[2].x == 0) this.m_localFS32[0] = 0; // 1e-15;

    if (components[2].y == 0) this.m_localFS32[5] = 0; // 1e-15;

    if (components[2].z == 0) this.m_localFS32[10] = 0; // 1e-15;

    scale = null;
    return true;
  }

  setThreeAxes(x_axis, y_axis, z_axis) {
    let vs = this.m_localFS32;
    vs[0] = x_axis.x;
    vs[1] = x_axis.y;
    vs[2] = x_axis.z;
    vs[4] = y_axis.x;
    vs[5] = y_axis.y;
    vs[6] = y_axis.z;
    vs[8] = z_axis.x;
    vs[9] = z_axis.y;
    vs[10] = z_axis.z;
  }

  deltaTransformVector(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    return new Vector3D_1.default(x * this.m_localFS32[0] + y * this.m_localFS32[4] + z * this.m_localFS32[8], x * this.m_localFS32[1] + y * this.m_localFS32[5] + z * this.m_localFS32[9], x * this.m_localFS32[2] + y * this.m_localFS32[6] + z * this.m_localFS32[10], 0.0);
  }

  deltaTransformVectorSelf(v3) {
    let fs = this.m_localFS32;
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    v3.x = x * fs[0] + y * fs[4] + z * fs[8];
    v3.y = x * fs[1] + y * fs[5] + z * fs[9];
    v3.z = x * fs[2] + y * fs[6] + z * fs[10];
  }

  deltaTransformOutVector(v3, out_v3) {
    let fs = this.m_localFS32;
    out_v3.x = v3.x * fs[0] + v3.y * fs[4] + v3.z * fs[8];
    out_v3.y = v3.x * fs[1] + v3.y * fs[5] + v3.z * fs[9];
    out_v3.z = v3.x * fs[2] + v3.y * fs[6] + v3.z * fs[10];
  }

  transformVector(v3) {
    let fs = this.m_localFS32;
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    return new Vector3D_1.default(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformOutVector(v3, out_v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.m_localFS32;
    out_v3.setTo(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformOutVector3(v3, out_v3) {
    let fs = this.m_localFS32;
    out_v3.x = v3.x * fs[0] + v3.y * fs[4] + v3.z * fs[8] + fs[12];
    out_v3.y = v3.x * fs[1] + v3.y * fs[5] + v3.z * fs[9] + fs[13];
    out_v3.z = v3.x * fs[2] + v3.y * fs[6] + v3.z * fs[10] + fs[14];
  }

  transformVector3Self(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.m_localFS32;
    v3.x = x * fs[0] + y * fs[4] + z * fs[8] + fs[12];
    v3.y = x * fs[1] + y * fs[5] + z * fs[9] + fs[13];
    v3.z = x * fs[2] + y * fs[6] + z * fs[10] + fs[14];
  }

  transformVectorSelf(v3) {
    let x = v3.x;
    let y = v3.y;
    let z = v3.z;
    let fs = this.m_localFS32;
    v3.setTo(x * fs[0] + y * fs[4] + z * fs[8] + fs[12], x * fs[1] + y * fs[5] + z * fs[9] + fs[13], x * fs[2] + y * fs[6] + z * fs[10] + fs[14], x * fs[3] + y * fs[7] + z * fs[11] + fs[15]);
  }

  transformVectors(float_vinArr, vinLength, float_voutArr) {
    let i = 0;
    let x, y, z;
    let pfs = this.m_localFS32;
    vinLength -= 3;

    while (i <= vinLength) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_voutArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_voutArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_voutArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transformVectorsSelf(float_vinArr, vinLength) {
    let i = 0;
    let x, y, z;
    let pfs = this.m_localFS32;
    vinLength -= 3;

    while (i <= vinLength) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_vinArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_vinArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_vinArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transformVectorsRangeSelf(float_vinArr, begin, end) {
    let i = begin;
    let x, y, z;
    let pfs = this.m_localFS32;
    end -= 3;

    while (i <= end) {
      x = float_vinArr[i];
      y = float_vinArr[i + 1];
      z = float_vinArr[i + 2];
      float_vinArr[i] = x * pfs[0] + y * pfs[4] + z * pfs[8] + pfs[12];
      float_vinArr[i + 1] = x * pfs[1] + y * pfs[5] + z * pfs[9] + pfs[13];
      float_vinArr[i + 2] = x * pfs[2] + y * pfs[6] + z * pfs[10] + pfs[14];
      i += 3;
    }
  }

  transpose() {
    Matrix4.s_tMat4.copyFrom(this);
    let fs32 = Matrix4.s_tMat4.getFS32();
    let fs = this.m_localFS32;
    fs[1] = fs32[4];
    fs[2] = fs32[8];
    fs[3] = fs32[12];
    fs[4] = fs32[1];
    fs[6] = fs32[9];
    fs[7] = fs32[13];
    fs[8] = fs32[2];
    fs[9] = fs32[6];
    fs[11] = fs32[14];
    fs[12] = fs32[3];
    fs[13] = fs32[7];
    fs[14] = fs32[11];
  }

  interpolateTo(toMat, float_percent) {
    let fs32 = toMat.getFS32();
    let fsI = toMat.getFSIndex();
    let _g = 0;
    let i = this.m_index;

    while (_g < 16) {
      this.m_fs32[i] += (fs32[fsI + _g] - this.m_fs32[i]) * float_percent;
      ++i;
      ++_g;
    }
  }

  getAxisRotation(x, y, z, radian) {
    radian = -radian;
    let fs = this.m_localFS32;
    let s = Math.sin(radian),
        c = Math.cos(radian);
    let t = 1.0 - c;
    fs[0] = c + x * x * t;
    fs[5] = c + y * y * t;
    fs[10] = c + z * z * t;
    let tmp1 = x * y * t;
    let tmp2 = z * s;
    fs[4] = tmp1 + tmp2;
    fs[1] = tmp1 - tmp2;
    tmp1 = x * z * t;
    tmp2 = y * s;
    fs[8] = tmp1 - tmp2;
    fs[2] = tmp1 + tmp2;
    tmp1 = y * z * t;
    tmp2 = x * s;
    fs[9] = tmp1 + tmp2;
    fs[6] = tmp1 - tmp2;
  }

  rotationX(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.m_localFS32[0] = 1.0;
    this.m_localFS32[1] = 0.0;
    this.m_localFS32[2] = 0.0;
    this.m_localFS32[4] = 0.0;
    this.m_localFS32[5] = c;
    this.m_localFS32[6] = s;
    this.m_localFS32[8] = 0.0;
    this.m_localFS32[9] = -s;
    this.m_localFS32[10] = c;
  }

  rotationY(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.m_localFS32[0] = c;
    this.m_localFS32[1] = 0.0;
    this.m_localFS32[2] = -s;
    this.m_localFS32[4] = 0.0;
    this.m_localFS32[5] = 1.0;
    this.m_localFS32[6] = 0.0;
    this.m_localFS32[8] = s;
    this.m_localFS32[9] = 0.0;
    this.m_localFS32[10] = c;
  }

  rotationZ(radian) {
    let s = Math.sin(radian),
        c = Math.cos(radian);
    this.m_localFS32[0] = c;
    this.m_localFS32[1] = s;
    this.m_localFS32[2] = 0.0;
    this.m_localFS32[4] = -s;
    this.m_localFS32[5] = c;
    this.m_localFS32[6] = 0.0;
    this.m_localFS32[8] = 0.0;
    this.m_localFS32[9] = 0.0;
    this.m_localFS32[10] = 1.0;
  } /////////////////////////////////////////////////////////////


  toString() {
    let str = "\n" + this.m_localFS32[0] + "," + this.m_localFS32[1] + "," + this.m_localFS32[2] + "," + this.m_localFS32[3] + "\n";
    str += this.m_localFS32[4] + "," + this.m_localFS32[5] + "," + this.m_localFS32[6] + "," + this.m_localFS32[7] + "\n";
    str += this.m_localFS32[8] + "," + this.m_localFS32[9] + "," + this.m_localFS32[10] + "," + this.m_localFS32[11] + "\n";
    str += this.m_localFS32[12] + "," + this.m_localFS32[13] + "," + this.m_localFS32[14] + "," + this.m_localFS32[15] + "\n";
    return str;
  }

  transformPerspV4Self(v4) {
    const fs = this.m_localFS32;
    v4.w = v4.z;
    v4.x *= fs[0];
    v4.y *= fs[5];
    v4.z *= fs[10];
    v4.z += fs[14];
    v4.w *= fs[11];
    v4.w += fs[15];
  }

  clone() {
    let m = new Matrix4();
    m.copyFrom(this);
    return m;
  } ///////
  // view etc..
  ///////////////////////////////////////////


  perspectiveRH(fovy, aspect, zNear, zFar) {
    //assert(abs(aspect - std::numeric_limits<float>::epsilon()) > minFloatValue)
    const fs = this.m_localFS32;
    let tanHalfFovy = Math.tan(fovy * 0.5);
    this.identity();
    fs[0] = 1.0 / (aspect * tanHalfFovy);
    fs[5] = 1.0 / tanHalfFovy;
    fs[10] = -(zFar + zNear) / (zFar - zNear);
    fs[11] = -1.0;
    fs[14] = -(2.0 * zFar * zNear) / (zFar - zNear);
  }

  perspectiveRH2(fovy, pw, ph, zNear, zFar) {
    let focalLength = pw / Math.tan(fovy * 0.5);
    let m0 = focalLength / pw;
    let m5 = focalLength / ph;
    let m10 = -zFar / (zFar - zNear);
    let m14 = -zNear * m10;
    this.identity();
    const fs = this.m_localFS32;
    fs[0] = m0;
    fs[5] = m5;
    fs[10] = m10;
    fs[11] = -1.0;
    fs[14] = m14;
  }

  orthoRH(b, t, l, r, zNear, zFar) {
    this.identity();
    const fs = this.m_localFS32;
    fs[0] = 2.0 / (r - l);
    fs[5] = 2.0 / (t - b);
    fs[10] = -2.0 / (zFar - zNear);
    fs[12] = -(r + l) / (r - l);
    fs[13] = -(t + b) / (t - b);
    fs[14] = -(zFar + zNear) / (zFar - zNear);
    fs[15] = 1.0;
  }

  perspectiveLH(fovy, aspect, zNear, zFar) {
    //assert(abs(aspect - std::numeric_limits<float>::epsilon()) > minFloatValue)
    let tanHalfFovy = Math.tan(fovy * 0.5);
    this.identity();
    const fs = this.m_localFS32;
    fs[0] = 1.0 / (aspect * tanHalfFovy);
    fs[5] = 1.0 / tanHalfFovy;
    fs[10] = (zFar + zNear) / (zFar - zNear);
    fs[11] = 1.0;
    fs[14] = 2.0 * zFar * zNear / (zFar - zNear);
  }

  orthoLH(b, t, l, r, zNear, zFar) {
    this.identity();
    const fs = this.m_localFS32;
    fs[0] = 2.0 / (r - l); // / (aspect * tanHalfFovy);

    fs[5] = 2.0 / (t - b); // / tanHalfFovy;

    fs[10] = 2.0 / (zFar - zNear);
    fs[12] = -(r + l) / (r - l);
    fs[13] = -(t + b) / (t - b);
    fs[14] = -(zFar + zNear) / (zFar - zNear);
    fs[15] = 1.0;
  }

  lookAtRH(eyePos, atPos, up) {
    this.identity();
    let f = atPos.subtract(eyePos);
    f.normalize();
    let s = f.crossProduct(up);
    s.normalize();
    let u = s.crossProduct(f);
    s.w = -s.dot(eyePos);
    u.w = -u.dot(eyePos);
    f.w = f.dot(eyePos);
    f.negate();
    this.copyRowFrom(0, s);
    this.copyRowFrom(1, u);
    this.copyRowFrom(2, f);
  }

  lookAtLH(eyePos, atPos, up) {
    this.identity();
    let f = atPos.subtract(eyePos);
    f.normalize();
    let s = f.crossProduct(up);
    s.normalize();
    let u = s.crossProduct(f);
    s.w = -s.dot(eyePos);
    u.w = -u.dot(eyePos);
    f.w = -f.dot(eyePos);
    this.copyRowFrom(0, s);
    this.copyRowFrom(1, u);
    this.copyRowFrom(2, f);
  }

  destroy() {
    this.m_localFS32 = null;
    this.m_fs32 = null;
    this.m_index = -1;
  }

}

Matrix4.s_InitData = new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);
Matrix4.m_v3 = new Vector3D_1.default();
Matrix4.s_uid = 0;
Matrix4.s_isolatedUid = 0x4ffff;
Matrix4.s_tMat4 = new Matrix4();
exports.default = Matrix4;

/***/ }),

/***/ "1e15":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const RCExtension_1 = __importDefault(__webpack_require__("030e"));

class ROVtxBuilder {
  constructor() {
    this.m_rcuid = 0;
    this.m_glVer = 2;
    this.m_rc = null;
    this.RGBA = 0;
    this.UNSIGNED_BYTE = 0;
    this.TRIANGLE_STRIP = 0;
    this.TRIANGLE_FAN = 0;
    this.TRIANGLES = 0;
    this.LINES = 0;
    this.LINE_STRIP = 0;
    this.UNSIGNED_SHORT = 0;
    this.UNSIGNED_INT = 0;
    this.COLOR = 0;
    this.DEPTH = 0;
    this.STENCIL = 0;
    this.DEPTH_STENCIL = 0;
    this.MAX = 0;
    this.MIN = 0;
    this.RContext = null;
    this.vroUid = 0;
    this.rioUid = 0;
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_rc;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  createBuf() {
    return this.m_rc.createBuffer();
  }

  deleteBuf(buf) {
    this.m_rc.deleteBuffer(buf);
  }

  bindArrBuf(buf) {
    this.m_rc.bindBuffer(this.m_rc.ARRAY_BUFFER, buf);
  }

  bindEleBuf(buf) {
    this.m_rc.bindBuffer(this.m_rc.ELEMENT_ARRAY_BUFFER, buf);
  }

  arrBufSubData(float32Arr, offset) {
    this.m_rc.bufferSubData(this.m_rc.ARRAY_BUFFER, offset, float32Arr);
  }

  arrBufData(float32Arr, usage) {
    this.m_rc.bufferData(this.m_rc.ARRAY_BUFFER, float32Arr, VtxBufConst_1.default.ToGL(this.m_rc, usage));
  }

  eleBufSubData(uintDataArr, offset) {
    this.m_rc.bufferSubData(this.m_rc.ELEMENT_ARRAY_BUFFER, offset, uintDataArr);
  }

  eleBufData(uintDataArr, usage) {
    this.m_rc.bufferData(this.m_rc.ELEMENT_ARRAY_BUFFER, uintDataArr, VtxBufConst_1.default.ToGL(this.m_rc, usage));
  }

  arrBufDataMem(bytesSize, usage) {
    this.m_rc.bufferData(this.m_rc.ARRAY_BUFFER, bytesSize, VtxBufConst_1.default.ToGL(this.m_rc, usage));
  }

  eleBufDataMem(bytesSize, usage) {
    this.m_rc.bufferData(this.m_rc.ELEMENT_ARRAY_BUFFER, bytesSize, VtxBufConst_1.default.ToGL(this.m_rc, usage));
  }

  useVtxAttribsPtrTypeFloat(shdp, buf, attribTypes, attribTypesLen, wholeOffsetList, wholeStride) {
    this.m_rc.bindBuffer(this.m_rc.ARRAY_BUFFER, buf);

    for (let i = 0; i < attribTypesLen; ++i) {
      shdp.vertexAttribPointerTypeFloat(attribTypes[i], wholeStride, wholeOffsetList[i]);
    }
  }

  useVtxAttribsPtrTypeFloatMulti(shdp, bufs, attribTypes, attribTypesLen, wholeOffsetList, wholeStride) {
    for (let i = 0; i < attribTypesLen; ++i) {
      this.m_rc.bindBuffer(this.m_rc.ARRAY_BUFFER, bufs[i]);
      shdp.vertexAttribPointerTypeFloat(attribTypes[i], wholeStride, wholeOffsetList[i]);
    }
  }

  createVertexArray() {
    let vao = null;

    if (this.m_glVer == 2) {
      vao = this.m_rc.createVertexArray();
    } else {
      vao = RCExtension_1.default.OES_vertex_array_object.createVertexArrayOES();
    }

    return vao;
  }

  bindVertexArray(vao) {
    if (this.m_glVer == 2) {
      this.m_rc.bindVertexArray(vao);
    } else {
      RCExtension_1.default.OES_vertex_array_object.bindVertexArrayOES(vao);
    }

    return vao;
  }

  deleteVertexArray(vao) {
    if (this.m_glVer == 2) {
      this.m_rc.deleteVertexArray(vao);
    } else {
      RCExtension_1.default.OES_vertex_array_object.deleteVertexArrayOES(vao);
    }
  }

  testVROUid(vroUid) {
    if (this.vroUid != vroUid) {
      this.vroUid = vroUid;
      return true;
    }

    return false;
  }

  testRIOUid(rioUid) {
    if (this.rioUid != rioUid) {
      this.rioUid = rioUid;
      return true;
    }

    return false;
  }

  initialize(rcuid, gl, glVer) {
    this.m_rc = gl;
    this.m_rcuid = rcuid;
    this.m_glVer = glVer;
    let selfT = this;
    selfT.RGBA = gl.RGBA;
    selfT.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
    selfT.TRIANGLE_STRIP = gl.TRIANGLE_STRIP;
    selfT.TRIANGLE_FAN = gl.TRIANGLE_FAN;
    selfT.TRIANGLES = gl.TRIANGLES;
    selfT.LINES = this.m_rc.LINES;
    selfT.LINE_STRIP = gl.LINE_STRIP;
    selfT.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    selfT.UNSIGNED_INT = gl.UNSIGNED_INT;
    selfT.COLOR = gl.COLOR;
    selfT.DEPTH = gl.DEPTH;
    selfT.STENCIL = gl.STENCIL;
    selfT.DEPTH_STENCIL = gl.DEPTH_STENCIL;

    if (this.m_glVer > 1) {
      selfT.MIN = gl.MIN;
      selfT.MAX = gl.MAX;
    } else {
      selfT.MIN = RCExtension_1.default.EXT_blend_minmax.MIN_EXT;
      selfT.MAX = RCExtension_1.default.EXT_blend_minmax.MAX_EXT;
    }

    selfT.RContext = gl;
  }

  renderBegin() {
    this.vroUid = -2;
    this.rioUid = -3;
  }

}

exports.default = ROVtxBuilder;

/***/ }),

/***/ "1e86":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 这些定义都是内部使用的，实现任务功能的使用者不必关心，当然也不能修改
 */

class ThreadCMD {}
/**
 * 单个数据处理任务
 */


ThreadCMD.DATA_PARSE = 3501;
/**
 * (3502)多个数据处理任务组成的队列
 */

ThreadCMD.DATA_QUEUE_PARSE = 3502;
/**
 * (3601)
 */

ThreadCMD.THREAD_INIT = 3601;
/**
 * (3621)
 */

ThreadCMD.INIT_COMMON_MODULE = 3621;
/**
 * (3631)线程中的任务程序初始化的时候主动从任务对象获取需要的数据
 */

ThreadCMD.THREAD_ACQUIRE_DATA = 3631;
/**
 * (3632)
 */

ThreadCMD.THREAD_TRANSMIT_DATA = 3632;
/**
 * (3701)
 */

ThreadCMD.INIT_TASK = 3701;
/**
 * (3801)
 */

ThreadCMD.INIT_PARAM = 3801;
exports.ThreadCMD = ThreadCMD;

/***/ }),

/***/ "1eb2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* unused harmony default export */ var _unused_webpack_default_export = (null);


/***/ }),

/***/ "1f61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RCExtension_1 = __importDefault(__webpack_require__("030e"));

class TextureDataType {
  static ToGL(gl, type) {
    switch (type) {
      case TextureDataType.UNSIGNED_BYTE:
        return gl.UNSIGNED_BYTE;
        break;

      case TextureDataType.BYTE:
        return gl.BYTE;
        break;

      case TextureDataType.FLOAT:
        return gl.FLOAT;
        break;

      case TextureDataType.HALF_FLOAT:
        return gl.HALF_FLOAT;
        break;

      case TextureDataType.HALF_FLOAT_OES:
        if (RCExtension_1.default.OES_texture_half_float != null) return RCExtension_1.default.OES_texture_half_float.HALF_FLOAT_OES;
        return gl.FLOAT;
        break;

      case TextureDataType.UNSIGNED_SHORT:
        return gl.UNSIGNED_SHORT;
        break;

      case TextureDataType.UNSIGNED_INT:
        return gl.UNSIGNED_INT;
        break;

      case TextureDataType.UNSIGNED_SHORT_5_6_5:
        return gl.UNSIGNED_SHORT_5_6_5;
        break;

      case TextureDataType.UNSIGNED_SHORT_4_4_4_4:
        return gl.UNSIGNED_SHORT_4_4_4_4;
        break;

      case TextureDataType.UNSIGNED_SHORT_5_5_5_1:
        return gl.UNSIGNED_SHORT_5_5_5_1;
        break;

      case TextureDataType.UNSIGNED_INT_24_8_WEBGL:
        return RCExtension_1.default.WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL;
        break;

      default:
        break;
    }

    return gl.UNSIGNED_BYTE;
  }

}

TextureDataType.UNSIGNED_BYTE = 1108;
TextureDataType.UNSIGNED_SHORT = 1109;
TextureDataType.UNSIGNED_INT = 1110;
TextureDataType.BYTE = 1111;
TextureDataType.FLOAT = 1211;
TextureDataType.HALF_FLOAT = 1212;
TextureDataType.HALF_FLOAT_OES = 1213;
TextureDataType.UNSIGNED_SHORT_5_6_5 = 1214;
TextureDataType.UNSIGNED_SHORT_4_4_4_4 = 1215;
TextureDataType.UNSIGNED_SHORT_5_5_5_1 = 1216;
TextureDataType.UNSIGNED_INT_24_8_WEBGL = 1217;
exports.default = TextureDataType;

/***/ }),

/***/ "1f9e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class CTMTaskCMD {}
/**
 * 处理数据
 */


CTMTaskCMD.PARSE = "CTM_PARSE";
/**
 * 加载和处理数据
 */

CTMTaskCMD.LOAD_AND_PARSE = "CTM_LOAD_AND_PARSE";
exports.CTMTaskCMD = CTMTaskCMD;

/***/ }),

/***/ "2033":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataPhaseFlag_1 = __webpack_require__("698b");
/**
 * 实现 DataUnitReceiver 行为的 基类
 */


class DataReceiverBase {
  constructor() {
    // 表示 none/net/cpu/gpu 三个阶段的信息, 初始值必须是DataPhaseFlag.PHASE_NONE, 外部用户不能操作
    this.dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.PHASE_NONE; // 初始值必须是0, 外部用户不能操作

    this.dataUnitUUID = 0; // 初始值必须是0, 外部用户不能操作

    this.listUUID = 0;
  }

  receiveDataUnit(unit, status) {
    console.log("DataReceiverBase::receiveDataUnit(), unit: ", unit);
  }

}

exports.DataReceiverBase = DataReceiverBase;

/***/ }),

/***/ "20ef":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

class ShdProgram {
  constructor(uid) {
    this.m_shdData = null;
    this.m_uid = -1;
    this.m_program = null;
    this.m_rcuid = -1;
    this.m_gl = null;
    this.m_shdUniqueName = "";
    this.m_texTotal = 0; // recorde uniform GLUniformLocation id

    this.m_aLocations = null;
    this.m_aLocationTypes = null;
    this.m_aLocationSizes = null;
    this.m_uLocations = null;
    this.m_texLocations = null;
    this.m_attribLIndexList = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    this.m_attribTypeSizeList = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    this.m_attriSizeList = null;
    this.m_uniformDict = new Map();
    this.m_uLocationDict = new Map();
    this.m_vertShader = null;
    this.m_fragShader = null; // recode shader uniform including status

    this.dataUniformEnabled = false;
    this.m_attrid = 0;
    this.m_attridIndex = 0;
    this.m_uLc = null;
    this.m_uIndex = 0;
    this.m_uid = uid;
  }

  setShdData(shdData) {
    this.m_shdData = shdData;
    this.m_shdUniqueName = shdData.getUniqueShaderName();
  }

  getUid() {
    return this.m_uid;
  }

  getTexTotal() {
    return this.m_shdData.getTexTotal();
  }

  useTexLocation() {
    for (let i = 0; i < this.m_texTotal; i++) {
      this.m_gl.uniform1i(this.m_texLocations[i], i);
    }
  } // use texture true or false


  haveTexture() {
    return this.m_shdData.haveTexture();
  }

  createLocations() {
    let i = 0;
    let len = 0;
    let attriNSList = this.m_shdData.getAttriNSList();

    if (attriNSList != null && attriNSList.length > 0) {
      if (this.m_aLocations == null) {
        this.dataUniformEnabled = false;
        let attriSizeList = this.m_shdData.getAttriSizeList();
        this.m_aLocations = [];
        this.m_aLocationTypes = [];
        this.m_aLocationSizes = [];
        len = attriNSList.length;
        let type = 0;
        let altI = 0;

        while (i < len) {
          altI = this.m_gl.getAttribLocation(this.m_program, attriNSList[i]);
          this.m_aLocations.push(altI);
          type = VtxBufConst_1.default.GetVBufAttributeTypeByNS(attriNSList[i]);
          this.m_aLocationTypes.push(type);
          this.m_aLocationSizes.push(attriSizeList[i]);
          this.m_attribLIndexList[type] = altI;
          this.m_attribTypeSizeList[type] = attriSizeList[i];
          this.dataUniformEnabled = true;
          ++i;
        }

        this.m_attriSizeList = [];

        for (i = 0; i < this.m_attribTypeSizeList.length; ++i) {
          if (this.m_attribTypeSizeList[i] > 0) {
            this.m_attriSizeList.push(this.m_attribTypeSizeList[i]);
          }
        }

        if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attri aLocationTypes: " + this.m_aLocationTypes);
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attri m_aLocations: " + this.m_aLocations);
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attriNSList: " + attriNSList);
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attribLIndexList: " + this.m_attribLIndexList);
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attribTypeSizeList: " + this.m_attribTypeSizeList);
          console.log("ShdProgram(" + this.m_uid + ")::createLocations(), attriSizeList: " + this.m_attriSizeList);
        }
      }
    }

    if (this.m_shdData.haveCommonUniform()) {
      if (this.m_uLocations == null) {
        let uninforms = this.m_shdData.getUniforms();
        this.m_uLocations = [];
        len = uninforms.length;
        i = 0;
        let ul = null;
        let uns = "";

        while (i < len) {
          if (!uninforms[i].isTex) {
            uns = uninforms[i].name;
            ul = this.m_gl.getUniformLocation(this.m_program, uns);

            if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
              console.log("ShdProgram::createLocations() uniform, ul " + ul + ", uninforms[" + i + "].name: " + uns);
            }

            if (ul != null) {
              ul.uniformName = uns;
              ul.uniqueName = this.m_shdUniqueName;
              uninforms[i].location = ul;
              this.m_uniformDict.set(uns, uninforms[i]);
              this.m_uLocationDict.set(uns, ul);
              this.m_uLocations.push(ul);
              this.dataUniformEnabled = true;
            } else {
              if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
                console.warn("uniform ", uns, " was not used!");
              }
            }
          }

          ++i;
        }
      }
    }

    this.m_texTotal = this.m_shdData.getTexTotal();

    if (this.m_texTotal > 0) {
      this.m_texLocations = new Array(this.m_texTotal);
      let texnsList = this.m_shdData.getTexUniformNames();

      for (i = 0; i < this.m_texTotal; ++i) {
        texnsList[i] = "u_sampler" + i;
        this.m_texLocations[i] = this.m_gl.getUniformLocation(this.m_program, texnsList[i]);
      }
    }
  }

  getLayoutBit() {
    return this.m_shdData.getLayoutBit();
  }

  getMid() {
    return this.m_shdData.getMid();
  }

  getFragOutputTotal() {
    return this.m_shdData.getFragOutputTotal();
  }

  getLocationsTotal() {
    return this.m_aLocationTypes.length;
  }

  getLocationTypeByIndex(index) {
    return this.m_aLocationTypes[index];
  }

  getLocationSizeByIndex(index) {
    return this.m_aLocationSizes[index];
  }

  testVertexAttribPointerOffset(offsetList) {
    let flag = false;

    if (offsetList != null && this.m_attriSizeList != null) {
      // 使用大于等于，例如绘制深度图的时候不需要法线和uv而只需要顶点数据即可
      if (offsetList.length >= this.m_attriSizeList.length) {
        let offset = 0;
        let i = 0;

        for (; i < this.m_attriSizeList.length; ++i) {
          if (offset != offsetList[i]) {
            break;
          }

          offset += this.m_attriSizeList[i] * 4;
        }

        flag = i >= this.m_attriSizeList.length;
      }
    }

    if (!flag) {
      console.error("顶点数据layout和顶点着色器中的layout(" + this.m_attriSizeList + ")不匹配");
      throw Error("Shader program vertx attributes layout can not match float attribute vertex data !!!");
    }

    return flag;
  }

  vertexAttribPointerType(attribType, size, type, normalized, stride, offset) {
    this.m_attrid = this.m_attribLIndexList[attribType];

    if (this.m_attrid > -1) {
      this.m_gl.enableVertexAttribArray(this.m_attrid);
      this.m_gl.vertexAttribPointer(this.m_attrid, this.m_attribTypeSizeList[attribType], type, normalized, stride, offset);
    }
  }

  vertexAttribPointerTypeFloat(attribType, stride, offset) {
    this.m_attrid = this.m_attribLIndexList[attribType];

    if (this.m_attrid > -1) {
      this.m_gl.enableVertexAttribArray(this.m_attrid);
      this.m_gl.vertexAttribPointer(this.m_attrid, this.m_attribTypeSizeList[attribType], this.m_gl.FLOAT, false, stride, offset);
    }
  }

  testVertexAttribPointerType(attribType) {
    return this.m_attribLIndexList[attribType] > -1;
  }

  getVertexAttribByTpye(attribType) {
    return this.m_attribLIndexList[attribType];
  }

  vertexAttribPointerAt(i, size, type, normalized, stride, offset) {
    this.m_attridIndex = i;
    this.m_attrid = this.m_aLocations[i];

    if (this.m_attrid > -1) {
      this.m_gl.enableVertexAttribArray(this.m_attrid);
      this.m_gl.vertexAttribPointer(this.m_attrid, size, type, normalized, stride, offset);
    }
  }

  vertexAttribPointerNext(size, type, normalized, stride, offset) {
    this.m_attrid = this.m_aLocations[this.m_attridIndex];

    if (this.m_attrid > -1) {
      this.m_gl.enableVertexAttribArray(this.m_attrid);
      this.m_gl.vertexAttribPointer(this.m_attrid, size, type, normalized, stride, offset);
    }

    this.m_attridIndex++;
  }

  vertexAttribPointerFirst(size, type, normalized, stride, offset) {
    this.m_attridIndex = 1;
    this.m_attrid = this.m_aLocations[0];

    if (this.m_attrid > -1) {
      this.m_gl.enableVertexAttribArray(this.m_attrid);
      this.m_gl.vertexAttribPointer(this.m_attrid, size, type, normalized, stride, offset);
    }
  }

  getUniformLocationAt(i) {
    this.m_uIndex = i + 1;
    return this.m_uLocations[i];
  }

  getUniformLocationNext() {
    this.m_uLc = this.m_uLocations[this.m_uIndex++];
    return this.m_uLc;
  }

  getUniformLocationFirst() {
    this.m_uIndex = 1;
    return this.m_uLocations[0];
  }

  getUniformLocationByNS(ns) {
    return this.m_uLocationDict.get(ns);
  }

  getUniformTypeNameByNS(ns) {
    if (this.m_uniformDict.has(ns)) {
      return this.m_uniformDict.get(ns).typeName;
    }

    return "";
  }

  getUniformTypeByNS(ns) {
    if (this.m_uniformDict.has(ns)) {
      return this.m_uniformDict.get(ns).type;
    }

    return 0;
  }

  hasUniformByName(ns) {
    return this.m_uniformDict.has(ns);
  }

  getUniformLengthByNS(ns) {
    if (this.m_uniformDict.has(ns)) {
      return this.m_uniformDict.get(ns).arrLength;
    }

    return 0;
  }

  initShdProgram() {
    let gl = this.m_gl;
    let vshd_str = this.m_shdData.getVSCodeStr();
    let fshd_str = this.m_shdData.getFSCodeStr(); //console.log("ShdProgram::initShdProgram(), this: ",this);

    let pr;

    if (this.m_shdData.preCompileInfo == null) {
      if (RendererDevice_1.default.VERT_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED) {
        if (vshd_str.indexOf(" mediump ") >= 0) {
          pr = new RegExp(" mediump ", "g");
          vshd_str = vshd_str.replace(pr, " highp ");
        }

        if (vshd_str.indexOf(" lowp ") >= 0) {
          pr = new RegExp(" lowp ", "g");
          vshd_str = vshd_str.replace(pr, " highp ");
        }
      }
    }

    if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
      console.log("vert shader code: \n" + vshd_str);
    }

    let vertShader = this.loadShader(gl.VERTEX_SHADER, vshd_str);

    if (this.m_shdData.preCompileInfo == null) {
      if (RendererDevice_1.default.FRAG_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED) {
        if (fshd_str.indexOf(" mediump ") >= 0) {
          pr = new RegExp(" mediump ", "g");
          fshd_str = fshd_str.replace(pr, " highp ");
        }

        if (fshd_str.indexOf(" lowp ") >= 0) {
          pr = new RegExp(" lowp ", "g");
          fshd_str = fshd_str.replace(pr, " highp ");
        }
      }
    }

    if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
      console.log("frag shader code: \n" + fshd_str);
    }

    let fragShader = this.loadShader(gl.FRAGMENT_SHADER, fshd_str); // Create the shader program      

    let shdProgram = gl.createProgram();
    gl.attachShader(shdProgram, fragShader);
    gl.attachShader(shdProgram, vertShader);
    gl.linkProgram(shdProgram);

    if (!gl.getProgramParameter(shdProgram, gl.LINK_STATUS)) {
      if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
        console.log('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shdProgram));
      }

      return null;
    }

    this.m_vertShader = vertShader;
    this.m_fragShader = fragShader;
    gl.detachShader(shdProgram, vertShader);
    gl.detachShader(shdProgram, fragShader);
    gl.deleteShader(vertShader);
    gl.deleteShader(fragShader);
    return shdProgram;
  }

  loadShader(type, source) {
    let shader = this.m_gl.createShader(type);
    this.m_gl.shaderSource(shader, source);
    this.m_gl.compileShader(shader);

    if (!this.m_gl.getShaderParameter(shader, this.m_gl.COMPILE_STATUS)) {
      if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
        console.log('An error occurred compiling the shaders: ' + this.m_gl.getShaderInfoLog(shader));
      }

      this.m_gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  getUniqueShaderName() {
    return this.m_shdUniqueName;
  }

  enabled() {
    return this.m_program != null;
  }

  upload(gl, rcuid) {
    if (this.m_program == null) {
      this.m_rcuid = rcuid;
      this.m_gl = gl;
      this.m_program = this.initShdProgram();
      this.m_program.uniqueName = this.m_shdUniqueName;
      if (null != this.m_program) this.createLocations();
    }
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  uniformBlockBinding(uniform_block_ns, bindingIndex) {
    this.m_gl.uniformBlockBinding(this.m_program, this.m_gl.getUniformBlockIndex(this.m_program, uniform_block_ns), bindingIndex);
  }

  toString() {
    return "[ShdProgram(uniqueName = " + this.m_shdUniqueName + ")]";
  }
  /**
   * @returns return current gpu shader  program
   */


  getGPUProgram() {
    return this.m_program;
  }

  destroy() {
    this.m_aLocations = null;
    this.m_attriSizeList = null;

    if (this.m_texTotal > 0) {
      this.m_texLocations.fill(null);
      this.m_texTotal = 0;
    }

    if (this.m_program != null) {
      this.m_gl.deleteShader(this.m_vertShader);
      this.m_gl.deleteShader(this.m_fragShader);
      this.m_vertShader = null;
      this.m_fragShader = null;
      this.m_gl.deleteProgram(this.m_program);
      this.m_program = null;
    }

    this.m_gl = null;
    this.m_shdData = null;
  }

}

exports.default = ShdProgram;

/***/ }),

/***/ "2139":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

class Matrix4Pool {
  static GetMatTotal() {
    return Matrix4Pool.s_mtotal;
  }

  static GetFS32Arr() {
    return Matrix4Pool.s_mfs32Arr;
  }

  static SetFS32Arr(fs32) {
    Matrix4Pool.s_mfs32Arr = fs32;
    let total = Matrix4Pool.s_mtotal;
    let list = Matrix4Pool.s_matList;

    for (let i = 0; i < total; ++i) {
      list[i].setF32Arr(fs32);
    }
  }

  static GetFreeId() {
    if (Matrix4Pool.m_freeIdList.length > 0) {
      return Matrix4Pool.m_freeIdList.pop();
    }

    return -1;
  }

  static Allocate(total) {
    if (total < 1024) {
      total = 1024;
    }

    if (Matrix4Pool.s_mtotal < 1) {
      console.log("Matrix4Pool::Allocate(), Matrix total: " + total);
      Matrix4Pool.s_mtotal = total;
      Matrix4Pool.s_mfs32Arr = new Float32Array(total * 16);
      let i = 0;
      let mat = new Matrix4_1.default(Matrix4Pool.s_mfs32Arr, i * 16);
      let uid = mat.getUid();
      Matrix4Pool.s_baseUid = uid;
      Matrix4Pool.s_maxUid = uid + total;

      for (; i < uid; ++i) {
        Matrix4Pool.s_matList.push(null);
        Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
      }

      Matrix4Pool.s_matList.push(mat);
      Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
      Matrix4Pool.m_freeIdList.push(mat.getUid());

      for (i = 1; i < total; ++i) {
        mat = new Matrix4_1.default(Matrix4Pool.s_mfs32Arr, i * 16);
        Matrix4Pool.s_matList.push(mat);
        Matrix4Pool.s_matFlagList.push(Matrix4Pool.s_FLAG_FREE);
        Matrix4Pool.m_freeIdList.push(mat.getUid());
      }
    }
  }

  static GetMatrix() {
    let mat = null;
    let index = Matrix4Pool.GetFreeId() - Matrix4Pool.s_baseUid;

    if (index >= 0) {
      mat = Matrix4Pool.s_matList[index];
      mat.identity();
      Matrix4Pool.s_matFlagList[index] = Matrix4Pool.s_FLAG_BUSY; //console.log("Get a free Matrix !!!");
    } else {
      //console.error("Matrix4Pool::GetMatrix(), Error Matrix4Pool is empty !!!");
      mat = new Matrix4_1.default();
    }

    return mat;
  }

  static RetrieveMatrix(mat) {
    if (mat != null) {
      let uid = mat.getUid();

      if (uid >= Matrix4Pool.s_baseUid && uid < Matrix4Pool.s_maxUid) {
        if (Matrix4Pool.s_matFlagList[uid - Matrix4Pool.s_baseUid] == Matrix4Pool.s_FLAG_BUSY) {
          Matrix4Pool.m_freeIdList.push(uid);
          Matrix4Pool.s_matFlagList[uid - Matrix4Pool.s_baseUid] = Matrix4Pool.s_FLAG_FREE;
        }
      }
    }
  }

}

Matrix4Pool.s_FLAG_BUSY = 1;
Matrix4Pool.s_FLAG_FREE = 0;
Matrix4Pool.s_matList = [];
Matrix4Pool.s_matFlagList = [];
Matrix4Pool.m_freeIdList = [];
Matrix4Pool.s_mfs32Arr = null;
Matrix4Pool.s_baseUid = 0;
Matrix4Pool.s_maxUid = 0;
Matrix4Pool.s_mtotal = 0;
exports.default = Matrix4Pool;

/***/ }),

/***/ "2356":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ThreadSendData {
  constructor() {
    // 多线程任务分类id
    this.taskclass = -1; // 多线程任务实例id

    this.srcuid = -1; // IThreadSendData 数据对象的唯一标识, 不能随便更改

    this.dataIndex = -1;
    /**
     * 直接传递内存句柄所有权的数据流对象数组
     */

    this.streams = null;
    /**
     * sendStatus   值为 -1 表示没有加入数据池等待处理
     *              值为 0 表示已经加入数据池正等待处理
     *              值为 1 表示已经发送给worker
     */

    this.sendStatus = -1;
    /**
     * build vaule from ThreadWFST.ts
     * 任务数据在执行过程中的状态(work flow status): 将32位分为4个8位, 分别表示任务执行过程中的四种类别的状态(未知 | 未知 | 未知 | 流转状态)，默认是0x0
     */

    this.wfst = 0;
  } // 按照实际需求构建自己的数据(sendData和transfers等)


  buildThis(transferEnabled) {}

  reset() {}

  static GetFreeId() {
    if (ThreadSendData.m_freeIdList.length > 0) {
      return ThreadSendData.m_freeIdList.pop();
    }

    return -1;
  }

  static Create() {
    let sd = null;
    let index = ThreadSendData.GetFreeId(); //console.log("index: "+index);
    //console.log("ThreadSendData::Create(), ThreadSendData.m_unitList.length: "+ThreadSendData.m_unitList.length);

    if (index >= 0) {
      sd = ThreadSendData.m_unitList[index];
      sd.dataIndex = index;
      ThreadSendData.m_unitFlagList[index] = ThreadSendData.s_FLAG_BUSY;
    } else {
      sd = new ThreadSendData();
      ThreadSendData.m_unitList.push(sd);
      ThreadSendData.m_unitFlagList.push(ThreadSendData.s_FLAG_BUSY);
      sd.dataIndex = ThreadSendData.m_unitListLen;
      ThreadSendData.m_unitListLen++;
    }

    return sd;
  }

  static Contains(psd) {
    if (psd != null) {
      let uid = psd.dataIndex;

      if (uid >= 0 && uid < ThreadSendData.m_unitListLen) {
        return ThreadSendData.m_unitList[uid] == psd;
      }
    }

    return false;
  }

  static Restore(psd) {
    if (ThreadSendData.Contains(psd)) {
      let uid = psd.dataIndex;

      if (ThreadSendData.m_unitFlagList[uid] == ThreadSendData.s_FLAG_BUSY) {
        ThreadSendData.m_freeIdList.push(uid);
        ThreadSendData.m_unitFlagList[uid] = ThreadSendData.s_FLAG_FREE;
        psd.sendStatus = -1;
        psd.reset();
      }
    }
  }

  static RestoreByUid(uid) {
    if (uid >= 0 && ThreadSendData.m_unitFlagList[uid] == ThreadSendData.s_FLAG_BUSY) {
      ThreadSendData.m_freeIdList.push(uid);
      ThreadSendData.m_unitFlagList[uid] = ThreadSendData.s_FLAG_FREE;
      ThreadSendData.m_unitList[uid].reset();
    }
  }

}

ThreadSendData.s_FLAG_BUSY = 1;
ThreadSendData.s_FLAG_FREE = 0;
ThreadSendData.m_unitFlagList = [];
ThreadSendData.m_unitListLen = 0;
ThreadSendData.m_unitList = [];
ThreadSendData.m_freeIdList = [];
exports.ThreadSendData = ThreadSendData;

/***/ }),

/***/ "2560":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class CameraUniformBuilder {
  create(rc, shdp) {
    let cam = rc.getCamera();

    if (shdp.hasUniformByName(UniformConst_1.default.CameraViewMatUNS) && shdp.hasUniformByName(UniformConst_1.default.CameraProjectiveMatUNS)) {
      return rc.uniformContext.createShaderGlobalUniformFromProbe(cam.matUProbe, "u_viewAndProjMat", [UniformConst_1.default.CameraViewMatUNS, UniformConst_1.default.CameraProjectiveMatUNS]);
    } else if (shdp.hasUniformByName(UniformConst_1.default.CameraViewMatUNS)) {
      return rc.uniformContext.createShaderGlobalUniformFromProbeAt(cam.matUProbe, "u_viewMat", [UniformConst_1.default.CameraViewMatUNS], 0);
    } else if (shdp.hasUniformByName(UniformConst_1.default.CameraProjectiveMatUNS)) {
      return rc.uniformContext.createShaderGlobalUniformFromProbeAt(cam.matUProbe, "u_projMat", [UniformConst_1.default.CameraProjectiveMatUNS], 1);
    }

    return null;
  }

  getIDNS() {
    return "CameraUniformBuilder";
  }

}

exports.default = CameraUniformBuilder;

/***/ }),

/***/ "264c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RenderSortBlock {
  constructor(shader) {
    this.m_begin = null;
    this.m_end = null;
    this.m_next = null;
    this.m_node = null;
    this.m_nodes = [];
    this.m_nodesTotal = 0;
    this.m_shader = null;
    this.m_renderTotal = 0;
    this.m_sorter = null;
    this.sortEnabled = true;
    this.m_shader = shader;
  }

  setSorter(sorter) {
    this.m_sorter = sorter;
  }

  showInfo() {
    let info = "";
    let next = this.m_begin;

    while (next != null) {
      //info += "("+next.unit.value+","+next.uid+"),";
      info += next.unit.value + ",";
      next = next.next;
    }

    console.log("RenderSortBlock info: \n", info);
  }

  clear() {
    if (this.m_shader != null) {
      if (this.m_nodes.length > 0) this.m_nodes = [];
      let next = this.m_begin;
      let curr = null;

      while (next != null) {
        curr = next;
        next = next.next;
        curr.prev = null;
        curr.next = null;
      }

      this.m_begin = this.m_end = null;
      this.m_nodesTotal = 0;
      this.m_renderTotal = 0;
      this.sortEnabled = true;
      this.m_shader = null;
    }

    this.m_sorter = null;
  }

  update() {
    if (this.sortEnabled) {
      this.sort();
    }
  }

  run(rc) {
    this.m_shader.resetUniform();
    let unit = null;
    let nodes = this.m_nodes; //let info:string = "";

    for (let i = 0; i < this.m_renderTotal; ++i) {
      unit = nodes[i];
      this.m_shader.bindToGpu(unit.shdUid);
      unit.run(rc);

      if (unit.partTotal < 1) {
        unit.drawThis(rc);
      } else {
        unit.drawPart(rc);
      } //info += unit.value+",";

    } //console.log(info);

  }

  runLockMaterial(rc) {
    this.m_shader.resetUniform();
    let unit = null;
    let nodes = this.m_nodes;

    for (let i = 0; i < this.m_renderTotal; ++i) {
      unit = nodes[i];
      this.m_shader.bindToGpu(unit.shdUid);
      unit.vro.run();
      unit.runLockMaterial2(null);

      if (unit.partTotal < 1) {
        unit.drawThis(rc);
      } else {
        unit.drawPart(rc);
      }
    }
  }

  sort() {
    if (this.m_nodesTotal > 0) {
      //console.log("this.m_nodesTotal: ",this.m_nodesTotal);
      // 整个sort执行过程放在渲染运行时渲染执行阶段是不妥的,但是目前还没有好办法
      // 理想的情况是运行时不会被复杂计算打断，复杂计算应该再渲染执行之前完成
      let next = this.m_begin;

      if (this.m_nodes.length < this.m_nodesTotal) {
        this.m_nodes = new Array(Math.round(this.m_nodesTotal * 1.1) + 1);
      }

      let i = 0;

      while (next != null) {
        if (next.drawEnabled && next.unit.drawEnabled) {
          this.m_nodes[i] = next.unit;
          ++i;
        }

        next = next.next;
      }

      this.m_renderTotal = i;
      let flat = 0;

      if (this.m_sorter != null) {
        flat = this.m_sorter.sortRODisplay(this.m_nodes, i);
      }

      if (flat < 1) {
        this.snsort(0, i - 1);
      }
    }
  }

  sorting(low, high) {
    let arr = this.m_nodes;
    this.m_node = arr[low];
    let pvalue = this.m_node.value;

    while (low < high) {
      while (low < high && arr[high].value >= pvalue) {
        --high;
      }

      arr[low] = arr[high];

      while (low < high && arr[low].value <= pvalue) {
        ++low;
      }

      arr[high] = arr[low];
    }

    arr[low] = this.m_node;
    return low;
  }

  snsort(low, high) {
    if (low < high) {
      let pos = this.sorting(low, high);
      this.snsort(low, pos - 1);
      this.snsort(pos + 1, high);
    }
  }

  getNodesTotal() {
    return this.m_nodesTotal;
  }

  getBegin() {
    this.m_next = this.m_begin;
    return this.m_begin;
  }

  getNext() {
    if (this.m_next != null) {
      this.m_next = this.m_next.next;
    }

    return this.m_next;
  }

  isEmpty() {
    return this.m_nodesTotal < 1; // return this.m_begin == null;
  }

  addNode(node) {
    //console.log("sort add node: ",node);
    if (node.prev == null && node.next == null) {
      if (this.m_begin == null) {
        this.m_end = this.m_begin = node;
      } else {
        if (this.m_end.prev != null) {
          this.m_end.next = node;
          node.prev = this.m_end;
          this.m_end = node;
        } else {
          this.m_begin.next = node;
          node.prev = this.m_end;
          this.m_end = node;
        }
      }

      this.m_end.next = null;
      this.m_nodesTotal++; //console.log("sort add node,this.m_nodesTotal: ",this.m_nodesTotal);
    }
  }

  removeNode(node) {
    //console.log("sort remove node: ",node);
    if (node.prev != null || node.next != null || node == this.m_begin) {
      if (node == this.m_begin) {
        if (node == this.m_end) {
          this.m_begin = this.m_end = null;
        } else {
          this.m_begin = node.next;
          this.m_begin.prev = null;
        }
      } else if (node == this.m_end) {
        this.m_end = node.prev;
        this.m_end.next = null;
      } else {
        node.next.prev = node.prev;
        node.prev.next = node.next;
      }

      node.prev = null;
      node.next = null;
      this.m_nodesTotal--; //console.log("sort remove node,this.m_nodesTotal: ",this.m_nodesTotal);
    }
  }

}

exports.default = RenderSortBlock;

/***/ }),

/***/ "265e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 真正被高频运行的渲染管线中的被执行对象

Object.defineProperty(exports, "__esModule", {
  value: true
}); // 为了渲染循环执行中持有RPOUnit和对应的Disp

class RPONode {
  constructor() {
    this.__$ruid = -1;
    this.drawEnabled = true;
    this.uid = -1;
    this.index = -1; // only for show info

    this.drawMode = 0;
    this.ivsIndex = 0;
    this.ivsCount = 0;
    this.insCount = 0;
    this.shdUid = -1;
    this.vtxUid = -1;
    this.texMid = -1;
    this.rtokey = -1;
    this.prev = null;
    this.next = null;
    this.unit = null;
    this.vro = null;
    this.tro = null;
    this.rvroI = -1;
    this.rtroI = -1;
  }

  setValue(value) {
    this.unit.value = value;
  }

  isVsible() {
    return this.unit == null || this.unit.drawEnabled;
  }

  updateData() {
    let p = this.unit;
    this.drawMode = p.drawMode;
    this.ivsIndex = p.ivsIndex;
    this.ivsCount = p.ivsCount;
    this.insCount = p.insCount;
    p.drawOffset = p.ivsIndex * p.ibufStep;
    this.vtxUid = p.vtxUid;
    this.vro = p.vro; // material info etc.

    this.shdUid = p.shdUid;
    this.texMid = p.texMid;
    this.tro = p.tro;
  }

  reset() {
    this.drawEnabled = true;
    this.uid = -1;
    this.index = -1;
    this.drawMode = 0;
    this.ivsIndex = 0;
    this.ivsCount = 0;
    this.insCount = 0;
    this.shdUid = -1;
    this.vtxUid = -1;
    this.texMid = -1;
    this.rtokey = -1;
    this.unit = null;
    this.vro = null;
    this.tro = null;
    this.prev = null;
    this.next = null;
  }

  toString() {
    return "[Object RPONode(uid = " + this.uid + ", index = " + this.index + ", shdUid = " + this.shdUid + ", vtxUid = " + this.vtxUid + ")]";
  }

}

exports.default = RPONode;

/***/ }),

/***/ "2931":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ListPool_1 = __webpack_require__("9cc2");

class UnitReceiverNode {
  constructor() {
    this.m_receivers = [];
    this.m_flag = true;
  }

  testReset() {
    this.m_flag = true; // console.log("AAAYYYT02 02 testReset() ...");
  }

  addReceiver(r) {
    this.m_receivers.push(r);
  }

  removeReceiver(r) {
    // console.log("AAAYYT remove an UnitReceiverNode instance.");
    let list = this.m_receivers;

    for (let i = 0, len = list.length; i < len; ++i) {
      if (r == list[i]) {
        list.splice(i, 1);
        break;
      }
    }
  }

  testUnitForce(flag) {
    if (this.m_flag) {
      if (this.unit.isCpuPhase()) {
        // console.log("a data unit is enabled in the cpu phase.");
        let list = this.m_receivers;

        for (let i = 0, len = list.length; i < len; ++i) {
          const r = list[i];

          if (r.dataUnitUUID > 0 && r.listUUID > 0) {
            // console.log("AAAYYYT02 03 testUnitForce() ...");
            r.receiveDataUnit(this.unit, 1);
          }
        }

        this.m_flag = false;
        return true;
      }

      return false;
    }

    return true;
  }

  testUnit() {
    if (this.m_flag) {
      if (this.unit.isCpuPhase()) {
        // console.log("a data unit is enabled in the cpu phase.");
        let list = this.m_receivers;

        for (let i = 0, len = list.length; i < len; ++i) {
          const r = list[i];

          if (r.dataUnitUUID > 0 && r.listUUID > 0) {
            r.receiveDataUnit(this.unit, 1);
          }
        }

        this.m_flag = false;
        return true;
      }

      return false;
    }

    return true;
  }

  destroy(receiverPool, nodeMap) {
    // console.log("AAAYYYT destroy an UnitReceiverNode instance.");
    let list = this.m_receivers;

    for (let i = 0, len = list.length; i < len; ++i) {
      const r = list[i];
      receiverPool.removeItem(r);
    }

    nodeMap.delete(this.uuid);
    this.uuid = 0;
    this.m_receivers = null;
  }

}

class ReceiverSchedule {
  constructor() {
    this.m_nodeMap = new Map();
    this.m_nodes = [];
    this.m_receiverPool = new ListPool_1.ListPool();
    this.m_receiversTotal = 0;
  }

  testUnitForce(unit, flag) {
    if (unit != null) {
      let node = this.m_nodeMap.get(unit.getUUID()); // console.log("AAAYYYT02 01 testUnitForce(), node != null: ", node != null);

      if (node != null) {
        node.testUnitForce(flag);
        return node.testUnit();
      }
    }

    return false;
  }

  testUnit(unit) {
    if (unit != null) {
      let node = this.m_nodeMap.get(unit.getUUID());

      if (node != null) {
        return node.testUnit();
      }
    }

    return false;
  }

  addReceiver(receiver, unit) {
    if (unit != null) {
      if (this.m_receiverPool.hasnotItem(receiver)) {
        let node;

        if (this.m_nodeMap.has(unit.getUUID())) {
          node = this.m_nodeMap.get(unit.getUUID());
        } else {
          node = new UnitReceiverNode();
          node.unit = unit;
          node.uuid = unit.getUUID();
          this.m_nodes.push(node);
          this.m_nodeMap.set(unit.getUUID(), node);
        }

        receiver.dataUnitUUID = unit.getUUID();
        let listUUID = receiver.listUUID; // console.log("this.m_receiverPool.addItem(receiver).................");

        this.m_receiverPool.addItem(receiver);

        if (listUUID == receiver.listUUID) {
          throw "ReceiverSchedule::addReceiver() is the illegal operation !!!(listUUID(" + listUUID + "), receiver.listUUID(" + receiver.listUUID + "))";
        }

        node.addReceiver(receiver);
        this.m_receiversTotal++;
      }
    }
  }

  removeReceiver(receiver) {
    // console.log("AAAYYYT02 01 -a receiver.dataUnitUUID: ", receiver.dataUnitUUID);
    if (receiver.dataUnitUUID > 0 && receiver.listUUID > 0) {
      // console.log("AAAYYYT02 01 -b removeReceiver testUnitForce(), this.m_receiverPool.hasItem(receiver): ", this.m_receiverPool.hasItem(receiver));
      if (this.m_receiverPool.hasItem(receiver)) {
        let node = this.m_nodeMap.get(receiver.dataUnitUUID);
        node.removeReceiver(receiver);
        this.m_receiverPool.removeItem(receiver);
        this.m_receiversTotal--;
      }
    } // 去除掉依赖


    receiver.dataUnitUUID = 0;
    receiver.listUUID = 0;
  }

  getReceiversTotal() {
    return this.m_receiversTotal;
  }

  run() {
    if (this.m_receiversTotal > 0) {
      let list = this.m_nodes;
      let flag;
      let node;

      for (let i = 0, len = list.length; i < len; ++i) {
        node = list[i];
        flag = node.testUnit();

        if (flag) {
          this.m_receiversTotal--;
          list.splice(i, 1); // console.log("AAAYYYT02 01 -c");

          node.destroy(this.m_receiverPool, this.m_nodeMap);
          i--;
          len--;
        }
      }
    }
  }

  destroy() {}

}

exports.ReceiverSchedule = ReceiverSchedule;

/***/ }),

/***/ "29ef":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class RendererState {
  static CreateBlendMode(name, srcColor, dstColor, blendEquation = 0) {
    return RendererState.rstb.createBlendMode(name, srcColor, dstColor, blendEquation);
  }

  static CreateBlendModeSeparate(name, srcColor, dstColor, srcAlpha = 0, dstAlpha = 0, blendEquation = 0) {
    return RendererState.rstb.createBlendModeSeparate(name, srcColor, dstColor, srcAlpha, dstAlpha, blendEquation);
  }

  static CreateRenderState(objName, cullFaceMode, blendMode, depthTestMode) {
    return RendererState.rstb.createRenderState(objName, cullFaceMode, blendMode, depthTestMode);
  }

  static CreateRenderColorMask(objName, rBoo, gBoo, bBoo, aBoo) {
    return RendererState.rstb.createRenderColorMask(objName, rBoo, gBoo, bBoo, aBoo);
  }

  static GetRenderStateByName(objName) {
    return RendererState.rstb.getRenderStateByName(objName);
  }

  static GetRenderColorMaskByName(objName) {
    return RendererState.rstb.getRenderColorMaskByName(objName);
  }

  static UnlockBlendMode() {
    RendererState.rstb.unlockBlendMode();
  }

  static LockBlendMode(cullFaceMode) {
    RendererState.rstb.lockBlendMode(cullFaceMode);
  }

  static UnlockDepthTestMode() {
    RendererState.rstb.unlockDepthTestMode();
  }

  static LockDepthTestMode(depthTestMode) {
    RendererState.rstb.lockDepthTestMode(depthTestMode);
  }

  static ResetState() {
    RendererState.rstb.resetState();
  }

  static Reset(context) {
    RendererState.rstb.reset(context);
  }

  static ResetInfo() {}

  static SetDepthTestEnable(enable) {
    RendererState.rstb.setDepthTestEnable(enable);
  }

  static SetBlendEnable(enable) {
    RendererState.rstb.setBlendEnable(enable);
  }

}

exports.default = RendererState;

/***/ }),

/***/ "2a59":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

const ResourceSchedule_1 = __webpack_require__("7de1");

const ModuleNS_1 = __webpack_require__("8eb0");

const GeometryDataUnit_1 = __webpack_require__("aeff");

const CTMParserListerner_1 = __webpack_require__("73f9");

const DracoParserListerner_1 = __webpack_require__("eed9");

const OBJParserListerner_1 = __webpack_require__("31e1");

const FBXParserListerner_1 = __webpack_require__("8f7d");
/**
 * 数据资源调度器基类
 */


class GeometryResourceSchedule extends ResourceSchedule_1.ResourceSchedule {
  constructor() {
    super();
    this.m_waitingUnits = [];
  }

  addUrlToTask(unit) {
    console.log("GeometryResourceSchedule::createDataUnit(), unit.data.dataFormat: ", unit.data.dataFormat);
    let url = unit.url;

    switch (unit.data.dataFormat) {
      case DataUnit_1.DataFormat.CTM:
        this.m_ctmListener.addUrlToTask(url);
        break;

      case DataUnit_1.DataFormat.Draco:
        this.m_dracoListener.addUrlToTask(url);
        break;

      case DataUnit_1.DataFormat.OBJ:
        this.m_objListener.addUrlToTask(url);
        break;

      case DataUnit_1.DataFormat.FBX:
        this.m_fbxListener.addUrlToTask(url);
        break;

      default:
        console.error("GeometryResourceSchedule::createDataUnit(), illegal data format:", unit.data.dataFormat, ", its url: ", url);
        break;
    }
  }
  /**
   * 覆盖父类函数，实现具体功能
   */


  createDataUnit(url, dataFormat, immediate = false) {
    GeometryDataUnit_1.DataUnitLock.lockStatus = 207;
    let unit = new GeometryDataUnit_1.GeometryDataUnit();
    unit.lossTime = Date.now();
    unit.immediate = immediate;
    unit.data = new GeometryDataUnit_1.GeometryDataContainer();
    unit.data.dataFormat = dataFormat;
    unit.url = url;

    if (this.isInitialized()) {
      this.addUrlToTask(unit);
    } else {
      this.m_waitingUnits.push(unit);
    }

    return unit;
  }
  /**
   * 被子类覆盖，以便实现具体功能
   */


  initTask(unitPool, threadSchedule, receiverSchedule, taskModules) {
    for (let i = 0; i < taskModules.length; ++i) {
      const module = taskModules[i]; // console.log("GeometryResourceSchedule::initTask(), module.name:", module.name);

      switch (module.name) {
        case ModuleNS_1.ModuleNS.ctmParser:
          this.m_ctmListener = new CTMParserListerner_1.CTMParserListerner(unitPool, threadSchedule, module, receiverSchedule);
          break;

        case ModuleNS_1.ModuleNS.dracoParser:
          this.m_dracoListener = new DracoParserListerner_1.DracoParserListerner(unitPool, threadSchedule, module, receiverSchedule);
          break;

        case ModuleNS_1.ModuleNS.objParser:
          this.m_objListener = new OBJParserListerner_1.OBJParserListerner(unitPool, threadSchedule, module, receiverSchedule);
          break;

        case ModuleNS_1.ModuleNS.fbxFastParser:
          this.m_fbxListener = new FBXParserListerner_1.FBXParserListerner(unitPool, threadSchedule, module, receiverSchedule);
          break;

        default:
          break;
      }
    }

    let units = this.m_waitingUnits;

    for (let i = 0; i < units.length; i++) {
      // console.log("XXXXXX geometry deferred units["+i+"]: ", units[i]);
      this.addUrlToTask(units[i]);
    }

    this.m_waitingUnits = [];
  }
  /**
   * 销毁当前实例
   */


  destroy() {
    super.destroy();
    this.m_waitingUnits = [];

    if (this.m_ctmListener != null) {
      this.m_ctmListener.destroy();
      this.m_ctmListener = null;
    }

    if (this.m_objListener != null) {
      this.m_objListener.destroy();
      this.m_objListener = null;
    }

    if (this.m_fbxListener != null) {
      this.m_fbxListener.destroy();
      this.m_fbxListener = null;
    }

    if (this.m_dracoListener != null) {
      this.m_dracoListener.destroy();
      this.m_dracoListener = null;
    }
  }

}

exports.GeometryResourceSchedule = GeometryResourceSchedule;

/***/ }),

/***/ "2be1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class PoolNodeBuilder {
  constructor() {
    this.m_nodesTotal = 0;
    this.m_nodes = [];
    this.m_flags = [];
    this.m_freeIdList = [];
  }
  /**
   * the sub class override this function, for real implement.
   */


  createNode() {
    return null;
  }
  /**
   * the sub class override this function, for real implement.
   */


  restoreUid(uid) {}

  getFreeId() {
    if (this.m_freeIdList.length > 0) {
      return this.m_freeIdList.pop();
    }

    return -1;
  }

  getNodeByUid(uid) {
    return this.m_nodes[uid];
  }

  create() {
    let node = null;
    let index = this.getFreeId();

    if (index >= 0) {
      node = this.m_nodes[index];
      node.uid = index;
      this.m_flags[index] = PoolNodeBuilder.S_BUSY;
    } else {
      // create a new nodeIndex
      node = this.createNode();
      this.m_nodes.push(node);
      this.m_flags.push(PoolNodeBuilder.S_BUSY);
      node.uid = this.m_nodesTotal;
      this.m_nodesTotal++;
    }

    return node;
  }

  restore(pnode) {
    if (pnode != null && pnode.uid >= 0 && this.m_flags[pnode.uid] == PoolNodeBuilder.S_BUSY) {
      this.restoreUid(pnode.uid);
      this.m_freeIdList.push(pnode.uid);
      this.m_flags[pnode.uid] = PoolNodeBuilder.S_FREE;
      pnode.reset();
      return true;
    }

    return false;
  }

  restoreByUid(uid) {
    if (uid >= 0 && uid < this.m_nodesTotal && this.m_flags[uid] == PoolNodeBuilder.S_BUSY) {
      this.restoreUid(uid);
      this.m_freeIdList.push(uid);
      this.m_flags[uid] = PoolNodeBuilder.S_FREE;
      this.m_nodes[uid].reset();
      return true;
    }

    return false;
  }

}

PoolNodeBuilder.S_BUSY = 1;
PoolNodeBuilder.S_FREE = 0;
exports.default = PoolNodeBuilder;

/***/ }),

/***/ "2e55":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class DracoTaskCMD {}
/**
 * 处理数据
 */


DracoTaskCMD.PARSE = "DRACO_PARSE";
DracoTaskCMD.ENCODE = "DRACO_ENCODE";
/**
 * 从其他线程获取数据
 */

DracoTaskCMD.THREAD_ACQUIRE_DATA = "DRACO_THREAD_ACQUIRE_DATA";
/**
 * 向其他线程发送数据
 */

DracoTaskCMD.THREAD_TRANSMIT_DATA = "DRACO_THREAD_TRANSMIT_DATA";
exports.DracoTaskCMD = DracoTaskCMD;

/***/ }),

/***/ "2e8a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const MaterialConst_1 = __importDefault(__webpack_require__("644c"));

class AttributeLine {
  constructor() {
    this.type = -1;
    this.attriType = -1;
    this.typeSize = 3;
    this.typeName = "";
    this.name = "";
    this.layoutEnabled = true;
  }

  parseCode(codeStr) {
    const SEMICOLON = ";";
    const SPACE = " "; // 去掉两头的空格

    codeStr = codeStr.replace(/^\s*|\s*$/g, "");
    let i = codeStr.indexOf(SEMICOLON);
    if (i > 0) codeStr = codeStr.slice(0, i);
    let arr = codeStr.split(SPACE);
    this.typeName = arr[arr.length - 2];
    this.name = arr[arr.length - 1];
    this.type = MaterialConst_1.default.GetTypeByTypeNS(this.typeName);
    this.typeSize = parseInt(this.typeName.slice(this.typeName.length - 1));
    this.attriType = VtxBufConst_1.default.GetVBufAttributeTypeByNS(this.name); //trace("Attribute: >"+this.typeName+"<,>"+this.name+"<,>"+this.type+"<,typeSize: >"+this.typeSize+",attriType: "+this.attriType);
  }

}

exports.default = AttributeLine;

/***/ }),

/***/ "3024":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderUniformProbe_1 = __importDefault(__webpack_require__("3077"));

class UniformVec4Probe extends ShaderUniformProbe_1.default {
  constructor(slot, vec4Total) {
    super(slot);
    this.m_datafs = null;
    this.m_vec4Total = 1;
    if (vec4Total < 1) vec4Total = 1;
    this.m_vec4Total = vec4Total;
    this.m_datafs = new Float32Array(4 * vec4Total);
    this.addVec4Data(this.m_datafs, this.m_vec4Total);
  } // bindSlotAt(i: number): void {
  //     super.bindSlotAt(i);
  //     this.addVec4Data(this.m_datafs, this.m_vec4Total);
  // }


  destroy() {
    super.destroy();
    this.m_datafs = null;
  }

}

exports.default = UniformVec4Probe;

/***/ }),

/***/ "3077":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MaterialConst_1 = __importDefault(__webpack_require__("644c"));

class ShaderUniformProbe {
  constructor(slot) {
    this.m_uid = ShaderUniformProbe.s_uid++;
    this.m_slot = null;
    this.m_fsList = null; // 当前probe中的数据在slot中的结束位置序号

    this.m_fsIndex = 0; // 当前probe在slot中的起始位置序号

    this.m_slotBeginIndex = -1;
    this.rst = -1;
    this.uniformsTotal = 0;
    this.uniformNames = null; // array -> [SHADER_MAT4, SHADER_VEC3]

    this.uniformTypes = null; // array -> [1, 3], the "3" is uniform Array,length is 3

    this.dataSizeList = null;
    this.bindSlot(slot);
  }

  bindSlot(slot) {
    if (this.rst >= 0) {
      this.reset();
    }

    if (this.m_fsList == null) {
      this.m_fsList = [];
      this.uniformTypes = [];
      this.dataSizeList = [];
    }

    this.m_slot = slot;
    this.rst = 1;
    this.m_slotBeginIndex = slot.index;
    this.m_fsIndex = slot.index;
  }

  getUid() {
    return this.m_uid;
  }
  /**
   * @return 获取当前probe在slot中的起始位置序号
   */


  getSlotBeginIndex() {
    return this.m_slotBeginIndex;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_slot.getRCUid();
  }

  getFS32At(i) {
    return this.m_fsList[i];
  }

  setFS32At(fs32, i) {
    this.m_fsList[i] = fs32;
  }

  setVec4DataAt(index, f0, f1, f2, f3) {
    let fs = this.m_fsList[index];
    fs[0] = f0;
    fs[1] = f1;
    fs[2] = f2;
    fs[3] = f3;
  }

  setVec4Data(f0, f1, f2, f3) {
    let fs = this.m_fsList[0];
    fs[0] = f0;
    fs[1] = f1;
    fs[2] = f2;
    fs[3] = f3;
  }

  setVec4DataAtWithArr4(index, arr4) {
    this.m_fsList[index].set(arr4, 0);
  }

  setVec4DataWithArr4(arr4) {
    this.m_fsList[0].set(arr4, 0);
  }

  addVec4Data(f32, vec4Total) {
    //console.log("addVec4Data() slot("+this.m_slot.getUid()+")");
    if (vec4Total < f32.length / 4) {
      console.warn("vec4 uniform array total are not equal to the vec4Total value.");
    }

    this.m_fsList.push(f32);
    this.uniformTypes.push(MaterialConst_1.default.SHADER_VEC4);
    this.dataSizeList.push(vec4Total);
    this.m_slot.dataList[this.m_fsIndex] = f32;
    this.m_fsIndex++;
    this.uniformsTotal++;
    this.m_slot.index++;
  }

  addMat4Data(f32, mat4Total) {
    //console.log("addMat4Data() slot("+this.m_slot.getUid()+")");
    this.m_fsList.push(f32);
    this.uniformTypes.push(MaterialConst_1.default.SHADER_MAT4);
    this.dataSizeList.push(mat4Total);
    this.m_slot.dataList[this.m_fsIndex] = f32;
    this.m_fsIndex++;
    this.uniformsTotal++;
    this.m_slot.index++;
  }

  isEnabled() {
    return this.rst >= 0;
  }

  update() {
    //如果溢出，可能有问题
    //if(this.rst > 0xffffff) this.rst = Math.round(Math.random() * 1000) + 100;
    this.rst++;

    if (this.uniformsTotal < 2) {
      this.m_slot.flagList[this.m_slotBeginIndex] = this.rst;
    } else {
      for (let i = this.m_slotBeginIndex; i <= this.m_fsIndex; ++i) {
        this.m_slot.flagList[i] = this.rst;
      }
    } // if (this.m_uid == 5) {
    //     console.log("this.m_slot.dataList: ", this.m_slot.dataList);
    //     console.log("this.m_fsList: ", this.m_fsList);
    // }
    //console.log("this.m_slot.dataList");

  }

  reset() {
    this.rst = -1;
    this.m_slotBeginIndex = -1;
    this.uniformsTotal = 0;
    this.m_fsIndex = 0;

    if (this.m_fsList != null) {
      this.m_fsList = null;
      this.uniformTypes = null;
      this.dataSizeList = null;
    }

    this.m_slot = null;
  }

  destroy() {
    this.reset();
  }

}

ShaderUniformProbe.s_uid = 0;
exports.default = ShaderUniformProbe;

/***/ }),

/***/ "3113":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const SpecularMode_1 = __webpack_require__("839a");

const ShadowMode_1 = __webpack_require__("a9f4");

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class ShaderCodeUniform {
  constructor() {
    this.m_codeBuilder = null;
    this.m_uniqueNSKeyString = "";
    this.m_uniqueNSKeys = new Uint16Array(128);
    this.m_uniqueNSKeysTotal = 16;
    this.m_uniqueNSKeyFlag = false;
  }

  __$setCodeBuilder(codeBuilder) {
    this.m_codeBuilder = codeBuilder;
  }

  getUniqueNSKeyID() {
    if (this.m_uniqueNSKeyFlag) {
      let id = 31;

      for (let i = 0; i < this.m_uniqueNSKeysTotal; ++i) {
        id = id * 131 + this.m_uniqueNSKeys[i];
      }

      return id;
    }

    return 0;
  }

  getUniqueNSKeyString() {
    if (this.m_uniqueNSKeyFlag) {
      this.m_uniqueNSKeyString = "[" + this.m_uniqueNSKeys[0];

      for (let i = 1; i < this.m_uniqueNSKeysTotal; ++i) {
        //this.m_uniqueNSKeyString += "-"+this.m_uniqueNSKeys[i];
        this.m_uniqueNSKeyString += "" + this.m_uniqueNSKeys[i];
      }

      this.m_uniqueNSKeyString += "]";
      return this.m_uniqueNSKeyString;
    }

    return "";
  }

  reset() {
    if (this.m_uniqueNSKeyFlag) {
      for (let i = 0; i < this.m_uniqueNSKeysTotal; ++i) {
        this.m_uniqueNSKeys[i] = 0;
      }

      this.m_uniqueNSKeyFlag = false;
    }
  }
  /**
   * apply camera position uniform in the shader,the uniform vec4 data: [x, y, z, w]
   * @param vertEnabled whether apply camera position uniform in the vertex shader, the default value is false
   * @param fragEnabled whether apply camera position uniform in the fragment shader, the default value is true
   */


  useCameraPosition(vertEnabled = false, fragEnabled = true) {
    if (vertEnabled) {
      this.m_codeBuilder.addVertUniformParam(UniformConst_1.default.CameraPosParam);
    }

    if (fragEnabled) {
      this.m_codeBuilder.addFragUniformParam(UniformConst_1.default.CameraPosParam);
    }
  }
  /**
   * apply view parameters uniform in the shader,the uniform vec4 data: [viewPortX, viewPortY, viewPortWidth, viewPortHeight]
   * @param vertEnabled whether apply view parameters uniform in the vertex shader, the default value is false
   * @param fragEnabled whether apply view parameters uniform in the fragment shader, the default value is true
   */


  useViewPort(vertEnabled = false, fragEnabled = true) {
    if (vertEnabled) {
      this.m_codeBuilder.addVertUniformParam(UniformConst_1.default.ViewportParam);
    }

    if (fragEnabled) {
      this.m_codeBuilder.addFragUniformParam(UniformConst_1.default.ViewportParam);
    }
  }
  /**
   * apply frustum parameters uniform in the shader,the uniform vec4 data: [camera zNear,camera zFar, camera nearPlaneHalfWidth, camera nearPlaneHalfHeight]
   * @param vertEnabled whether apply frustum parameters uniform in the vertex shader, the default value is false
   * @param fragEnabled whether apply frustum parameters uniform in the fragment shader, the default value is true
   */


  useFrustum(vertEnabled = false, fragEnabled = true) {
    if (vertEnabled) {
      this.m_codeBuilder.addVertUniformParam(UniformConst_1.default.FrustumParam);
    }

    if (fragEnabled) {
      this.m_codeBuilder.addFragUniformParam(UniformConst_1.default.FrustumParam);
    }
  }
  /**
   * apply stage parameters uniform in the shader,the uniform vec4 data: [2.0/stageWidth,2.0/stageHeight, stageWidth,stageHeight]
   * @param vertEnabled whether apply stage parameters uniform in the vertex shader, the default value is false
   * @param fragEnabled whether apply stage parameters uniform in the fragment shader, the default value is true
   */


  useStage(vertEnabled, fragEnabled) {
    if (vertEnabled) {
      this.m_codeBuilder.addVertUniformParam(UniformConst_1.default.StageParam);
    }

    if (fragEnabled) {
      this.m_codeBuilder.addFragUniformParam(UniformConst_1.default.StageParam);
    }
  }
  /**
   * add diffuse map uniform code
   */


  addDiffuseMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_DIFFUSE_MAP", true, true, false);
    this.m_uniqueNSKeys[0] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add normal map uniform code
   */


  addNormalMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_NORMAL_MAP", true, true, false);
    this.m_codeBuilder.normalMapEnabled = true;
    this.m_uniqueNSKeys[1] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add parallax map uniform code
   * @param parallaxParamIndex parallax map parameter uniform data array index
   */


  addParallaxMap(parallaxParamIndex) {
    this.m_codeBuilder.addTextureSample2D("VOX_PARALLAX_MAP", true, true, false);

    if (parallaxParamIndex >= 0) {
      this.m_codeBuilder.addDefine("VOX_PARALLAX_PARAMS_INDEX", "" + parallaxParamIndex);
      this.m_uniqueNSKeys[2] = 1 + (parallaxParamIndex << 1);
    } else {
      this.m_uniqueNSKeys[2] = 1;
    }

    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add displacement map uniform code
   * @param parallaxParamIndex vec4 param array index in the vertex shader
   */


  addDisplacementMap(displacementParamIndex) {
    this.m_codeBuilder.addTextureSample2D("VOX_DISPLACEMENT_MAP", true, false, true);

    if (displacementParamIndex >= 0) {
      this.m_codeBuilder.addDefine("VOX_DISPLACEMENT_PARAMS_INDEX", "" + displacementParamIndex);
      this.m_uniqueNSKeys[3] = 1 + (displacementParamIndex << 1);
    } else {
      this.m_uniqueNSKeys[3] = 1;
    }

    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add specular map uniform code
   * @param specularMode is SpecularMode type value, the default is SpecularMode.Default
   */


  addSpecularMap(specularMode = SpecularMode_1.SpecularMode.Default) {
    this.m_codeBuilder.addTextureSample2D("VOX_SPECULAR_MAP", true, true, false);
    this.m_codeBuilder.addDefine("VOX_SPECULAR_MODE", "" + specularMode);
    this.m_uniqueNSKeys[5] = 1 + (specularMode << 1);
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add shadow map uniform code
   * @param shadowMode is shadowMode type value, the default is ShadowMode.VSM
   */


  addShadowMap(shadowMode = ShadowMode_1.ShadowMode.VSM) {
    this.m_codeBuilder.addTextureSample2D("VOX_VSM_SHADOW_MAP", false, true, false);
    this.m_uniqueNSKeys[6] = 1 + (shadowMode << 1);
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add fog color map uniform code
   */


  addFogColorMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_FOG_COLOR_MAP", true, true, false);
    this.m_uniqueNSKeys[7] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add env specular cube map uniform code
   * @param cubeMap yes or no, the default is true
   */


  addSpecularEnvMap(cubeMap = true) {
    if (cubeMap) {
      this.m_codeBuilder.addTextureSampleCube("VOX_ENV_MAP", true, false);
    } else {
      this.m_codeBuilder.addTextureSample2D("VOX_ENV_MAP", true, true, false);
    }

    this.m_uniqueNSKeys[8] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add ambient occlusion map uniform code
   */


  addAOMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_AO_MAP", true, true, false);
    this.m_uniqueNSKeys[4] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add roughness map uniform code
   */


  addRoughnessMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_ROUGHNESS_MAP", true, true, false);
    this.m_uniqueNSKeys[9] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add metalness map uniform code
   */


  addMetalnessMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_METALNESS_MAP", true, true, false);
    this.m_uniqueNSKeys[10] = 1;
    this.m_uniqueNSKeyFlag = true;
  }
  /**
   * add ao, roughness, metalness map uniform code
   */


  addARMMap() {
    this.m_codeBuilder.addTextureSample2D("VOX_ARM_MAP", true, true, false);
    this.m_uniqueNSKeys[11] = 1;
    this.m_uniqueNSKeyFlag = true;
  }

  add2DMap(macroName = "", map2DEnabled = true, fragEnabled = true, vertEnabled = false) {
    this.m_codeBuilder.addTextureSample2D(macroName, map2DEnabled, fragEnabled, vertEnabled);
  }

  addCubeMap(macroName = "", fragEnabled = true, vertEnabled = false) {
    this.m_codeBuilder.addTextureSampleCube(macroName, fragEnabled, vertEnabled);
  }

  add3DMap(macroName = "", fragEnabled = true, vertEnabled = false) {
    this.m_codeBuilder.addTextureSample3D(macroName, fragEnabled, vertEnabled);
  }

}

exports.ShaderCodeUniform = ShaderCodeUniform;

/***/ }),

/***/ "31e1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const GeometryDataUnit_1 = __webpack_require__("aeff");

const OBJParseTask_1 = __webpack_require__("ceac");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

class OBJParserListerner {
  constructor(unitPool, threadSchedule, module, receiverSchedule) {
    this.m_parseTask = null;
    this.m_moduleUrl = module.url;
    this.m_unitPool = unitPool;
    this.m_threadSchedule = threadSchedule;
    this.m_receiverSchedule = receiverSchedule;
  }

  addUrlToTask(url) {
    if (!this.m_unitPool.hasUnitByUrl(url)) {
      if (this.m_parseTask == null) {
        // 创建ctm 加载解析任务
        let parseTask = new OBJParseTask_1.OBJParseTask(this.m_moduleUrl); // 绑定当前任务到多线程调度器

        this.m_threadSchedule.bindTask(parseTask);
        parseTask.setListener(this);
        this.m_parseTask = parseTask;
      }

      new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
        DivLog_1.default.ShowLogOnce("正在解析OBJ数据...");
        this.m_parseTask.addBinaryData(buf, url);
      }, (progress, url) => {
        let k = Math.round(100 * progress);
        DivLog_1.default.ShowLogOnce("obj file loading " + k + "%");
      }, (status, url) => {
        console.error("load obj mesh data error, url: ", url);
      });
    }
  } // 一个任务数据处理完成后的侦听器回调函数


  objParseFinish(models, url) {
    // console.log("ObjParserListerner::ctmParseFinish(), models: ", models, ", url: ", url);
    if (this.m_unitPool.hasUnitByUrl(url)) {
      let unit = this.m_unitPool.getUnitByUrl(url);

      if (unit != null) {
        unit.lossTime = Date.now() - unit.lossTime;
        unit.data.dataFormat = GeometryDataUnit_1.DataFormat.OBJ;
        unit.data.models = models;
        GeometryDataUnit_1.DataUnitLock.lockStatus = 209;
        unit.toCpuPhase();

        if (unit.immediate) {
          // console.log("geom data receive at once.");
          this.m_receiverSchedule.testUnit(unit);
        }
      }
    }
  }

  destroy() {
    if (this.m_parseTask != null) {
      this.m_parseTask.destroy();
      this.m_parseTask = null;
    }

    this.m_unitPool = null;
    this.m_threadSchedule = null;
    this.m_receiverSchedule = null;
  }

}

exports.OBJParserListerner = OBJParserListerner;

/***/ }),

/***/ "32cc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderUniformData_1 = __importDefault(__webpack_require__("b3bd"));

const ShaderCodeBuffer_1 = __importDefault(__webpack_require__("faa5"));

const MaterialBase_1 = __importDefault(__webpack_require__("0fc4"));

class Line3DShaderBuffer extends ShaderCodeBuffer_1.default {
  constructor() {
    super();
    this.m_uniqueName = "";
    this.dynColorEnabled = false;
  }

  initialize(texEnabled) {
    super.initialize(texEnabled);
    this.m_uniqueName = "Line3DShd";
    if (this.dynColorEnabled) this.m_uniqueName += "_dynColor";
  }

  buildShader() {
    this.m_coder.addVertLayout("vec3", "a_vs");
    this.m_coder.addFragUniform("vec4", "u_color");

    if (this.dynColorEnabled) {
      this.m_coder.addDefine("DYNAMIC_COLOR");
    } else {
      this.m_coder.addVertLayout("vec3", "a_cvs");
      this.m_coder.addVarying("vec3", "v_color");
    }

    this.m_coder.addFragOutputHighp("vec4", "FragColor0");
    this.m_coder.addFragMainCode(`
    #ifndef DYNAMIC_COLOR
        FragColor0 = vec4(v_color, 1.0) * u_color;
    #else
        FragColor0 = u_color;
    #endif
`);
    this.m_coder.addVertMainCode(`
    viewPosition = u_viewMat * u_objMat * vec4(a_vs,1.0);
    vec4 pv = u_projMat * viewPosition;
    #ifndef DYNAMIC_COLOR
        v_color = a_cvs;
    #endif
    gl_Position = pv;
            `);
  }

  getUniqueShaderName() {
    return this.m_uniqueName;
  }

  static GetInstance() {
    let lsb = Line3DShaderBuffer;

    if (lsb.s_instance != null) {
      return lsb.s_instance;
    }

    lsb.s_instance = new Line3DShaderBuffer();
    return lsb.s_instance;
  }

}

Line3DShaderBuffer.s_instance = null;

class Line3DMaterial extends MaterialBase_1.default {
  /**
   * @param dynColorEnabled the default value is false
   */
  constructor(dynColorEnabled = false) {
    super();
    this.m_dynColorEnabled = false;
    this.m_data = null;
    this.premultiplyAlpha = false;
    this.normalEnabled = false;
    this.shadowReceiveEnabled = false;
    this.m_dynColorEnabled = dynColorEnabled;
    this.m_data = new Float32Array([1.0, 1.0, 1.0, 1.0]);
    let oum = new ShaderUniformData_1.default();
    oum.uniformNameList = ["u_color"];
    oum.dataList = [this.m_data];
    this.m_shaderUniformData = oum;
  }

  buildBuf() {
    Line3DShaderBuffer.GetInstance().dynColorEnabled = this.m_dynColorEnabled;
  }

  getCodeBuf() {
    return Line3DShaderBuffer.GetInstance();
  }

  setRGB3f(pr, pg, pb) {
    this.m_data[0] = pr;
    this.m_data[1] = pg;
    this.m_data[2] = pb;
  }

  getRGB3f(color) {
    let ds = this.m_data;
    color.setRGB3f(ds[0], ds[1], ds[2]);
  }

  setRGBA4f(pr, pg, pb, pa) {
    this.m_data[0] = pr;
    this.m_data[1] = pg;
    this.m_data[2] = pb;
    this.m_data[3] = pa;
  }

  getRGBA4f(color) {
    color.fromArray(this.m_data);
  }

  setAlpha(pa) {
    this.m_data[3] = pa;
  }

  getAlpha() {
    return this.m_data[3];
  }

  setColor(color) {
    color.toArray(this.m_data);
  }

  getColor(color) {
    color.fromArray(this.m_data);
  }

}

exports.default = Line3DMaterial;

/***/ }),

/***/ "35fa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class SurfaceNormalCalc {
  /**
  * calc a triangle's normal,cw is positive, right hand rule. there is calc result is positive.
  */
  static ClacTriNormal(va, vb, vc, resultNormal) {
    let calc = SurfaceNormalCalc;
    Vector3D_1.default.Subtract(vb, va, calc.s_temp_vb);
    Vector3D_1.default.Subtract(vc, vb, calc.s_temp_vc);
    Vector3D_1.default.Cross(calc.s_temp_vb, calc.s_temp_vc, resultNormal);
    resultNormal.normalize();
  }
  /**
  * calc a triangle's normal,cw is positive, right hand rule. there is calc result is positive.
  * @param verteies			verteies's length is N multiple 9
  * @param triangleIndex		triangle index of triangles
  * @param resultNormal		result normalize Vector3D normal
  */


  static ClacTriNormalByVS(verteies, triangleIndex, resultNormal) {
    let calc = SurfaceNormalCalc;
    let i = triangleIndex * 9;
    calc.s_temp_va.setTo(verteies[i], verteies[i + 1], verteies[i + 2]);
    resultNormal.setTo(verteies[i + 3], verteies[i + 4], verteies[i + 5]);
    calc.s_temp_vc.setTo(verteies[i + 6], verteies[i + 7], verteies[i + 8]);
    resultNormal.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va); //vox::kernel::geom::Vector3D::cross(vb, vc, resultNormal);

    resultNormal.crossBy(calc.s_temp_vc);
    resultNormal.normalize();
  }

  static ClacTriNormalByIVS(verteies, triangleIndex, indices, resultNormal) {
    let calc = SurfaceNormalCalc;
    let j = triangleIndex * 3;
    let i = indices[j] * 3;
    calc.s_temp_va.setTo(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 1] * 3;
    resultNormal.setTo(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 2] * 3;
    calc.s_temp_vc.setTo(verteies[i], verteies[i + 1], verteies[i + 2]); //trace(triangleIndex, ", v3a: ", SurfaceNormalCalc.s_temp_va, ", v3b: ", resultNormal, ", v3c: ", SurfaceNormalCalc.s_temp_vc);

    resultNormal.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va);
    resultNormal.crossBy(calc.s_temp_vc);
    resultNormal.normalize(); //trace("						normal: ", resultNormal);
  }

  static ClacTrisNormal(verteies, verteiesLength, numTriangles, indices, normals) {
    let calc = SurfaceNormalCalc;
    let v3 = new Vector3D_1.default();
    let j = 0,
        k = 0,
        i = 0;

    for (i = 0; i < verteiesLength; ++i) {
      normals[i] = 0.0;
    }

    for (i = 0; i < numTriangles; ++i) {
      calc.ClacTriNormalByIVS(verteies, i, indices, v3);
      j = i * 3;
      k = indices[j] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
      k = indices[j + 1] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
      k = indices[j + 2] * 3;
      normals[k] += v3.x;
      normals[k + 1] += v3.y;
      normals[k + 2] += v3.z;
    }

    for (i = 0; i < verteiesLength; i += 3) {
      calc.s_temp_va.setTo(normals[i], normals[i + 1], normals[i + 2]);
      calc.s_temp_va.normalize();
      normals[i] = calc.s_temp_va.x;
      normals[i + 1] = calc.s_temp_va.y;
      normals[i + 2] = calc.s_temp_va.z;
    }
  }

  static ClacTriTangent(verteies, uvs, nvs, triangleIndex, indices, tangent, biTangent) {
    let calc = SurfaceNormalCalc;
    let j = triangleIndex * 3; // pos

    let i = indices[j] * 3;
    calc.s_temp_va.setTo(nvs[i], nvs[i + 1], nvs[i + 2]);
    calc.s_temp_va.setTo(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 1] * 3;
    calc.s_temp_vb.setTo(verteies[i], verteies[i + 1], verteies[i + 2]);
    i = indices[j + 2] * 3;
    calc.s_temp_vc.setTo(verteies[i], verteies[i + 1], verteies[i + 2]); // uv

    i = indices[j] * 2;
    calc.s_temp_vd.setTo(uvs[i], uvs[i + 1], 0.0);
    i = indices[j + 1] * 2;
    calc.s_temp_ve.setTo(uvs[i], uvs[i + 1], 0.0);
    i = indices[j + 2] * 2;
    calc.s_temp_vf.setTo(uvs[i], uvs[i + 1], 0.0); // edges of pos

    calc.s_temp_vb.subtractBy(calc.s_temp_va);
    calc.s_temp_vc.subtractBy(calc.s_temp_va);
    calc.s_temp_ve.subtractBy(calc.s_temp_vd);
    calc.s_temp_vf.subtractBy(calc.s_temp_vd);
    let dt = 1.0 / (calc.s_temp_ve.x * calc.s_temp_vf.y - calc.s_temp_ve.y * calc.s_temp_vf.x);
    tangent.copyFrom(calc.s_temp_vb);
    tangent.scaleBy(calc.s_temp_vf.y);
    calc.s_temp_va.copyFrom(calc.s_temp_vc);
    calc.s_temp_va.scaleBy(calc.s_temp_ve.y);
    tangent.subtractBy(calc.s_temp_va);
    tangent.scaleBy(dt);
    tangent.normalize();
    biTangent.copyFrom(calc.s_temp_vc);
    biTangent.scaleBy(calc.s_temp_ve.x);
    calc.s_temp_va.copyFrom(calc.s_temp_vb);
    calc.s_temp_va.scaleBy(calc.s_temp_vf.x);
    biTangent.subtractBy(calc.s_temp_va);
    biTangent.scaleBy(dt);
    biTangent.normalize(); //*/
  }

  static ClacTrisTangent(verteies, verteiesLength, uvs, nvs, numTriangles, indices, tangent, biTangent) {
    let calc = SurfaceNormalCalc;
    let tv3 = new Vector3D_1.default(),
        btv3 = new Vector3D_1.default();
    let j = 0,
        k = 0,
        i = 0;

    for (i = 0; i < verteiesLength; ++i) {
      tangent[i] = 0.0;
      biTangent[i] = 0.0;
    }

    for (i = 0; i < numTriangles; ++i) {
      calc.ClacTriTangent(verteies, uvs, nvs, i, indices, tv3, btv3);
      j = i * 3;
      k = indices[j] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
      k = indices[j + 1] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
      k = indices[j + 2] * 3;
      tangent[k] = tv3.x;
      tangent[k + 1] = tv3.y;
      tangent[k + 2] = tv3.z;
      biTangent[k] = btv3.x;
      biTangent[k + 1] = btv3.y;
      biTangent[k + 2] = btv3.z;
    }

    for (i = 0; i < verteiesLength; i += 3) {
      calc.s_temp_vd.setTo(tangent[i], tangent[i + 1], tangent[i + 2]);
      calc.s_temp_vd.normalize();
      calc.s_temp_vb.setTo(biTangent[i], biTangent[i + 1], biTangent[i + 2]);
      calc.s_temp_vb.normalize();
      calc.s_temp_vc.setTo(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_va.copyFrom(calc.s_temp_vc);
      calc.s_temp_vc.scaleBy(calc.s_temp_vc.dot(calc.s_temp_vd));
      calc.s_temp_vd.subtractBy(calc.s_temp_vc);
      calc.s_temp_vd.normalize(); //b = b - n * dot( b, n )

      calc.s_temp_vc.setTo(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_vc.scaleBy(calc.s_temp_vb.dot(calc.s_temp_vc));
      calc.s_temp_vb.subtractBy(calc.s_temp_vc);
      calc.s_temp_vb.normalize();
      calc.s_temp_va.crossBy(calc.s_temp_vd);

      if (calc.s_temp_va.dot(calc.s_temp_vb) < 0.0) {
        calc.s_temp_vd.scaleBy(-1.0);
      }

      tangent[i] = calc.s_temp_vd.x;
      tangent[i + 1] = calc.s_temp_vd.y;
      tangent[i + 2] = calc.s_temp_vd.z;
      calc.s_temp_vb.setTo(nvs[i], nvs[i + 1], nvs[i + 2]);
      calc.s_temp_vb.crossBy(calc.s_temp_vd);
      calc.s_temp_vb.normalize();
      biTangent[i] = calc.s_temp_vb.x;
      biTangent[i + 1] = calc.s_temp_vb.y;
      biTangent[i + 2] = calc.s_temp_vb.z;
    }
  }

}

SurfaceNormalCalc.s_temp_va = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_vb = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_vc = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_vd = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_ve = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_vf = new Vector3D_1.default();
SurfaceNormalCalc.s_temp_vg = new Vector3D_1.default();
exports.default = SurfaceNormalCalc;

/***/ }),

/***/ "36cb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderConst_1 = __webpack_require__("e08e");

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

const TextureRenderObj_1 = __webpack_require__("b02c");

const ShdUniformTool_1 = __importDefault(__webpack_require__("4f27"));

const RenderShader_1 = __importDefault(__webpack_require__("b30a"));

const ROTransPool_1 = __importDefault(__webpack_require__("9156"));

const GpuVtxObject_1 = __webpack_require__("670e");
/**
 * 本类实现了将 系统内存数据 合成为 渲染运行时系统所需的数据资源(包括: 渲染运行时管理数据和显存数据)
 */


class RODataBuilder {
  constructor(shdProgramBuilder) {
    this.m_emptyTRO = null;
    this.m_shader = null;
    this.m_rpoUnitBuilder = null;
    this.m_processBuider = null;
    this.m_roVtxBuild = null;
    this.m_rc = null;
    this.m_vtxRes = null;
    this.m_texRes = null;
    this.m_deferredVbufs = [];
    this.m_deferredTROs = [];
    this.m_deferredTextures = [];
    this.m_haveDeferredUpdate = false;
    this.m_shdpBuilder = null;
    this.m_shdpBuilder = shdProgramBuilder;
  }

  initialize(rc, rpoUnitBuilder, processBuider, roVtxBuild) {
    if (this.m_shader == null) {
      this.m_rc = rc;
      this.m_vtxRes = rc.Vertex;
      this.m_texRes = rc.Texture;
      this.m_shader = new RenderShader_1.default(rc.getRCUid(), rc.getRC(), rc.getRenderAdapter(), this.m_shdpBuilder);
      this.m_rpoUnitBuilder = rpoUnitBuilder;
      this.m_processBuider = processBuider;
      this.m_roVtxBuild = roVtxBuild;
      this.m_emptyTRO = new TextureRenderObj_1.EmptyTexRenderObj(this.m_texRes);
      this.m_shdUniformTool = new ShdUniformTool_1.default();
      this.m_shdUniformTool.initialize();
    }
  }

  getRenderProxy() {
    return this.m_rc;
  }

  getRenderShader() {
    return this.m_shader;
  }

  getTextureResource() {
    return this.m_texRes;
  }
  /**
   * update single texture self system memory data to gpu memory data
   */


  updateTextureData(textureProxy, deferred) {
    if (this.m_texRes.hasResUid(textureProxy.getResUid())) {
      if (deferred) {
        this.m_deferredTextures.push(textureProxy);
        this.m_haveDeferredUpdate = true;
      } else {
        textureProxy.__$updateToGpu(this.m_texRes);
      }
    }
  }
  /**
   * update display entity texture list  system memory data to gpu memory data
   */


  updateDispTRO(disp, deferred) {
    if (disp.__$ruid > -1) {
      if (deferred) {
        this.m_deferredTROs.push(disp);
        this.m_haveDeferredUpdate = true;
      } else {
        this.updateTextureTRO(disp);
      }
    }
  }

  createTRO(texList, texTotal) {
    if (texList != null) {
      for (let i = 0; i < texList.length; ++i) {
        if (texList[i] != null) {
          texList[i].__$setRenderProxy(this.m_rc);
        }
      }

      return TextureRenderObj_1.TextureRenderObj.Create(this.m_texRes, texList, texTotal);
    }

    return null;
  }

  updateTextureTRO(disp) {
    if (disp.__$$runit != null) {
      let material = disp.getMaterial();

      if (material != null) {
        let texRes = this.m_texRes;
        let runit = disp.__$$runit;
        let tro = TextureRenderObj_1.TextureRenderObj.GetByMid(texRes.getRCUid(), material.__$troMid);

        if (runit.tro != null && (tro == null || runit.tro.getMid() != tro.getMid())) {
          let shdp = this.m_shdpBuilder.findShdProgramByShdData(material.getShaderData());

          if (shdp != null) {
            if (shdp.getTexTotal() > 0) {
              if (tro == null) {
                tro = this.createTRO(material.getTextureList(), shdp.getTexTotal()); //tro = TextureRenderObj.Create(texRes, material.getTextureList(), shdp.getTexTotal());
              }

              if (runit.tro != tro) {
                if (runit.tro != null) {
                  runit.tro.__$detachThis();
                }

                runit.tro = tro;

                tro.__$attachThis();

                runit.texMid = runit.tro.getMid();
                this.m_processBuider.rejoinRunitForTro(runit);
                material.__$troMid = runit.tro.getMid();
              }
            } else {
              if (runit.tro != this.m_emptyTRO) {
                if (runit.tro != null) {
                  runit.tro.__$detachThis();
                }

                runit.tro = this.m_emptyTRO;
                runit.texMid = runit.tro.getMid();
                this.m_processBuider.rejoinRunitForTro(runit);
                material.__$troMid = runit.texMid;
              }
            }
          }
        }
      }
    }
  }

  updateDispMaterial(runit, disp) {
    let shdp = null;

    if (disp.__$ruid >= 0) {
      let rc = this.m_rc;
      let material = disp.getMaterial();

      if (material != null) {
        if (material.getShaderData() == null) {
          let texList = material.getTextureList();
          let texEnabled = texList != null && texList != null && texList.length > 0;
          material.initializeByCodeBuf(texEnabled);
        } // shdp = this.m_shader.create(material.getShaderData());


        shdp = this.m_shdpBuilder.create(material.getShaderData());
        shdp.upload(rc.RContext, rc.getUid());
        runit.shdUid = shdp.getUid();
        let tro = null;

        if (shdp.getTexTotal() > 0) {
          tro = this.createTRO(material.getTextureList(), shdp.getTexTotal()); //tro = TextureRenderObj.Create(this.m_texRes, material.getTextureList(), shdp.getTexTotal());

          if (runit.tro != tro) {
            if (runit.tro != null) {
              runit.tro.__$detachThis();
            }

            runit.tro = tro;

            tro.__$attachThis();

            runit.texMid = runit.tro.getMid();
            if (runit.__$rprouid >= 0) this.m_processBuider.rejoinRunitForTro(runit);
            material.__$troMid = runit.tro.getMid();
          }
        } else {
          if (runit.tro != this.m_emptyTRO) {
            if (runit.tro != null) {
              runit.tro.__$detachThis();
            }

            runit.tro = this.m_emptyTRO;
            runit.texMid = runit.tro.getMid();
            if (runit.__$rprouid >= 0) this.m_processBuider.rejoinRunitForTro(runit);
            material.__$troMid = runit.texMid;
          }
        }

        if (this.m_shader.getSharedUniformByShd(shdp) == null) {
          let sharedMList = this.createsharedMList(material, shdp);

          if (sharedMList != null) {
            for (let i = 0; i < sharedMList.length; ++i) {
              sharedMList[i].program = shdp.getGPUProgram();
            }
          }

          this.m_shader.setSharedUniformByShd(shdp, this.m_shdUniformTool.buildShared(sharedMList, rc, shdp));
        }

        let hasTrans = shdp.hasUniformByName(UniformConst_1.default.LocalTransformMatUNS);

        if (material.__$uniform == null) {
          material.__$uniform = this.m_shdUniformTool.buildLocalFromData(material.createSelfUniformData(), shdp);
        }

        if (hasTrans) {
          if (disp.getTransform() != null) {
            //console.log("disp.getTransform().getUid(): "+disp.getTransform().getUid());
            runit.transUniform = ROTransPool_1.default.GetTransUniform(disp.getTransform(), shdp); //console.log("RODataBuilder::updateDispMaterial(), get runit.transUniform: ",runit.transUniform);
          }
        } // console.log("RODataBuilder::updateDispMaterial(), runit: ",runit);
        // console.log("RODataBuilder::updateDispMaterial(), runit.uid: ",runit.getUid());
        // console.log("RODataBuilder::updateDispMaterial(), runit.transUniform == null: ",runit.transUniform == null);


        if (runit.transUniform == null) {
          runit.transUniform = this.m_shdUniformTool.buildLocalFromTransformV(hasTrans ? disp.getMatrixFS32() : null, shdp);
          ROTransPool_1.default.SetTransUniform(disp.getTransform(), runit.transUniform, shdp);
        } else {
          runit.transUniform = this.m_shdUniformTool.updateLocalFromTransformV(runit.transUniform, hasTrans ? disp.getMatrixFS32() : null, shdp);
        }

        runit.polygonOffset = material.getPolygonOffset();
        runit.uniform = material.__$uniform;
      } else {
        console.log("Error RODataBuilder::updateDispMaterial(), material is null !!!");
      }
    }

    return shdp;
  }

  updateVtxDataToGpuByUid(vtxUid, deferred) {
    this.m_vtxRes.updateDataToGpu(vtxUid, deferred);
  }
  /**
   * update vertex system memory data to gpu memory data
   */


  updateDispVbuf(disp, deferred) {
    if (disp.__$ruid > -1) {
      if (deferred) {
        this.m_deferredVbufs.push(disp);
        this.m_haveDeferredUpdate = true;
      } else {
        let runit = disp.__$$runit;

        if (runit != null && runit.vtxUid != disp.vbuf.getUid()) {
          let oldResUid = runit.vtxUid;
          let vtxRes = this.m_vtxRes;

          if (vtxRes.hasResUid(oldResUid)) {
            vtxRes.__$detachRes(oldResUid);
          }

          runit.vro.__$detachThis(); // build vtx gpu data


          this.buildVtxRes(disp, runit, this.m_shdpBuilder.findShdProgramByUid(runit.shdUid));
          if (runit.__$rprouid >= 0) this.m_processBuider.rejoinRunitForVro(runit);
        }
      }
    }
  } // build vtx gpu data


  buildVtxRes(disp, runit, shdp) {
    if (disp.vbuf != null) {
      let vtxRes = this.m_vtxRes;
      runit.ivsIndex = disp.ivsIndex;
      runit.ivsCount = disp.ivsCount;
      runit.insCount = disp.insCount;
      runit.visible = disp.visible;
      runit.setVisible(disp.visible);
      runit.drawMode = disp.drawMode;
      runit.renderState = disp.renderState;
      runit.rcolorMask = disp.rcolorMask;
      runit.trisNumber = disp.trisNumber; // build vertex gpu resoure

      let resUid = disp.vbuf.getUid();
      let vtx;
      let needBuild = true;

      if (vtxRes.hasResUid(resUid)) {
        vtx = vtxRes.getVertexRes(resUid);
        needBuild = vtx.version != disp.vbuf.version; //console.log("GpuVtxObject instance repeat to be used,needBuild: "+needBuild,vtx.getAttachCount());

        if (needBuild) {
          vtxRes.destroyRes(resUid);
          vtx.rcuid = vtxRes.getRCUid();
          vtx.resUid = resUid;
        }
      } else {
        vtx = new GpuVtxObject_1.GpuVtxObject();
        vtx.rcuid = vtxRes.getRCUid();
        vtx.resUid = resUid;
        vtxRes.addVertexRes(vtx); //console.log("GpuVtxObject instance create new: ",vtx.resUid);
      }

      if (needBuild) {
        vtx.indices.ibufStep = disp.vbuf.getIBufStep();
        vtx.indices.initialize(this.m_roVtxBuild, disp.vbuf);
        vtx.vertex.initialize(this.m_roVtxBuild, shdp, disp.vbuf);
        vtx.version = disp.vbuf.version;
      }

      vtxRes.__$attachRes(resUid);

      runit.vro = vtx.createVRO(this.m_roVtxBuild, shdp, true);
      runit.indicesRes = runit.vro.indicesRes;

      runit.vro.__$attachThis();

      runit.vtxUid = disp.vbuf.getUid();
      runit.ibufStep = runit.vro.ibufStep;
      runit.ibufType = runit.ibufStep != 4 ? this.m_rc.UNSIGNED_SHORT : this.m_rc.UNSIGNED_INT;
    }
  }

  buildGpuDisp(disp) {
    if (disp.__$ruid < 0) {
      if (disp.getMaterial() != null) {
        disp.__$$rsign = RenderConst_1.DisplayRenderSign.LIVE_IN_RENDERER;
        let runit = this.m_rpoUnitBuilder.create();
        disp.__$ruid = runit.uid;
        disp.__$$runit = runit;

        if (disp.getPartGroup() != null) {
          runit.partGroup = disp.getPartGroup().slice(0);
          runit.partTotal = runit.partGroup.length;
          let fs = runit.partGroup;

          for (let i = 0, len = runit.partTotal; i < len;) {
            i++;
            fs[i++] *= runit.ibufStep;
          }
        }

        runit.setDrawFlag(disp.renderState, disp.rcolorMask);
        this.buildVtxRes(disp, runit, this.updateDispMaterial(runit, disp));
        return true;
      } else {
        console.log("Error RODataBuilder::buildGpuDisp(), material is null !!!");
      }
    }

    return false;
  }

  update() {
    //this.updateDispToProcess();
    if (this.m_haveDeferredUpdate) {
      this.m_haveDeferredUpdate = false;
      let len = this.m_deferredVbufs.length;
      let i = 0;

      if (len > 0) {
        // deferred update vtx to gpu
        for (; i < len; ++i) {
          this.updateDispVbuf(this.m_deferredVbufs[i], false);
        }

        this.m_deferredVbufs = [];
      }

      len = this.m_deferredTROs.length;

      if (len > 0) {
        // deferred update texture list to gpu
        i = 0;

        for (; i < len; ++i) {
          this.updateTextureTRO(this.m_deferredTROs[i]);
        }

        this.m_deferredTROs = [];
      }

      len = this.m_deferredTextures.length;

      if (len > 0) {
        // deferred update single texture self system memory data to gpu memory data
        i = 0;

        for (; i < len; ++i) {
          this.m_deferredTextures[i].__$updateToGpu(this.m_texRes);
        }

        this.m_deferredTextures = [];
      }
    }
  }

  createsharedMList(material, shdp) {
    let sharedMList = material.createSharedUniforms();

    if (sharedMList == null) {
      // 通过shader uniform data 创建 shared uniform
      let dataList = material.createSharedUniformsData();

      if (dataList != null && dataList.length > 0) {
        sharedMList = [];

        for (let i = 0; i < dataList.length; ++i) {
          if (dataList[i] != null) {
            let uniform = this.m_shdUniformTool.buildLocalFromData(dataList[i], shdp);
            sharedMList.push(uniform);
          }
        }

        if (sharedMList.length < 1) {
          sharedMList = null;
        }
      }
    }

    return sharedMList;
  }

  updateGlobalMaterial(material, materialUniformUpdate = false) {
    if (material != null) {
      let rc = this.m_rc;
      let tro = null;
      let shdp = null;
      let texList = null;
      let texEnabled = false;

      if (material.getShaderData() == null) {
        texList = material.getTextureList();
        texEnabled = texList != null && texList.length > 0;
        material.initializeByCodeBuf(texEnabled);
      } else {
        texList = material.getTextureList();
      } // shdp = this.m_shader.create(material.getShaderData());


      shdp = this.m_shdpBuilder.create(material.getShaderData());
      shdp.upload(rc.RContext, rc.getUid());
      let texTotal = shdp.getTexTotal();

      if (texTotal > 0) {
        tro = this.createTRO(texList, texTotal); //tro = TextureRenderObj.Create(this.m_texRes, texList, texTotal);
      }

      if (this.m_shader.getSharedUniformByShd(shdp) == null) {
        let sharedMList = this.createsharedMList(material, shdp);

        if (sharedMList != null) {
          for (let i = 0; i < sharedMList.length; ++i) {
            sharedMList[i].program = shdp.getGPUProgram();
          }
        }

        this.m_shader.setSharedUniformByShd(shdp, this.m_shdUniformTool.buildShared(sharedMList, rc, shdp));
      }

      if (material.__$uniform == null) {
        material.__$uniform = this.m_shdUniformTool.buildLocalFromData(material.createSelfUniformData(), shdp);
      }

      this.m_shader.__$globalUniform = material.__$uniform;
      this.m_shader.bindToGpu(shdp.getUid());

      if (materialUniformUpdate && material.__$uniform != null) {
        this.m_shader.useUniform(material.__$uniform);
      }

      if (tro != null) {
        tro.run();
      }
    }
  }

  reset() {
    this.m_deferredVbufs = [];
    this.m_deferredTROs = [];
  }

}

exports.default = RODataBuilder;

/***/ }),

/***/ "3806":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("a996"));

const KeyboardEvent_1 = __importDefault(__webpack_require__("7045"));

const Keyboard_1 = __importDefault(__webpack_require__("9260"));

const StageBase_1 = __importDefault(__webpack_require__("7b29"));

class Stage3D extends StageBase_1.default {
  constructor(rcuid, pdocument) {
    super(rcuid);
    this.m_resize_listener = [];
    this.m_resize_ers = [];
    this.m_enterFrame_listener = [];
    this.m_enterFrame_ers = [];
    this.m_keyEvt = new KeyboardEvent_1.default();
    this.m_keyDown_listener = [];
    this.m_keyDown_ers = [];
    this.m_keyUp_listener = [];
    this.m_keyUp_ers = [];
    this.m_enterFrameEvt = new EventBase_1.default();

    if (Stage3D.s_document == null) {
      Stage3D.s_document = pdocument;

      pdocument.onkeydown = function (evt) {
        Keyboard_1.default.KeyDown(evt);
      };

      pdocument.onkeyup = function (evt) {
        Keyboard_1.default.KeyUp(evt);
      };
    }

    Keyboard_1.default.AddEventListener(KeyboardEvent_1.default.KEY_DOWN, this, this.keyDown);
    Keyboard_1.default.AddEventListener(KeyboardEvent_1.default.KEY_UP, this, this.keyUp);
  }

  enterFrame() {
    this.m_enterFrameEvt.type = EventBase_1.default.ENTER_FRAME;
    const ls = this.m_enterFrame_listener;
    let len = ls.length;

    for (var i = 0; i < len; ++i) {
      ls[i].call(this.m_enterFrame_ers[i], this.m_enterFrameEvt);
    }
  }

  setViewPort(px, py, pw, ph) {
    this.m_autoSynViewAndStageSize = false;
    this.m_viewX = px;
    this.m_viewY = py;

    if (pw != this.m_viewW || ph != this.m_viewH) {
      this.m_viewW = pw;
      this.m_viewH = ph;
      this.updateViewUData();
    }
  }

  updateViewUData() {
    this.uProbe.setVec4Data(2.0 / this.stageWidth, 2.0 / this.stageHeight, this.stageWidth, this.stageHeight);
    this.uProbe.update();
    this.m_preStageWidth = this.m_viewW;
    this.m_preStageHeight = this.m_viewH;
  }

  update() {
    if (this.m_preStageWidth != this.stageWidth || this.m_preStageHeight != this.stageHeight) {
      if (this.m_autoSynViewAndStageSize) {
        this.m_viewW = this.stageWidth;
        this.m_viewH = this.stageHeight;
        this.updateViewUData();
      }

      this.m_stW = this.stageWidth;
      this.m_stH = this.stageHeight;
      this.stageHalfWidth = 0.5 * this.m_stW;
      this.stageHalfHeight = 0.5 * this.m_stH;
      this.m_baseEvt.target = this;
      this.m_baseEvt.type = EventBase_1.default.RESIZE;
      this.m_baseEvt.phase = 1;
      this.sendResizeEvt(this.m_baseEvt);
    } else {
      this.stageWidth = this.m_stW;
      this.stageHeight = this.m_stH;
      this.stageHalfWidth = 0.5 * this.m_stW;
      this.stageHalfHeight = 0.5 * this.m_stH;
    }
  }

  keyDown(evt) {
    this.m_keyEvt.phase = 1;
    this.m_keyEvt.type = KeyboardEvent_1.default.KEY_DOWN;
    this.m_keyEvt.altKey = evt.altKey;
    this.m_keyEvt.ctrlKey = evt.ctrlKey;
    this.m_keyEvt.shiftKey = evt.shiftKey;
    this.m_keyEvt.repeat = evt.repeat;
    this.m_keyEvt.key = evt.key;
    this.m_keyEvt.keyCode = evt.keyCode;
    this.m_keyEvt.location = evt.location;
    let len = this.m_keyDown_listener.length;

    for (var i = 0; i < len; ++i) {
      this.m_keyDown_listener[i].call(this.m_keyDown_ers[i], this.m_keyEvt);
    }
  }

  keyUp(evt) {
    this.m_keyEvt.phase = 1;
    this.m_keyEvt.type = KeyboardEvent_1.default.KEY_UP;
    this.m_keyEvt.altKey = evt.altKey;
    this.m_keyEvt.ctrlKey = evt.ctrlKey;
    this.m_keyEvt.shiftKey = evt.shiftKey;
    this.m_keyEvt.repeat = evt.repeat;
    this.m_keyEvt.key = evt.key;
    this.m_keyEvt.keyCode = evt.keyCode;
    this.m_keyEvt.location = evt.location;
    this.m_keyEvt.target = this;
    let len = this.m_keyUp_listener.length;

    for (var i = 0; i < len; ++i) {
      this.m_keyUp_listener[i].call(this.m_keyUp_ers[i], this.m_keyEvt);
    }
  }

  sendResizeEvt(evt) {
    let len = this.m_resize_listener.length; //console.log("Stage3D::sendResizeEvt(), m_resize_listener.length: ",this.m_resize_listener.length);

    for (var i = 0; i < len; ++i) {
      this.m_resize_listener[i].call(this.m_resize_ers[i], evt);
    }
  }

  addEventListener(type, target, func, captureEnabled = true, bubbleEnabled = true) {
    if (func != null && target != null) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          this.addTarget(this.m_resize_listener, this.m_resize_ers, target, func);
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.addTarget(this.m_enterFrame_listener, this.m_enterFrame_ers, target, func);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          this.addTarget(this.m_keyDown_listener, this.m_keyDown_ers, target, func);
          break;

        case KeyboardEvent_1.default.KEY_UP:
          this.addTarget(this.m_keyUp_listener, this.m_keyUp_ers, target, func);
          break;

        default:
          this.m_dp.addEventListener(type, target, func, captureEnabled, bubbleEnabled);
          break;
      }
    }
  }

  removeEventListener(type, target, func) {
    if (func != null && target != null) {
      switch (type) {
        case EventBase_1.default.RESIZE:
          this.removeTarget(this.m_resize_listener, this.m_resize_ers, target);
          break;

        case EventBase_1.default.ENTER_FRAME:
          this.removeTarget(this.m_enterFrame_listener, this.m_enterFrame_ers, target);
          break;

        case KeyboardEvent_1.default.KEY_DOWN:
          this.removeTarget(this.m_keyDown_listener, this.m_keyDown_ers, target);
          break;

        case KeyboardEvent_1.default.KEY_UP:
          this.removeTarget(this.m_keyUp_listener, this.m_keyUp_ers, target);
          break;

        default:
          this.m_dp.removeEventListener(type, target, func);
          break;
      }
    }
  }

}

Stage3D.s_document = null;
exports.default = Stage3D;

/***/ }),

/***/ "3844":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "38de":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const AbsGeomBase_1 = __importDefault(__webpack_require__("f48d"));

class RadialLine extends AbsGeomBase_1.default {
  constructor() {
    super(...arguments);
    this.tv = new Vector3D_1.default(1.0, 0.0, 0.0);
  }

  update() {
    this.tv.normalize();
  }

  updateFast() {
    this.tv.normalize();
  } // 射线和三个点表示的三角形是否相交


  static IntersectionTri(rlpv, rltv, triva, trivb, trivc, outV) {
    return 0;
  } // 射线和两个点表示的线段是否相交


  static IntersectionLS(rlpv, rltv, lspva, lspvb, outV, radius = 1.0) {
    let pv = RadialLine.__tAv;
    pv.copyFrom(lspvb);
    pv.subtractBy(lspva);
    pv.normalize();
    Vector3D_1.default.Cross(rltv, pv, outV);
    outV.normalize();
    pv.w = outV.dot(rlpv) - outV.dot(lspvb);

    if (Math.abs(pv.w) <= radius) {
      // 两条直线已经相交
      // outV 和 rlpv rltv 计算构成了一个平面
      outV.crossBy(rltv);
      outV.normalize();
      outV.w = outV.dot(rlpv); // 计算 lspva 所在的直线与平面的交点
      //let tv2:Vector3D = AbsGeomBase.__tV1;

      pv.w = (outV.w - outV.dot(lspva)) / pv.dot(outV);
      outV.copyFrom(pv);
      outV.scaleBy(pv.w);
      outV.addBy(lspva);
      pv.copyFrom(outV);
      pv.subtractBy(lspva);
      let pv1 = AbsGeomBase_1.default.__tV1;
      pv1.copyFrom(outV);
      pv1.subtractBy(lspvb);

      if (pv.dot(pv1) <= 0.0) {
        return 1;
      }
    }

    return 0;
  }
  /**
   * @param rlpv 射线起点
   * @param rltv  射线朝向
   * @param cv 球心坐标
   * @param radius 球体半径
   * @param outV 如果相交，记录下交点
   * @returns 检测得到距离射线起点最近的点, 1表示相交, 0表示不相交
   */


  static IntersectioNearSphere2(rlpv, rltv, cv, radius, outV) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);
    radius *= radius;

    if (pv.w > MathConst_1.default.MATH_MIN_POSITIVE) {
      outV.copyFrom(rltv);
      outV.scaleBy(pv.w);
      outV.subtractBy(pv);
      pv.x = outV.getLengthSquared();

      if (pv.x <= radius) {
        // 远距离
        //outV.w = pv.w + Math.sqrt(radius * radius - outV.getLengthSquared());
        // 取近距离
        pv.w -= Math.sqrt(radius - pv.x);
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    } else if (pv.getLengthSquared() <= radius) {
      outV.copyFrom(rltv);
      outV.scaleBy(pv.w);
      outV.subtractBy(pv);
      pv.x = outV.getLengthSquared();

      if (pv.x <= radius) {
        // 取远距离
        pv.w += Math.sqrt(radius - pv.x);
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    }

    return 0;
  } // @return 检测得到距离射线起点最近的点, 1表示相交,0表示不相交


  static IntersectioNearSphere(rlpv, rltv, cv, radius, outV) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);

    if (pv.w > MathConst_1.default.MATH_MIN_POSITIVE) {
      outV.x = pv.x - pv.w * rltv.x;
      outV.y = pv.y - pv.w * rltv.y;
      outV.z = pv.z - pv.w * rltv.z;
      outV.x = outV.getLengthSquared();
      outV.w = radius * radius;

      if (outV.x <= outV.w) {
        // rlpv到远交点记作XP, rlpv到球心记作CP, CP到远交点记作RP
        // 通过余弦定律得到一元二次方程得并且解这个方程得到 XP 的距离
        // 获得CP距离的平方值
        outV.x = pv.getLengthSquared(); // RP距离的平方值 减去 CP距离的平方值

        outV.z = outV.w - outV.x; //	// 获得CP距离值
        //	outV.w = Math.sqrt(outV.x);
        // 准备计算 CP和XP 之间夹角a的余弦值, cos(a)值

        pv.normalize(); // cos(a) 值 和 CP距离值相乘
        //pv.y = pv.dot(rltv) * outV.w;

        outV.y = pv.dot(rltv) * Math.sqrt(outV.x); // 求解方程的根,得到近些的距离

        pv.w = (-outV.y + Math.sqrt(outV.y * outV.y + 4.0 * outV.z)) * 0.5;
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    } else {
      outV.x = pv.getLengthSquared();
      outV.w = radius * radius;

      if (outV.x <= outV.w) {
        outV.z = outV.w - outV.x;
        pv.normalize();
        outV.y = pv.dot(rltv) * Math.sqrt(outV.x); // 求解方程的根,得到远些的距离

        pv.w = (-outV.y + Math.sqrt(outV.y * outV.y + 4.0 * outV.z)) * 0.5;
        outV.copyFrom(rltv);
        outV.scaleBy(pv.w);
        outV.addBy(rlpv);
        outV.w = 1.0;
        return 1;
      }
    }

    return 0;
  }

  static IntersectSphere(rlpv, rltv, cv, radius) {
    let pv = RadialLine.__tAv;
    pv.x = cv.x - rlpv.x;
    pv.y = cv.y - rlpv.y;
    pv.z = cv.z - rlpv.z;
    pv.w = pv.dot(rltv);

    if (pv.w < MathConst_1.default.MATH_MIN_POSITIVE) {
      return pv.getLengthSquared() <= radius * radius;
    }

    pv.x -= pv.w * rltv.x;
    pv.y -= pv.w * rltv.y;
    pv.z -= pv.w * rltv.z;
    return pv.getLengthSquared() <= radius * radius;
  }

}

RadialLine.__tAv = new Vector3D_1.default();
exports.default = RadialLine;

/***/ }),

/***/ "3930":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
const __$mcv = 1e-5;

class Color4 {
  constructor(pr = 1.0, pg = 1.0, pb = 1.0, pa = 1.0) {
    this.r = pr;
    this.g = pg;
    this.b = pb;
    this.a = pa;
  }

  fromArray(arr, offset = 0) {
    this.r = arr[offset];
    this.g = arr[offset + 1];
    this.b = arr[offset + 2];
    this.a = arr[offset + 3];
    return this;
  }

  toArray(arr, offset = 0) {
    arr[offset] = this.r;
    arr[offset + 1] = this.g;
    arr[offset + 2] = this.b;
    arr[offset + 3] = this.a;
    return this;
  }

  fromArray3(arr, offset = 0) {
    this.r = arr[offset];
    this.g = arr[offset + 1];
    this.b = arr[offset + 2];
    return this;
  }

  toArray3(arr, offset = 0) {
    arr[offset] = this.r;
    arr[offset + 1] = this.g;
    arr[offset + 2] = this.b;
    return this;
  }

  setRGB3Bytes(r, g, b) {
    this.r = r / 255.0;
    this.g = g / 255.0;
    this.b = b / 255.0;
    return this;
  }

  setRGB3f(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }

  setRGBUint8(uint8R, uint8G, uint8B) {
    let k = 1.0 / 255.0;
    this.r = uint8R * k;
    this.g = uint8G * k;
    this.b = uint8B * k;
    return this;
  }

  setRGBUint24(rgbUint24) {
    this.r = (rgbUint24 >> 16 & 0x0000ff) / 255.0;
    this.g = (rgbUint24 >> 8 & 0x0000ff) / 255.0;
    this.b = (rgbUint24 & 0x0000ff) / 255.0;
    return this;
  }

  getRGBUint24() {
    return (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
  }

  setRGBA4f(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }

  copyFrom(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }

  copyFromRGB(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    return this;
  }

  scaleBy(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }

  inverseRGB() {
    this.r = 1.0 - this.r;
    this.g = 1.0 - this.g;
    this.b = 1.0 - this.b;
    return this;
  }

  randomRGB(density = 1.0, bias = 0.0) {
    this.r = Math.random() * density;
    this.g = Math.random() * density;
    this.b = Math.random() * density;
    this.r += bias;
    this.g += bias;
    this.b += bias;
    return this;
  }

  normalizeRandom(density = 1.0, bias = 0.0) {
    this.r = Math.random();
    this.g = Math.random();
    this.b = Math.random();
    let d = Math.sqrt(this.r * this.r + this.g * this.g + this.b * this.b);

    if (d > __$mcv) {
      this.r = density * this.r / d;
      this.g = density * this.g / d;
      this.b = density * this.b / d;
    }

    this.r += bias;
    this.g += bias;
    this.b += bias;
    return this;
  }

  normalize(density) {
    if (density == undefined) density = 1.0;
    let d = Math.sqrt(this.r * this.r + this.g * this.g + this.b * this.b);

    if (d > __$mcv) {
      this.r = density * this.r / d;
      this.g = density * this.g / d;
      this.b = density * this.b / d;
    }

    return this;
  }
  /**
   * @returns for example: rgba(255,255,255,1.0)
   */


  getCSSDecRGBAColor() {
    let pr = Math.floor(this.r * 255.0);
    let pg = Math.floor(this.g * 255.0);
    let pb = Math.floor(this.b * 255.0);
    let pa = this.a;
    return "rgba(" + pr + "," + pg + "," + pb + "," + pa + ")";
  }
  /**
   * @returns for example: #350b7e
   */


  getCSSHeXRGBColor() {
    let str = "#";
    let t = Math.floor(this.r * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    t = Math.floor(this.g * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    t = Math.floor(this.b * 255.0);

    if (t < 0xf) {
      str += "0" + t.toString(16);
    } else {
      str += "" + t.toString(16);
    }

    return str;
  }

  toString() {
    return "[Color4(r=" + this.r + ", g=" + this.g + ",b=" + this.b + ",a=" + this.a + ")]";
  }

}

exports.default = Color4;

/***/ }),

/***/ "3964":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 处理子线程和主线程之、子线程和子线程 这些线程间的数据传输路由
 */

class TaskDataRouter {
  constructor(taskclass) {
    // 这个变量的值将由实现者视具体情况而定，因为这个值为true则表示数据已经准备好了处于可用状态
    this.m_dataEnabled = false;
    this.param = null;
    this.m_taskclass = taskclass;
  }

  getTaskClass() {
    return this.m_taskclass;
  }

  isDataEnabled() {
    return this.m_dataEnabled;
  }
  /**
   * @returns 返回是否处在传输状态中，如果是，则返回true
   */


  isTransmission() {
    return this.m_dataEnabled && this.param != null;
  }

  disable() {
    this.m_dataEnabled = false;
  }

  setData(data) {// 这里不一定是直接赋值，可能要经过处理和转化
  }
  /**
   * 由线程对象调用，以便启动数据处理的相应， 子类覆盖此函数以便实现具体的功能
   */


  acquireTrigger() {}
  /**
   * 这个过程默认支持异步机制，如果有数据则使用，如果没数据，则进入到等待队列, 需要被子类覆盖之后再使用
   * 这个数据的获取过程分为两类:
   * 纯值访问的方式: 内存操作无影响的可复制数据，则可以保持源数据直接使用。
   * 内存转移的方式: 这个情况下数据要以内存转移的形式传递出去，传递出去之后而没有传回来之前是不能再使用了
   * 具体实现则由子类的具体逻辑来决定
   * @returns 由线程相关过程获取数据对象
   */


  getData() {
    // 如果有，就直接返回，如果没有，则将自己加入到等等队列
    throw Error("illegal operation !!!");
    return null;
  }
  /**
   * 具体实现逻辑由子类覆盖
   * @returns 由线程相关过程获取数据对象的transfer对象数组
   */


  getTransfers() {
    return null;
  }

}

exports.TaskDataRouter = TaskDataRouter;

/***/ }),

/***/ "3a1d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadConfigure_1 = __webpack_require__("fce7");

const ThrDataPool_1 = __webpack_require__("7566");

const ThreadSendData_1 = __webpack_require__("2356");

const ThreadBase_1 = __webpack_require__("7ebf");

const TaskDescriptor_1 = __webpack_require__("c917");

const ThreadCodeSrcType_1 = __webpack_require__("d2d9");

const ThreadTaskPool_1 = __webpack_require__("42a2");

const TDRManager_1 = __webpack_require__("85f5");

const TaskRegister_1 = __webpack_require__("63fb");
/**
 * 多线程任务调度器, 之所以用实例，是因为不同的实例实际上就能对线程集合做分类管理
 */


class ThreadSchedule {
  // private m_autoTerminate: boolean = true;
  constructor() {
    // allow ThreadSchedule initialize yes or no
    this.m_initBoo = true; // 延迟销毁子线程的毫秒数

    this.m_teDelay = 3000;
    this.m_teTime = 0;
    this.m_maxThreadsTotal = 0;
    this.m_thrSupportFlag = -1;
    this.m_codeBlob = null;
    this.m_commonModuleUrls = [];
    this.m_threads = [];
    this.m_threadsTotal = 0;
    this.m_threadEnabled = true; // TODO(lyl): 下面两行暂时这么写

    this.m_thrIdexSDList = [];
    this.m_thrIndexList = [];
    this.m_codeStrList = [];
    this.m_dataPool = new ThrDataPool_1.ThrDataPool();
    /**
     * 线程中子模块间依赖关系的json描述
     */

    this.m_graphJsonStr = "";
    this.m_autoSendData = false;
    this.m_currNewThr = null;
    let tot = ThreadConfigure_1.ThreadConfigure.MAX_TASKS_TOTAL;
    this.m_taskPool = new ThreadTaskPool_1.ThreadTaskPool(tot);
    this.m_descList = new Array(tot);
    this.m_descList.fill(null);
    this.m_tdrManager = new TDRManager_1.TDRManager(tot);
    this.m_taskReg = new TaskRegister_1.TaskRegister();
    this.m_teTime = Date.now();
  }

  setParams(autoSendData, terminateDelayMS = 3000) {
    this.m_autoSendData = autoSendData;
    this.m_teDelay = terminateDelayMS;
  }

  hasRouterByTaskClass(taskclass) {
    return this.m_tdrManager.hasRouterByTaskClass(taskclass);
  }

  setTaskDataRouter(taskDataRouter) {
    this.m_tdrManager.setRouter(taskDataRouter);
  }
  /**
   * 任务实例和当前线程系统建立关联
   * @param task 任务实例
   * @param taskDataRouter 用户为线程中数据路由
   * @param threadIndex 指定线程序号, 默认值为1表示未指定
   */


  bindTask(task, threadIndex = -1) {
    if (task != null) {
      let success = task.attach(this.m_taskPool);

      if (success) {
        let localPool = null;

        if (threadIndex >= 0 && threadIndex < this.m_maxThreadsTotal) {
          for (;;) {
            if (threadIndex >= this.m_threadsTotal) {
              this.createThread();
            } else {
              break;
            }
          }

          localPool = this.m_threads[threadIndex].localDataPool;
        }

        let d = task.dependency;
        let info = null;

        if (d != null) {
          if (d.isJSFile()) {
            info = this.initTaskByURL(d.threadCodeFileURL, -1);
          } else if (d.isDependency()) {
            info = this.initTaskByDependency(d.dependencyUniqueName, d.moduleName);
          } else if (d.isCodeString()) {
            info = this.initTaskByCodeStr(d.threadCodeString, d.moduleName);
          }
        }

        task.setDataPool(this.m_dataPool, localPool);
        task.setTaskInfo(info);
      }
    }
  }

  sendDataToThreadAt(i, sendData) {
    if (i >= 0 && i < this.m_maxThreadsTotal) {
      if (i >= this.m_threadsTotal) {
        for (;;) {
          if (i >= this.m_threadsTotal) {
            this.createThread();
          } else {
            break;
          }
        }
      }

      if (sendData != null && sendData.sendStatus < 0) {
        if (this.m_threads[i].isFree()) {
          sendData.sendStatus = 0;
          this.m_threads[i].sendDataTo(sendData);
        } else {
          this.m_threads[i].localDataPool.addData(sendData);
        }
      }
    } else {
      this.m_thrIdexSDList.push(sendData);
      this.m_thrIndexList.push(i);
    }
  }
  /**
   * @returns 返回是否在队列中还有待处理的数据
   */


  hasTaskData() {
    return this.m_dataPool.isEnabled();
  }

  getThrDataPool() {
    return this.m_dataPool;
  }
  /**
   * 间隔一定的时间，循环执行
   */


  run() {
    let terminate = false;

    if (this.getThreadEnabled()) {
      this.m_tdrManager.run(); //console.log("this.m_dataPool.isEnabled(): ",this.m_dataPool.isEnabled());

      let needTotal = 0;

      if (this.m_dataPool.isEnabled()) {
        for (let i = 0; i < this.m_threadsTotal; ++i) {
          // console.log("this.m_threads["+i+"].isFree(): ",this.m_threads[i].isFree(),", enabled: ",this.m_threads[i].isEnabled());
          if (this.m_threads[i].isFree()) {
            this.m_dataPool.sendDataTo(this.m_threads[i]);
          } else {
            if (this.m_dataPool.isEnabled()) needTotal++;
          }
        }
      } else {
        for (let i = 0; i < this.m_threadsTotal; ++i) {
          if (!this.m_threads[i].sendPoolDataToThread()) {
            if (this.m_threads[i].hasDataToThread()) needTotal++;
          }
        }
      }

      needTotal += this.m_dataPool.isEnabled() ? 1 : 0;

      if (needTotal > 0) {
        this.createThread();
      } else {
        needTotal = 0;

        for (let i = 0; i < this.m_threadsTotal; ++i) {
          if (this.m_threads[i].isFree()) {
            needTotal++;
          }
        }

        if (this.m_teDelay > 0) {
          terminate = needTotal >= this.m_threadsTotal;
          if (!terminate) this.m_teTime = Date.now();
        }
      }
    } // console.log("terminate: ",terminate,this.m_threadsTotal);


    if (terminate && this.m_threadsTotal > 0) {
      let dt = Date.now() - this.m_teTime;

      if (dt > this.m_teDelay) {
        this.m_teTime = Date.now();
        let thr = this.m_threads[this.m_threadsTotal - 1];

        if (thr.isFree()) {
          this.m_threads.pop();
          this.m_threadsTotal--;
          thr.destroy();
          console.log("ThreadSchedule::run(), terminate and destroy a thread instance, threadsTotal: ", this.m_threadsTotal);
        }
      }
    }
  }

  createThread() {
    if (this.m_currNewThr != null && (this.m_currNewThr.isEnabled() || this.m_currNewThr.isDestroyed())) {
      this.m_currNewThr = null;
    }

    if (this.m_currNewThr == null && this.m_threadsTotal < this.m_maxThreadsTotal) {
      let thread = new ThreadBase_1.ThreadBase(this.m_tdrManager, this.m_taskPool, this.m_graphJsonStr);
      this.m_currNewThr = thread;
      thread.autoSendData = this.m_autoSendData;
      thread.globalDataPool = this.m_dataPool;
      thread.initialize(this.m_codeBlob);
      this.m_threads.push(thread);
      console.log("create Thread(" + this.m_threadsTotal + "), dataTotal: ", this.m_dataPool.getDataTotal());
      this.m_threadsTotal++;
      this.m_tdrManager.setThreads(this.m_threads);

      for (let i = 0, len = this.m_descList.length; i < len; ++i) {
        thread.initModuleByTaskDescriptor(this.m_descList[i]);
      }

      thread.initModules(this.m_commonModuleUrls);

      for (let i = 0; i < this.m_codeStrList.length; ++i) {
        thread.initModuleByCodeString(this.m_codeStrList[i]);
      }

      if (this.m_threadsTotal >= this.m_maxThreadsTotal) {
        this.m_commonModuleUrls = [];
        this.m_codeStrList = [];
      }

      let sdList = this.m_thrIdexSDList.slice(0);
      let indexList = this.m_thrIndexList.slice(0);
      this.m_thrIdexSDList = [];
      this.m_thrIndexList = [];

      for (let i = 0; i < sdList.length; ++i) {
        this.sendDataToThreadAt(indexList[i], sdList[i]);
      }
    }
  }
  /**
   * 通过参数, 添加发送给子线程的数据
   * @param taskCmd 处理当前数据的任务命令名字符串
   * @param streams 用于内存所有权转换的数据流数组, 例如 Float32Array 数组, 默认值是null
   * @param descriptor 会发送到子线程的用于当前数据处理的数据描述对象, for example: {flag : 0, type: 12, name: "First"}, 默认值是 null
   */


  addDataWithParam(taskCmd, streams = null, descriptor = null) {
    let sd = ThreadSendData_1.ThreadSendData.Create();
    sd.taskCmd = taskCmd;
    sd.streams = streams;
    sd.descriptor = descriptor;
    this.addData(sd);
  }
  /**
   * 将任务实例重点额数据对象添加到线程系统任务池子中
   * @param thrData
   */


  addData(thrData) {
    if (thrData != null && thrData.srcuid >= 0) {
      this.m_dataPool.addData(thrData);
    }
  }

  getAFreeThread() {
    for (let i = 0; i < this.m_threadsTotal; ++i) {
      if (this.m_threads[i].isFree()) {
        return this.m_threads[i];
      }
    }

    return null;
  }

  getThreadsTotal() {
    return this.m_threadsTotal;
  }

  getMaxThreadsTotal() {
    return this.m_maxThreadsTotal;
  } // 当前系统是否开启 worker multi threads


  setThreadEnabled(boo) {
    if (this.m_thrSupportFlag > 0) this.m_thrSupportFlag = boo ? 2 : 1;
    this.m_threadEnabled = boo;
  }

  getThreadEnabled() {
    return this.m_threadEnabled;
  } // runtime support worker multi thrads yes or no


  isSupported() {
    if (this.m_thrSupportFlag > 0) {
      return this.m_thrSupportFlag == 2;
    }

    let boo = typeof Worker !== "undefined" && typeof Blob !== "undefined";
    this.m_thrSupportFlag = boo ? 2 : 1;
    this.m_threadEnabled = boo;
    return boo;
  }
  /**
   * 通过外部js文件源码初始化在线程中处理指定任务的程序代码
   * @param jsFileUrl 子线程中执行的源码的js文件的相对url
   * @param taskclass 子线程中执行的源码中的对象类名
   */


  initTaskByURL(jsFileUrl, taskclass, moduleName = "") {
    if (jsFileUrl != "") {
      let id = this.m_taskReg.getTaskClassByKeyuns(jsFileUrl);
      let task = id >= 0 ? this.m_descList[id] : null;

      if (task == null) {
        task = new TaskDescriptor_1.TaskDescriptor(ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE, jsFileUrl, moduleName);
        this.m_taskReg.buildTaskInfo(task);
        id = task.info.taskClass;
        this.m_descList[id] = task;
        this.initModuleByTaskDescriptor(task);
      }

      return task.info;
    }

    return null;
  }
  /**
   * 通过唯一依赖名初始化在线程中处理指定任务的程序代码
   * @param jsFileUrl 子线程中执行的源码的js文件的相对url
   * @param taskclass 子线程中执行的源码中的对象类名
   */


  initTaskByDependency(dependencyUniqueName, moduleName = "") {
    if (dependencyUniqueName != "") {
      let id = this.m_taskReg.getTaskClassByKeyuns(dependencyUniqueName);
      let task = id >= 0 ? this.m_descList[id] : null;

      if (task == null) {
        task = new TaskDescriptor_1.TaskDescriptor(ThreadCodeSrcType_1.ThreadCodeSrcType.DEPENDENCY, dependencyUniqueName, moduleName);
        this.m_taskReg.buildTaskInfo(task);
        id = task.info.taskClass;
        this.m_descList[id] = task;
        this.initModuleByTaskDescriptor(task);
      }

      return task.info;
    }

    return null;
  }
  /**
   * 通过字符串源码初始化在线程中处理指定任务的程序代码
   * @param codestr 子线程中执行的源码字符串
   * @param moduleName 子线程中执行的源码中的对象类名
   */


  initTaskByCodeStr(codestr, moduleName) {
    if (codestr != "") {
      let id = this.m_taskReg.getTaskClassByKeyuns(moduleName);
      let task = id >= 0 ? this.m_descList[id] : null;

      if (task == null) {
        task = new TaskDescriptor_1.TaskDescriptor(ThreadCodeSrcType_1.ThreadCodeSrcType.STRING_CODE, codestr, moduleName);
        this.m_taskReg.buildTaskInfo(task);
        id = task.info.taskClass;
        this.m_descList[id] = task;
        this.initModuleByTaskDescriptor(task);
      }

      return task.info;
    }

    return null;
  }

  initModuleByTaskDescriptor(task) {
    for (let i = 0; i < this.m_threadsTotal; ++i) {
      this.m_threads[i].initModuleByTaskDescriptor(task);
    }
  }
  /**
   * 通过js文件url数组来初始化子线程中的若干共有基础功能模块
   * @param moduleUrls 模块的js代码url数组
   */


  initModules(moduleUrls) {
    if (moduleUrls != null && moduleUrls.length > 0) {
      for (let i = 0; i < moduleUrls.length; ++i) {
        if (moduleUrls[i] == "") throw Error("moduleUrls[" + i + '] == ""');
        this.m_commonModuleUrls.push(moduleUrls[i]);
      }

      for (let i = 0; i < this.m_threadsTotal; ++i) {
        this.m_threads[i].initModules(moduleUrls);
      }
    }
  }
  /**
   * 通过代码字符串形式来初始化子线程中的共有基础功能模块
   * @param codeStr js代码的字符串形式
   */


  initModuleByCodeString(codeStr) {
    if (codeStr.length > 8) {
      if (this.m_threadsTotal < this.m_maxThreadsTotal) {
        this.m_codeStrList.push(codeStr);
      }

      for (let i = 0; i < this.m_threadsTotal; ++i) {
        this.m_threads[i].initModuleByCodeString(codeStr);
      }
    }
  }

  destroy() {
    if (this.m_tdrManager != null) {
      for (let i = 0; i < this.m_threadsTotal; ++i) {
        this.m_threads[i].destroy();
      }

      this.m_threads = [];
      this.m_tdrManager.destroy();
      this.m_tdrManager = null;
      this.m_threadsTotal = 0;
    }
  }
  /**
   * 设置线程中子模块间依赖关系的json描述字符串
   * @param graphJsonStr json描述字符串
   */


  setDependencyGraphJsonString(graphJsonStr) {
    this.m_graphJsonStr = graphJsonStr;
  }
  /**
   * 初始化线程系统的子线程
   * @param maxThreadsTotal 最大子线程数量
   * @param coreCodeUrl 线程初始核心代码文件url
   */


  initialize(maxThreadsTotal, coreCodeUrl, baseCodeStr = "") {
    if (this.m_initBoo) {
      if (this.getThreadEnabled() && this.isSupported()) {
        if (coreCodeUrl == "") {
          throw Error('coreCodeUrl == "" !!!');
        }

        coreCodeUrl = this.getUrl(coreCodeUrl);
        let request = new XMLHttpRequest();
        request.open("GET", coreCodeUrl, true);

        request.onload = () => {
          if (request.status <= 206) {
            let bolb = baseCodeStr == "" ? new Blob([request.responseText]) : new Blob([baseCodeStr + request.responseText]);
            this.initThread(maxThreadsTotal, bolb);
          } else {
            console.error("load thread core code file url error: ", coreCodeUrl);
          }
        };

        request.onerror = e => {
          console.error("load thread core code file url error: ", coreCodeUrl);
        };

        request.send(null);
      }

      this.m_initBoo = false;
    }
  }

  initThread(maxThreadsTotal, bolb) {
    if (maxThreadsTotal < 1) maxThreadsTotal = 1;
    this.m_codeBlob = bolb;
    this.m_maxThreadsTotal = maxThreadsTotal; // this.createThread();
  }

  getUrl(url) {
    let k = url.indexOf("http://");
    if (k < 0) k = url.indexOf("https://");
    if (k >= 0) return url;
    let scriptDir = window.location.href;
    let baseUrl = scriptDir.slice(0, scriptDir.lastIndexOf("/") + 1);
    url = baseUrl + url;
    return url;
  }

}

exports.ThreadSchedule = ThreadSchedule;

/***/ }),

/***/ "3b73":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RendererDevice {
  /**
   * set web html body background color
   * @param color a color string, the default value is "white"
   */
  static SetWebBodyColor(color = "white") {
    const body = document.body;
    body.style.background = color;
  }

  static SetLanguage(language) {
    RendererDevice.s_language = language;
  }

  static GetLanguage() {
    if (RendererDevice.s_language != "") {
      return RendererDevice.s_language;
    }

    RendererDevice.s_language = navigator.language;
    return RendererDevice.s_language;
  }

  static SetThreadEnabled(boo) {
    RendererDevice.s_threadEnabled = boo;
  }

  static GetThreadEnabled() {
    return RendererDevice.s_threadEnabled;
  }

  static GetDebugEnabled() {
    return RendererDevice.s_debugEnabled;
  }

  static SetDebugEnabled(boo) {
    RendererDevice.s_debugEnabled = boo;
  }

  static SetDevicePixelRatio(dpr) {
    RendererDevice.s_devicePixelRatio = dpr;
  }

  static GetDevicePixelRatio() {
    return RendererDevice.s_devicePixelRatio;
  }

  static Initialize(infoArr) {
    if (RendererDevice.s_inited) {
      RendererDevice.s_inited = false;
      RendererDevice.s_WEBGL_VER = infoArr[0];
      RendererDevice.TestMobileWeb();
      RendererDevice.s_language = navigator.language + "";
    }
  }
  /**
   * 返回当前是不是window操作系统 PC端
   */


  static IsWindowsPCOS() {
    return !(RendererDevice.IsSafariWeb() || RendererDevice.IsMobileWeb());
  }
  /**
   * 得到windows系统环境下当前浏览器是否使用独立显卡。集显 integrated video card, 独显 external video card
   * get whether the gpu is external video card in window os
   * @returns get whether the gpu is external video card in window os
   */


  static IsWinExternalVideoCard() {
    if (RendererDevice.s_winExternalVideoCardFlag > 0) {
      return RendererDevice.s_winExternalVideoCardFlag == 2;
    }

    let flag = RendererDevice.IsSafariWeb() || RendererDevice.IsMobileWeb();

    if (!flag) {
      flag = RendererDevice.GPU_RENDERER.indexOf("Intel(R)") < 0;
    }

    RendererDevice.s_winExternalVideoCardFlag = flag ? 2 : 1;
    /**
     * webgl_renderer:  ANGLE (Intel, Intel(R) UHD Graphics 630 Direct3D11 vs_5_0 ps_5_0, D3D11-25.20.100.6617)
     */

    return RendererDevice.s_winExternalVideoCardFlag == 2;
  }

  static TestSafariWeb() {
    //return /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
    return /Safari/.test(navigator.userAgent) && /Mac OS/.test(navigator.userAgent);
  }

  static IsWebGL1() {
    return RendererDevice.s_WEBGL_VER == 1;
  }

  static IsWebGL2() {
    return RendererDevice.s_WEBGL_VER == 2;
  }

  static IsMobileWeb() {
    if (RendererDevice.s_mobileFlag > 0) {
      return RendererDevice.s_mobileFlag == 2;
    }

    return RendererDevice.TestMobileWeb();
  }

  static IsSafariWeb() {
    if (RendererDevice.s_safariFlag > 0) {
      return RendererDevice.s_safariFlag == 2;
    }

    RendererDevice.s_safariFlag = RendererDevice.TestSafariWeb() ? 2 : 1;
    return RendererDevice.s_safariFlag == 2;
  }

  static IsIOS() {
    if (RendererDevice.s_IOS_Flag > 0) {
      return RendererDevice.s_IOS_Flag == 2;
    }

    let boo = false;

    if (/iPad|iPhone|iPod/.test(navigator.platform)) {
      boo = true;
    } else {
      boo = navigator.maxTouchPoints != undefined && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
    }

    RendererDevice.s_IOS_Flag = boo ? 2 : 1;
    return boo;
  }

  static IsIpadOS() {
    if (RendererDevice.s_IPad_Flag > 0) {
      return RendererDevice.s_IPad_Flag == 2;
    }

    let boo = navigator.maxTouchPoints > 0 && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);

    if (!boo && /iPod|iPad|iPadPro|iPodPro/i.test(navigator.userAgent)) {
      boo = true;
    }

    RendererDevice.s_IPad_Flag = boo ? 2 : 1;
    return boo;
  }

  static IsAndroidOS() {
    if (RendererDevice.s_Android_Flag > 0) {
      return RendererDevice.s_Android_Flag == 2;
    }

    let boo = RendererDevice.TestMobileWeb();

    if (boo && /Android|Linux/i.test(navigator.userAgent)) {
      boo = true;
    } else {
      boo = false;
    }

    RendererDevice.s_Android_Flag = boo ? 2 : 1;
    return boo;
  }

  static TestMobileWeb() {
    if (RendererDevice.s_mobileFlag > 0) {
      return RendererDevice.s_mobileFlag == 2;
    }

    if (/mobile/.test(location.href)) {
      RendererDevice.s_mobileFlag = 2;
      return RendererDevice.s_mobileFlag == 2;
    }

    if (/Android/i.test(navigator.userAgent)) {
      if (/Mobile/i.test(navigator.userAgent)) {
        RendererDevice.s_mobileFlag = 2;
        return RendererDevice.s_mobileFlag == 2;
      } else {
        RendererDevice.s_mobileFlag = 1;
        return RendererDevice.s_mobileFlag == 2;
      }
    } else if (/webOS|iPhone|iPod|iPad|iPodPro|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      RendererDevice.s_mobileFlag = 2;
      return RendererDevice.s_mobileFlag == 2;
    }

    RendererDevice.s_mobileFlag = 1;
    return RendererDevice.s_mobileFlag == 2;
  }

}

RendererDevice.s_inited = true;
RendererDevice.s_WEBGL_VER = 2;
RendererDevice.s_devicePixelRatio = 1.0;
RendererDevice.s_mobileFlag = 0;
RendererDevice.s_safariFlag = 0;
RendererDevice.s_Android_Flag = 0;
RendererDevice.s_IOS_Flag = 0;
RendererDevice.s_IPad_Flag = 0;
RendererDevice.s_winExternalVideoCardFlag = 0;
/**
 * zh-CN, en-US, ect....
 */

RendererDevice.s_language = "";
RendererDevice.s_debugEnabled = true;
RendererDevice.GPU_VENDOR = "unknown";
RendererDevice.GPU_RENDERER = "unknown";
RendererDevice.MAX_TEXTURE_SIZE = 4096;
RendererDevice.MAX_RENDERBUFFER_SIZE = 4096;
RendererDevice.MAX_VIEWPORT_WIDTH = 4096;
RendererDevice.MAX_VIEWPORT_HEIGHT = 4096; // for debug

RendererDevice.SHOWLOG_ENABLED = false;
RendererDevice.SHADERCODE_TRACE_ENABLED = false; // true: force vertex shader precision to highp

RendererDevice.VERT_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED = true; // true: force fragment shader precision to highp

RendererDevice.FRAG_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED = true; // worker multi threads enabled yes or no

RendererDevice.s_threadEnabled = true;
exports.default = RendererDevice;

/***/ }),

/***/ "3b80":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadCodeSrcType_1 = __webpack_require__("d2d9");
/**
 * 主线程中功能逻辑任务对于子线程中对于的代码模块的依赖关系
 */


class TaskDependency {
  constructor() {
    this.moduleName = "";
    this.threadCodeString = "";
    this.threadCodeFileURL = "";
    this.dependencyUniqueName = "";
    this.threadCodeSrcType = ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE;
  } // toJSFile(): void {
  //     this.threadCodeFileURL = "";
  //     this.threadCodeSrcType = ThreadCodeSrcType.JS_FILE_CODE;
  // }
  // toDependency(): void {
  //     this.dependencyUniqueName = "";
  //     this.threadCodeSrcType = ThreadCodeSrcType.DEPENDENCY;
  // }
  // toCodeString(): void {
  //     this.threadCodeString = "";
  //     this.threadCodeSrcType = ThreadCodeSrcType.STRING_CODE;
  // }

  /**
   * @returns 如果是基于代码字符串初始化，则返回true
   */


  isCodeString() {
    return this.threadCodeSrcType == ThreadCodeSrcType_1.ThreadCodeSrcType.STRING_CODE;
  }
  /**
   * @returns 如果是基于外部js文件url初始化，则返回true
   */


  isJSFile() {
    return this.threadCodeSrcType == ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE;
  }
  /**
   * @returns 如果是基于唯一依赖名初始化，则返回true
   */


  isDependency() {
    return this.threadCodeSrcType == ThreadCodeSrcType_1.ThreadCodeSrcType.DEPENDENCY;
  }

  isCodeBlob() {
    return this.threadCodeSrcType == ThreadCodeSrcType_1.ThreadCodeSrcType.BLOB_CODE;
  }

  clone() {
    let td = new TaskDependency();
    if (this.isCodeString()) td.threadCodeString = this.threadCodeString;
    if (this.isJSFile()) td.threadCodeFileURL = this.threadCodeFileURL;
    if (this.isDependency()) td.dependencyUniqueName = this.dependencyUniqueName; // if(this.isCodeBlob()) 

    td.threadCodeSrcType = this.threadCodeSrcType;
    return td;
  }

}

exports.TaskDependency = TaskDependency;
/**
 * 主线程中功能逻辑任务对于子线程中对于的代码模块的依赖关系: js 文件依赖形式
 */

class TaskJSFileDependency extends TaskDependency {
  constructor(codeFileURL) {
    super();
    this.threadCodeFileURL = codeFileURL;
    this.threadCodeSrcType = ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE;
  }

}

exports.TaskJSFileDependency = TaskJSFileDependency;
/**
 * 主线程中功能逻辑任务对于子线程中对于的代码模块的依赖关系: 依赖的唯一名称依赖形式
 */

class TaskUniqueNameDependency extends TaskDependency {
  constructor(dependencyUniqueName) {
    super();
    this.dependencyUniqueName = dependencyUniqueName;
    this.threadCodeSrcType = ThreadCodeSrcType_1.ThreadCodeSrcType.DEPENDENCY;
  }

}

exports.TaskUniqueNameDependency = TaskUniqueNameDependency;
/**
 * 主线程中功能逻辑任务对于子线程中对于的代码模块的依赖关系: 代码字符串依赖形式
 */

class TaskCodeStringDependency extends TaskDependency {
  constructor(codeString, moduleName) {
    super();
    this.threadCodeString = codeString;
    this.moduleName = moduleName;
    this.threadCodeSrcType = ThreadCodeSrcType_1.ThreadCodeSrcType.STRING_CODE;
  }

}

exports.TaskCodeStringDependency = TaskCodeStringDependency;

/***/ }),

/***/ "3bda":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ColorUtils_1 = __webpack_require__("a567");

class DivLog {
  static SetDebugEnabled(boo) {
    DivLog.s_debugEanbled = boo;
  }

  static SetXY(px, py) {
    DivLog.s_leftX = px;
    DivLog.s_topY = py;
  }
  /**
   * @param uintRGB24, uint 24bit rgb color, example: 0xff003a
   */


  static SetTextBgColor(uintRGB24) {
    DivLog.s_textBGColor = ColorUtils_1.RGBColorUtil.uint24RGBToCSSHeXRGBColor(uintRGB24);

    if (DivLog.s_infoDiv != null) {
      DivLog.s_infoDiv.style.backgroundColor = this.s_textBGColor;
    }
  }
  /**
   * @param uintRGB24, uint 24bit rgb color, example: 0xff003a
   */


  static SetTextColor(uintRGB24) {
    DivLog.s_textColor = ColorUtils_1.RGBColorUtil.uint24RGBToCSSHeXRGBColor(uintRGB24);

    if (DivLog.s_infoDiv != null) {
      DivLog.s_infoDiv.style.color = this.s_textColor;
    }
  }

  static SetTextBgEnabled(boo) {
    this.s_textBgEnabled = boo;

    if (DivLog.s_infoDiv != null) {
      let pdiv = DivLog.s_infoDiv;

      if (DivLog.s_textBgEnabled) {
        pdiv.style.backgroundColor = this.s_textBGColor;
      } else {
        pdiv.style.backgroundColor = "";
      }
    }
  }

  static ShowLog(logStr) {
    if (DivLog.s_debugEanbled) {
      if (DivLog.s_logStr.length > 0) {
        DivLog.s_logStr += "<br/>" + logStr;
      } else {
        DivLog.s_logStr = logStr;
      }

      DivLog.UpdateDivText();
    }
  }

  static GetLog() {
    return DivLog.s_logStr;
  }

  static ShowLogOnce(logStr) {
    if (DivLog.s_debugEanbled) {
      DivLog.s_logStr = logStr;
      DivLog.UpdateDivText();
    }
  }

  static ClearLog(logStr = "") {
    if (DivLog.s_debugEanbled) {
      DivLog.s_logStr = logStr;
      DivLog.UpdateDivText();
    }
  }

  static UpdateDivText() {
    if (DivLog.s_debugEanbled) {
      if (DivLog.s_infoDiv != null) {
        DivLog.s_infoDiv.innerHTML = DivLog.s_logStr;
      } else {
        let div = document.createElement('div');
        div.style.color = "";
        let pdiv = div;
        pdiv.width = 128;
        pdiv.height = 64;

        if (DivLog.s_textBgEnabled) {
          pdiv.style.backgroundColor = this.s_textBGColor;
        } else {
          pdiv.style.backgroundColor = "";
        }

        pdiv.style.color = this.s_textColor;
        pdiv.style.left = DivLog.s_leftX + 'px';
        pdiv.style.top = DivLog.s_topY + 'px';
        pdiv.style.zIndex = "9999";
        pdiv.style.position = 'absolute';
        document.body.appendChild(pdiv);
        DivLog.s_infoDiv = pdiv;
        pdiv.innerHTML = DivLog.s_logStr;
      }
    }
  }

  static ShowAtTop() {
    if (DivLog.s_infoDiv != null) {
      DivLog.s_infoDiv.parentElement.removeChild(DivLog.s_infoDiv);
      document.body.appendChild(DivLog.s_infoDiv);
    }
  }

}

DivLog.s_logStr = "";
DivLog.s_infoDiv = null;
DivLog.s_debugEanbled = false;
DivLog.s_textBGColor = "#aa0033";
DivLog.s_textColor = "#000000";
DivLog.s_textBgEnabled = true;
DivLog.s_leftX = 0;
DivLog.s_topY = 128;
exports.default = DivLog;

/***/ }),

/***/ "3c81":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PoolNodeBuilder_1 = __importDefault(__webpack_require__("2be1"));

const RenderProcess_1 = __importDefault(__webpack_require__("7696"));

class RenderProcessBuider extends PoolNodeBuilder_1.default {
  setCreateParams(shader, rpoNodeBuilder, rpoUnitBuilder, vtxResource, batchEnabled, fixedState) {
    this.m_shader = shader;
    this.m_rpoNodeBuilder = rpoNodeBuilder;
    this.m_rpoUnitBuilder = rpoUnitBuilder;
    this.m_vtxResource = vtxResource;
    this.m_batchEnabled = batchEnabled;
    this.m_fixedState = fixedState;
  }

  createNode() {
    return new RenderProcess_1.default(this.m_shader, this.m_rpoNodeBuilder, this.m_rpoUnitBuilder, this.m_vtxResource, this.m_batchEnabled, this.m_fixedState);
  }

  rejoinRunitForTro(runit) {
    this.getNodeByUid(runit.__$rprouid).rejoinRunitForTro(runit);
  }

  rejoinRunitForVro(runit) {
    this.getNodeByUid(runit.__$rprouid).rejoinRunitForVro(runit);
  }

}

exports.default = RenderProcessBuider;

/***/ }),

/***/ "402a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("11e6"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const AABB_1 = __importDefault(__webpack_require__("fecb"));

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const ROTransform_1 = __importDefault(__webpack_require__("0929"));

const SpaceCullingMask_1 = __webpack_require__("cc48");

const RODisplay_1 = __importDefault(__webpack_require__("dc2b"));

class DisplayEntity {
  constructor(transform = null, sharedData = false) {
    this.m_uid = 0;
    this.m_transfrom = null;
    this.m_eventDispatcher = null;
    this.m_visible = true;
    this.m_drawEnabled = true;
    this.m_rcolorMask = RendererState_1.default.COLOR_MASK_ALL_TRUE;
    this.m_renderState = RendererState_1.default.BACK_CULLFACE_NORMAL_STATE;
    this.m_display = null;
    this.m_mesh = null; // 如果一个entity如果包含了多个mesh,则这个bounds就是多个mesh aabb 合并的aabb

    this.m_localBounds = null;
    this.m_globalBounds = null;
    this.m_localBuondsVer = -1;
    this.m_parent = null;
    this.m_renderProxy = null;
    this.m_pipeLine = null;
    /**
     * renderer scene entity flag, be used by the renderer system
     * 第0位到第19位总共20位存放自身在space中的 index id(最小值为1, 最大值为1048575,默认值是0, 也就是最多只能展示1048575个entitys),
     * 第20位开始到26位为总共7位止存放在renderer中的状态数据(renderer unique id and others)
     * 第27位存放是否在container里面
     * 第28位开始到29位总共二位存放renderer 载入状态 的相关信息
     * 第30位位存放是否渲染运行时排序
     */

    this.__$rseFlag = RSEntityFlag_1.default.DEFAULT;
    this.name = "DisplayEntity";
    /**
     * 可见性裁剪是否开启, 如果不开启，则摄像机和遮挡剔除都不会裁剪, 取值于 SpaceCullingMask, 默认只会有摄像机裁剪
     */

    this.spaceCullMask = SpaceCullingMask_1.SpaceCullingMask.CAMERA;
    /**
     * recorde a draw status
     */

    this.drawEnabled = false;
    /**
     * mouse interaction enabled
     */

    this.mouseEnabled = false;
    /**
     * whether merge vertex geometry data for shader vertex buffer attribute data
     */

    this.vbWholeDataEnabled = true;
    /**
     * pipes type list for material pipeline
     */

    this.pipeTypes = null;
    this.m_texChanged = false;
    this.m_meshChanged = false;
    this.m_lBoundsVS = null;
    this.m_transStatus = ROTransform_1.default.UPDATE_TRANSFORM;
    this.m_uid = DisplayEntity.s_uid++;

    if (transform == null) {
      this.m_transfrom = ROTransform_1.default.Create();
    } else {
      if (sharedData) {
        this.m_transfrom = ROTransform_1.default.Create(null, transform.getFS32Data());
      } else {
        this.m_transfrom = transform;
      }
    }

    this.createBounds();
  }

  createBounds() {
    this.m_globalBounds = new AABB_1.default();
  }

  __$setRenderProxy(rc) {
    this.m_renderProxy = rc;
  }

  __$setParent(parent) {
    if (this.m_parent == null) {}

    this.m_parent = parent;
  }

  __$getParent() {
    return this.m_parent;
  }

  __$testSpaceEnabled() {
    //return this.__$spaceId < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestSpaceEnabled2(this.__$rseFlag);
  }

  __$testContainerEnabled() {
    //return this.__$wuid < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestContainerEnabled(this.__$rseFlag);
  }

  __$testRendererEnabled() {
    //return this.__$wuid < 0 && this.__$weid < 0 && this.__$contId < 1;
    return RSEntityFlag_1.default.TestRendererEnabled(this.__$rseFlag);
  }

  getRendererUid() {
    return RSEntityFlag_1.default.GetRendererUid(this.__$rseFlag);
  }

  setMaterialPipeline(pipeline) {
    this.m_pipeLine = pipeline;
  }

  getMaterialPipeline() {
    return this.m_pipeLine;
  }
  /**
   * @returns 自身是否未必任何渲染器相关的系统使用
   */


  isFree() {
    return this.__$rseFlag == RSEntityFlag_1.default.DEFAULT;
  }

  dispatchEvt(evt) {
    // if (evt.getClassType() == MouseEvent.EventClassType) {
    if (this.m_eventDispatcher != null) {
      return this.m_eventDispatcher.dispatchEvt(evt);
    } // }


    return 0;
  }

  getEvtDispatcher(evtClassType) {
    return this.m_eventDispatcher;
  }

  setEvtDispatcher(evtDisptacher) {
    this.m_eventDispatcher = evtDisptacher;
  }

  getGlobalBounds() {
    return this.m_globalBounds;
  }

  getLocalBounds() {
    return this.m_mesh.bounds;
  }

  getGlobalBoundsVer() {
    if (this.m_globalBounds != null) {
      return this.m_globalBounds.version;
    }

    return -1;
  }

  __$setDrawEnabled(boo) {
    if (this.m_drawEnabled != boo) {
      this.m_drawEnabled = boo;
      const d = this.m_display;

      if (d != null) {
        d.visible = this.m_visible && boo;

        if (d.__$$runit != null) {
          d.__$$runit.setVisible(d.visible);
        }
      }
    }
  }

  isDrawEnabled() {
    return this.m_drawEnabled;
  }
  /**
   * users need to call this function manually
   * 更新有两种形式, 1: 只是更改资源内部的数据, 2: 替换资源本身
   * 更新过程可以通过DisplayEntity对象来控制，也可以通过资源本身来控制
   */


  updateMeshToGpu(rc = null, deferred = true) {
    if (rc != null) this.m_renderProxy = rc;

    if (this.m_renderProxy != null && this.m_display != null && this.m_display.__$ruid > -1) {
      if (this.m_meshChanged) {
        this.m_meshChanged = false;
        this.m_renderProxy.VtxBufUpdater.updateDispVbuf(this.m_display, deferred);
      } else {
        this.m_renderProxy.VtxBufUpdater.updateVtxDataToGpuByUid(this.m_display.vbuf.getUid(), deferred);
      }
    }
  }
  /**
   * users need to call this function manually
   * 更新有两种形式, 1: 只是更改资源内部的数据, 2: 替换资源本身
   * 更新过程可以通过DisplayEntity对象来控制，也可以通过资源本身来控制
   */


  updateMaterialToGpu(rc = null, deferred = true) {
    if (rc != null) this.m_renderProxy = rc;

    if (this.m_renderProxy != null && this.m_display != null && this.m_display.__$ruid > -1) {
      if (this.m_texChanged) {
        this.m_texChanged = false;
        this.m_renderProxy.MaterialUpdater.updateDispTRO(this.m_display, deferred);
      }
    }
  }
  /**
   * set new textures list for the material of this instance.
   */


  setTextureList(texList) {
    if (this.m_display != null && this.m_display.__$ruid > -1) {
      let material = this.m_display.getMaterial();

      if (material != null) {
        material.setTextureList(texList);
        this.m_texChanged = true;
      }
    }
  }
  /**
   * set new texture by the index in the material textures list for the material of this instance.
   */


  setTextureAt(index, tex) {
    if (this.m_display != null && this.m_display.__$ruid > -1) {
      let material = this.m_display.getMaterial();

      if (material != null) {
        material.setTextureAt(index, tex);
        this.m_texChanged = true;
      }
    }
  }

  setSortValue(value) {
    if (this.m_display != null) {
      if (this.m_display.__$$runit != null) {
        this.m_display.__$$runit.value = value;
      }
    }
  }

  setVisible(boo) {
    if (this.m_visible != boo) {
      this.m_visible = boo;

      if (this.m_display != null) {
        this.m_display.visible = boo && this.m_drawEnabled;

        if (this.m_display.__$$runit != null) {
          this.m_display.__$$runit.setVisible(this.m_display.visible);
        }
      }
    }
  }

  getVisible() {
    return this.m_visible;
  }

  getTransform() {
    return this.m_transfrom;
  }

  copyPositionFrom(entity) {
    if (entity != null) {
      this.m_transfrom.copyPositionFrom(entity.getTransform());
    }
  }

  copyMeshFrom(entity) {
    if (entity != null) {
      this.setMesh(entity.getMesh());
    }
  }

  copyMaterialFrom(entity) {
    if (entity != null) {
      this.setMaterial(entity.getMaterial());
    }
  }

  copyTransformFrom(entity) {
    let pe = entity;

    if (pe != null) {
      this.m_transfrom.copyFrom(pe.m_transfrom);
    }
  }

  initDisplay(m) {
    this.m_display.vbuf = m.__$attachVBuf();
    this.m_display.ivsIndex = 0;
    this.m_display.ivsCount = m.vtCount;
    this.m_display.drawMode = m.drawMode;
    this.m_display.trisNumber = m.trisNumber;
    this.m_display.visible = this.m_visible && this.m_drawEnabled;
  }
  /**
   * 设置几何相关的数据,必须是构建完备的mesh才能被设置进来
   * 这个设置函数也可以动态运行时更新几何相关的顶点数据
   */


  setMesh(m) {
    // let m = pm as MeshBase;
    if (this.m_mesh == null) {
      if (m != null) {
        if (!m.isEnabled()) {
          m.rebuild();
        }

        if (m.isEnabled()) {
          this.m_mesh = m;

          m.__$attachThis();

          if (this.m_display == null) {
            this.createDisplay();
          }

          if (this.m_display != null) {
            this.m_display.setTransform(this.m_transfrom.getMatrix());
            this.initDisplay(m);
          } //console.log("DisplayEntity::setMesh(), "+this.m_display.toString()+",m.drawMode: "+m.drawMode);


          if (this.m_localBounds == null) {
            this.m_localBounds = m.bounds;
          } else {
            this.m_localBounds.copyFrom(m.bounds);
          }

          this.updateMesh();
        }
      }
    } else if (this.m_display != null && this.m_display.__$ruid > -1) {
      if (this.m_mesh != m && m != null) {
        this.m_transfrom.updatedStatus |= 2;

        this.m_mesh.__$detachVBuf(this.m_display.vbuf);

        this.m_mesh.__$detachThis();

        m.__$attachThis();

        this.m_mesh = m;
        this.initDisplay(m);
        this.updateMesh();
        this.m_meshChanged = true;
      }
    }
  }

  updateMesh() {}

  getIvsIndex() {
    return this.m_display.ivsIndex;
  }

  getIvsCount() {
    return this.m_display.ivsCount;
  }

  setIvsParam(ivsIndex, ivsCount, updateBounds = false) {
    if (this.m_display != null) {
      this.m_display.ivsIndex = ivsIndex;
      this.m_display.ivsCount = ivsCount;

      if (this.m_display.__$ruid > -1) {
        this.m_display.__$$runit.trisNumber = Math.floor((ivsCount - ivsIndex) / 3);

        this.m_display.__$$runit.setIvsParam(ivsIndex, ivsCount);

        this.m_display.__$$runit.drawMode = this.m_mesh.drawMode;

        if (updateBounds && this.isPolyhedral()) {
          if (this.m_localBounds == this.m_mesh.bounds) {
            this.m_localBounds = new AABB_1.default();
            this.m_localBounds.copyFrom(this.m_mesh.bounds);
          }

          this.m_transStatus = ROTransform_1.default.UPDATE_TRANSFORM;
          this.m_localBounds.reset();
          let ivs = this.m_mesh.getIVS();
          this.m_localBounds.addXYZFloat32AndIndicesArr(this.m_mesh.getVS(), ivs.subarray(ivsIndex, ivsIndex + ivsCount));
          this.m_localBounds.update();
        }
      }
    }
  }

  getMesh() {
    return this.m_mesh;
  }

  hasMesh() {
    return this.m_mesh != null;
  }
  /**
   * @return 返回true是则表示这是基于三角面的多面体, 返回false则是一个数学方程描述的几何体(例如球体),默认返回true
   */


  isPolyhedral() {
    return this.m_mesh === null || this.m_mesh.isPolyhedral();
  }
  /**
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    return this.m_mesh.testRay(rlpv, rltv, outV, boundsHit);
  }
  /**
   * 只允许在加入渲染器之前设置 IRenderMaterial 实例
   */


  setMaterial(m) {
    if (m != null) {
      if (this.m_display == null) {
        this.m_display = RODisplay_1.default.Create();
        this.m_display.setTransform(this.m_transfrom.getMatrix());
        this.m_display.visible = this.m_visible && this.m_drawEnabled;
      } //if(this.m_display.getMaterial() != m && this.__$wuid == RSEntityFlag.RENDERER_UID_FLAG && this.m_display.__$ruid < 0)


      if (this.m_display.getMaterial() != m && (RSEntityFlag_1.default.RENDERER_UID_FLAG & this.__$rseFlag) == RSEntityFlag_1.default.RENDERER_UID_FLAG && this.m_display.__$ruid < 0) {
        // if(m.getMaterialPipeline() == null && this.getMaterialPipeline() != null) {
        //     m.setMaterialPipeline( this.getMaterialPipeline() );
        // }
        // if(m.pipeTypes == null) {
        //     m.pipeTypes = this.pipeTypes;
        // }
        this.m_display.renderState = this.m_renderState;
        this.m_display.rcolorMask = this.m_rcolorMask;
        this.m_display.setMaterial(m);
      }
    }
  }

  getMaterial() {
    if (this.m_display != null) {
      return this.m_display.getMaterial();
    }

    return null;
  }

  getDisplay() {
    return this.m_display;
  }

  getInvMatrix() {
    return this.m_transfrom.getInvMatrix();
  }
  /**
   * 获取当前 entity 的 local space to world space matrix
   * @param flag 是否将当前matrix更新到最新, 默认值是true
   * @returns local space to world space matrix
   */


  getMatrix(flag = true) {
    return this.m_transfrom.getMatrix(flag);
  }

  getToParentMatrix() {
    return this.m_transfrom.getToParentMatrix();
  }

  setRenderColorMask(rt) {
    this.m_rcolorMask = rt;

    if (this.m_display != null) {
      this.m_display.rcolorMask = this.m_rcolorMask;

      if (this.m_display.__$$runit != null) {
        this.m_display.__$$runit.setDrawFlag(this.m_renderState, this.m_rcolorMask);
      }
    }
  }

  setRenderColorMaskByName(rt_name) {
    this.m_rcolorMask = RendererState_1.default.GetRenderColorMaskByName(rt_name);

    if (this.m_display != null) {
      this.m_display.rcolorMask = this.m_rcolorMask;

      if (this.m_display.__$$runit != null) {
        this.m_display.__$$runit.setDrawFlag(this.m_renderState, this.m_rcolorMask);
      }
    }
  }

  setRenderState(renderState) {
    this.m_renderState = renderState;

    if (this.m_display != null) {
      this.m_display.renderState = this.m_renderState;

      if (this.m_display.__$$runit != null) {
        this.m_display.__$$runit.setDrawFlag(this.m_renderState, this.m_rcolorMask);
      }
    }
  }

  setRenderStateByName(renderState_name) {
    this.m_renderState = RendererState_1.default.GetRenderStateByName(renderState_name);

    if (this.m_display != null) {
      this.m_display.renderState = this.m_renderState;

      if (this.m_display.__$$runit != null) {
        this.m_display.__$$runit.setDrawFlag(this.m_renderState, this.m_rcolorMask);
      }
    }
  }

  createDisplay() {
    this.m_display = RODisplay_1.default.Create();
  }

  activeDisplay() {
    if (this.m_display != null) {
      let material = this.m_display.getMaterial();

      if (material != null) {
        if (material.getShaderData() == null) {
          if (material.getCodeBuf() != null) {
            if (material.getShaderData() == null) {
              let texList = material.getTextureList();
              let texEnabled = texList != null && texList.length > 0;

              if (material.getMaterialPipeline() == null && this.getMaterialPipeline() != null) {
                material.setMaterialPipeline(this.getMaterialPipeline());
              }

              if (material.pipeTypes == null) {
                material.pipeTypes = this.pipeTypes;
              }

              material.initializeByCodeBuf(texEnabled);
            }
          }
        }

        if (this.getMesh() == null) {
          this.__activeMesh(material); //  // for debug


          this.m_display.name = this.name;
        }
      }
    }
  } // for sub class override


  __activeMesh(material) {}

  getUid() {
    return this.m_uid;
  }

  setXYZ(px, py, pz) {
    this.m_transfrom.setXYZ(px, py, pz);
  }

  offsetPosition(pv) {
    this.m_transfrom.offsetPosition(pv);
  }

  setPosition(pv) {
    this.m_transfrom.setPosition(pv);
  }

  getPosition(pv) {
    this.m_transfrom.getPosition(pv);
    return pv;
  }

  setRotation3(rotV) {
    this.m_transfrom.setRotationXYZ(rotV.x, rotV.y, rotV.z);
  }

  setRotationXYZ(rx, ry, rz) {
    this.m_transfrom.setRotationXYZ(rx, ry, rz);
  }

  setScale3(scaleV) {
    this.m_transfrom.setScaleXYZ(scaleV.x, scaleV.y, scaleV.z);
  }

  setScaleXYZ(sx, sy, sz) {
    this.m_transfrom.setScaleXYZ(sx, sy, sz);
  }

  getRotationXYZ(pv) {
    this.m_transfrom.getRotationXYZ(pv);
  }

  getScaleXYZ(pv) {
    this.m_transfrom.getScaleXYZ(pv);
  }

  localToGlobal(pv) {
    if (this.m_transfrom != null) {
      this.m_transfrom.localToGlobal(pv);
    }
  }

  globalToLocal(pv) {
    if (this.m_transfrom != null) {
      this.m_transfrom.globalToLocal(pv);
    }
  }
  /**
   * 表示没有加入任何渲染场景或者渲染器
   */


  isRFree() {
    return this.__$rseFlag == RSEntityFlag_1.default.DEFAULT;
  }
  /**
   * @returns 是否已经加入渲染器中(但是可能还没有进入真正的渲染运行时)
   */


  isInRenderer() {
    return (this.__$rseFlag & RSEntityFlag_1.default.RENDERER_UID_FLAG) != RSEntityFlag_1.default.RENDERER_UID_FLAG;
  }
  /**
   * @returns 是否在渲染器渲染过程中
   */


  isInRendererProcess() {
    return this.m_display != null && this.m_display.__$ruid > -1;
  }
  /**
   * @returns 是否能被渲染
   */


  isRenderEnabled() {
    return this.drawEnabled && this.m_visible && this.m_display != null && this.m_display.__$ruid > -1;
  }

  updateBounds() {
    if (this.m_transfrom != null) {
      this.m_transStatus = ROTransform_1.default.UPDATE_TRANSFORM;

      if (this.m_mesh != null && this.m_localBounds != this.m_mesh.bounds) {
        this.m_localBounds.reset();
        let ivs = this.m_mesh.getIVS();
        this.m_localBounds.addXYZFloat32AndIndicesArr(this.m_mesh.getVS(), ivs.subarray(this.m_display.ivsIndex, this.m_display.ivsIndex + this.m_display.ivsCount));
        this.m_localBounds.update();
      }

      this.update();
    }
  }

  updateLocalBoundsVS(bounds) {
    let pminV = bounds.min;
    let pmaxV = bounds.max;

    if (this.m_lBoundsVS == null) {
      this.m_lBoundsVS = new Float32Array(24);
    }

    let pvs = this.m_lBoundsVS;
    pvs[0] = pminV.x;
    pvs[1] = pminV.y;
    pvs[2] = pminV.z;
    pvs[3] = pmaxV.x;
    pvs[4] = pminV.y;
    pvs[5] = pminV.z;
    pvs[6] = pminV.x;
    pvs[7] = pminV.y;
    pvs[8] = pmaxV.z;
    pvs[9] = pmaxV.x;
    pvs[10] = pminV.y;
    pvs[11] = pmaxV.z;
    pvs[12] = pminV.x;
    pvs[13] = pmaxV.y;
    pvs[14] = pminV.z;
    pvs[15] = pmaxV.x;
    pvs[16] = pmaxV.y;
    pvs[17] = pminV.z;
    pvs[18] = pminV.x;
    pvs[19] = pmaxV.y;
    pvs[20] = pmaxV.z;
    pvs[21] = pmaxV.x;
    pvs[22] = pmaxV.y;
    pvs[23] = pmaxV.z;
  }

  updateGlobalBounds() {
    // 这里的逻辑也有问题,需要再处理，为了支持摄像机等的拾取以及支持遮挡计算等空间管理计算
    let DE = DisplayEntity;
    let bounds = this.m_localBounds;

    if (this.m_transStatus > ROTransform_1.default.UPDATE_POSITION || this.m_localBuondsVer != bounds.version) {
      let st = this.m_transfrom.updateStatus;
      this.m_transfrom.update();

      if (this.m_localBuondsVer != bounds.version || st != this.m_transfrom.updateStatus) {
        this.m_localBuondsVer = bounds.version;
        this.updateLocalBoundsVS(bounds);
        let in_vs = this.m_lBoundsVS;
        let out_vs = DE.s_boundsOutVS;
        this.m_transfrom.getMatrix().transformVectors(in_vs, 24, out_vs);
        this.m_globalBounds.reset();
        this.m_globalBounds.addXYZFloat32Arr(out_vs);
        this.m_globalBounds.update();
      }
    } else {
      DE.s_prePos.setXYZ(0, 0, 0);
      DE.s_pos.setXYZ(0, 0, 0);
      let matrix = this.m_transfrom.getMatrix(false);
      matrix.transformVector3Self(DE.s_prePos);
      this.m_transfrom.update();
      matrix = this.m_transfrom.getMatrix(false);
      matrix.transformVector3Self(DE.s_pos);
      DE.s_pos.subtractBy(DE.s_prePos);
      let gbounds = this.m_globalBounds;
      gbounds.min.addBy(DE.s_pos);
      gbounds.max.addBy(DE.s_pos);
      gbounds.center.addBy(DE.s_pos);
      ++this.m_globalBounds.version;
    }
  }

  update() {
    if (this.m_transfrom.updatedStatus > this.m_transStatus) this.m_transStatus = this.m_transfrom.updatedStatus;

    if (this.m_transStatus != ROTransform_1.default.UPDATE_NONE) {
      if (this.m_mesh != null && this.m_globalBounds != null) {
        this.updateGlobalBounds();
      } else {
        this.m_transfrom.update();
      }

      this.m_transStatus = ROTransform_1.default.UPDATE_NONE;
      this.m_transfrom.updatedStatus = this.m_transStatus;
    }
  }

  destroy() {
    // 当自身被完全移出RenderWorld之后才能执行自身的destroy
    //console.log("DisplayEntity::destroy(), renderer uid: "+this.getRendererUid()+", this.__$spaceId: "+this.__$spaceId);
    if (this.m_eventDispatcher != null) {
      this.m_eventDispatcher.destroy();
      this.m_eventDispatcher = null;
    }

    if (this.m_transfrom != null && this.isFree()) {
      // 这里要保证其在所有的process中都被移除
      if (this.m_display != null) {
        this.m_mesh.__$detachVBuf(this.m_display.vbuf);

        RODisplay_1.default.Restore(this.m_display);
        this.m_display = null;
      }

      ROTransform_1.default.Restore(this.m_transfrom);
      this.m_transfrom = null;

      if (this.m_mesh != null) {
        this.m_mesh.__$detachThis();

        this.m_mesh = null;
      }

      this.__$setParent(null);

      this.m_visible = true;
      this.m_drawEnabled = true;
      this.m_renderProxy = null;
      this.__$rseFlag = RSEntityFlag_1.default.DEFAULT;
    }

    this.m_globalBounds = null;
    this.m_localBounds = null;
    this.m_pipeLine = null;
  }

  toString() {
    return "DisplayEntity(name=" + this.name + ",uid = " + this.m_uid + ", rseFlag = " + this.__$rseFlag + ")";
  }

}

DisplayEntity.s_uid = 0; //private static s_boundsInVS: Float32Array = new Float32Array(24);

DisplayEntity.s_boundsOutVS = new Float32Array(24);
DisplayEntity.s_pos = new Vector3D_1.default();
DisplayEntity.s_prePos = new Vector3D_1.default();
exports.default = DisplayEntity;

/***/ }),

/***/ "42a2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 记录绑定在当前线程控制模块的任务对象
 */

class ThreadTaskPool {
  constructor(total) {
    this.m_total = 0;
    this.m_total = total;
    this.m_taskList = new Array(total);
    this.m_taskList[0] = null;
    this.m_freeList = new Array(total);

    for (let i = 1, len = total; i < len; ++i) {
      this.m_freeList[i] = i;
    }
  }

  getTaskByUid(uid) {
    if (uid < this.m_total && uid > 0) {
      return this.m_taskList[uid];
    }

    return null;
  } // 重新关联一个 DetachTask 操作之后的 task


  attachTask(task) {
    // console.log("ThreadTaskPool::AttachTask()...");
    if (task.getUid() < 1) {
      if (this.m_freeList.length > 0) {
        let uid = this.m_freeList.pop();
        this.m_taskList[uid] = task;
        return uid;
      }
    }

    return -1;
  } // detach a task, 使之不会再被多任务系统调用


  detachTask(task) {
    // console.log("ThreadTaskPool::detachTask()...");
    if (task.getUid() > 0 && this.m_taskList[task.getUid()] != null) {
      this.m_taskList[task.getUid()] = null;
      this.m_freeList.push(task.getUid());
    }
  }

}

exports.ThreadTaskPool = ThreadTaskPool;

/***/ }),

/***/ "442e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PoolNodeBuilder_1 = __importDefault(__webpack_require__("2be1"));

const RPONode_1 = __importDefault(__webpack_require__("265e"));
/*
 * render process object node pool management
 */


class RPONodeBuilder extends PoolNodeBuilder_1.default {
  createNode() {
    return new RPONode_1.default();
  }

  createRPONode() {
    return new RPONode_1.default();
  }

}

exports.default = RPONodeBuilder;

/***/ }),

/***/ "45db":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VertexRenderObj_1 = __importDefault(__webpack_require__("8def"));

const VaoVertexRenderObj_1 = __importDefault(__webpack_require__("fa60"));

class ROVertexRes {
  constructor() {
    this.m_vtx = null;
    this.m_vtxUid = -1;
    this.m_gpuBufs = [];
    this.m_gpuBufsTotal = 0;
    this.m_type = 0;
    this.m_attribsTotal = 0;
    this.m_wholeStride = 0;
    this.m_typeList = null;
    this.m_offsetList = null;
    this.m_sizeList = null;
    this.m_vroList = [];
    this.m_vroListLen = 0;
  }

  updateToGpu(rc) {
    let len = this.m_gpuBufs.length;

    if (len > 0) {
      let vtx = this.m_vtx;

      if (this.version != vtx.vertexVer) {
        let usage = vtx.getBufDataUsage();
        let fvs;
        let sizeList = this.m_sizeList;

        for (let i = 0; i < len; ++i) {
          fvs = vtx.getF32DataAt(i);

          if (sizeList[i] >= fvs.length) {
            rc.bindArrBuf(this.m_gpuBufs[i]);
            rc.arrBufSubData(fvs, 0);
          } else {
            rc.bindArrBuf(this.m_gpuBufs[i]);
            rc.arrBufData(fvs, usage);
            sizeList[i] = fvs.length;
          }
        }

        this.version = vtx.vertexVer;
      }
    }
  } //private m_preCombinedSize: number = 0;


  uploadCombined(rc, shdp) {
    let vtx = this.m_vtx;
    let fvs = vtx.getF32DataAt(0); //console.log("uploadCombined combSize: ",this.m_preCombinedSize, fvs.length);
    //this.m_preCombinedSize = fvs.length;

    this.m_gpuBufs.push(rc.createBuf());
    rc.bindArrBuf(this.m_gpuBufs[0]); // console.log("uploadCombined, this.m_gpuBufs: "+this.m_gpuBufs);

    rc.arrBufData(fvs, vtx.getBufDataUsage());
    this.m_gpuBufsTotal = 1;
    this.m_sizeList = [fvs.length];

    if (this.m_typeList == null) {
      this.m_wholeStride = 0;
      this.m_typeList = new Array(this.m_attribsTotal);
      this.m_offsetList = new Array(this.m_attribsTotal);
      let typeList = vtx.getBufTypeList();
      let sizeList = vtx.getBufSizeList();

      if (typeList != null) {
        for (let i = 0; i < this.m_attribsTotal; ++i) {
          this.m_offsetList[i] = this.m_wholeStride;
          this.m_wholeStride += sizeList[i] * 4;
          this.m_typeList[i] = typeList[i];
        }
      } else {
        for (let i = 0; i < this.m_attribsTotal; ++i) {
          this.m_offsetList[i] = this.m_wholeStride;
          this.m_wholeStride += shdp.getLocationSizeByIndex(i) * 4;
          this.m_typeList[i] = shdp.getLocationTypeByIndex(i);
        }
      }
    }
  }

  uploadSeparated(rc, shdp) {
    let vtx = this.m_vtx;
    let i = 0;
    let buf = null;
    let dataUsage = vtx.getBufDataUsage();
    this.m_gpuBufsTotal = this.m_vtx.getBuffersTotal();
    this.m_sizeList = new Array(this.m_attribsTotal); // console.log("uploadSeparated, this.m_gpuBufs: "+this.m_gpuBufs);

    if (vtx.bufData == null) {
      for (; i < this.m_attribsTotal; ++i) {
        buf = rc.createBuf();
        this.m_gpuBufs.push(buf);
        rc.bindArrBuf(buf);
        rc.arrBufData(vtx.getF32DataAt(i), dataUsage);
        this.m_sizeList[i] = vtx.getF32DataAt(i).length;
      }
    } else {
      //console.log(">>>>>>>>vtxSepbuf use (this.bufData == null) : "+(this.bufData == null));
      let fs32 = null;
      let j = 0;
      let tot = 0;
      let offset = 0;
      let dataSize = 0;

      for (; i < this.m_attribsTotal; ++i) {
        buf = rc.createBuf(); //console.log("this.bufData.getAttributeDataTotalBytesAt("+i+"): "+this.bufData.getAttributeDataTotalBytesAt(i));

        this.m_gpuBufs.push(buf);
        rc.bindArrBuf(buf);
        rc.arrBufDataMem(vtx.bufData.getAttributeDataTotalBytesAt(i), dataUsage);
        offset = 0;
        dataSize = 0;
        tot = vtx.bufData.getAttributeDataTotalAt(i);

        for (j = 0; j < tot; ++j) {
          fs32 = vtx.bufData.getAttributeDataAt(i, j);
          dataSize += fs32.length;
          rc.arrBufSubData(fs32, offset);
          offset += fs32.byteLength;
        }

        this.m_sizeList[i] = dataSize;
      }
    }

    if (this.m_typeList == null) {
      this.m_typeList = new Array(this.m_attribsTotal);
      this.m_offsetList = new Array(this.m_attribsTotal);
      let typeList = vtx.getBufTypeList();
      let sizeList = vtx.getBufSizeList();

      if (typeList != null) {
        for (let i = 0; i < this.m_attribsTotal; ++i) {
          this.m_offsetList[i] = this.m_wholeStride;
          this.m_wholeStride += sizeList[i] * 4;
          this.m_typeList[i] = typeList[i];
        }
      } else {
        for (let i = 0; i < this.m_attribsTotal; ++i) {
          this.m_offsetList[i] = this.m_wholeStride;
          this.m_wholeStride += shdp.getLocationSizeByIndex(i) * 4;
          this.m_typeList[i] = shdp.getLocationTypeByIndex(i);
        }
      }

      this.m_wholeStride = 0;
    }
  }

  initialize(rc, shdp, vtx) {
    if (this.m_gpuBufs.length < 1 && vtx != null) {
      this.version = vtx.vertexVer;
      this.m_vtx = vtx;
      this.m_vtxUid = vtx.getUid();
      this.m_type = vtx.getType();
      let typeList = vtx.getBufTypeList(); //let sizeList: number[] = vtx.getBufSizeList();

      this.m_attribsTotal = typeList != null ? typeList.length : shdp.getLocationsTotal();

      if (shdp.getLocationsTotal() != vtx.getAttribsTotal()) {
        console.warn("shdp.getLocationsTotal() is " + shdp.getLocationsTotal() + " != vtx.getAttribsTotal() is " + vtx.getAttribsTotal() + "/" + (typeList != null ? typeList.length : 0));
      }

      if (this.m_type < 1) {
        // combined buf
        this.uploadCombined(rc, shdp);
      } else {
        // separated buf
        this.uploadSeparated(rc, shdp);
      }
    }
  }
  /**
   * get vro object attribute mix id
   */


  getVROMid(rc, shdp, vaoEnabled, ibufId) {
    let mid = (131 + rc.getRCUid()) * this.m_vtxUid;
    if (vaoEnabled) mid = mid * 131 + 1;
    mid = mid * 131 + shdp.getMid();
    mid = mid * 131 + ibufId;
    return mid;
  } // 创建被 RPOUnit 使用的 vro 实例


  createVRO(rc, shdp, vaoEnabled, ibufRes, ibufId) {
    let attribsTotal = shdp.getLocationsTotal();

    if (this.m_attribsTotal * attribsTotal > 0 && attribsTotal <= this.m_attribsTotal) {
      let mid = this.getVROMid(rc, shdp, vaoEnabled, ibufId);
      let i = 0;
      let pvro = VaoVertexRenderObj_1.default.GetByMid(mid);

      if (pvro != null) {
        return pvro;
      } // console.log("VtxCombinedBuf::createVROBegin(), this.m_type: ",this.m_type, "mid: ",mid);
      // TODO(vilyLei): 暂时注释掉下面这行代码
      // let flag: boolean = shdp.testVertexAttribPointerOffset(this.m_offsetList);
      // console.log("createVRO testVertexAttribPointerOffset flag: ",flag, this.m_typeList);
      // DivLog.ShowLog("createVRO testVertexAttribPointerOffset flag: "+flag);


      if (vaoEnabled) {
        // vao 的生成要记录标记,防止重复生成, 因为同一组数据在不同的shader使用中可能组合方式不同，导致了vao可能是多样的
        // console.log("VtxCombinedBuf::createVROBegin(), "+this.m_typeList+" /// "+this.m_wholeStride+" /// "+this.m_offsetList);
        // console.log("VtxCombinedBuf::createVROBegin(), "+this.m_type);
        let vro = VaoVertexRenderObj_1.default.Create(rc, mid, this.m_vtx.getUid());
        vro.indicesRes = ibufRes;
        vro.vao = rc.createVertexArray();
        rc.bindVertexArray(vro.vao);

        if (this.m_type < 1) {
          // combined buf vro
          rc.bindArrBuf(this.m_gpuBufs[0]);

          for (i = 0; i < attribsTotal; ++i) {
            shdp.vertexAttribPointerTypeFloat(this.m_typeList[i], this.m_wholeStride, this.m_offsetList[i]);
          }
        } else {
          for (i = 0; i < attribsTotal; ++i) {
            rc.bindArrBuf(this.m_gpuBufs[i]);
            shdp.vertexAttribPointerTypeFloat(this.m_typeList[i], 0, 0);
          }
        }

        pvro = vro;
        vro.ibuf = ibufRes.getGpuBuf(); // rc.bindEleBuf(vro.ibuf);

        rc.bindVertexArray(null);
      } else {
        let vro = VertexRenderObj_1.default.Create(rc, mid, this.m_vtx.getUid());
        vro.indicesRes = ibufRes;
        vro.shdp = shdp;
        vro.attribTypes = [];
        vro.wholeOffsetList = [];
        vro.wholeStride = this.m_wholeStride;

        if (this.m_type < 1) {
          vro.vbuf = this.m_gpuBufs[0];
        } else {
          vro.vbufs = this.m_gpuBufs;
        }

        for (i = 0; i < attribsTotal; ++i) {
          if (shdp.testVertexAttribPointerType(this.m_typeList[i])) {
            vro.attribTypes.push(this.m_typeList[i]); //vro.wholeOffsetList.push( this.m_offsetList[i] );

            vro.wholeOffsetList.push(0);
          }
        }

        vro.attribTypesLen = vro.attribTypes.length;
        vro.ibuf = ibufRes.getGpuBuf();
        pvro = vro;
      }

      this.m_vroList.push(pvro);
      ++this.m_vroListLen;
      return pvro;
    }

    return null;
  }

  destroy(rc) {
    if (this.m_gpuBufs.length > 0) {
      console.log("ROVertexRes::destroy(), type: " + this.m_type);
      this.m_type = -1;
      let i = 0;
      let vro = null;

      for (; i < this.m_vroListLen; ++i) {
        vro = this.m_vroList.pop();
        vro.restoreThis();
        this.m_vroList[i] = null;
      }

      this.m_vroListLen = 0;

      for (i = 0; i < this.m_attribsTotal; ++i) {
        rc.deleteBuf(this.m_gpuBufs[i]);
        this.m_gpuBufs[i] = null;
      }

      this.m_attribsTotal = 0;
      this.m_gpuBufs = [];
    }
  }

}

exports.ROVertexRes = ROVertexRes;

/***/ }),

/***/ "4a54":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const GLSLConverter_1 = __importDefault(__webpack_require__("81ce"));

const ShaderCompileInfo_1 = __importDefault(__webpack_require__("f208"));

const ShaderCode_1 = __webpack_require__("c164");

class ShaderCodeBuilder {
  constructor(uniform) {
    this.m_versionDeclare = `#version 300 es
`;
    this.m_preciousCode = `precision mediump float;
`;
    this.m_fragExt = [];
    this.m_vertExt = [];
    this.m_defineNames = [];
    this.m_defineValues = [];
    this.m_vertLayoutNames = [];
    this.m_vertLayoutTypes = [];
    this.m_fragOutputPrecises = [];
    this.m_fragOutputNames = [];
    this.m_fragOutputTypes = [];
    this.m_vertUniformNames = [];
    this.m_vertUniformTypes = [];
    this.m_fragUniformNames = [];
    this.m_fragUniformTypes = [];
    this.m_varyingNames = [];
    this.m_varyingTypes = [];
    this.m_fragFunctionBlocks = [];
    this.m_vertFunctionBlocks = [];
    this.m_textureSampleTypes = [];
    this.m_texturePrecises = [];
    this.m_textureMacroNames = [];
    this.m_texturePrecise = "";
    this.m_textureFlags = [];
    this.m_vertObjMat = false;
    this.m_vertViewMat = false;
    this.m_vertProjMat = false;
    this.m_fragObjMat = false;
    this.m_fragViewMat = false;
    this.m_fragProjMat = false;
    this.m_vertHeadCode = "";
    this.m_vertMainCode = "";
    this.m_fragHeadCode = "";
    this.m_fragMainCode = "";
    this.m_uniqueNSKeyString = "";
    this.m_uniqueNSKeysTotal = 10;
    this.m_use2DMap = false;
    /**
     * 记录 shader 预编译信息
     */

    this.m_preCompileInfo = null;
    this.fragHeadCodeUnlock = true;
    this.fragMainCodeUnlock = true;
    this.vertHeadCodeUnlock = true;
    this.vertMainCodeUnlock = true;
    this.gamma = true;
    this.autoBuildHeadCodeEnabled = true;
    this.mathDefineEanbled = true;
    this.normalEnabled = false;
    this.normalMapEnabled = false;
    this.mapLodEnabled = false;
    this.derivatives = false;
    this.vertMatrixInverseEnabled = false;
    this.vtxUVTransfromEnabled = false;
    this.fragMatrixInverseEnabled = false;
    let self = this;
    self.uniform = uniform;
  }

  getUniqueNSKeyID() {
    throw Error("can not use this function !!!");
    return this.uniform.getUniqueNSKeyID();
  }

  getUniqueNSKeyString() {
    let ns = this.m_uniqueNSKeyString;
    if (this.vtxUVTransfromEnabled) ns += "VtxUVT";
    if (this.normalEnabled) ns += "Nor";
    return this.uniform.getUniqueNSKeyString() + ns;
  }

  reset() {
    this.m_vertObjMat = true;
    this.m_vertViewMat = true;
    this.m_vertProjMat = true;
    this.m_fragObjMat = false;
    this.m_fragViewMat = false;
    this.m_fragProjMat = false;
    this.fragHeadCodeUnlock = true;
    this.fragMainCodeUnlock = true;
    this.vertHeadCodeUnlock = true;
    this.vertMainCodeUnlock = true;
    this.gamma = true;
    this.autoBuildHeadCodeEnabled = true;
    this.m_use2DMap = false;
    this.m_vertHeadCode = "";
    this.m_vertMainCode = "";
    this.m_fragHeadCode = "";
    this.m_fragMainCode = "";
    this.m_uniqueNSKeyString = "";
    this.m_vertExt = [];
    this.m_fragExt = [];
    this.m_vertLayoutNames = [];
    this.m_vertLayoutTypes = [];
    this.m_fragOutputPrecises = [];
    this.m_fragOutputNames = [];
    this.m_fragOutputTypes = [];
    this.m_varyingNames = [];
    this.m_varyingTypes = [];
    this.m_vertUniformNames = [];
    this.m_vertUniformTypes = [];
    this.m_fragUniformNames = [];
    this.m_fragUniformTypes = [];
    this.m_fragFunctionBlocks = [];
    this.m_vertFunctionBlocks = [];
    this.m_defineNames = [];
    this.m_defineValues = [];
    this.m_textureSampleTypes = [];
    this.m_texturePrecises = [];
    this.m_textureMacroNames = [];
    this.m_textureFlags = [];
    this.m_texturePrecise = "";
    this.mathDefineEanbled = true;
    this.normalEnabled = false;
    this.normalMapEnabled = false;
    this.mapLodEnabled = false;
    this.vertMatrixInverseEnabled = false;
    this.fragMatrixInverseEnabled = false;
    this.vtxUVTransfromEnabled = false;
    this.m_preCompileInfo = null;
    this.uniform.reset();
  }

  addUniqueNSKeyString(key) {
    this.m_uniqueNSKeyString += key;
  }
  /**
   * 预编译信息
   * @returns 返回预编译信息
   */


  getPreCompileInfo() {
    let info = this.m_preCompileInfo;
    this.m_preCompileInfo = null;
    return info;
  }

  useHighPrecious() {
    this.m_preciousCode = "precision highp float;";
  }

  useMediumPrecious() {
    this.m_preciousCode = "precision mediump float;";
  }

  useLowPrecious() {
    this.m_preciousCode = "precision lowp float;";
  }

  addDefine(name, value = "1") {
    if (!this.m_defineNames.includes(name)) {
      this.m_defineNames.push(name);
      this.m_defineValues.push(value);
      return true;
    }

    return false;
  }

  addVertLayout(type, name) {
    if (!this.m_vertLayoutNames.includes(name)) {
      this.m_vertLayoutNames.push(name);
      this.m_vertLayoutTypes.push(type);
    }
  }

  addFragOutputHighp(type, name) {
    if (!this.m_fragOutputNames.includes(name)) {
      this.m_fragOutputPrecises.push("highp");
      this.m_fragOutputNames.push(name);
      this.m_fragOutputTypes.push(type);
    }
  }

  addFragOutput(type, name) {
    if (!this.m_fragOutputNames.includes(name)) {
      this.m_fragOutputPrecises.push("");
      this.m_fragOutputNames.push(name);
      this.m_fragOutputTypes.push(type);
    }
  }

  addVarying(type, name) {
    if (!this.m_varyingNames.includes(name)) {
      this.m_varyingNames.push(name);
      this.m_varyingTypes.push(type);
    }
  }

  addVertUniform(type, name, arrayLength = 0) {
    if (!this.m_vertUniformNames.includes(name)) {
      if (arrayLength > 0) {
        this.m_vertUniformNames.push(name + "[" + arrayLength + "]");
      } else {
        this.m_vertUniformNames.push(name);
      }

      this.m_vertUniformTypes.push(type);
    }
  }

  addVertUniformParam(unifromParam) {
    this.addVertUniform(unifromParam.type, unifromParam.name, unifromParam.arrayLength);
  }

  addFragUniform(type, name, arrayLength = 0) {
    if (!this.m_fragUniformNames.includes(name)) {
      if (arrayLength > 0) {
        this.m_fragUniformNames.push(name + "[" + arrayLength + "]");
      } else {
        this.m_fragUniformNames.push(name);
      }

      this.m_fragUniformTypes.push(type);
    }
  }

  addFragUniformParam(unifromParam) {
    this.addFragUniform(unifromParam.type, unifromParam.name, unifromParam.arrayLength);
  }

  addVertAndFragUniform(type, name, arrayLength = 0) {
    this.addVertUniform(type, name, arrayLength);
    this.addFragUniform(type, name, arrayLength);
  }

  addFragFunction(codeBlock) {
    this.m_fragFunctionBlocks.push(codeBlock);
  }

  addVertFunction(codeBlock) {
    this.m_vertFunctionBlocks.push(codeBlock);
  }

  useTexturePreciseHighp() {
    this.m_texturePrecise = "highp";
  }

  addTextureSample2D(macroName = "", map2DEnabled = true, fragEnabled = true, vertEnabled = false) {
    if (macroName == "" || !this.m_textureMacroNames.includes(macroName)) {
      this.m_textureSampleTypes.push("sampler2D");
      this.m_textureMacroNames.push(macroName);
      this.m_texturePrecises.push(this.m_texturePrecise);
      let flag = 0;
      if (fragEnabled) flag |= 2;
      if (vertEnabled) flag |= 4;
      this.m_textureFlags.push(flag);
      this.m_texturePrecise = "";

      if (map2DEnabled) {
        this.m_use2DMap = true;
      }
    }
  }

  addTextureSampleCube(macroName = "", fragEnabled = true, vertEnabled = false) {
    if (macroName == "" || !this.m_textureMacroNames.includes(macroName)) {
      this.m_textureSampleTypes.push("samplerCube");
      this.m_textureMacroNames.push(macroName);
      this.m_texturePrecises.push(this.m_texturePrecise);
      let flag = 0;
      if (fragEnabled) flag |= 2;
      if (vertEnabled) flag |= 4;
      this.m_textureFlags.push(flag);
      this.m_texturePrecise = "";
    }
  }

  addTextureSample3D(macroName = "", fragEnabled = true, vertEnabled = false) {
    if (macroName == "" || !this.m_textureMacroNames.includes(macroName)) {
      this.m_textureSampleTypes.push("sampler3D");
      this.m_textureMacroNames.push(macroName);
      this.m_texturePrecises.push(this.m_texturePrecise);
      let flag = 0;
      if (fragEnabled) flag |= 2;
      if (vertEnabled) flag |= 4;
      this.m_textureFlags.push(flag);
      this.m_texturePrecise = "";
    }
  }

  isHaveTexture() {
    return this.m_textureSampleTypes.length > 0;
  }

  isHaveTexture2D() {
    return this.m_use2DMap;
  }
  /**
   * vertex shader 使用 空间变换矩阵
   * @param objMatEnabled object space(local space) to wrold space matrix4
   * @param viewMatEnabled world space to view space matrix4
   * @param projMatEnabled view space to projective space matrix4
   */


  useVertSpaceMats(objMatEnabled = true, viewMatEnabled = true, projMatEnabled = true) {
    this.m_vertObjMat = objMatEnabled;
    this.m_vertViewMat = viewMatEnabled;
    this.m_vertProjMat = projMatEnabled;
  }
  /**
   * fragment shader 使用 空间变换矩阵
   * @param objMatEnabled object space(local space) to wrold space matrix4
   * @param viewMatEnabled world space to view space matrix4
   * @param projMatEnabled view space to projective space matrix4
   */


  useFragSpaceMats(objMatEnabled = true, viewMatEnabled = true, projMatEnabled = true) {
    this.m_fragObjMat = objMatEnabled;
    this.m_fragViewMat = viewMatEnabled;
    this.m_fragProjMat = projMatEnabled;
  }

  addVertExtend(code) {
    this.m_vertExt.push(code);
  }

  addFragExtend(code) {
    this.m_fragExt.push(code);
  }

  addVertHeadCode(code) {
    if (code != "") this.m_vertHeadCode += "\n" + code;
  }

  addVertMainCode(code) {
    if (code != "") this.m_vertMainCode += "\n" + code;
  }

  addFragHeadCode(code) {
    if (code != "") this.m_fragHeadCode += "\n" + code;
  }

  addFragMainCode(code) {
    if (code != "") this.m_fragMainCode += "\n" + code;
  }

  addShaderObject(shaderObj) {
    if (this.fragHeadCodeUnlock) this.addFragHeadCode(shaderObj.frag_head);
    if (this.fragMainCodeUnlock) this.addFragMainCode(shaderObj.frag_body);
    if (this.vertHeadCodeUnlock) this.addVertHeadCode(shaderObj.vert_head);
    if (this.vertMainCodeUnlock) this.addVertMainCode(shaderObj.vert_body);
  }

  addShaderObjectHead(shaderObj) {
    if (this.fragHeadCodeUnlock) this.addFragHeadCode(shaderObj.frag_head);
    if (this.vertHeadCodeUnlock) this.addVertMainCode(shaderObj.vert_head);
  }

  autoBuildHeadCode() {
    this.addVertLayout("vec3", "a_vs");

    if (this.m_use2DMap || this.m_vertLayoutNames.includes("a_uvs")) {
      this.addVertLayout("vec2", "a_uvs");
      this.addVarying("vec2", "v_uv");
    }

    if (this.normalEnabled || this.normalMapEnabled || this.m_vertLayoutNames.includes("a_nvs")) {
      this.addVertLayout("vec3", "a_nvs");
      this.addVarying("vec3", "v_worldNormal");
      this.addVarying("vec3", "v_worldPosition");
      this.addDefine("VOX_USE_NORMAL");
      this.vertMatrixInverseEnabled = true;
    } // 保证 顶点shader 中 vtx数据的顺序 a_vs -> a_uvs -> a_nvs


    let words = ["a_vs", "a_uvs", "a_nvs"];
    let nameList = [];
    let typeList = [];

    for (; words.length > 0;) {
      let i = this.m_vertLayoutNames.indexOf(words[0]);

      if (i >= 0) {
        nameList.push(this.m_vertLayoutNames[i]);
        typeList.push(this.m_vertLayoutTypes[i]);
        this.m_vertLayoutNames.splice(i, 1);
        this.m_vertLayoutTypes.splice(i, 1);
      }

      words.shift();
    }

    this.m_vertLayoutNames = nameList.concat(this.m_vertLayoutNames);
    this.m_vertLayoutTypes = typeList.concat(this.m_vertLayoutTypes);

    if (this.vtxUVTransfromEnabled) {
      this.addDefine("VOX_VTX_TRANSFORM_PARAM_INDEX", "0");
    }
  }

  buildFragCode() {
    if (this.autoBuildHeadCodeEnabled) {
      this.autoBuildHeadCode();
    }

    if (this.m_fragOutputNames.length < 1) {
      this.addFragOutput("vec4", "FragColor0");
    }

    let i = 0;
    let len = 0;
    let code = "";

    if (RendererDevice_1.default.FRAG_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED || RendererDevice_1.default.IsMobileWeb()) {
      this.useHighPrecious();
    }

    if (RendererDevice_1.default.IsWebGL2()) {
      code += this.m_versionDeclare;
    }

    this.m_preCompileInfo = new ShaderCompileInfo_1.default();
    this.m_preCompileInfo.info = "\n//##COMPILE_INFO_BEGIN"; // complie info, for example: uniform info

    this.m_preCompileInfo.info += "\n//##COMPILE_INFO_END";
    i = 0;
    len = this.m_fragExt.length;

    for (; i < len; i++) {
      code += "\n" + this.m_fragExt[i];
    }

    if (RendererDevice_1.default.IsWebGL1()) {
      if (this.m_fragOutputNames.length > 1) {
        code += "\n#extension GL_EXT_draw_buffers: require";
      }

      if (this.normalMapEnabled || this.derivatives) {
        code += "\n#extension GL_OES_standard_derivatives : enable";
      }

      if (this.mapLodEnabled) {
        code += "\n#extension GL_EXT_shader_texture_lod : enable";
      }
    }

    if (RendererDevice_1.default.IsMobileWeb()) {
      code += "\nprecision highp float;";
    } else {
      code += "\n" + this.m_preciousCode;
    }

    if (RendererDevice_1.default.IsWebGL2()) {
      code += "\n#define VOX_GLSL_ES3 1";
      code += "\n#define VOX_IN in";

      if (this.mapLodEnabled) {
        code += "\n#define VOX_TextureCubeLod textureLod";
        code += "\n#define VOX_Texture2DLod textureLod";
      }

      code += "\n#define VOX_Texture2D texture";
      code += "\n#define VOX_TextureCube texture";
    } else {
      code += "\n#define VOX_GLSL_ES2 1";
      code += "\n#define VOX_IN varying";

      if (this.mapLodEnabled) {
        code += "\n#define VOX_TextureCubeLod textureCubeLodEXT";
        code += "\n#define VOX_Texture2DLod texture2DLodEXT";
      }

      code += "\n#define VOX_TextureCube textureCube";
      code += "\n#define VOX_Texture2D texture2D";
    }

    if (this.mathDefineEanbled) {
      code += ShaderCode_1.MathShaderCode.BasePredefined;
    }

    len = this.m_defineNames.length;

    for (i = 0; i < len; i++) {
      if (this.m_defineValues[i] != "") {
        code += "\n#define " + this.m_defineNames[i] + " " + this.m_defineValues[i];
      } else {
        code += "\n#define " + this.m_defineNames[i] + " 1";
      }
    }

    i = 0;
    len = this.m_textureMacroNames.length;

    for (; i < len; i++) {
      if (this.m_textureMacroNames[i] != "" && (this.m_textureFlags[i] & 2) != 0) {
        code += "\n#define " + this.m_textureMacroNames[i] + " u_sampler" + i + "";
      }
    }

    if (this.m_use2DMap) {
      code += "\n#define VOX_USE_2D_MAP 1";
    }

    i = 0;
    len = this.m_textureSampleTypes.length;

    for (; i < len; i++) {
      if ((this.m_textureFlags[i] & 2) != 0) {
        if (this.m_texturePrecises[i] == "") {
          code += "\nuniform " + this.m_textureSampleTypes[i] + " u_sampler" + i + ";";
        } else {
          code += "\nuniform " + this.m_texturePrecises[i] + " " + this.m_textureSampleTypes[i] + " u_sampler" + i + ";";
        }
      }
    }

    i = 0;
    len = this.m_fragUniformTypes.length;

    for (; i < len; i++) {
      code += "\nuniform " + this.m_fragUniformTypes[i] + " " + this.m_fragUniformNames[i] + ";";
    }

    if (this.m_fragObjMat) code += "\nuniform mat4 u_objMat;";
    if (this.m_fragViewMat) code += "\nuniform mat4 u_viewMat;";
    if (this.m_fragProjMat) code += "\nuniform mat4 u_projMat;";
    len = this.m_varyingNames.length;

    if (RendererDevice_1.default.IsWebGL2()) {
      for (i = 0; i < len; i++) {
        code += "\nin " + this.m_varyingTypes[i] + " " + this.m_varyingNames[i] + ";";
      }
    } else {
      for (i = 0; i < len; i++) {
        code += "\nvarying " + this.m_varyingTypes[i] + " " + this.m_varyingNames[i] + ";";
      }
    }

    code += ShaderCode_1.ShaderCode.BasePredefined;

    if (this.fragMatrixInverseEnabled && RendererDevice_1.default.IsWebGL1()) {
      this.addVertFunction(GLSLConverter_1.default.__glslInverseMat3);
      this.addVertFunction(GLSLConverter_1.default.__glslInverseMat4);
    }

    code += this.m_fragHeadCode;
    i = 0;
    len = this.m_fragFunctionBlocks.length;

    for (; i < len; i++) {
      code += "\n" + this.m_fragFunctionBlocks[i];
    }

    i = 0;
    len = this.m_fragOutputNames.length;

    if (RendererDevice_1.default.IsWebGL2()) {
      for (; i < len; i++) {
        if (this.m_fragOutputPrecises[i] != "") {
          code += "\nlayout(location = " + i + ") out " + this.m_fragOutputPrecises[i] + " " + this.m_fragOutputTypes[i] + " " + this.m_fragOutputNames[i] + ";";
        } else {
          code += "\nlayout(location = " + i + ") out " + this.m_fragOutputTypes[i] + " " + this.m_fragOutputNames[i] + ";";
        }
      }
    } else {
      if (len == 1) {
        code += "\n#define " + this.m_fragOutputNames[i] + " gl_FragColor";
      }
    } // 检测是否有 main函数


    let haveMainName = false;
    let index = this.m_fragMainCode.indexOf("{");

    if (index > 0) {
      let subStr = this.m_fragMainCode.slice(0, index);
      haveMainName = subStr.indexOf(" main") > 0;

      if (!haveMainName) {
        haveMainName = this.m_fragMainCode.indexOf(" main") > 0;
      }
    }

    if (haveMainName) {
      code += this.m_fragMainCode;
    } else {
      code += "\nvoid main() {\n";
      code += this.m_fragMainCode;
      code += "\n}\n";
    }

    len = this.m_fragOutputNames.length;

    if (RendererDevice_1.default.IsWebGL1()) {
      if (len > 1) {
        for (i = 0; i < len; i++) {
          let tempReg = new RegExp(this.m_fragOutputNames[i], "g");
          code = code.replace(tempReg, "gl_FragData[" + i + "]");
        }
      }
    }

    return code;
  }

  buildVertCode() {
    let i = 0;
    let len = 0;
    let code = "";

    if (RendererDevice_1.default.VERT_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED) {
      this.useHighPrecious();
    }

    if (RendererDevice_1.default.IsWebGL2()) {
      code += this.m_versionDeclare;
    }

    i = 0;
    len = this.m_vertExt.length;

    for (; i < len; i++) {
      code += "\n" + this.m_vertExt[i];
    }

    if (RendererDevice_1.default.IsMobileWeb()) {
      code += "\nprecision highp float;";
    } else {
      code += "\n" + this.m_preciousCode;
    }

    if (RendererDevice_1.default.IsWebGL2()) {
      code += "\n#define VOX_GLSL_ES3 1";
      code += "\n#define VOX_IN in";

      if (this.mapLodEnabled) {
        code += "\n#define VOX_TextureCubeLod textureLod";
        code += "\n#define VOX_Texture2DLod textureLod";
      }

      code += "\n#define VOX_Texture2D texture";
      code += "\n#define VOX_TextureCube texture";
    } else {
      code += "\n#define VOX_GLSL_ES2 1";
      code += "\n#define VOX_IN varying";

      if (this.mapLodEnabled) {
        code += "\n#define VOX_TextureCubeLod textureCubeLodEXT";
        code += "\n#define VOX_Texture2DLod texture2DLodEXT";
      }

      code += "\n#define VOX_TextureCube textureCube";
      code += "\n#define VOX_Texture2D texture2D";
    }

    if (RendererDevice_1.default.IsWebGL2()) {
      code += "\n#define VOX_OUT out";
    } else {
      code += "\n#define VOX_OUT varying";
    }

    if (this.mathDefineEanbled) {
      code += ShaderCode_1.MathShaderCode.BasePredefined;
    }

    len = this.m_defineNames.length;

    for (i = 0; i < len; i++) {
      if (this.m_defineValues[i] != "") {
        code += "\n#define " + this.m_defineNames[i] + " " + this.m_defineValues[i];
      } else {
        code += "\n#define " + this.m_defineNames[i];
      }
    } //if (this.m_use2DMap) {
    //    code += "\n#define VOX_USE_2D_MAP 1";
    //}


    i = 0;
    len = this.m_textureMacroNames.length;

    for (; i < len; i++) {
      if (this.m_textureMacroNames[i] != "" && (this.m_textureFlags[i] & 4) != 0) {
        code += "\n#define " + this.m_textureMacroNames[i] + " u_sampler" + i + "";
      }
    }

    if (this.m_use2DMap) {
      code += "\n#define VOX_USE_2D_MAP 1";
    }

    i = 0;
    len = this.m_textureSampleTypes.length;

    for (; i < len; i++) {
      if ((this.m_textureFlags[i] & 4) != 0) {
        if (this.m_texturePrecises[i] == "") {
          code += "\nuniform " + this.m_textureSampleTypes[i] + " u_sampler" + i + ";";
        } else {
          code += "\nuniform " + this.m_texturePrecises[i] + " " + this.m_textureSampleTypes[i] + " u_sampler" + i + ";";
        }
      }
    }

    len = this.m_vertLayoutNames.length;

    if (RendererDevice_1.default.IsWebGL2()) {
      for (i = 0; i < len; i++) {
        code += "\nlayout(location = " + i + ") in " + this.m_vertLayoutTypes[i] + " " + this.m_vertLayoutNames[i] + ";";
      }
    } else {
      for (i = 0; i < len; i++) {
        code += "\nattribute " + this.m_vertLayoutTypes[i] + " " + this.m_vertLayoutNames[i] + ";";
      }
    }

    len = this.m_vertUniformTypes.length;

    for (i = 0; i < len; i++) {
      code += "\nuniform " + this.m_vertUniformTypes[i] + " " + this.m_vertUniformNames[i] + ";";
    }

    if (this.m_vertObjMat) code += "\nuniform mat4 u_objMat;";
    if (this.m_vertViewMat) code += "\nuniform mat4 u_viewMat;";
    if (this.m_vertProjMat) code += "\nuniform mat4 u_projMat;";
    len = this.m_varyingNames.length;

    if (RendererDevice_1.default.IsWebGL2()) {
      for (i = 0; i < len; i++) {
        code += "\nout " + this.m_varyingTypes[i] + " " + this.m_varyingNames[i] + ";";
      }
    } else {
      for (i = 0; i < len; i++) {
        code += "\nvarying " + this.m_varyingTypes[i] + " " + this.m_varyingNames[i] + ";";
      }
    }

    code += ShaderCode_1.ShaderCode.BasePredefined;
    code += ShaderCode_1.ShaderCode.VertPredefined;

    if (this.vertMatrixInverseEnabled && RendererDevice_1.default.IsWebGL1()) {
      this.addVertFunction(GLSLConverter_1.default.__glslInverseMat3);
      this.addVertFunction(GLSLConverter_1.default.__glslInverseMat4);
    }

    code += this.m_vertHeadCode;
    i = 0;
    len = this.m_vertFunctionBlocks.length;

    for (; i < len; i++) {
      code += "\n" + this.m_vertFunctionBlocks[i];
    } // 检测是否有 main函数


    let haveMainName = false;
    let index = this.m_vertMainCode.indexOf("{");

    if (index > 0) {
      let subStr = this.m_vertMainCode.slice(0, index);
      haveMainName = subStr.indexOf(" main") > 0;

      if (!haveMainName) {
        haveMainName = this.m_vertMainCode.indexOf(" main") > 0;
      }
    }

    if (haveMainName) {
      code += this.m_vertMainCode;
    } else {
      code += "\nvoid main() {\n";
      code += this.m_vertMainCode;
      code += "\n}\n";
    }

    return code;
  }

}

exports.default = ShaderCodeBuilder;

/***/ }),

/***/ "4aad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const CoSpace_1 = __webpack_require__("cbd5");

const FBXSceneNode_1 = __webpack_require__("b627");

const CTMSceneNode_1 = __webpack_require__("9468");

const OBJSceneNode_1 = __webpack_require__("7b85");

const Axis3DEntity_1 = __importDefault(__webpack_require__("b9b5"));

const DropFileController_1 = __webpack_require__("7126");

const VerifierParam_1 = __webpack_require__("08aa");

const TaskCodeModuleParam_1 = __webpack_require__("0817");

const ModuleNS_1 = __webpack_require__("8eb0");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

class VerifierScene {
  constructor() {
    /**
     * (引擎)数据协同中心实例
     */
    this.m_cospace = new CoSpace_1.CoSpace();
    this.m_vfParam = new VerifierParam_1.VerifierParam();
    this.m_rscene = null;
    this.m_waitSceneNodes = [];
    this.m_sceneNodes = [];
    this.m_dropController = new DropFileController_1.DropFileController();
  }

  initialize(rscene) {
    if (this.m_rscene == null) {
      this.m_rscene = rscene;
      let axis = new Axis3DEntity_1.default();
      axis.initialize(300);
      this.m_rscene.addEntity(axis);
      this.m_vfParam.initialize();
      this.initCurr(); // this.initTestSvr();

      this.m_dropController.initialize(this.m_rscene.getCanvas(), this);
      DivLog_1.default.ShowLogOnce("模型法线检查</br>请用谷歌浏览器(Google Chrome)</br>请拖入单个模型文件(ctm/obj/fbx)</br>或者拖入只包含ctm文件的文件夹</br>蓝色点状颜色表示法线需要翻转</br>红色或绿色点状颜色表示法线倾斜了");
      this.test();
    }
  }

  initCurr() {
    /*
    let line: DashedLine3DEntity = new DashedLine3DEntity();
      // line.initializeByPosition([
    // 	new Vector3D(), new Vector3D(0,100, 0),
    // 	new Vector3D(50), new Vector3D(100,100)
    // ], true);
      
    line.initializeBySegmentLines([
        new Vector3D(), new Vector3D(0,100, 0),
        new Vector3D(50), new Vector3D(100,100)
    ]);
      // let lineF32VS = new Float32Array(
    // 	[0,0,0, 0, 100,0, 100,0,0, 100, 100, 0]
    // );
    // line.initializeF32VS(lineF32VS);
      this.m_rscene.addEntity(line);
      // let bline: BrokenLine3DEntity = new BrokenLine3DEntity();
    // bline.ini([
    // 	new Vector3D(), new Vector3D(0,100),
    // 	new Vector3D(50), new Vector3D(100,100)
    // ])
    //*/
    console.log("this.m_vfParam: ", this.m_vfParam);

    if ((this.m_vfParam.hostUrl.indexOf(".artvily.") > 0 || this.m_vfParam.demoType != "") && this.m_vfParam.threadsTotal > 0) {
      let preUrl = "http://www.artvily.com:9090/static/publish/";
      let modules = [new TaskCodeModuleParam_1.TaskCodeModuleParam(preUrl + "renderingVerifier/modules/ct1.js", ModuleNS_1.ModuleNS.ctmParser), new TaskCodeModuleParam_1.TaskCodeModuleParam(preUrl + "renderingVerifier/modules/ob1.js", ModuleNS_1.ModuleNS.objParser)];
      this.m_cospace.setTaskModuleParams(modules);
      this.m_cospace.initialize(this.m_vfParam.threadsTotal, preUrl + "renderingVerifier/modules/th1.js", true);
    } else {
      let modules = [new TaskCodeModuleParam_1.TaskCodeModuleParam("static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js", ModuleNS_1.ModuleNS.ctmParser), new TaskCodeModuleParam_1.TaskCodeModuleParam("static/cospace/modules/obj/ModuleOBJGeomParser.umd.js", ModuleNS_1.ModuleNS.objParser)];
      this.m_cospace.setTaskModuleParams(modules); // this.m_cospace.geometry.setTaskModuleUrls(["static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js"]);
      // // 初始化数据协同中心
      // this.m_cospace.initialize(3, "static/renderingVerifier/modules/c1.js", true);
      // this.m_cospace.initialize(3, "static/cospace/core/code/ThreadCore.umd.min.js", true);

      this.m_cospace.initialize(3, "static/cospace/core/code/ThreadCore.umd.js", true);
    }
  }

  initTestSvr() {
    let dir = "static/renderingVerifier/";

    if ((this.m_vfParam.hostUrl.indexOf(".artvily.") > 0 || this.m_vfParam.demoType != "") && this.m_vfParam.threadsTotal > 0) {
      let modules = [new TaskCodeModuleParam_1.TaskCodeModuleParam(dir + "modules/ct1.js", ModuleNS_1.ModuleNS.ctmParser), new TaskCodeModuleParam_1.TaskCodeModuleParam(dir + "modules/ob1.js", ModuleNS_1.ModuleNS.objParser)];
      this.m_cospace.setTaskModuleParams(modules); // this.m_cospace.geometry.setTaskModuleUrls(modules);

      this.m_cospace.initialize(this.m_vfParam.threadsTotal, dir + "modules/th1.js", true);
    } else {
      dir = "http://localhost:9090/static/publish/renderingVerifier/";
      let modules = [new TaskCodeModuleParam_1.TaskCodeModuleParam(dir + "modules/ct1.js", ModuleNS_1.ModuleNS.ctmParser), new TaskCodeModuleParam_1.TaskCodeModuleParam(dir + "modules/ob1.js", ModuleNS_1.ModuleNS.objParser)];
      this.m_cospace.setTaskModuleParams(modules); // this.m_cospace.geometry.setTaskModuleUrls(modules);
      // this.m_cospace.geometry.setTaskModuleUrls(["static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js"]);
      // // 初始化数据协同中心
      // this.m_cospace.initialize(3, "static/renderingVerifier/modules/c1.js", true);
      // this.m_cospace.initialize(3, "static/cospace/core/code/ThreadCore.umd.min.js", true);

      this.m_cospace.initialize(3, dir + "modules/th1.js", true);
    }
  }

  test() {// let list = [236, 82, 86, -236, 82, 26, 83, -87, 86, 83, 30, -85, 254, 235, 86, -85];
    // list.forEach( function ( va: number, vb: number ): void {
    // 	console.log("va, vb: ", va, vb);
    // });
  }

  isDropEnabled() {
    return this.isFinish();
  }

  resetScene() {
    DivLog_1.default.ShowLogOnce("正在载入模型文件...");
    this.clear();
  }

  initFileLoad(files) {
    console.log("initFileLoad(), files.length: ", files.length);
    let flag = 1;

    if (files.length > 0) {
      let name = "";
      let urls = [];

      for (let i = 0; i < files.length; i++) {
        if (i == 0) name = files[i].name;
        const urlObj = window.URL.createObjectURL(files[i]);
        urls.push(urlObj);
      }

      if (name != "") {
        name.toLocaleLowerCase();

        if (name.indexOf(".ctm") > 1) {
          this.resetScene();
          this.addCTM(urls);
        } else if (name.indexOf(".fbx") > 1) {
          this.resetScene();
          this.addFBX(urls);
        } else if (name.indexOf(".obj") > 1) {
          this.resetScene();
          this.addOBJ(urls);
        } else {
          flag = 31;
        }
      } else {
        flag = 31;
      }
    } else {
      flag = 31;
    }

    this.m_dropController.alertShow(flag);
  }

  initTest() {
    if (this.m_vfParam.demoType != "") {
      let urls = this.m_vfParam.getUrls();

      switch (this.m_vfParam.demoType) {
        case "fbx":
          this.addFBX(urls);
          break;

        case "ctm":
          this.addCTM(urls);
          break;

        default:
          break;
      }

      return;
    }

    if (this.m_vfParam.hostUrl.indexOf(".artvily.") > 0) {
      return;
    } // return;


    let size = 107375616; // return;

    let url = "static/assets/fbx/test01.fbx";
    url = "static/assets/fbx/box.fbx"; // url = "static/private/fbx/box01.fbx";
    // url = "static/private/fbx/sph.fbx";
    // url = "static/private/fbx/cylinder.fbx";
    // url = "static/private/fbx/cylinder0.fbx";
    // url = "static/private/fbx/cylinder1.fbx";
    // url = "static/private/fbx/cylinder2.fbx";
    // url = "static/private/fbx/cylinder3.fbx";
    // url = "static/private/fbx/sph01.fbx";
    // url = "static/private/fbx/sph02.fbx";
    // url = "static/private/fbx/cone0.fbx";
    // url = "static/private/fbx/face2.fbx";
    // url = "static/private/fbx/tri.fbx";
    // url = "static/private/fbx/plane.fbx";
    // url = "static/private/fbx/base2.fbx";
    // url = "static/private/fbx/model_500W.fbx";

    url = "static/private/fbx/base3.fbx"; // url = "static/private/fbx/base4.fbx";
    // url = "static/private/fbx/nvxie_zzb.fbx";
    // url = "static/private/fbx/3279.fbx";
    // url = "static/private/fbx/3279_b.fbx";
    // url = "static/private/fbx/model_1000W.fbx";
    // url = "static/private/fbx/model2_1000W.fbx";
    // url = "static/private/fbx/Samba_Dancing.fbx";
    // url = "static/private/fbx/monkey.fbx";
    // this.addFBX( [url] );
    // return;

    let hostUrl = this.m_vfParam.hostUrl;
    let baseUrl = "static/private/ctm/";
    let urls = [];

    for (let i = 0; i <= 26; ++i) {
      urls.push(baseUrl + "sh202/sh202_" + i + ".ctm");
    }

    urls = [baseUrl + "errorNormal.ctm"]; // urls = [baseUrl + "errorIndex.ctm"];

    this.addCTM(urls); // this.testCTM(urls[0]);

    baseUrl = hostUrl + "static/private/obj/";
    urls = [baseUrl + "base.obj"]; // urls = ["http://localhost:9090/static/assets/obj/apple_01.obj"];
    // this.addOBJ(urls);
  }

  testCTM(url) {
    let i = 0;
    let len = 6;
    let s0 = url.substr(i, 6);
    let s1 = url.slice(i, i + 6);
    console.log("test s0,s1: ", s0, s1);
    let buf = new ArrayBuffer(64);
    let buf32 = new Uint32Array(buf, 0, 8);
    buf32[6] = 16;
    console.log("test buf,buf32: ", buf, buf32);
  }

  mouseDown(evt) {
    let nodes = this.m_sceneNodes;

    for (let i = 0; i < nodes.length; ++i) {
      nodes[i].mouseDown(evt);
    }
  }

  addFBX(urls) {
    this.addNewNode(new FBXSceneNode_1.FBXSceneNode(), urls);
  }

  addCTM(urls) {
    this.addNewNode(new CTMSceneNode_1.CTMSceneNode(), urls);
  }

  addOBJ(urls) {
    this.addNewNode(new OBJSceneNode_1.OBJSceneNode(), urls);
  }

  addNewNode(node, urls) {
    DivLog_1.default.ShowLogOnce("正在解析原数据...");
    node.initialize(this.m_rscene, this.m_cospace);
    node.load(urls);
    this.m_waitSceneNodes.push(node);
    this.m_sceneNodes.push(node);
  }

  showInfo(info) {
    DivLog_1.default.ShowLogOnce(info);
  }

  isFinish() {
    return this.m_waitSceneNodes.length == 0;
  }

  clear() {
    if (this.isFinish()) {
      let nodes = this.m_sceneNodes;

      for (let i = 0; i < nodes.length; ++i) {
        const node = nodes[i];
        node.clear();
      }

      this.m_sceneNodes = [];
    }
  }

  run() {
    let nodes = this.m_waitSceneNodes;

    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      node.run();

      if (node.isFinish()) {
        nodes.splice(i, 1);
        i--;
      }
    }
  }

}

exports.VerifierScene = VerifierScene;

/***/ }),

/***/ "4cf7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const TextureProxyType_1 = __webpack_require__("7918");
/**
 * 本类作基础纹理对象的对象池
 */


class TexturePool {
  constructor() {
    this.m_imgTexList = [];
    this.m_bytesTexList = [];
    this.m_floatTexList = [];
    this.m_wrapperTexList = [];
  }

  addTexture(texture) {
    switch (texture.getType()) {
      case TextureProxyType_1.TextureProxyType.Image:
        this.m_imgTexList.push(texture);
        break;

      case TextureProxyType_1.TextureProxyType.Bytes:
        this.m_bytesTexList.push(texture);
        break;

      case TextureProxyType_1.TextureProxyType.Float:
        this.m_floatTexList.push(texture);
        break;

      case TextureProxyType_1.TextureProxyType.Wrapper:
        this.m_wrapperTexList.push(texture);
        break;

      default:
        break;
    }
  }

  getTexture(type) {
    switch (type) {
      case TextureProxyType_1.TextureProxyType.Image:
        if (this.m_imgTexList.length > 0) {
          return this.m_imgTexList.pop();
        }

        break;

      case TextureProxyType_1.TextureProxyType.Bytes:
        if (this.m_bytesTexList.length > 0) {
          return this.m_bytesTexList.pop();
        }

        break;

      case TextureProxyType_1.TextureProxyType.Float:
        if (this.m_floatTexList.length > 0) return this.m_floatTexList.pop();
        break;

      case TextureProxyType_1.TextureProxyType.Wrapper:
        if (this.m_wrapperTexList.length > 0) return this.m_wrapperTexList.pop();
        break;

      default:
        break;
    }

    return null;
  }

}

exports.TexturePool = TexturePool;
exports.default = TexturePool;

/***/ }),

/***/ "4efa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const SpecularMode_1 = __webpack_require__("839a");

const ShadowMode_1 = __webpack_require__("a9f4");

class ShaderTextureBuilder {
  constructor(codeBuilder) {
    this.m_coderBuilder = null;
    this.m_uniform = null;
    this.m_texList = [];
    this.m_coderBuilder = codeBuilder;
    this.m_uniform = codeBuilder.uniform;
  }

  getCodeBuilder() {
    return this.m_coderBuilder;
  }

  reset() {
    this.m_texList = [];
  }

  getTextures() {
    return this.m_texList;
  }

  getTexturesTotal() {
    return this.m_texList.length;
  }
  /**
   * add diffuse map uniform code
   */


  addDiffuseMap(tex) {
    if (tex != null) {
      this.m_uniform.addDiffuseMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add normal map uniform code
   */


  addNormalMap(tex) {
    if (tex != null) {
      this.m_uniform.addNormalMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add parallax map uniform code
   * @param parallaxParamIndex parallax map parameter uniform data array index
   */


  addParallaxMap(tex, parallaxParamIndex) {
    if (tex != null) {
      this.m_uniform.addParallaxMap(parallaxParamIndex);
      this.m_texList.push(tex);
    }
  }
  /**
   * add displacement map uniform code
   * @param parallaxParamIndex vec4 param array index in the vertex shader
   */


  addDisplacementMap(tex, displacementParamIndex) {
    if (tex != null) {
      this.m_uniform.addDisplacementMap(displacementParamIndex);
      this.m_texList.push(tex);
    }
  }
  /**
   * add specular map uniform code
   * @param specularMode is SpecularMode type value, the default is SpecularMode.Default
   */


  addSpecularMap(tex, specularMode = SpecularMode_1.SpecularMode.Default) {
    if (tex != null) {
      this.m_uniform.addSpecularMap(specularMode);
      this.m_texList.push(tex);
    }
  }
  /**
   * add shadow map uniform code
   * @param shadowMode is shadowMode type value, the default is ShadowMode.VSM
   */


  addShadowMap(tex, shadowMode = ShadowMode_1.ShadowMode.VSM) {
    if (tex != null) {
      this.m_uniform.addShadowMap(shadowMode);
      this.m_texList.push(tex);
    }
  }
  /**
   * add env specular cube map uniform code
   * @param cubeMap yes or no, the default is true
   */


  addSpecularEnvMap(tex, cubeMap = true) {
    if (tex != null) {
      this.m_uniform.addSpecularEnvMap(cubeMap);
      this.m_texList.push(tex);
    }
  }
  /**
   * add ambient occlusion map uniform code
   */


  addAOMap(tex) {
    if (tex != null) {
      this.m_uniform.addAOMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add roughness map uniform code
   */


  addRoughnessMap(tex) {
    if (tex != null) {
      this.m_uniform.addRoughnessMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add metalness map uniform code
   */


  addMetalnessMap(tex) {
    if (tex != null) {
      this.m_uniform.addMetalnessMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add ao, roughness, metalness map uniform code
   */


  addARMMap(tex) {
    if (tex != null) {
      this.m_uniform.addARMMap();
      this.m_texList.push(tex);
    }
  }
  /**
   * add sampler2d texture uniform code
   * @param tex 2d IRenderTexture instance
   * @param macroName shader code macro define name, the default vaule is empty string
   * @param map2DEnabled texture 2d enabled, the default vaule is true
   * @param fragEnabled fragment shader applying enabled, the default vaule is true
   * @param vertEnabled vertex shader applying enabled, the default vaule is false
   */


  add2DMap(tex, macroName = "", map2DEnabled = true, fragEnabled = true, vertEnabled = false) {
    if (tex != null) {
      this.m_uniform.add2DMap(macroName, map2DEnabled, fragEnabled, vertEnabled);
      this.m_texList.push(tex);
    }
  }
  /**
   * add sampleCube texture uniform code
   * @param tex cube IRenderTexture instance
   * @param macroName shader code macro define name, the default vaule is empty string
   * @param fragEnabled fragment shader applying enabled, the default vaule is true
   * @param vertEnabled vertex shader applying enabled, the default vaule is false
   */


  addCubeMap(tex, macroName = "", fragEnabled = true, vertEnabled = false) {
    if (tex != null) {
      this.m_uniform.addCubeMap(macroName, fragEnabled, vertEnabled);
      this.m_texList.push(tex);
    }
  }
  /**
   * add sample3D texture uniform code
   * @param tex 3d IRenderTexture instance
   * @param macroName shader code macro define name, the default vaule is empty string
   * @param fragEnabled fragment shader applying enabled, the default vaule is true
   * @param vertEnabled vertex shader applying enabled, the default vaule is false
   */


  add3DMap(tex, macroName = "", fragEnabled = true, vertEnabled = false) {
    if (tex != null) {
      this.m_uniform.add3DMap(macroName, fragEnabled, vertEnabled);
      this.m_texList.push(tex);
    }
  }

}

exports.ShaderTextureBuilder = ShaderTextureBuilder;

/***/ }),

/***/ "4f27":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const ShaderUniform_1 = __webpack_require__("d53d");

const CameraUniformBuilder_1 = __importDefault(__webpack_require__("2560"));

const StageParamUniformBuilder_1 = __importDefault(__webpack_require__("83d1"));

const FrustumUniformBuilder_1 = __importDefault(__webpack_require__("a7ed"));

const CameraPosUniformBuilder_1 = __importDefault(__webpack_require__("857b"));

const ViewParamUniformBuilder_1 = __importDefault(__webpack_require__("e87b"));

class EmptyShdUniform extends ShaderUniform_1.ShaderUniform {
  use(rc) {}

  useByLocation(rc, type, location, i) {}

  useByShd(rc, shd) {}

  updateData() {}

  destroy() {}

}

EmptyShdUniform.EmptyUniform = new EmptyShdUniform();

class ShdUniformTool {
  constructor() {
    this.m_initFlag = true;
    this.m_uniformDict = new Map();
    this.m_builders = [];
    this.m_buildersTot = 0;
    this.m_emptyUniform = new ShaderUniform_1.ShaderUniform();
  }

  appendUniformBuilder(builder) {
    if (!this.m_uniformDict.has(builder.getIDNS())) {
      this.m_builders.push(builder);
      this.m_uniformDict.set(builder.getIDNS(), builder);
      this.m_buildersTot = this.m_builders.length;
    }
  }

  initialize() {
    if (this.m_initFlag) {
      this.m_initFlag = false;
      this.appendUniformBuilder(new CameraUniformBuilder_1.default());
      this.appendUniformBuilder(new FrustumUniformBuilder_1.default());
      this.appendUniformBuilder(new CameraPosUniformBuilder_1.default());
      this.appendUniformBuilder(new StageParamUniformBuilder_1.default());
      this.appendUniformBuilder(new ViewParamUniformBuilder_1.default());
    }
  }

  addSharedUniformBuilder(builder) {
    if (builder != null && !this.m_uniformDict.has(builder.getIDNS())) {
      this.m_builders.push(builder);
      this.m_uniformDict.set(builder.getIDNS(), builder);
      ++this.m_buildersTot;
    }
  }

  removeSharedUniformBuilder(builder) {
    if (builder != null && this.m_uniformDict.has(builder.getIDNS())) {
      for (let i = 0; i < this.m_buildersTot; ++i) {
        if (builder == this.m_builders[i]) {
          this.m_builders.splice(i, 1);
          --this.m_buildersTot;
          break;
        }
      }

      this.m_uniformDict.delete(builder.getIDNS());
    }
  }

  removeSharedUniformBuilderByName(builderNS) {
    if (this.m_uniformDict.has(builderNS)) {
      let builder = this.m_uniformDict.get(builderNS);

      for (let i = 0; i < this.m_buildersTot; ++i) {
        if (builder == this.m_builders[i]) {
          this.m_builders.splice(i, 1);
          --this.m_buildersTot;
          break;
        }
      }

      this.m_uniformDict.delete(builderNS);
    }
  }

  buildShared(guniforms, rc, shdp) {
    let guniform;
    let headU = null;
    let prevU = null;
    let builders = this.m_builders;
    let i = 0;
    let len = this.m_buildersTot;
    let puo = null;

    for (; i < len; ++i) {
      puo = builders[i].create(rc, shdp);

      if (puo != null) {
        if (prevU != null) {
          prevU.next = puo;
        } else if (headU == null) {
          headU = puo;
        }

        prevU = puo;
      }
    }

    if (guniforms == null) {
      guniform = headU;
    } else if (headU != null) {
      for (let i = 0; i < guniforms.length; ++i) {
        prevU.next = guniforms[i];
        prevU = prevU.next;
      }

      guniform = headU;
    }

    if (guniform == null) {
      guniform = EmptyShdUniform.EmptyUniform;
    } else {
      // normalize uniform
      let pdata = guniform; //  let boo: boolean = false;
      //  if(pdata.uns == "u_projMat") {
      //      boo = true;
      //      console.log("u_projMat global build begin pdata.uns: ",pdata.uns);
      //  }

      let i = 0;

      while (pdata != null) {
        //  if(boo) {
        //      console.log("### u_projMat global build...pdata.uns: ",pdata.uns);
        //  }
        if (pdata.uniformNameList != null && pdata.locations == null) {
          pdata.types = [];
          pdata.locations = [];
          pdata.uniformSize = pdata.uniformNameList.length;

          for (i = 0; i < pdata.uniformSize; ++i) {
            pdata.types.push(shdp.getUniformTypeByNS(pdata.uniformNameList[i]));
            pdata.locations.push(shdp.getUniformLocationByNS(pdata.uniformNameList[i]));
          } //console.log("global uniform names: "+pdata.uniformNameList);
          //console.log("global uniform types: "+pdata.types);
          //console.log("global uniform locations: "+pdata.locations);

        }

        pdata = pdata.next;
      } //  if(boo) {
      //      console.log("u_projMat global build end pdata.uns: u_projMat.");
      //  }

    }

    return guniform;
  }

  buildLocalFromTransformV(transformData, shdp) {
    if (transformData != null) {
      let shdUniform;
      shdUniform = new ShaderUniform_1.ShaderMat4Uniform();
      shdUniform.uniformSize = 0;
      shdUniform.uniformNameList = [];
      shdUniform.types = [];
      shdUniform.locations = [];
      shdUniform.dataList = [];
      shdUniform.dataSizeList = [];
      shdUniform.uniformSize += 1;
      shdUniform.uniformNameList.push("u_objMat");
      shdUniform.types.push(shdp.getUniformTypeByNS("u_objMat"));
      shdUniform.locations.push(shdp.getUniformLocationByNS("u_objMat"));
      shdUniform.dataList.push(transformData);
      shdUniform.dataSizeList.push(1);
      return shdUniform;
    }

    return this.m_emptyUniform;
  }

  updateLocalFromTransformV(dstUniform, transformData, shdp) {
    if (transformData != null) {
      let shdUniform;
      let srcUniform = dstUniform;

      if (srcUniform == null) {
        srcUniform = new ShaderUniform_1.ShaderMat4Uniform();
        shdUniform = srcUniform;
        shdUniform.uniformSize = 0;
        shdUniform.uniformNameList = [];
        shdUniform.types = [];
        shdUniform.locations = [];
        shdUniform.dataList = [];
        shdUniform.dataSizeList = [];
        shdUniform.uniformSize += 1;
        shdUniform.uniformNameList.push("u_objMat");
        shdUniform.types.push(shdp.getUniformTypeByNS("u_objMat"));
        shdUniform.locations.push(shdp.getUniformLocationByNS("u_objMat"));
        shdUniform.dataList.push(transformData);
        shdUniform.dataSizeList.push(1);
      } else {
        shdUniform = srcUniform;
        shdUniform.locations = [];
        shdUniform.locations.push(shdp.getUniformLocationByNS("u_objMat"));
      }

      return shdUniform;
    }

    return this.m_emptyUniform;
  }

  buildLocalFromData(uniformData, shdp) {
    if (uniformData != null) {
      // collect all uniform data,create a new runned uniform
      let shdUniform;

      if (RendererDevice_1.default.IsWebGL1()) {
        shdUniform = new ShaderUniform_1.ShaderUniformV1();
      } else {
        shdUniform = new ShaderUniform_1.ShaderUniformV2();
      }

      shdUniform.uns = uniformData.uns;
      shdUniform.uniformNameList = [];
      shdUniform.types = [];
      shdUniform.locations = [];
      shdUniform.dataList = [];
      shdUniform.dataSizeList = [];
      shdUniform.uniformSize = 0;
      let pdata = uniformData;
      let i = 0;

      while (pdata != null) {
        if (pdata.uniformNameList != null && pdata.locations == null) {
          shdUniform.uniformSize += pdata.uniformNameList.length;

          for (i = 0; i < shdUniform.uniformSize; ++i) {
            shdUniform.uniformNameList.push(pdata.uniformNameList[i]);
            shdUniform.types.push(shdp.getUniformTypeByNS(pdata.uniformNameList[i]));
            shdUniform.locations.push(shdp.getUniformLocationByNS(pdata.uniformNameList[i]));
            shdUniform.dataList.push(pdata.dataList[i]);
            shdUniform.dataSizeList.push(shdp.getUniformLengthByNS(pdata.uniformNameList[i]));
          } // console.log("local uniform frome data names: ",shdUniform.uniformNameList);
          // console.log("local uniform frome data types: ",shdUniform.types);
          // console.log("local uniform frome data locations: ",shdUniform.locations);
          // console.log("local uniform frome data dataSizeList: ",shdUniform.dataSizeList);

        }

        pdata = pdata.next;
      }

      return shdUniform;
    }

    return EmptyShdUniform.EmptyUniform;
  }

}

exports.default = ShdUniformTool;

/***/ }),

/***/ "519e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const MeshBase_1 = __importDefault(__webpack_require__("cb29"));

const ROVertexBuffer_1 = __importDefault(__webpack_require__("e7d2"));

const AABB_1 = __importDefault(__webpack_require__("fecb"));

const SurfaceNormalCalc_1 = __importDefault(__webpack_require__("35fa"));

class DataMesh extends MeshBase_1.default {
  constructor(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    super(bufDataUsage);
    this.m_initIVS = null;
    this.m_boundsChanged = true;
    this.m_vs = null;
    this.m_uvs = null;
    this.m_nvs = null;
    this.m_cvs = null;
    this.m_tvs = null;
    this.m_btvs = null;
    this.m_rayTester = null;
    this.m_boundsVersion = -2;
    this.autoBuilding = true;
    this.vsStride = 3;
    this.uvsStride = 2;
    this.nvsStride = 3;
    this.cvsStride = 3;
  }

  setRayTester(rayTester) {
    this.m_rayTester = rayTester;
  }
  /**
   * set vertex position data
   * @param vs vertex position buffer Float32Array
   */


  setVS(vs) {
    this.m_vs = vs;
    this.m_boundsChanged = true;
    return this;
  }
  /**
   * @returns vertex position buffer Float32Array
   */


  getVS() {
    return this.m_vs;
  }
  /**
   * set vertex uv data
   * @param vs vertex uv buffer Float32Array
   */


  setUVS(uvs) {
    this.m_uvs = uvs;
    return this;
  }
  /**
   * @returns vertex uv buffer Float32Array
   */


  getUVS() {
    return this.m_uvs;
  }
  /**
   * set vertex normal data
   * @param vs vertex normal buffer Float32Array
   */


  setNVS(nvs) {
    this.m_nvs = nvs;
    return this;
  }
  /**
   * @returns vertex normal buffer Float32Array
   */


  getNVS() {
    return this.m_nvs;
  }
  /**
   * set vertex tangent data
   * @param vs vertex tangent buffer Float32Array
   */


  setTVS(tvs) {
    this.m_tvs = tvs;
    return this;
  }
  /**
   * @returns vertex tangent buffer Float32Array
   */


  getTVS() {
    return this.m_tvs;
  }
  /**
   * set vertex bitangent data
   * @param vs vertex bitangent buffer Float32Array
   */


  setBTVS(btvs) {
    this.m_btvs = btvs;
    return this;
  }
  /**
   * set vertex color(r,g,b) data
   * @param vs vertex color(r,g,b) buffer Float32Array
   */


  setCVS(cvs) {
    this.m_cvs = cvs;
    return this;
  }
  /**
   * @returns vertex bitangent buffer Float32Array
   */


  getBTVS() {
    return this.m_btvs;
  }

  setIVS(ivs) {
    this.m_initIVS = ivs;
    this.m_ivs = ivs;
    this.m_boundsChanged = true;
    return this;
  }

  initializeFromGeometry(geom) {
    this.m_vs = geom.getVS();
    this.m_uvs = geom.getUVS();
    this.m_nvs = geom.getNVS();
    this.m_tvs = geom.getTVS();
    this.m_btvs = geom.getBTVS();
    this.m_cvs = geom.getCVS();
    this.m_ivs = geom.getIVS();
    this.m_initIVS = this.m_ivs;
    this.m_boundsChanged = true;
    this.initialize();
  }

  initialize() {
    if (this.m_vs != null) {
      if (this.autoBuilding) {
        if (this.bounds == null) {
          this.bounds = new AABB_1.default();
          this.bounds.addXYZFloat32Arr(this.m_vs);
          this.bounds.update();
        } else if (this.m_boundsChanged || this.m_boundsVersion == this.bounds.version) {
          this.bounds.reset(); // 如果重新init, 但是版本号却没有改变，说明bounds需要重新计算

          this.bounds.addXYZFloat32Arr(this.m_vs);
          this.bounds.update();
        }
      }

      this.m_boundsVersion = this.bounds.version;
      this.m_boundsChanged = false;
      this.m_ivs = this.m_initIVS;
      ROVertexBuffer_1.default.Reset();
      ROVertexBuffer_1.default.AddFloat32Data(this.m_vs, this.vsStride);

      if (this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_UVS_INDEX)) {
        ROVertexBuffer_1.default.AddFloat32Data(this.m_uvs, this.uvsStride);
      } else {
        console.warn("DataMesh hasn't uv data.");
      }

      if (this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_NVS_INDEX)) {
        if (this.m_nvs == null) {
          let trisNumber = this.m_ivs.length / 3;
          this.m_nvs = new Float32Array(this.m_vs.length);
          SurfaceNormalCalc_1.default.ClacTrisNormal(this.m_vs, this.m_vs.length, trisNumber, this.m_ivs, this.m_nvs);
        }

        ROVertexBuffer_1.default.AddFloat32Data(this.m_nvs, this.nvsStride);
      } else {
        console.warn("DataMesh hasn't normal(nvs) data.");
      }

      if (this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_CVS_INDEX)) {
        ROVertexBuffer_1.default.AddFloat32Data(this.m_cvs, this.cvsStride);
      } else {
        console.warn("DataMesh hasn't color(cvs) data.");
      }

      if (this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_TVS_INDEX)) {
        ROVertexBuffer_1.default.AddFloat32Data(this.m_tvs, 3);
        ROVertexBuffer_1.default.AddFloat32Data(this.m_btvs, 3);
      }

      ROVertexBuffer_1.default.vbWholeDataEnabled = this.vbWholeDataEnabled;
      this.vtCount = this.m_ivs.length;

      if (this.autoBuilding) {
        this.vtxTotal = this.m_vs.length / this.vsStride;
        this.updateWireframeIvs();
        this.vtCount = this.m_ivs.length;
        this.trisNumber = this.vtCount / 3;
      }

      if (this.m_vbuf != null) {
        ROVertexBuffer_1.default.UpdateBufData(this.m_vbuf);
      } else {
        let u = this.getBufDataUsage();
        let f = this.getBufSortFormat();
        this.m_vbuf = ROVertexBuffer_1.default.CreateBySaveData(u, f);

        if (this.vbWholeDataEnabled) {
          this.m_vbuf = ROVertexBuffer_1.default.CreateBySaveData(u, f);
        } else {
          this.m_vbuf = ROVertexBuffer_1.default.CreateBySaveDataSeparate(u);
        }
      }

      this.m_vbuf.setUintIVSData(this.m_ivs);
      this.buildEnd();
    }
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    if (this.m_rayTester != null) {
      return this.m_rayTester.testRay(rlpv, rltv, outV, boundsHit);
    }

    return -1;
  }

  __$destroy() {
    if (this.isResFree()) {
      this.bounds = null;

      if (this.m_rayTester != null) {
        this.m_rayTester.destroy();
        this.m_rayTester = null;
      }

      this.m_vs = null;
      this.m_uvs = null;
      this.m_nvs = null;
      this.m_cvs = null;
      this.m_tvs = null;
      this.m_btvs = null;
      this.m_initIVS = null;

      super.__$destroy();
    }
  }

}

exports.default = DataMesh;

/***/ }),

/***/ "5216":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var MaterialPipeType;

(function (MaterialPipeType) {
  MaterialPipeType[MaterialPipeType["ENV_LIGHT_PARAM"] = 0] = "ENV_LIGHT_PARAM";
  MaterialPipeType[MaterialPipeType["ENV_AMBIENT_LIGHT"] = 1] = "ENV_AMBIENT_LIGHT";
  MaterialPipeType[MaterialPipeType["FOG"] = 2] = "FOG";
  MaterialPipeType[MaterialPipeType["FOG_EXP2"] = 3] = "FOG_EXP2";
  MaterialPipeType[MaterialPipeType["VSM_SHADOW"] = 4] = "VSM_SHADOW";
  MaterialPipeType[MaterialPipeType["GLOBAL_LIGHT"] = 5] = "GLOBAL_LIGHT";
})(MaterialPipeType || (MaterialPipeType = {}));

exports.MaterialPipeType = MaterialPipeType;

/***/ }),

/***/ "52e0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const TextureProxyType_1 = __webpack_require__("7918");

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class BytesCubeTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight) {
    super(texWidth, texHeight, false);
    this.m_imgDataList = null;
    this.m_texTarget = TextureTarget_1.default.TEXTURE_CUBE;
    this.mipmapEnabled = true;
    this.m_type = TextureProxyType_1.TextureProxyType.BytesCube;
  }

  toAlphaFormat() {
    this.srcFormat = TextureFormat_1.default.ALPHA;
    this.internalFormat = TextureFormat_1.default.ALPHA;
    this.unpackAlignment = 1;
  }

  toRedFormat() {
    this.srcFormat = TextureFormat_1.default.RED;
    this.internalFormat = TextureFormat_1.default.RED;
    this.unpackAlignment = 1;
  }

  toRGBFormat() {
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB;
    this.unpackAlignment = 1;
  }

  toRGBAFormat() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.unpackAlignment = 4;
  }

  setDataFromBytesToFaceAt(index, bytes, pw, ph, miplevel = 0) {
    if (this.m_imgDataList == null) {
      this.m_imgDataList = [null, null, null, null, null, null];
    }

    if (pw > 0 && ph > 0) {
      if (index == 0 && miplevel < 1) {
        this.m_texWidth = pw;
        this.m_texHeight = ph;
        this.m_miplevel = miplevel;
      }

      if (this.m_imgDataList[index] == null) {
        this.m_imgDataList[index] = new Array(16);
      }

      let arr = this.m_imgDataList[index];
      arr[miplevel] = {
        width: pw,
        height: ph,
        imgData: bytes,
        miplevel: miplevel
      };
      this.m_haveRData = arr[miplevel].imgData != null;
    }
  }

  uploadData(texRes) {
    let gl = texRes.getRC();
    let imo = null;
    let width = this.getWidth();
    let height = this.getHeight();
    let pw;
    let ph;

    for (let i = 0; i < 6; ++i) {
      let arr = this.m_imgDataList[i];

      if (this.mipmapEnabled && this.m_generateMipmap) {
        imo = arr[0];
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, TextureFormat_1.default.ToGL(gl, this.internalFormat), width, height, 0, TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), imo.imgData);
      } else {
        pw = width;
        ph = height;
        let j = 0;

        for (; pw > 0 || ph > 0;) {
          if (arr[j] != null) {
            imo = arr[j];
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, TextureFormat_1.default.ToGL(gl, this.internalFormat), pw, ph, 0, TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), imo.imgData);
          }

          if (pw > 0) pw >>= 1;
          if (ph > 0) ph >>= 1;
          ++j;
        }
      }
    }

    this.version = 0;
  }

  toString() {
    return "[BytesCubeTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      this.version = 0;

      if (this.m_imgDataList != null) {
        for (let i = 0; i < 6; ++i) {
          if (this.m_imgDataList[i] != null) {
            this.m_imgDataList[i].imgData = null;
          }
        }
      }

      console.log("BytesCubeTextureProxy::destroy(), destroy a BytesCubeTextureProxy instance...");

      super.__$destroy();
    }
  }

}

exports.default = BytesCubeTextureProxy;

/***/ }),

/***/ "5326":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 本类作为当前 renderer instance 的共享 uniform 数据管理类
 */

class UniformDataSlot {
  constructor(rcuid, total = 256) {
    this.m_total = 256;
    this.m_rcuid = 0;
    /**
     * 记录当前的数据序号，不可随意更改
     */

    this.index = 0;
    this.dataList = null;
    this.flagList = null;
    this.m_rcuid = rcuid;
    this.m_total = total;
    this.flagList = new Uint16Array(this.m_total);
    this.dataList = new Array(this.m_total);

    for (let i = 0; i < this.m_total; ++i) {
      this.dataList[i] = null;
      this.flagList[i] = 0;
    }
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

}

exports.UniformDataSlot = UniformDataSlot;

/***/ }),

/***/ "53d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RenderingState {
  constructor(st) {
    let t = this;
    t.NORMAL_STATE = st.NORMAL_STATE;
    t.BACK_CULLFACE_NORMAL_STATE = st.BACK_CULLFACE_NORMAL_STATE;
    t.FRONT_CULLFACE_NORMAL_STATE = st.FRONT_CULLFACE_NORMAL_STATE;
    t.NONE_CULLFACE_NORMAL_STATE = st.NONE_CULLFACE_NORMAL_STATE;
    t.ALL_CULLFACE_NORMAL_STATE = st.ALL_CULLFACE_NORMAL_STATE;
    t.BACK_NORMAL_ALWAYS_STATE = st.BACK_NORMAL_ALWAYS_STATE;
    t.BACK_TRANSPARENT_STATE = st.BACK_TRANSPARENT_STATE;
    t.BACK_TRANSPARENT_ALWAYS_STATE = st.BACK_TRANSPARENT_ALWAYS_STATE;
    t.NONE_TRANSPARENT_STATE = st.NONE_TRANSPARENT_STATE;
    t.NONE_TRANSPARENT_ALWAYS_STATE = st.NONE_TRANSPARENT_ALWAYS_STATE;
    t.FRONT_CULLFACE_GREATER_STATE = st.FRONT_CULLFACE_GREATER_STATE;
    t.BACK_ADD_BLENDSORT_STATE = st.BACK_ADD_BLENDSORT_STATE;
    t.BACK_ADD_ALWAYS_STATE = st.BACK_ADD_ALWAYS_STATE;
    t.BACK_ALPHA_ADD_ALWAYS_STATE = st.BACK_ALPHA_ADD_ALWAYS_STATE;
    t.NONE_ADD_ALWAYS_STATE = st.NONE_ADD_ALWAYS_STATE;
    t.NONE_ADD_BLENDSORT_STATE = st.NONE_ADD_BLENDSORT_STATE;
    t.NONE_ALPHA_ADD_ALWAYS_STATE = st.NONE_ALPHA_ADD_ALWAYS_STATE;
    t.FRONT_ADD_ALWAYS_STATE = st.FRONT_ADD_ALWAYS_STATE;
    t.FRONT_TRANSPARENT_STATE = st.FRONT_TRANSPARENT_STATE;
    t.FRONT_TRANSPARENT_ALWAYS_STATE = st.FRONT_TRANSPARENT_ALWAYS_STATE;
    t.NONE_CULLFACE_NORMAL_ALWAYS_STATE = st.NONE_CULLFACE_NORMAL_ALWAYS_STATE;
    t.BACK_ALPHA_ADD_BLENDSORT_STATE = st.BACK_ALPHA_ADD_BLENDSORT_STATE;
  }

}

exports.RenderingState = RenderingState;

/***/ }),

/***/ "557f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class Texture3DProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight, tex3DDepth = 1, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_bytes = null;
    this.m_tex3DDepth = 1;
    this.internalFormat = TextureFormat_1.default.R8;
    this.srcFormat = TextureFormat_1.default.RED;
    this.m_tex3DDepth = tex3DDepth;
    this.m_texTarget = TextureTarget_1.default.TEXTURE_3D;
    this.m_type = TextureProxyType_1.TextureProxyType.Texture3D;
    this.unpackAlignment = 1;
  }

  getDepth() {
    return this.m_tex3DDepth;
  }

  uploadFromTypedArray(bytesData, miplevel = 0) {
    if (!this.isGpuEnabled()) {
      this.m_bytes = bytesData;
      this.m_miplevel = miplevel;
      this.m_haveRData = true;
    }
  }

  uploadData(texRes) {
    if (this.m_bytes != null) {
      let gl = texRes.getRC();
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.texImage3D(gl.TEXTURE_3D, // target
      0, // level
      TextureFormat_1.default.ToGL(gl, this.internalFormat), // internalformat,DEFAULT: gl.R8
      this.m_texWidth, // width
      this.m_texHeight, // height
      this.m_tex3DDepth, // depth
      0, // border
      TextureFormat_1.default.ToGL(gl, this.srcFormat), // format,DEFAULT: gl.RED
      gl.UNSIGNED_BYTE, // type
      this.m_bytes // pixels
      );
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    }
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      this.m_bytes = null;
      console.log("Texture3DProxy::destroy(), destroy a Texture3DProxy instance...");

      super.__$destroy();
    }
  }

  toString() {
    return "[Texture3DProxy(width=" + this.getWidth() + ",height=" + this.getHeight() + ",depth=" + this.getDepth() + ")]";
  }

}

exports.default = Texture3DProxy;

/***/ }),

/***/ "56a9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));
/**
 * 正在被渲染的可渲染实体的集合
 */


class RenderingEntitySet {
  constructor() {
    this.m_entities = new Array(2048);
    this.m_total = 0;
    this.m_flag = false;
  }

  query(q) {
    q.query(this.m_entities, this.m_total);
  }

  getTotal() {
    return this.m_total;
  }

  clear() {
    if (this.m_flag) {
      this.m_flag = false;
      let len = this.m_entities.length;
      let ls = this.m_entities;

      for (let i = 0; i < len; ++i) {
        ls[i] = null;
      }

      this.m_total = 0;
    }
  }

  reset(total) {
    this.m_flag = true;

    if (total > this.m_entities.length) {
      total = MathConst_1.default.GetNearestCeilPow2(total);
      this.m_entities = new Array(total);
    }

    this.m_total = 0;
  }

  addEntity(et) {
    this.m_entities[this.m_total++] = et;
  }

}

exports.default = RenderingEntitySet;

/***/ }),

/***/ "56c5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RCExtension_1 = __importDefault(__webpack_require__("030e")); //import RCExtension = RCExtensionT.vox.render.RCExtension;
//import RAdapterContext = RAdapterContextT.vox.render.RAdapterContext;


class RenderFBOProxy {
  static SetRenderer(pr) {
    RenderFBOProxy.m_rc = pr.getRC();
    RenderFBOProxy.m_webGLVer = pr.getWebGLVersion();
    let thisT = RenderFBOProxy;

    if (RenderFBOProxy.m_webGLVer == 1) {
      if (RCExtension_1.default.WEBGL_draw_buffers != null) {
        thisT.COLOR_ATTACHMENT0 = RCExtension_1.default.WEBGL_draw_buffers.COLOR_ATTACHMENT0_WEBGL;
      } else {
        thisT.COLOR_ATTACHMENT0 = RenderFBOProxy.m_rc.COLOR_ATTACHMENT0;
      }
    } else {
      thisT.COLOR_ATTACHMENT0 = RenderFBOProxy.m_rc.COLOR_ATTACHMENT0;
    }
  }

  static DrawBuffers(attachments) {
    if (RenderFBOProxy.m_webGLVer == 2) {
      RenderFBOProxy.m_rc.drawBuffers(attachments);
    } else if (RCExtension_1.default.WEBGL_draw_buffers != null) {
      RCExtension_1.default.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
    }
  }

}

RenderFBOProxy.m_rc = null;
RenderFBOProxy.m_webGLVer = 2;
RenderFBOProxy.COLOR_ATTACHMENT0 = 0x0;
exports.default = RenderFBOProxy;

/***/ }),

/***/ "58fc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "5ab6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const FBXBufferObject_1 = __webpack_require__("8310");

class ElementGeomData {
  constructor() {}

  calcVtxIVS(sivs) {
    //[0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 3, 1, 9, 7, -6, 6, 7, 9, -9, 8, 9, 1, -1, 0, 2, 4, 6, -9]
    // console.log("sivs: ",sivs);
    let s = sivs; //let ivs: number[] = [];

    let step = 0;
    let sivsLen = sivs.length;
    let ivsLen = 0;

    for (let i = 0; i < sivsLen; ++i) {
      step++;

      if (s[i] < 0) {
        if (step == 4) {
          // ivs.push(i - 3, i - 2, i-1);
          // ivs.push(i, i - 3, i-1);
          ivsLen += 6;
        } else if (step == 3) {
          // ivs.push(i - 2, i - 1, i);
          ivsLen += 3;
        } else {
          for (let j = step - 2; j > 0; j--) {
            // ivs.push(i, i - j - 1, i - j);
            ivsLen += 3;
          }
        }

        step = 0;
      }
    }

    let ivs = ivsLen > 65535 ? new Uint32Array(ivsLen) : new Uint16Array(ivsLen);
    let k = 0;

    for (let i = 0; i < sivsLen; ++i) {
      step++;

      if (s[i] < 0) {
        if (step == 4) {
          ivs[k] = i - 3;
          ivs[k + 1] = i - 2;
          ivs[k + 2] = i - 1;
          ivs[k + 3] = i;
          ivs[k + 4] = i - 3;
          ivs[k + 5] = i - 1;
          k += 6; // ivs.push(i - 3, i - 2, i-1);
          // ivs.push(i, i - 3, i-1);
        } else if (step == 3) {
          // ivs.push(i - 2, i - 1, i);
          ivs[k] = i - 2;
          ivs[k + 1] = i - 1;
          ivs[k + 2] = i;
          k += 3;
        } else {
          for (let j = step - 2; j > 0; j--) {
            // ivs.push(i, i - j - 1, i - j);
            ivs[k] = i;
            ivs[k + 1] = i - j - 1;
            ivs[k + 2] = i - j;
            k += 3;
          }
        }

        step = 0;
      }
    }

    return ivs;
  }

  buildBufs(obj, sivs, svs, snvs) {
    let vsLen = sivs.length * 3;
    let nvs = null;
    let ivs = this.calcVtxIVS(sivs);
    let vs = new Float32Array(vsLen);
    let sivsLen = sivs.length;
    let sk = 0;
    let k = 0;

    if (snvs == null || snvs.length == vs.length) {
      if (snvs != null) {
        nvs = new Float32Array(snvs);
      }

      for (let i = 0; i < sivsLen; ++i) {
        k = i * 3;
        sk = sivs[i];
        if (sk < 0) sk = sk * -1 - 1;
        sk *= 3;
        vs[k] = svs[sk];
        vs[k + 1] = svs[sk + 1];
        vs[k + 2] = svs[sk + 2];
        k += 3;
      }
    } else {
      if (snvs != null) {
        nvs = new Float32Array(vsLen);

        for (let i = 0; i < sivsLen; ++i) {
          k = i * 3;
          sk = sivs[i];
          if (sk < 0) sk = sk * -1 - 1;
          sk *= 3;
          vs[k] = svs[sk];
          vs[k + 1] = svs[sk + 1];
          vs[k + 2] = svs[sk + 2];
          nvs[k] = snvs[sk];
          nvs[k + 1] = snvs[sk + 1];
          nvs[k + 2] = snvs[sk + 2];
          k += 3;
        }
      } else {
        for (let i = 0; i < sivsLen; ++i) {
          k = i * 3;
          sk = sivs[i];
          if (sk < 0) sk = sk * -1 - 1;
          sk *= 3;
          vs[k] = svs[sk];
          vs[k + 1] = svs[sk + 1];
          vs[k + 2] = svs[sk + 2];
          k += 3;
        }
      }
    }

    obj.vertex = vs;
    obj.normal = nvs;
    obj.indices = ivs;
  }

  createBufObject(geoInfo) {
    let obj = new FBXBufferObject_1.FBXBufferObject();

    if (geoInfo.normal != null) {
      this.buildBufs(obj, geoInfo.vertexIndices, geoInfo.vertexPositions, geoInfo.normal.buffer);
    } else {
      this.buildBufs(obj, geoInfo.vertexIndices, geoInfo.vertexPositions, null);
      console.error("当前FBX模型法线数据缺失!!!");
    }

    let uvsLen = 2 * obj.vertex.length / 3;
    let uvs = new Float32Array(uvsLen);
    obj.isEntity = true;
    obj.uvs = [uvs];
    return obj;
  }

}

exports.ElementGeomData = ElementGeomData;
;

/***/ }),

/***/ "5b39":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class HttpFileLoader {
  constructor() {
    this.crossOrigin = 'anonymous';
  }

  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
  }

  async load(url, onLoad,
  /**
   * @param progress its value is 0.0 -> 1.0
   */
  onProgress = null, onError = null, responseType = "blob", headRange = "") {
    // console.log("loadBinBuffer, headRange != '': ", headRange != "");
    if (onLoad == null) {
      throw Error("onload == null !!!");
    }

    const reader = new FileReader();

    reader.onload = e => {
      if (onLoad != null) onLoad(reader.result, url);
    };

    const request = new XMLHttpRequest();
    request.open("GET", url, true);

    if (headRange != "") {
      request.setRequestHeader("Range", headRange);
    }

    request.responseType = responseType;

    request.onload = e => {
      // console.log("loaded binary buffer request.status: ", request.status, e);
      if (request.status <= 206) {
        reader.readAsArrayBuffer(request.response);
      } else if (onError != null) {
        onError(request.status, url);
      }
    };

    if (onProgress != null) {
      request.onprogress = evt => {
        // console.log("progress evt: ", evt);
        // console.log("progress total: ", evt.total, ", loaded: ", evt.loaded);
        let k = 0.0;

        if (evt.total > 0 || evt.lengthComputable) {
          k = Math.min(1.0, evt.loaded / evt.total);
        } else {
          let content_length = parseInt(request.getResponseHeader("content-length")); // var encoding = req.getResponseHeader("content-encoding");
          // if (total && encoding && encoding.indexOf("gzip") > -1) {

          if (content_length > 0) {
            // assuming average gzip compression ratio to be 25%
            content_length *= 4; // original size / compressed size

            k = Math.min(1.0, evt.loaded / content_length);
          } else {
            console.warn("lengthComputable failed");
          }
        } //let progressInfo = k + "%";
        //console.log("progress progressInfo: ", progressInfo);			


        onProgress(k, url);
      };
    }

    if (onError != null) {
      request.onerror = e => {
        console.error("load error, request.status: ", request.status, ", url: ", url);
        onError(request.status, url);
      };
    }

    request.send(null);
  }

}

exports.HttpFileLoader = HttpFileLoader;

/***/ }),

/***/ "5d04":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TexturePool_1 = __importDefault(__webpack_require__("4cf7"));

const ImageTextureProxy_1 = __importDefault(__webpack_require__("5e78"));

const BytesTextureProxy_1 = __importDefault(__webpack_require__("fe7f"));

const Uint16TextureProxy_1 = __importDefault(__webpack_require__("9f3e"));

const FloatTextureProxy_1 = __importDefault(__webpack_require__("f928"));

const FloatCubeTextureProxy_1 = __importDefault(__webpack_require__("eaee"));

const BytesCubeTextureProxy_1 = __importDefault(__webpack_require__("52e0"));

const ImageCubeTextureProxy_1 = __importDefault(__webpack_require__("d314"));

const Texture3DProxy_1 = __importDefault(__webpack_require__("557f"));

const TextureResSlot_1 = __importDefault(__webpack_require__("da6a"));

const RTTTextureStore_1 = __webpack_require__("ccdf");
/**
 * 本类作为所有基础纹理对象的管理类,只允许在RendererInstance之上的类中使用
 */


class TextureBlock {
  constructor() {
    this.m_texPool = new TexturePool_1.default();
    this.m_rttStore = null;
    this.m_renderProxy = null;
    this.m_texLoaders = [];
    this.m_clearDelay = 128;
  }

  addTexLoader(texLoader) {
    if (texLoader != null) {
      let i = 0;
      let il = this.m_texLoaders.length;

      for (; i < il; ++i) {
        if (texLoader == this.m_texLoaders[i]) {
          break;
        }
      }

      if (i >= il) {
        this.m_texLoaders.push(texLoader);
      }
    }
  }

  removeTexLoader(texLoader) {
    if (texLoader != null) {
      let i = 0;
      let il = this.m_texLoaders.length;

      for (; i < il; ++i) {
        if (texLoader == this.m_texLoaders[i]) {
          this.m_texLoaders.slice(i, 1);
          break;
        }
      }
    }
  }
  /**
   * 设置当前的渲染器
   * @param renderProxy 当前的渲染器
   */


  setRenderer(renderProxy) {
    this.m_renderProxy = renderProxy;
    TextureResSlot_1.default.GetInstance().setRenderProxy(renderProxy);

    if (this.m_rttStore == null && renderProxy != null) {
      this.m_rttStore = new RTTTextureStore_1.RTTTextureStore(renderProxy);
    }
  }

  getRTTStrore() {
    return this.m_rttStore;
  }

  createWrapperTex(pw, ph, powerof2Boo = false) {
    return this.m_rttStore.createWrapperTex(pw, ph, powerof2Boo);
  }

  createRTTTex2D(pw, ph, powerof2Boo = false) {
    let tex = this.m_rttStore.createRTTTex2D(pw, ph, powerof2Boo);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createImageTex2D(pw, ph, powerof2Boo = false) {
    let tex = this.m_texPool.getTexture(TextureProxyType_1.TextureProxyType.Image);

    if (tex == null) {
      tex = new ImageTextureProxy_1.default(pw, ph, powerof2Boo);
    }

    tex.__$setRenderProxy(this.m_renderProxy);

    tex.mipmapEnabled = true;
    tex.setWrap(TextureConst_1.default.WRAP_REPEAT);
    return tex;
  }

  createHalfFloatTex2D(pw, ph, powerof2Boo = false) {
    let tex = this.m_texPool.getTexture(TextureProxyType_1.TextureProxyType.Float);

    if (tex == null) {
      tex = new FloatTextureProxy_1.default(pw, ph, powerof2Boo);
    }

    tex.__$setRenderProxy(this.m_renderProxy);

    tex.srcFormat = TextureFormat_1.default.RGBA;
    tex.dataType = TextureDataType_1.default.HALF_FLOAT_OES; //tex.srcFormat = TextureFormat.RGBA16F;
    //tex.dataType = TextureDataType.FLOAT;

    return tex;
  }

  createFloatTex2D(pw, ph, powerof2Boo = false) {
    let tex = this.m_texPool.getTexture(TextureProxyType_1.TextureProxyType.Float);

    if (tex == null) {
      tex = new FloatTextureProxy_1.default(pw, ph, powerof2Boo);
    }

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createUint16Tex2D(pw, ph, powerof2Boo = false) {
    return new Uint16TextureProxy_1.default(pw, ph, powerof2Boo);
  }

  createFloatCubeTex(pw, ph, powerof2Boo = false) {
    return new FloatCubeTextureProxy_1.default(pw, ph);
  }

  createBytesTex(texW, texH) {
    let tex = this.m_texPool.getTexture(TextureProxyType_1.TextureProxyType.Bytes);

    if (tex == null) {
      tex = new BytesTextureProxy_1.default(texW, texH);
    }

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createBytesCubeTex(texW, texH) {
    let tex = new BytesCubeTextureProxy_1.default(texW, texH);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createImageCubeTex(texW, texH) {
    let tex = new ImageCubeTextureProxy_1.default(texW, texH);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createTex3D(texW, texH, depth = 1) {
    if (depth < 1) {
      depth = 1;
    }

    let tex = new Texture3DProxy_1.default(texW, texH, depth);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createRGBATex2D(pw, ph, color) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;
    let tot = pw * ph;
    let tex = this.createBytesTex(pw, ph);
    let bytes = new Uint8Array(tot * 4);
    let pr = Math.round(color.r * 255.0);
    let pg = Math.round(color.g * 255.0);
    let pb = Math.round(color.b * 255.0);
    let pa = Math.round(color.a * 255.0);
    let k = 0;
    let fs = [pr, pg, pb, pa];

    for (let i = 0; i < tot; ++i) {
      bytes.set(fs, k);
      k += 4;
    }

    tex.setDataFromBytes(bytes, 0, pw, ph, 0, 0, false);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
    return tex;
  }

  createAlphaTex2D(pw, ph, alpha) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;
    let size = pw * ph;
    let tex = this.createBytesTex(pw, ph);
    tex.toAlphaFormat();
    let bytes = new Uint8Array(size);
    let value = Math.round(alpha * 255.0);
    bytes.fill(value, 0, size);
    tex.setDataFromBytes(bytes, 0, pw, ph, 0, 0, false);

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createAlphaTexBytes2D(pw, ph, bytes) {
    let tex = this.createBytesTex(pw, ph);
    tex.setDataFromBytes(bytes, 0, pw, ph, 0, 0, false);
    tex.toAlphaFormat();

    tex.__$setRenderProxy(this.m_renderProxy);

    return tex;
  }
  /**
   * get a system cube rtt texture
   * @param i rtt texture index in the system
   */


  getCubeRTTTextureAt(i) {
    return this.m_rttStore.getCubeRTTTextureAt(i);
  }

  createCubeRTTTextureAt(i, pw, ph) {
    return this.m_rttStore.createCubeRTTTextureAt(i, pw, ph);
  }

  getRTTTextureAt(i) {
    return this.m_rttStore.getRTTTextureAt(i);
  }

  createRTTTextureAt(i, pw, ph) {
    return this.m_rttStore.createRTTTextureAt(i, pw, ph);
  }

  getDepthTextureAt(i) {
    return this.m_rttStore.getDepthTextureAt(i);
  }

  createDepthTextureAt(i, pw, ph) {
    return this.m_rttStore.createDepthTextureAt(i, pw, ph);
  }

  getRTTFloatTextureAt(i) {
    return this.m_rttStore.getRTTFloatTextureAt(i);
  }

  createRTTFloatTextureAt(i, pw, ph) {
    return this.m_rttStore.createRTTFloatTextureAt(i, pw, ph);
  }

  run() {
    let i = 0;
    let il = this.m_texLoaders.length;

    for (; i < il; ++i) {
      this.m_texLoaders[i].run();
    }

    if (this.m_clearDelay < 1) {
      /**
       * 准备释放回收 texture resource.
       */
      let tex;
      this.m_clearDelay = 128;
      let freeMap = TextureResSlot_1.default.GetInstance().getFreeResUidMap();
      let total = 32;

      for (const [key, value] of freeMap) {
        if (total < 1) {
          break;
        }

        total--;

        if (value > 2) {
          freeMap.delete(key);
          tex = TextureResSlot_1.default.GetInstance().removeTextureByUid(key);

          if (tex != null) {
            this.m_texPool.addTexture(tex);
          } else {
            console.warn("TextureBlock remove a texture(uid=" + key + ") error.");
          }

          console.log("TextureBlock remove a texture: ", tex);
        } else {
          freeMap.set(key, value + 1);
        }
      }
    }

    this.m_clearDelay--;
  }

}

exports.TextureBlock = TextureBlock;

/***/ }),

/***/ "5deb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class TextureTarget {
  static GetValue(rc, param) {
    switch (param) {
      case TextureTarget.TEXTURE_2D:
        return rc.TEXTURE_2D;
        break;

      case TextureTarget.TEXTURE_2D_ARRAY:
        return rc.TEXTURE_2D_ARRAY;
        break;

      case TextureTarget.TEXTURE_CUBE:
        return rc.TEXTURE_CUBE_MAP;
        break;

      case TextureTarget.TEXTURE_3D:
        return rc.TEXTURE_3D;
        break;

      default:
        break;
    }

    return rc.TEXTURE_2D;
  }

}

TextureTarget.TEXTURE_2D = 20;
TextureTarget.TEXTURE_2D_ARRAY = 22;
TextureTarget.TEXTURE_SHADOW_2D = 23;
TextureTarget.TEXTURE_CUBE = 25;
TextureTarget.TEXTURE_3D = 30;
exports.default = TextureTarget;

/***/ }),

/***/ "5e78":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const ImgTexData_1 = __importDefault(__webpack_require__("7181"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class ImageTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_texData = null;
    this.m_texDatas = null;
    this.m_texDatasLen = 0;
    this.mipmapEnabled = true;
    this.minFilter = TextureConst_1.default.LINEAR_MIPMAP_LINEAR;
    this.m_type = TextureProxyType_1.TextureProxyType.Image;
  }

  getTexData() {
    return this.m_texData;
  }
  /**
   * 设置纹理原始数据，可以对纹理局部或者整体(rebuild = true)更新
   * @param img value from: ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap
   * @param miplevel mipmaps level
  */


  setDataFromImage(img, miplevel = 0, offsetx = 0, offsety = 0, rebuild = false) {
    if (img != null && img.width > 0 && img.height > 0) {
      this.m_haveRData = true;
      if (miplevel < 0) miplevel = 0;
      if (miplevel > 15) miplevel = 15;

      if (miplevel >= this.m_texDatasLen) {
        this.m_texDatasLen = miplevel + 1;
      }

      let td = this.m_texData;

      if (td != null) {
        if (this.m_texData.miplevel != miplevel) {
          if (this.m_texDatas == null) {
            this.m_texDatas = [this.m_texData, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
          }

          td = this.m_texDatas[miplevel];

          if (td == null) {
            td = ImgTexData_1.default.Create();
            td.miplevel = miplevel;
            rebuild = true;
            this.m_texDatas[miplevel] = td;
          }
        } else if (this.isGpuEnabled()) {
          td.status = 0;
        }
      } else {
        td = this.m_texData = ImgTexData_1.default.Create();
        td.miplevel = miplevel;
        rebuild = true;
        this.m_texWidth = img.width;
        this.m_texHeight = img.height;
      }

      if (td.data != img || td.offsetx != offsetx || td.offsety != offsety) {
        if (miplevel == 0) {
          this.m_texWidth = img.width;
          this.m_texHeight = img.height;
        }

        td.data = img;
        td.status = 0; // 0表示 更新纹理数据而不会重新开辟空间, 1表示需要重新开辟空间并更新纹理数据, -1表示不需要更新

        if (td.width < img.width || td.height < img.height || rebuild) {
          td.width = img.width;
          td.height = img.height;
          td.status = 1;
        }

        td.offsetx = offsetx;
        td.offsety = offsety;
      }

      this.version++;
    }
  }

  uploadData(texRes) {
    if (this.m_texData != null) {
      this.dataUploadToGpu(texRes.getRC(), this.m_texData, this.m_texDatas, true);
    }

    this.version = 0;
  }

  __$updateToGpu(texRes) {
    // 这里之所以用这种方式判断，是为了运行时支持多 gpu context
    if (this.version > 0 && texRes.hasResUid(this.getResUid())) {
      if (this.m_texData != null) {
        let gl = texRes.getRC();

        this.__$updateToGpuBegin(texRes);

        this.dataUploadToGpu(gl, this.m_texData, this.m_texDatas);

        this.__$buildParam(gl);

        this.m_generateMipmap = true;
      }
    }
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      this.version = 0;

      if (this.m_texDatas != null) {
        for (let i = 0; i < this.m_texDatasLen; ++i) {
          ImgTexData_1.default.Restore(this.m_texDatas[i]);
        }

        this.m_texDatasLen = 0;
        this.m_texDatas = null;
        this.m_texData = null;
      }

      if (this.m_texData != null) {
        ImgTexData_1.default.Restore(this.m_texData);
        this.m_texData = null;
      }

      super.__$destroy();
    }
  }

  toString() {
    return "[ImageTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = ImageTextureProxy;

/***/ }),

/***/ "5f3c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 用于对 RPOBlock 进行必要的组织, 例如 合批或者按照 shader不同来分类, 以及依据其他机制分类等等
// 目前一个block内的所有node 所使用的shader program 是相同的

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const RPONodeLinker_1 = __importDefault(__webpack_require__("df9d"));

const RenderColorMask_1 = __webpack_require__("070b");

const RenderStateObject_1 = __webpack_require__("a5ba"); //import DebugFlag from "../debug/DebugFlag";


class RPOBlock {
  constructor(shader) {
    this.m_uid = -1; // 用于唯一记录运行时的自己(RPOBlock实例)唯一id

    this.m_nodeLinker = new RPONodeLinker_1.default();
    this.m_shader = null;
    this.index = -1; // 记录自身在 RenderProcess blocks数组中的序号

    this.shdUid = -1; // 记录 material 对应的 shader program uid

    this.procuid = -1;
    this.batchEnabled = true;
    this.fixedState = true;
    this.runMode = 0;
    this.rpoNodeBuilder = null;
    this.rpoUnitBuilder = null;
    this.vtxResource = null;
    this.m_shader = shader;
    this.m_uid = RPOBlock.s_uid++;
  }

  showInfo() {
    this.m_nodeLinker.showInfo();
  }

  addNode(node) {
    this.m_nodeLinker.addNodeAndSort(node);
  }

  rejoinNode(node) {
    if (this.m_nodeLinker.containsNode(node)) {
      this.m_nodeLinker.removeNodeAndSort(node);
      this.m_nodeLinker.addNodeAndSort(node);
    }
  }

  removeNode(node) {
    this.m_nodeLinker.removeNodeAndSort(node);
  }

  isEmpty() {
    return this.m_nodeLinker.getBegin() == null;
  }

  run(rc) {
    switch (this.runMode) {
      case 2:
        this.run2(rc);
        break;

      case 1:
        this.run1(rc);
        break;

      case 0:
        this.run0(rc);
        break;

      default:
        break;
    }
  }

  run0(rc) {
    let nextNode = this.m_nodeLinker.getBegin();

    if (nextNode != null) {
      this.m_shader.bindToGpu(this.shdUid);
      this.m_shader.resetUniform();
      let unit = null;

      while (nextNode != null) {
        if (nextNode.drawEnabled) {
          unit = nextNode.unit;

          if (unit.drawEnabled) {
            unit.run(rc);

            if (unit.partTotal < 1) {
              unit.drawThis(rc);
            } else {
              unit.drawPart(rc);
            }
          }
        }

        nextNode = nextNode.next;
      }
    }
  }

  run1(rc) {
    let nextNode = this.m_nodeLinker.getBegin();

    if (nextNode != null) {
      this.m_shader.bindToGpu(this.shdUid);
      this.m_shader.resetUniform();
      let unit = null;
      let vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
      let texTotal = this.m_nodeLinker.getTexTotalAt(nextNode.rtroI);
      let vtxFlag = vtxTotal > 0;
      let texFlag = texTotal > 0; //console.log("run1",vtxFlag,texFlag);

      while (nextNode != null) {
        if (vtxTotal < 1) {
          vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
          vtxFlag = true;
        }

        vtxTotal--;

        if (texTotal < 1) {
          texTotal = this.m_nodeLinker.getTexTotalAt(nextNode.rtroI);
          texFlag = true;
        }

        texTotal--; // if(DebugFlag.Flag_0 > 0) console.log("nextNode.drawEnabled: ",nextNode.drawEnabled);

        if (nextNode.drawEnabled) {
          unit = nextNode.unit; // if(DebugFlag.Flag_0 > 0) console.log("unit.drawEnabled: ",unit.drawEnabled);

          if (unit.drawEnabled) {
            if (vtxFlag) {
              nextNode.vro.run();
              vtxFlag = false;
            }

            if (texFlag) {
              nextNode.tro.run();
              texFlag = false;
            }

            unit.run2(rc);

            if (unit.partTotal < 1) {
              unit.drawThis(rc);
            } else {
              unit.drawPart(rc);
            }
          }
        }

        nextNode = nextNode.next;
      }
    }
  }

  run2(rc) {
    let nextNode = this.m_nodeLinker.getBegin();

    if (nextNode != null) {
      this.m_shader.bindToGpu(this.shdUid);
      this.m_shader.resetUniform();
      let unit = null;
      RenderStateObject_1.RenderStateObject.UseRenderState(nextNode.unit.renderState);
      RenderColorMask_1.RenderColorMask.UseRenderState(nextNode.unit.rcolorMask);
      let vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
      let texTotal = this.m_nodeLinker.getTexTotalAt(nextNode.rtroI);
      let vtxFlag = vtxTotal > 0;
      let texFlag = texTotal > 0;

      while (nextNode != null) {
        if (vtxTotal < 0) {
          vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
          vtxFlag = true;
        }

        vtxTotal--;

        if (texTotal < 0) {
          texTotal = this.m_nodeLinker.getTexTotalAt(nextNode.rtroI);
          texFlag = true;
        }

        texTotal--;

        if (nextNode.drawEnabled) {
          unit = nextNode.unit;

          if (unit.drawEnabled) {
            if (vtxFlag) {
              nextNode.vro.run();
              vtxFlag = false;
            }

            if (texFlag) {
              nextNode.tro.run();
              texFlag = false;
            }

            if (unit.ubo != null) {
              unit.ubo.run(rc);
            }

            this.m_shader.useTransUniform(unit.transUniform);
            this.m_shader.useUniform(unit.uniform);

            if (unit.partTotal < 1) {
              unit.drawThis(rc);
            } else {
              unit.drawPart(rc);
            }
          }
        }

        nextNode = nextNode.next;
      }
    }
  }

  runLockMaterial(rc) {
    let nextNode = this.m_nodeLinker.getBegin();

    if (nextNode != null) {
      this.m_shader.bindToGpu(this.shdUid);
      this.m_shader.resetUniform();
      let texUnlock = this.m_shader.isTextureUnLocked();
      rc.Texture.unlocked = texUnlock;
      let unit = null;

      if (this.batchEnabled) {
        let vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
        let vtxFlag = vtxTotal > 0;

        while (nextNode != null) {
          if (vtxTotal < 1) {
            vtxTotal = this.m_nodeLinker.getVtxTotalAt(nextNode.rvroI);
            vtxFlag = true;
          }

          vtxTotal--;
          unit = nextNode.unit;

          if (nextNode.drawEnabled && unit.drawEnabled) {
            if (vtxFlag) {
              nextNode.vro.run();
              vtxFlag = false;
            }

            if (texUnlock) {
              nextNode.tro.run();
            }

            unit.runLockMaterial2(null);

            if (unit.partTotal < 1) {
              unit.drawThis(rc);
            } else {
              unit.drawPart(rc);
            }
          }

          nextNode = nextNode.next;
        }
      } else {
        while (nextNode != null) {
          unit = nextNode.unit;

          if (nextNode.drawEnabled && unit.drawEnabled) {
            unit.runLockMaterial();

            if (texUnlock) {
              nextNode.tro.run();
            }

            if (unit.partTotal < 1) {
              unit.drawThis(rc);
            } else {
              unit.drawPart(rc);
            }
          }

          nextNode = nextNode.next;
        }
      }

      rc.Texture.unlocked = false;
    }
  } // 在锁定material的时候,直接绘制单个unit


  drawUnit(rc, unit, disp) {
    if (unit.drawEnabled) {
      this.m_shader.bindToGpu(unit.shdUid);
      unit.run(rc);

      if (unit.partTotal < 1) {
        unit.drawThis(rc);
      } else {
        unit.drawPart(rc);
      }
    }
  } // 在锁定material的时候,直接绘制单个unit


  drawLockMaterialByUnit(rc, unit, disp, useGlobalUniform, forceUpdateUniform) {
    if (unit.drawEnabled) {
      if (forceUpdateUniform) {
        this.m_shader.resetUniform();
      } // console.log("***8** drawLockMaterialByUnit(), unit: ",unit);


      if (RendererDevice_1.default.IsMobileWeb()) {
        // 如果不这么做，vro和shader attributes没有完全匹配的时候可能在某些设备上会有问题(例如ip6s上无法正常绘制)
        // 注意临时产生的 vro 对象的回收问题
        let vro = this.vtxResource.getVROByResUid(disp.vbuf.getUid(), this.m_shader.getCurrentShd(), true);
        vro.run();
      } else {
        unit.vro.run();
      }

      unit.runLockMaterial2(useGlobalUniform ? this.m_shader.__$globalUniform : null);

      if (unit.partTotal < 1) {
        unit.drawThis(rc);
      } else {
        unit.drawPart(rc);
      }
    }
  }

  reset() {
    let nextNode = this.m_nodeLinker.getBegin();
    let node = null;

    if (nextNode != null) {
      let runit;

      while (nextNode != null) {
        node = nextNode;
        nextNode = nextNode.next;
        this.rpoUnitBuilder.setRPNodeParam(node.__$ruid, this.procuid, -1);
        node.reset();
        runit = node.unit;

        if (this.rpoNodeBuilder.restore(node)) {
          this.rpoUnitBuilder.restore(runit);
        }
      }
    }

    this.index = -1;
    this.shdUid = -1;
    this.procuid = -1;
    this.m_nodeLinker.clear();
    this.rpoNodeBuilder = null;
    this.rpoUnitBuilder = null;
    this.vtxResource = null;
  }

  destroy() {
    this.reset();
  }

  getUid() {
    return this.m_uid;
  }

  toString() {
    return "[RPOBlock(uid = " + this.m_uid + ", index = " + this.index + ", shdUid = " + this.shdUid + ")]";
  }

}

RPOBlock.s_uid = 0;
exports.default = RPOBlock;

/***/ }),

/***/ "60cd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * TaskDataRouter 参数对象
 */

class TDRParam {
  constructor(ptaskclass, pcmd, ptaskCmd, pthreadIndex) {
    this.status = 0;
    this.taskclass = ptaskclass;
    this.cmd = pcmd;
    this.taskCmd = ptaskCmd;
    this.threadIndex = pthreadIndex;
  }

}

exports.TDRParam = TDRParam;

/***/ }),

/***/ "63fb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadCodeSrcType_1 = __webpack_require__("d2d9");

class TaskRegister {
  constructor() {
    this.m_taskTotal = 0;
    this.m_map = new Map();
  }

  getTaskClassByKeyuns(keyuns) {
    if (this.m_map.has(keyuns)) {
      return this.m_map.get(keyuns);
    }

    return -1;
  }

  hasKeyuns(keyuns) {
    return this.m_map.has(keyuns);
  }

  buildTaskInfo(des) {
    let keyuns = des.moduleName;

    switch (des.type) {
      case ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE:
        keyuns = des.src;
        break;

      case ThreadCodeSrcType_1.ThreadCodeSrcType.DEPENDENCY:
        keyuns = des.src;
        break;

      default:
        break;
    }

    let i = -1;

    if (keyuns != "") {
      if (this.m_map.has(keyuns)) {
        i = this.m_map.get(keyuns);
      } else {
        i = this.m_taskTotal++;
        this.m_map.set(keyuns, i);
      }
    } else {
      console.error("keyuns's value is empty!!!");
    }

    des.info = {
      taskClass: i,
      keyuns: keyuns
    };
  }

}

exports.TaskRegister = TaskRegister;

/***/ }),

/***/ "644c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class MaterialConst {
  static GetTypeByTypeNS(tns) {
    const mc = MaterialConst;

    switch (tns) {
      case "mat4":
        return mc.SHADER_MAT4;
        break;

      case "mat3":
        return mc.SHADER_MAT3;
        break;

      case "mat2":
        return mc.SHADER_MAT2;
        break;

      case "float":
        return mc.SHADER_FLOAT;
        break;

      case "int":
        return mc.SHADER_INT;
        break;

      case "vec4":
        return mc.SHADER_VEC4;
        break;

      case "vec3":
        return mc.SHADER_VEC3;
        break;

      case "vec2":
        return mc.SHADER_VEC2;
        break;

      case "vec4[]":
        return mc.SHADER_VEC4FV;
        break;

      case "vec3[]":
        return mc.SHADER_VEC3FV;
        break;

      case "vec2[]":
        return mc.SHADER_VEC2FV;
        break;

      case "sampler2D":
        return mc.SHADER_SAMPLER2D;
        break;

      case "sampler3D":
        return mc.SHADER_SAMPLER3D;
        break;

      case "samplerCube":
        return mc.SHADER_SAMPLERCUBE;
        break;

      default:
        break;
    }

    return MaterialConst.SHADER_UNDEFINED;
  }

  static GetTypeNSByType(type) {
    const mc = MaterialConst;

    switch (type) {
      case mc.SHADER_MAT4:
        return "mat4";
        break;

      case mc.SHADER_MAT3:
        return "mat3";
        break;

      case mc.SHADER_MAT2:
        return "mat2";
        break;

      case mc.SHADER_FLOAT:
        return "float";
        break;

      case mc.SHADER_VEC4:
        return "vec4";

      case mc.SHADER_VEC3:
        return "vec3";
        break;

      case mc.SHADER_VEC2:
        return "vec2";
        break;

      case mc.SHADER_SAMPLER2D:
        return "sampler2D";
        break;

      case mc.SHADER_SAMPLER3D:
        return "sampler3D";
        break;

      case mc.SHADER_SAMPLERCUBE:
        return "samplerCube";
        break;

      case mc.SHADER_UNDEFINED:
        return "undefined";
        break;

      default:
        break;
    }

    return "";
  }

} // for glsl shader auto build


MaterialConst.ATTRINS_VTX_VS = "a_vs";
MaterialConst.ATTRINS_VTX_UVS = "a_uvs";
MaterialConst.ATTRINS_VTX_NVS = "a_nvs";
MaterialConst.ATTRINS_VTX_CVS = "a_cvs"; //

MaterialConst.UNIFORMNS_OBJ_MAT_NS = "u_objMat";
MaterialConst.UNIFORMNS_VIEW_MAT_NS = "u_viewMat";
MaterialConst.UNIFORMNS_PROJ_MAT_NS = "u_projMat"; // 取值范围3001(包括3001) 到 3255(包括3255)

MaterialConst.SHADER_UNDEFINED = 3010;
MaterialConst.SHADER_VEC2 = 3011;
MaterialConst.SHADER_VEC3 = 3012;
MaterialConst.SHADER_VEC4 = 3013;
MaterialConst.SHADER_VEC2FV = 3014;
MaterialConst.SHADER_VEC3FV = 3015;
MaterialConst.SHADER_VEC4FV = 3016;
MaterialConst.SHADER_MAT2 = 3017;
MaterialConst.SHADER_MAT3 = 3018;
MaterialConst.SHADER_MAT4 = 3019;
MaterialConst.SHADER_FLOAT = 3020;
MaterialConst.SHADER_INT = 3021;
MaterialConst.SHADER_MAT2FV = 3022;
MaterialConst.SHADER_MAT3FV = 3023;
MaterialConst.SHADER_MAT4FV = 3024;
MaterialConst.SHADER_SAMPLER2D = 3031;
MaterialConst.SHADER_SAMPLERCUBE = 3032;
MaterialConst.SHADER_SAMPLER3D = 3033;
MaterialConst.SHADER_PRECISION_LOWP = 3101;
MaterialConst.SHADER_PRECISION_MEDIUMP = 3111;
MaterialConst.SHADER_PRECISION_HIGHP = 3121; // texture uniform name define

MaterialConst.UNIFORM_TEX_SAMPLER2D = "sampler2D";
MaterialConst.UNIFORM_TEX_SAMPLERCUBE = "samplerCube";
MaterialConst.UNIFORM_TEX_SAMPLER3D = "sampler3D";
MaterialConst.UNIFORMNS_TEX_SAMPLER_0 = "u_sampler0";
MaterialConst.UNIFORMNS_TEX_SAMPLER_1 = "u_sampler1";
MaterialConst.UNIFORMNS_TEX_SAMPLER_2 = "u_sampler2";
MaterialConst.UNIFORMNS_TEX_SAMPLER_3 = "u_sampler3";
MaterialConst.UNIFORMNS_TEX_SAMPLER_4 = "u_sampler4";
MaterialConst.UNIFORMNS_TEX_SAMPLER_5 = "u_sampler5";
MaterialConst.UNIFORMNS_TEX_SAMPLER_6 = "u_sampler6";
MaterialConst.UNIFORMNS_TEX_SAMPLER_7 = "u_sampler7";
MaterialConst.UNIFORMNS_TEX_SAMPLER_LIST = [MaterialConst.UNIFORMNS_TEX_SAMPLER_0, MaterialConst.UNIFORMNS_TEX_SAMPLER_1, MaterialConst.UNIFORMNS_TEX_SAMPLER_2, MaterialConst.UNIFORMNS_TEX_SAMPLER_3, MaterialConst.UNIFORMNS_TEX_SAMPLER_4, MaterialConst.UNIFORMNS_TEX_SAMPLER_5, MaterialConst.UNIFORMNS_TEX_SAMPLER_6, MaterialConst.UNIFORMNS_TEX_SAMPLER_7];
exports.default = MaterialConst;

/***/ }),

/***/ "670e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ROVertexRes_1 = __webpack_require__("45db");

const ROIndicesRes_1 = __webpack_require__("8ae4");

class GpuVtxObject {
  constructor() {
    this.version = -1; // wait del times

    this.waitDelTimes = 0; // renderer context unique id

    this.rcuid = 0; // texture resource unique id

    this.resUid = 0;
    this.vertex = new ROVertexRes_1.ROVertexRes();
    this.indices = new ROIndicesRes_1.ROIndicesRes();
    this.m_attachCount = 0;
  }

  __$attachThis() {
    ++this.m_attachCount; //console.log("GpuVtxObject::__$attachThis() this.m_attachCount: "+this.m_attachCount);
  }

  __$detachThis() {
    --this.m_attachCount; //console.log("GpuVtxObject::__$detachThis() this.m_attachCount: "+this.m_attachCount);

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0;
      console.log("GpuVtxObject::__$detachThis() this.m_attachCount value is 0."); // do something
    }
  }

  getAttachCount() {
    return this.m_attachCount;
  }

  createVRO(rc, shdp, vaoEnabled) {
    let vro = this.vertex.createVRO(rc, shdp, vaoEnabled, this.indices, this.indices.getUid()); //vro.ibuf = this.indices.getGpuBuf();

    vro.ibufStep = this.indices.ibufStep;
    return vro;
  }

  updateToGpu(rc) {
    this.indices.updateToGpu(rc);
    this.vertex.updateToGpu(rc);
  }

  destroy(rc) {
    if (this.getAttachCount() < 1 && this.resUid >= 0) {
      this.vertex.destroy(rc);
      this.indices.destroy(rc);
      this.resUid = -1;
    }
  }

}

exports.GpuVtxObject = GpuVtxObject;

/***/ }),

/***/ "68aa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RawTexData {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.data = null;
    this.miplevel = 0; // 0表示 更新纹理数据而不会重新开辟空间, 1表示需要重新开辟空间并更新纹理数据, -1表示不需要更新

    this.status = 1;
    this.offsetx = 0;
    this.offsety = 0;
  }

  updateToGpu(gl, samplerTarget, interType, format, type, force) {
    if (this.status == 1 || force) {
      gl.texImage2D(samplerTarget, this.miplevel, interType, this.width, this.height, 0, format, type, this.data);
    } else if (this.status == 0) {
      gl.texSubImage2D(samplerTarget, this.miplevel, this.offsetx, this.offsety, this.width, this.height, format, type, this.data);
    }

    this.status = -1;
  }

  static Create() {
    if (RawTexData.s_list.length > 0) {
      return RawTexData.s_list.pop();
    }

    return new RawTexData();
  }

  static Restore(tsd) {
    if (tsd != null) {
      tsd.data = null;
      RawTexData.s_list.push(tsd);
    }
  }

}

RawTexData.s_list = [];
exports.default = RawTexData;

/***/ }),

/***/ "698b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 表示数据所处的阶段, 当数据由网路载入到 gpu 则 其phase = PHASE_NET | PHASE_CPU | PHASE_GPU
 */

class DataPhaseFlag {
  static clearAllPhase(phaseFlag = 0) {
    return DataPhaseFlag.PHASE_NONE;
  }

  static addNetPhase(phaseFlag) {
    return DataPhaseFlag.PHASE_NET | phaseFlag;
  }

  static addCpuPhase(phaseFlag) {
    return DataPhaseFlag.PHASE_CPU | phaseFlag;
  }

  static addGpuPhase(phaseFlag) {
    return DataPhaseFlag.PHASE_GPU | phaseFlag;
  }

  static removeNetPhase(phaseFlag) {
    return ~DataPhaseFlag.PHASE_NET & phaseFlag;
  }

  static removeCpuPhase(phaseFlag) {
    return ~DataPhaseFlag.PHASE_CPU & phaseFlag;
  }

  static removeGpuPhase(phaseFlag) {
    return ~DataPhaseFlag.PHASE_GPU & phaseFlag;
  }

  static isNonePhase(phaseFlag) {
    return DataPhaseFlag.PHASE_NONE == phaseFlag;
  }

  static isNetPhase(phaseFlag) {
    return (DataPhaseFlag.PHASE_NET & phaseFlag) == DataPhaseFlag.PHASE_NET;
  }

  static isCpuPhase(phaseFlag) {
    return (DataPhaseFlag.PHASE_CPU & phaseFlag) == DataPhaseFlag.PHASE_CPU;
  }

  static isGpuPhase(phaseFlag) {
    return (DataPhaseFlag.PHASE_GPU & phaseFlag) == DataPhaseFlag.PHASE_GPU;
  }

}
/**
 * 表示处于未定义的情况
 */


DataPhaseFlag.PHASE_NONE = 0;
/**
 * 表示数据处于网路请求的阶段
 */

DataPhaseFlag.PHASE_NET = 1 << 2;
/**
 * 表示数据处于cpu阶段
 */

DataPhaseFlag.PHASE_CPU = 1 << 3;
/**
 * 表示数据处于gpu阶段
 */

DataPhaseFlag.PHASE_GPU = 1 << 4;
exports.DataPhaseFlag = DataPhaseFlag;

/***/ }),

/***/ "6d49":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const FrameBufferType_1 = __importDefault(__webpack_require__("baae"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const RenderFBOProxy_1 = __importDefault(__webpack_require__("56c5"));

class FrameBufferObject {
  constructor(rcuid, texResource, frameBufType) {
    this.m_uid = -1; // renderer context unique id

    this.m_rcuid = 0;
    this.m_COLOR_ATTACHMENT0 = 0x0;
    this.m_fbo = null;
    this.m_depthStencilRBO = null;
    this.m_depthRBO = null;
    this.m_colorRBO = null;
    this.m_width = 512;
    this.m_height = 512;
    this.m_bufferLType = 0;
    this.m_gl = null;
    this.m_fboTarget = 0;
    this.m_texTargetTypes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.m_attachmentMaskList = [true, true, true, true, true, true, true, true];
    this.m_preAttachTotal = 0;
    this.m_preAttachIndex = 0;
    this.m_activeAttachmentTotal = 0;
    this.m_attachmentIndex = 0;
    this.m_clearDepthArr = new Float32Array(1);
    this.m_clearColorArr = new Float32Array(4);
    this.m_stencilValueArr = new Int16Array(4);
    this.m_fboSizeChanged = false;
    this.textureLevel = 0;
    this.sizeFixed = false;
    this.writeDepthEnabled = true;
    this.writeStencilEnabled = false;
    this.multisampleEnabled = false;
    this.multisampleLevel = 0;
    this.m_preAttachments = new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    this.m_preTragets = new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    this.m_preFTIndex = 0;
    this.m_haveDepthTex = false; //invalidateFramebuffer(target, attachments)

    this.m_resizeW = 2;
    this.m_resizeH = 2;
    this.m_rcuid = rcuid;
    this.m_texRes = texResource;
    this.m_bufferLType = frameBufType;
    this.m_uid = FrameBufferObject.s_uid++;
  }

  getUid() {
    return this.m_uid;
  }

  resetAttachmentMask(boo) {
    let i = this.m_attachmentMaskList.length - 1;

    while (i >= 0) {
      this.m_attachmentMaskList[i] = boo;
      --i;
    } //console.log("resetAttachmentMask, this.m_attachmentMaskList: ",this.m_attachmentMaskList);

  }

  setAttachmentMaskAt(index, boo) {
    this.m_attachmentMaskList[index] = boo;
  }

  getActiveAttachmentTotal() {
    return this.m_haveDepthTex ? this.m_activeAttachmentTotal - 1 : this.m_activeAttachmentTotal;
  }

  getAttachmentTotal() {
    return this.m_attachmentMaskList.length;
  }

  bindToBackbuffer(frameBufferType) {
    switch (frameBufferType) {
      case FrameBufferType_1.default.DRAW_FRAMEBUFFER:
        this.m_gl.bindFramebuffer(this.m_gl.DRAW_FRAMEBUFFER, null);
        break;

      case FrameBufferType_1.default.READ_FRAMEBUFFER:
        this.m_gl.indFramebuffer(this.m_gl.READ_FRAMEBUFFER, null);
        break;

      default:
        this.m_gl.bindFramebuffer(this.m_gl.FRAMEBUFFER, null);
    }
  }

  bind(frameBufferType) {
    if (this.m_fbo != null) {
      switch (frameBufferType) {
        case FrameBufferType_1.default.DRAW_FRAMEBUFFER:
          this.m_gl.bindFramebuffer(this.m_gl.DRAW_FRAMEBUFFER, this.m_fbo);
          break;

        case FrameBufferType_1.default.READ_FRAMEBUFFER:
          this.m_gl.bindFramebuffer(this.m_gl.READ_FRAMEBUFFER, this.m_fbo);
          break;

        default:
          this.m_gl.bindFramebuffer(this.m_gl.FRAMEBUFFER, this.m_fbo);
      }
    }
  }

  getFBO() {
    return this.m_fbo;
  }

  getDepthStencilRBO() {
    return this.m_depthStencilRBO;
  }

  getDepthRBO() {
    return this.m_depthRBO;
  }

  getWidth() {
    return this.m_width;
  }

  getHeight() {
    return this.m_height;
  }

  getFramebufferType() {
    return this.m_bufferLType;
  }
  /**
   * bind a texture to fbo attachment by attachment index
   * @param texProxy  IRenderTexture instance
   * @param enableDepth  enable depth buffer yes or no
   * @param enableStencil  enable stencil buffer yes or no
   * @param attachmentIndex  fbo attachment index
   */


  renderToTexAt(rgl, texProxy, attachmentIndex) {
    let inFormat = texProxy != null ? texProxy.internalFormat : -1;
    this.m_gl = rgl;

    if (attachmentIndex == 0) {
      this.m_preFTIndex = 0;
      this.m_haveDepthTex = false; // 注意, 防止多次重复调用的没必要重设

      this.m_gl.bindFramebuffer(this.m_fboTarget, this.m_fbo);

      if (inFormat != TextureFormat_1.default.DEPTH_COMPONENT && inFormat != TextureFormat_1.default.DEPTH_STENCIL) {
        this.m_activeAttachmentTotal = 0;
        this.m_attachmentIndex = 0;
      }
    }

    let targetType = -1;
    let rTex = null; //trace("FrameBufferObject::use(), texProxy != null: "+(texProxy != null));

    if (texProxy != null) {
      targetType = texProxy.getTargetType();
      rTex = this.m_texRes.getGpuBuffer(texProxy.getResUid());
      texProxy.uploadFromFbo(this.m_texRes, this.m_width, this.m_height);
    } else {
      targetType = this.m_texTargetTypes[this.m_activeAttachmentTotal];
    }

    this.framebufferTextureBind(rgl, targetType, inFormat, rTex);
  }

  glFramebufferTex2D(attachment, rTex) {
    let rgl = this.m_gl;
    rgl.framebufferTexture2D(this.m_fboTarget, attachment, rgl.TEXTURE_2D, rTex, 0);
    this.m_preAttachments[this.m_preFTIndex] = attachment;
    this.m_preTragets[this.m_preFTIndex] = rgl.TEXTURE_2D;
    this.m_preFTIndex++;
  }

  glFramebufferTexCube(attachment, cubeFaceIndex, rTex) {
    let rgl = this.m_gl;
    rgl.framebufferTexture2D(this.m_fboTarget, attachment, rgl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFaceIndex, rTex, 0);
    this.m_preAttachments[this.m_preFTIndex] = attachment;
    this.m_preTragets[this.m_preFTIndex] = rgl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFaceIndex;
    this.m_preFTIndex++;
  }

  framebufferTexture2D(rgl, targetType, inFormat, rTex) {
    let attachment = -1;

    switch (inFormat) {
      case TextureFormat_1.default.DEPTH_COMPONENT:
        this.m_haveDepthTex = true;
        attachment = this.m_gl.DEPTH_ATTACHMENT; //rgl.framebufferTexture2D(this.m_fboTarget, this.m_gl.DEPTH_ATTACHMENT, rgl.TEXTURE_2D, rTex, 0);
        //this.glFramebufferTex2D(this.m_gl.DEPTH_ATTACHMENT, rTex);

        break;

      case TextureFormat_1.default.DEPTH_STENCIL:
        this.m_haveDepthTex = true;
        attachment = this.m_gl.DEPTH_STENCIL_ATTACHMENT; //rgl.framebufferTexture2D(this.m_fboTarget, this.m_gl.DEPTH_STENCIL_ATTACHMENT, rgl.TEXTURE_2D, rTex, 0);
        //this.glFramebufferTex2D(this.m_gl.DEPTH_STENCIL_ATTACHMENT, rTex);

        break;

      default:
        attachment = this.m_COLOR_ATTACHMENT0 + this.m_attachmentIndex;
        /*
        if(this.m_attachmentMaskList[this.m_activeAttachmentTotal])
        {
            
            //rgl.framebufferTexture2D(this.m_fboTarget, this.m_COLOR_ATTACHMENT0 + this.m_attachmentIndex, rgl.TEXTURE_2D, rTex, this.textureLevel);
            this.glFramebufferTex2D(this.m_COLOR_ATTACHMENT0 + this.m_attachmentIndex, rTex);
            ++this.m_attachmentIndex;
            if (rTex != null)
            {
                this.m_texTargetTypes[this.m_activeAttachmentTotal] = targetType;
            }
            else
            {
                this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
            }
        }
        else
        {
            this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
        }
        ++this.m_activeAttachmentTotal;
        //*/

        break;
    }

    if (attachment > 0) {
      if (this.m_attachmentMaskList[this.m_activeAttachmentTotal]) {
        this.glFramebufferTex2D(attachment, rTex);
        ++this.m_attachmentIndex;

        if (rTex != null) {
          this.m_texTargetTypes[this.m_activeAttachmentTotal] = targetType;
        } else {
          this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
        }
      } else {
        this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
      }

      ++this.m_activeAttachmentTotal;
    }
  }

  framebufferTextureBind(rgl, targetType, inFormat, rTex) {
    // current texture attachments
    switch (targetType) {
      case TextureTarget_1.default.TEXTURE_2D:
        this.framebufferTexture2D(rgl, targetType, inFormat, rTex);
        break;

      case TextureTarget_1.default.TEXTURE_CUBE:
        let cubeAttachmentTot = 0;

        for (let i = 0; i < 6; ++i) {
          if (this.m_attachmentMaskList[i]) {
            //rgl.framebufferTexture2D(this.m_fboTarget, this.m_COLOR_ATTACHMENT0 + this.m_attachmentIndex, rgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, rTex, this.textureLevel);
            this.glFramebufferTexCube(this.m_COLOR_ATTACHMENT0 + this.m_attachmentIndex, i, rTex);
            ++this.m_attachmentIndex;

            if (rTex != null) {
              this.m_texTargetTypes[this.m_activeAttachmentTotal + i] = targetType;
            } else {
              this.m_texTargetTypes[this.m_activeAttachmentTotal + i] = 0;
            }

            cubeAttachmentTot++;
          } else {
            this.m_texTargetTypes[this.m_activeAttachmentTotal + i] = 0;
          }
        }

        cubeAttachmentTot = cubeAttachmentTot > 0 ? cubeAttachmentTot : 6;
        this.m_activeAttachmentTotal += cubeAttachmentTot;
        break;

      case TextureTarget_1.default.TEXTURE_SHADOW_2D:
        if (this.m_attachmentMaskList[this.m_activeAttachmentTotal]) {
          //rgl.framebufferTexture2D(this.m_gl.FRAMEBUFFER, this.m_gl.DEPTH_ATTACHMENT, this.m_gl.TEXTURE_2D, rTex, this.textureLevel);
          this.glFramebufferTex2D(this.m_gl.DEPTH_ATTACHMENT, rTex);

          if (rTex != null) {
            this.m_texTargetTypes[this.m_activeAttachmentTotal] = targetType;
          } else {
            this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
          }
        } else {
          this.m_texTargetTypes[this.m_activeAttachmentTotal] = 0;
        }

        ++this.m_activeAttachmentTotal;
        break;

      default:
        break;
    }
  }

  reset() {
    this.m_preAttachTotal = -1;
    this.m_preAttachIndex = -1;
  }

  use(rgl) {
    this.m_gl = rgl;

    if (this.m_fbo != null) {
      //console.log("this.m_preAttachIndex,this.m_attachmentIndex: ",this.m_preAttachIndex,this.m_attachmentIndex,this.m_activeAttachmentTotal);
      if (this.m_activeAttachmentTotal > 1) {
        if (this.m_preAttachIndex != this.m_attachmentIndex) {
          let attachments = [];
          let i = 0;

          for (; i < this.m_attachmentIndex; ++i) {
            attachments.push(this.m_COLOR_ATTACHMENT0 + i);
          }

          if (this.m_preAttachIndex > this.m_attachmentIndex) {
            for (; i < this.m_preAttachIndex; ++i) {
              this.m_gl.framebufferTexture2D(this.m_fboTarget, this.m_preAttachments[i], this.m_preTragets[i], null, 0);
            }
          } // support webgl2 and webgl1
          //console.log("AAA attachments 0: ",attachments);


          RenderFBOProxy_1.default.DrawBuffers(attachments);
          this.m_preAttachIndex = this.m_attachmentIndex;
        }
      } else if (this.m_preAttachIndex != this.m_attachmentIndex) {
        if (this.m_preAttachIndex > this.m_attachmentIndex) {
          for (let i = 1; i < this.m_preAttachIndex; ++i) {
            this.m_gl.framebufferTexture2D(this.m_fboTarget, this.m_preAttachments[i], this.m_preTragets[i], null, 0);
          }
        }

        let attachments = [this.m_COLOR_ATTACHMENT0]; //console.log("AAA attachments 1: ",attachments);

        RenderFBOProxy_1.default.DrawBuffers(attachments);
        this.m_preAttachIndex = this.m_attachmentIndex;
      }

      this.m_preAttachTotal = this.m_activeAttachmentTotal;
    }
  }

  clearOnlyColor(color4) {
    if (this.m_fbo != null) {
      if (RendererDevice_1.default.IsWebGL2()) {
        this.m_clearColorArr[0] = color4[0];
        this.m_clearColorArr[1] = color4[1];
        this.m_clearColorArr[2] = color4[2];
        this.m_clearColorArr[3] = color4[3];

        if (this.m_preAttachTotal > 1) {
          for (let i = 0; i < this.m_preAttachTotal; ++i) {
            this.m_gl.clearBufferfv(this.m_gl.COLOR, i, this.m_clearColorArr);
          }
        } else {
          this.m_gl.clearBufferfv(this.m_gl.COLOR, 0, this.m_clearColorArr);
        }
      } else {
        this.m_gl.clearColor(color4[0], color4[1], color4[2], color4[3]);
      }
    } //trace("XXXXXXXXXXXXXXXXXXXX FrameBufferObject::clearOnlyColor(), m_fbo: ", m_fbo);

  }

  clearOnlyDepth(depth = 1.0) {
    if (RendererDevice_1.default.IsWebGL2()) {
      this.m_clearDepthArr[0] = depth;
      this.m_gl.clearBufferfv(this.m_gl.DEPTH, 0, this.m_clearDepthArr);
    } else {
      this.m_gl.clearDepth(depth);
    }
  }

  clearOnlyStencil(stencil) {
    this.m_stencilValueArr[0] = stencil;
    this.m_gl.clearBufferuiv(this.m_gl.STENCIL, 0, this.m_stencilValueArr);
  }

  clearOnlyDepthAndStencil(depth, stencil) {
    this.m_gl.clearBufferfi(this.m_gl.DEPTH_STENCIL, 0, depth, stencil);
  }

  invalidateFramebuffer() {} // 一旦这个函数调用，则size的控制权以后都会由这个resize决定


  resize(pw, ph) {
    if (this.m_resizeW != pw || this.m_resizeH != ph) {
      this.m_fboSizeChanged = true;
      this.m_resizeW = pw;
      this.m_resizeH = ph;
    }
  }

  initialize(rgl, pw, ph) {
    this.m_gl = rgl;
    this.m_COLOR_ATTACHMENT0 = RenderFBOProxy_1.default.COLOR_ATTACHMENT0;

    if (this.m_fboSizeChanged) {
      pw = this.m_resizeW;
      ph = this.m_resizeH;
    }

    if (this.m_fbo == null) {
      this.createNewFBO(rgl, pw, ph);
      console.log("FrameBufferObject create a new fbo: ", this);
    } else if (this.m_width != pw || this.m_height != ph) {
      // ready rebuild some new fbo's Renderbuffers.
      this.createNewFBO(rgl, pw, ph);
      console.log("FrameBufferObject ready rebuild another new fbo(" + pw + "," + ph + "): ", this);
    }

    this.m_fboSizeChanged = false;
  }

  isSizeChanged() {
    return this.m_fboSizeChanged;
  }

  destroy(rgl) {
    if (this.m_fbo != null) {
      if (this.m_depthStencilRBO != null) {
        rgl.deleteFramebuffer(this.m_depthStencilRBO);
        this.m_depthStencilRBO = null;
      }

      if (this.m_depthRBO != null) {
        rgl.deleteFramebuffer(this.m_depthRBO);
        this.m_depthRBO = null;
      }

      if (this.m_colorRBO != null) {
        rgl.deleteFramebuffer(this.m_colorRBO);
        this.m_colorRBO = null;
      }

      rgl.deleteFramebuffer(this.m_fbo);
      this.m_fbo = null;
    }

    this.m_gl = null;
    this.m_fboTarget = 0;
    this.m_fboSizeChanged = false;
  } // toString = function()
  // {
  // 	switch (this.m_bufferLType)
  // 	{
  // 	case FrameBufferType.DRAW_FRAMEBUFFER:
  // 		return "[FrameBufferObject(DRAW_FRAMEBUFFER(uid="+this.m_uid+" width="+this.m_width+",height="+this.m_height+")]";
  // 		break;
  // 	case FrameBufferType.READ_FRAMEBUFFER:
  // 		return "[FrameBufferObject(READ_FRAMEBUFFER(uid="+this.m_uid+" width="+this.m_width+",height="+this.m_height+")]";
  // 		break;
  // 	default:
  // 		break;
  // 	}
  // 	return "[FrameBufferObject(FRAMEBUFFER(uid="+this.m_uid+" width="+this.m_width+",height="+this.m_height+")]";
  // }


  buildDepthStencilRBO(rgl, pw, ph) {
    if (this.m_depthStencilRBO == null) this.m_depthStencilRBO = rgl.createRenderbuffer();

    if (this.multisampleEnabled) {
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthStencilRBO);
      rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.DEPTH_STENCIL, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.DEPTH_STENCIL_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthStencilRBO);
      if (this.m_colorRBO == null) this.m_colorRBO = rgl.createRenderbuffer();
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_colorRBO);
      rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.RGBA8, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, this.m_COLOR_ATTACHMENT0, rgl.RENDERBUFFER, this.m_colorRBO);
    } else {
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthStencilRBO);
      rgl.renderbufferStorage(rgl.RENDERBUFFER, rgl.DEPTH_STENCIL, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.DEPTH_STENCIL_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthStencilRBO);
    }
  }

  buildDepthRBO(rgl, pw, ph) {
    if (this.m_depthRBO == null) this.m_depthRBO = rgl.createRenderbuffer();

    if (this.multisampleEnabled) {
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthRBO);
      rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.DEPTH_COMPONENT24, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.DEPTH_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthRBO);
      if (this.m_colorRBO == null) this.m_colorRBO = rgl.createRenderbuffer();
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_colorRBO);
      rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.RGBA8, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, this.m_COLOR_ATTACHMENT0, rgl.RENDERBUFFER, this.m_colorRBO);
    } else {
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthRBO);

      if (RendererDevice_1.default.IsWebGL2()) {
        rgl.renderbufferStorage(rgl.RENDERBUFFER, rgl.DEPTH_COMPONENT24, pw, ph);
      } else {
        console.log("Only use webgl1 depth fbo buffer.");
        rgl.renderbufferStorage(rgl.RENDERBUFFER, rgl.DEPTH_COMPONENT16, pw, ph);
      }

      rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.DEPTH_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthRBO);
    }
  }

  buildStencilRBO(rgl, pw, ph) {
    if (this.m_depthStencilRBO == null) {
      //trace("FrameBufferObject create stencil buf...this.multisampleEnabled: "+this.multisampleEnabled+",this.multisampleLevel:"+this.multisampleLevel);
      if (this.m_depthStencilRBO == null) this.m_depthStencilRBO = rgl.createRenderbuffer();

      if (this.multisampleEnabled) {
        rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthStencilRBO);
        rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.STENCIL_INDEX8, pw, ph);
        rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.STENCIL_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthStencilRBO);
        if (this.m_colorRBO == null) this.m_colorRBO = rgl.createRenderbuffer();
        rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_colorRBO);
        rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.RGBA8, pw, ph);
        rgl.framebufferRenderbuffer(this.m_fboTarget, this.m_COLOR_ATTACHMENT0, rgl.RENDERBUFFER, this.m_colorRBO);
      } else {
        rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_depthStencilRBO);
        rgl.renderbufferStorage(rgl.RENDERBUFFER, rgl.STENCIL_INDEX8, pw, ph);
        rgl.framebufferRenderbuffer(this.m_fboTarget, rgl.STENCIL_ATTACHMENT, rgl.RENDERBUFFER, this.m_depthStencilRBO);
      }
    }
  }

  buildColorRBO(rgl, pw, ph) {
    if (this.multisampleEnabled) {
      if (this.m_colorRBO == null) this.m_colorRBO = rgl.createRenderbuffer();
      rgl.bindRenderbuffer(rgl.RENDERBUFFER, this.m_colorRBO);
      rgl.renderbufferStorageMultisample(rgl.RENDERBUFFER, this.multisampleLevel, rgl.RGBA8, pw, ph);
      rgl.framebufferRenderbuffer(this.m_fboTarget, this.m_COLOR_ATTACHMENT0, rgl.RENDERBUFFER, this.m_colorRBO); //
    }

    console.log("FrameBufferObject create only color buf...this.multisampleEnabled: " + this.multisampleEnabled + ",this.multisampleLevel:" + this.multisampleLevel);
  }

  createNewFBO(rgl, pw, ph) {
    let boo = this.m_fbo == null;
    this.m_preAttachTotal = this.m_activeAttachmentTotal = 0;
    this.m_preAttachIndex = this.m_attachmentIndex = 0;
    this.m_width = pw;
    this.m_height = ph;
    this.m_resizeW = pw;
    this.m_resizeH = ph; //trace("XXXXXXXXXXXXXX ready create framebuf, m_fbo: ", m_fbo);

    if (boo) this.m_fbo = rgl.createFramebuffer(); //trace("XXXXXXXXXXXXXX doing create framebuf, m_fbo: ", m_fbo);

    switch (this.m_bufferLType) {
      case FrameBufferType_1.default.DRAW_FRAMEBUFFER:
        this.m_fboTarget = rgl.DRAW_FRAMEBUFFER; //console.log("create FrameBufferType is DRAW_FRAMEBUFFER.");

        break;

      case FrameBufferType_1.default.READ_FRAMEBUFFER:
        this.m_fboTarget = rgl.READ_FRAMEBUFFER; //console.log("create FrameBufferType is READ_FRAMEBUFFER.");

        break;

      default:
        this.m_fboTarget = rgl.FRAMEBUFFER; //console.log("create FrameBufferType is FRAMEBUFFER.");

        break;
    }

    rgl.bindFramebuffer(this.m_fboTarget, this.m_fbo); //console.log("FrameBufferObject::initialize() writeDepthEnabled: "+this.writeDepthEnabled+", writeDepthEnabled: " , this.writeDepthEnabled+" ,size("+pw + "," ,ph+")");

    if (this.writeDepthEnabled) {
      //trace("FrameBufferObject writeStencilEnabled: " ,this.writeStencilEnabled);
      if (this.writeStencilEnabled) {
        if (this.m_depthStencilRBO == null) {
          //trace("FrameBufferObject create depth and stencil buf...this.multisampleEnabled: "+this.multisampleEnabled+",this.multisampleLevel:"+this.multisampleLevel);
          this.buildDepthStencilRBO(rgl, pw, ph);
        }
      } else {
        this.buildDepthRBO(rgl, pw, ph);
      }
    } else if (this.writeStencilEnabled) {
      this.buildStencilRBO(rgl, pw, ph);
    } else {
      this.buildColorRBO(rgl, pw, ph);
    }

    if (boo) {
      let e = rgl.checkFramebufferStatus(this.m_fboTarget); //trace("XXXXX   XXXXXXXXx Err: "+e+", rgl.FRAMEBUFFER_COMPLETE: "+rgl.FRAMEBUFFER_COMPLETE);

      if (e !== rgl.FRAMEBUFFER_COMPLETE) {
        console.error("FrameBufferObject::createNewFBO(), Error: create failure!!!!");
      } else {
        console.log("FrameBufferObject::createNewFBO(), create success...,size: " + pw + "," + ph);
      }
    }

    FrameBufferObject.BindToBackbuffer(rgl, this.m_bufferLType);
  }

  static BindToBackbuffer(rc, frameBufferType) {
    switch (frameBufferType) {
      case FrameBufferType_1.default.DRAW_FRAMEBUFFER:
        rc.bindFramebuffer(rc.DRAW_FRAMEBUFFER, null);
        break;

      case FrameBufferType_1.default.READ_FRAMEBUFFER:
        rc.indFramebuffer(rc.READ_FRAMEBUFFER, null);
        break;

      default:
        rc.bindFramebuffer(rc.FRAMEBUFFER, null);
        break;
    }
  }

}

FrameBufferObject.s_uid = 0;
exports.default = FrameBufferObject;

/***/ }),

/***/ "6e01":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class MathConst {
  static Clamp(value, min, max) {
    return Math.max(Math.min(value, max), min);
  }

  static IsPowerOf2(value) {
    return (value & value - 1) == 0;
  }

  static CalcCeilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }

  static CalcNearestCeilPow2(int_n) {
    return Math.pow(2, Math.round(Math.log(int_n) / Math.LN2));
  }

  static CalcFloorCeilPow2(int_n) {
    return Math.pow(2, Math.floor(Math.log(int_n) / Math.LN2));
  }

  static DegreeToRadian(degree) {
    return MathConst.MATH_PI_OVER_180 * degree;
  }

  static Log2(f) {
    return Math.log(f) / Math.LN2;
  }

  static GetMaxMipMapLevel(width, height) {
    return Math.round(MathConst.Log2(Math.max(width, height)) + 1);
  }

  static SafeACos(x) {
    if (x <= -1.0) {
      return MathConst.MATH_PI;
    }

    if (x >= 1.0) {
      return 0.0;
    }

    return Math.acos(x);
  }

  static GetNearestCeilPow2(int_n) {
    let x = 1;

    while (x < int_n) {
      x <<= 1;
    }

    return x;
  } // ccw is positive


  static GetMinRadian(a1, a0) {
    a0 %= MathConst.MATH_2PI;
    a1 %= MathConst.MATH_2PI;

    if (a0 < a1) {
      a0 = MathConst.MATH_2PI - a1 + a0;
      if (a0 > MathConst.MATH_PI) return a0 - MathConst.MATH_2PI;
      return a0;
    } else if (a0 > a1) {
      a1 = MathConst.MATH_2PI - a0 + a1;
      if (a1 > MathConst.MATH_PI) return MathConst.MATH_2PI - a1;
      return -a1;
    }

    return 0.0;
  }
  /**
   * get the directional angle offset degree value: dst_angle_degree = src_angle_degree + directional_angle_offset_degree_value
   * @param a0 src angle degree
   * @param a1 dst angle degree
   * @returns directional angle offset degree value
   */


  static GetMinDegree(a0, a1) {
    let angle = 0;

    if (a1 >= 270 && a0 < 90) {
      angle = (a1 - (a0 + 360)) % 180;
    } else if (a1 <= 90 && a0 >= 270) {
      angle = (a1 + 360 - a0) % 180;
    } else {
      angle = a1 - a0; //  if (Math.abs(angle) > 180) {
      //      angle -= 360;
      //  }

      if (angle > 180) {
        angle -= 360;
        angle %= 360;
      } else if (angle < -180) {
        angle += 360;
        angle %= 360;
      }
    }

    return angle;
  }

  static GetDegreeByXY(dx, dy) {
    if (Math.abs(dx) < 0.00001) {
      if (dy >= 0) return 270;else return 90;
    }

    let angle = Math.atan(dy / dx) * 180 / Math.PI;

    if (dx >= 0) {
      return angle;
    } else {
      return 180 + angle;
    } //  if (dy > 0 && dx > 0) {
    //      return angle
    //  } else if (dy < 0 && dx >= 0) {
    //      return 360 + angle;
    //  } else {
    //      return dx > 0 ? angle : 180 + angle;
    //  }

  }

  static GetRadianByXY(dx, dy) {
    if (Math.abs(dx) < MathConst.MATH_MIN_POSITIVE) {
      if (dy >= 0) return MathConst.MATH_1PER2PI;else return MathConst.MATH_3PER2PI;
    }

    let rad = Math.atan(dy / dx);

    if (dx >= 0) {
      return rad;
    } else {
      return MathConst.MATH_PI + rad;
    }
  }

  static GetRadianByCos(cosv, dx, dy) {
    var rad = Math.acos(cosv); //Math.atan(dy/dx);

    if (dx >= 0) {
      return rad;
    } else {
      return MathConst.MATH_PI + rad;
    }
  }

}

MathConst.MATH_MIN_POSITIVE = 1e-5;
MathConst.MATH_MAX_NEGATIVE = -1e-5;
MathConst.MATH_MAX_POSITIVE = 0xffffffe;
MathConst.MATH_MIN_NEGATIVE = -0xffffffe;
MathConst.MATH_1_OVER_255 = 1.0 / 255.0;
MathConst.MATH_PI = Math.PI;
MathConst.MATH_2PI = MathConst.MATH_PI * 2.0;
MathConst.MATH_3PER2PI = MathConst.MATH_PI * 1.5;
MathConst.MATH_1PER2PI = MathConst.MATH_PI * 0.5;
MathConst.MATH_1_OVER_PI = 1.0 / MathConst.MATH_PI;
MathConst.MATH_1_OVER_360 = 1.0 / 360.0;
MathConst.MATH_1_OVER_180 = 1.0 / 180.0;
MathConst.MATH_180_OVER_PI = 180.0 / MathConst.MATH_PI;
MathConst.MATH_PI_OVER_180 = MathConst.MATH_PI / 180.0;
MathConst.MATH_LN2 = 0.6931471805599453;
exports.default = MathConst;

/***/ }),

/***/ "7045":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class KeyboardEvent {
  constructor() {
    // phase is event flow phase: 0(none phase),1(capture phase),2(bubble phase)
    this.phase = 0; // 事件类型

    this.type = KeyboardEvent.KEY_DOWN; // 事件发送者

    this.target = null;
    this.altKey = false;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.repeat = false;
    this.key = "";
    this.keyCode = 0;
    this.location = 0;
  }

  getClassType() {
    return KeyboardEvent.EventClassType;
  }

  toString() {
    return "[KeyboardEvent]";
  }

}

KeyboardEvent.EventClassType = 1003;
KeyboardEvent.KEY_DOWN = 6001;
KeyboardEvent.KEY_UP = 6002;
exports.default = KeyboardEvent;

/***/ }),

/***/ "70f2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 独立的渲染场景子集,也就是子渲染场景类,字渲染场景拥有子集独立的Camera3D对象和view port 区域
// 不同的子场景，甚至可以拥有独立的matrix3D这样的数据池子

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const SubStage3D_1 = __importDefault(__webpack_require__("0236"));

const CameraBase_1 = __importDefault(__webpack_require__("c51d"));

const EntityNodeQueue_1 = __importDefault(__webpack_require__("af68"));

const Entity3DNodeLinker_1 = __importDefault(__webpack_require__("a80a"));

const RendererSpace_1 = __importDefault(__webpack_require__("a446"));

const RaySelector_1 = __importDefault(__webpack_require__("c711"));

const RayGpuSelector_1 = __importDefault(__webpack_require__("955e"));

const MouseEvt3DController_1 = __importDefault(__webpack_require__("765c"));

const FBOInstance_1 = __importDefault(__webpack_require__("af29"));

const RunnableQueue_1 = __importDefault(__webpack_require__("9c4d"));

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

class RendererSubScene {
  constructor(parent, renderer, evtFlowEnabled) {
    this.m_uid = -1;
    this.m_adapter = null;
    this.m_renderProxy = null;
    this.m_rcontext = null;
    this.m_renderer = null;
    this.m_parent = null;
    this.m_processids = new Uint8Array(128);
    this.m_processidsLen = 0;
    this.m_rspace = null;
    this.m_mouse_rltv = new Vector3D_1.default();
    this.m_mouse_rlpv = new Vector3D_1.default();
    this.m_accessor = null; // event flow control enable

    this.m_evtFlowEnabled = false;
    this.m_evt3DCtr = null;
    this.m_mouseEvtEnabled = true;
    this.m_camera = null;
    this.m_viewX = 0.0;
    this.m_viewY = 0.0;
    this.m_viewW = 800.0;
    this.m_viewH = 800.0;
    this.m_nodeWaitLinker = null;
    this.m_nodeWaitQueue = null;
    this.m_perspectiveEnabled = true;
    this.m_rparam = null;
    this.m_stage3D = null;
    this.m_shader = null;
    this.m_runFlag = -1;
    this.m_autoRunning = true;
    this.m_currStage3D = null;
    this.m_enabled = true;
    this.runnableQueue = new RunnableQueue_1.default();
    this.textureBlock = null;
    this.materialBlock = null;
    this.entityBlock = null;
    this.m_containers = [];
    this.m_containersTotal = 0;
    this.m_mouseTestBoo = true;
    this.m_cullingTestBoo = true;
    this.m_rayTestFlag = true;
    this.m_rayTestEnabled = true;
    this.m_prependNodes = null;
    this.m_appendNodes = null;
    this.m_evtFlowEnabled = evtFlowEnabled;
    this.m_parent = parent;
    this.m_renderer = renderer;
    this.m_shader = renderer.getDataBuilder().getRenderShader();
    this.m_uid = 1024 + RendererSubScene.s_uid++;
  }

  enable() {
    this.m_enabled = true;
  }

  disable() {
    this.m_enabled = false;
  }

  isEnabled() {
    return this.m_enabled;
  }

  getUid() {
    return this.m_uid;
  }

  getRPONodeBuilder() {
    return null;
  }

  getRenderProxy() {
    return this.m_renderProxy;
  } // set new view port rectangle area


  setViewPort(px, py, pw, ph) {
    if (this.m_renderProxy != null) {
      this.m_viewX = px;
      this.m_viewY = py;
      this.m_viewW = pw;
      this.m_viewH = ph;
    }
  } // apply new view port rectangle area


  reseizeViewPort() {
    this.m_renderProxy.reseizeRCViewPort();
  }

  getRendererAdapter() {
    return this.m_adapter;
  }

  getRenderer() {
    return this.m_renderer;
  }

  getRendererContext() {
    return this.m_rcontext;
  }

  getStage3D() {
    return this.m_renderProxy.getStage3D();
  }

  getCurrentStage3D() {
    return this.m_currStage3D;
  }

  getViewWidth() {
    return this.m_renderProxy.getStage3D().viewWidth;
  }

  getViewHeight() {
    return this.m_renderProxy.getStage3D().viewHeight;
  }

  getCamera() {
    return this.m_camera;
  }
  /**
   * 获取渲染器可渲染对象管理器状态(版本号)
   */


  getRendererStatus() {
    return this.m_renderer.getRendererStatus();
  }

  getMouseXYWorldRay(rl_position, rl_tv) {
    this.m_camera.getWorldPickingRayByScreenXY(this.m_stage3D.mouseX, this.m_stage3D.mouseY, rl_position, rl_tv);
  }

  createCamera() {
    return new CameraBase_1.default();
  }

  createFBOInstance() {
    return new FBOInstance_1.default(this, this.textureBlock.getRTTStrore());
  }

  createMatrix4() {
    return new Matrix4_1.default();
  }

  createVector3D(x = 0.0, y = 0.0, z = 0.0, w = 1.0) {
    return new Vector3D_1.default(x, y, z, w);
  }

  setEvt3DController(evt3DCtr) {
    if (evt3DCtr != null) {
      if (this.m_currStage3D == null) {
        this.m_currStage3D = new SubStage3D_1.default(this.m_renderProxy.getRCUid(), null);
        this.m_currStage3D.uProbe = this.m_renderProxy.uniformContext.createUniformVec4Probe(1);
      }

      evt3DCtr.initialize(this.getStage3D(), this.m_currStage3D);
      evt3DCtr.setRaySelector(this.m_rspace.getRaySelector());
    }

    this.m_evt3DCtr = evt3DCtr;
  }

  isRayPickSelected() {
    return this.m_evt3DCtr != null && this.m_evt3DCtr.isSelected();
  }

  enableMouseEvent(gpuTestEnabled = true) {
    if (this.m_evt3DCtr == null) {
      if (gpuTestEnabled) {
        this.m_rspace.setRaySelector(new RayGpuSelector_1.default());
      } else {
        this.m_rspace.setRaySelector(new RaySelector_1.default());
      }

      this.setEvt3DController(new MouseEvt3DController_1.default());
    }

    this.m_mouseEvtEnabled = true;
  }

  disableMouseEvent() {
    this.m_mouseEvtEnabled = false;
  }

  getEvt3DController() {
    return this.m_evt3DCtr;
  }

  getSpace() {
    return this.m_rspace;
  }

  getDevicePixelRatio() {
    return this.m_adapter.getDevicePixelRatio();
  }

  addEventListener(type, target, func, captureEnabled = true, bubbleEnabled = false) {
    this.m_currStage3D.addEventListener(type, target, func, captureEnabled, bubbleEnabled);
  }

  removeEventListener(type, target, func) {
    this.m_currStage3D.removeEventListener(type, target, func);
  }

  setAccessor(accessor) {
    this.m_accessor = accessor;
  }

  initialize(rparam, renderProcessesTotal = 3, createNewCamera = true) {
    if (this.m_renderProxy == null) {
      if (renderProcessesTotal < 1) {
        renderProcessesTotal = 1;
      }

      if (renderProcessesTotal > 8) {
        renderProcessesTotal = 8;
      }

      this.m_rparam = rparam;
      this.m_perspectiveEnabled = rparam.cameraPerspectiveEnabled;
      let process = null;

      for (; renderProcessesTotal >= 0;) {
        process = this.m_renderer.appendProcess(rparam.batchEnabled, rparam.processFixedState);
        this.m_processids[this.m_processidsLen] = process.getRPIndex();
        this.m_processidsLen++;
        --renderProcessesTotal;
      }

      this.m_rcontext = this.m_renderer.getRendererContext();
      this.m_renderProxy = this.m_rcontext.getRenderProxy();
      this.m_adapter = this.m_renderProxy.getRenderAdapter();
      this.m_stage3D = this.m_renderProxy.getStage3D();
      this.m_viewX = this.m_stage3D.getViewX();
      this.m_viewY = this.m_stage3D.getViewY();
      this.m_viewW = this.m_stage3D.getViewWidth();
      this.m_viewH = this.m_stage3D.getViewHeight();

      if (createNewCamera) {
        this.createMainCamera();
      } else {
        this.m_camera = this.m_renderProxy.getCamera();
      }

      if (this.m_rspace == null) {
        this.m_rspace = new RendererSpace_1.default();
        this.m_rspace.initialize(this.m_renderer, this.m_camera);
      }
    }
  }

  createMainCamera() {
    this.m_camera = new CameraBase_1.default();
    this.m_camera.setViewXY(this.m_viewX, this.m_viewY);
    this.m_camera.setViewSize(this.m_viewW, this.m_viewH);
    let vec3 = this.m_rparam.camProjParam;

    if (this.m_perspectiveEnabled) {
      this.m_camera.perspectiveRH(MathConst_1.default.DegreeToRadian(vec3.x), this.m_viewW / this.m_viewH, vec3.y, vec3.z);
    } else {
      this.m_camera.orthoRH(vec3.y, vec3.z, -0.5 * this.m_viewH, 0.5 * this.m_viewH, -0.5 * this.m_viewW, 0.5 * this.m_viewW);
    }

    this.m_camera.lookAtRH(this.m_rparam.camPosition, this.m_rparam.camLookAtPos, this.m_rparam.camUpDirect);
    this.m_camera.update();
  }

  cameraLock() {
    this.m_camera.lock();
  }

  cameraUnlock() {
    this.m_camera.unlock();
  }

  updateRenderBufferSize() {
    this.m_adapter.updateRenderBufferSize();
  }

  setRendererProcessParam(index, batchEnabled, processFixedState) {
    this.m_renderer.setRendererProcessParam(this.m_processids[index], batchEnabled, processFixedState);
  }

  appendARendererProcess(batchEnabled = true, processFixedState = false) {
    let process = this.m_renderer.appendProcess(batchEnabled, processFixedState);
    this.m_processids[this.m_processidsLen] = process.getRPIndex();
    this.m_processidsLen++;
  }
  /**
   * get the renderer process by process index
   * @param processIndex IRenderProcess instance index in renderer scene instance
   */


  getRenderProcessAt(processIndex) {
    return this.m_renderer.getProcessAt(this.m_processids[processIndex]);
  }

  addContainer(container, processIndex = 0) {
    if (processIndex < 0) {
      processIndex = 0;
    }

    if (container != null && container.__$wuid < 0 && container.__$contId < 1) {
      let i = 0;

      for (; i < this.m_containersTotal; ++i) {
        if (this.m_containers[i] == container) {
          return;
        }
      }

      if (i >= this.m_containersTotal) {
        container.__$wuid = this.m_uid;
        container.wprocuid = processIndex;

        container.__$setRenderer(this);

        this.m_containers.push(container);
        this.m_containersTotal++;
      }
    }
  }

  removeContainer(container) {
    if (container != null && container.__$wuid == this.m_uid && container.getRenderer() == this.m_renderer) {
      let i = 0;

      for (; i < this.m_containersTotal; ++i) {
        if (this.m_containers[i] == container) {
          container.__$wuid = -1;
          container.wprocuid = -1;

          container.__$setRenderer(null);

          this.m_containers.splice(i, 1);
          --this.m_containersTotal;
          break;
        }
      }
    }
  }

  setAutoRunningEnabled(autoRunning) {
    this.m_autoRunning = autoRunning;
  }
  /**
   * 将已经在渲染运行时中的entity移动到指定 process uid 的 render process 中去
   * move rendering runtime displayEntity to different renderer process
   */


  moveEntityTo(entity, processIndex) {
    this.m_renderer.moveEntityToProcessAt(entity, this.m_processids[processIndex]);
  }
  /**
   * 单独绘制可渲染对象, 可能是使用了 global material也可能没有。这种方式比较耗性能,只能用在特殊的地方。
   * @param entity 需要指定绘制的 IRenderEntity 实例
   * @param useGlobalUniform 是否使用当前 global material 所携带的 uniform, default value: false
   * @param forceUpdateUniform 是否强制更新当前 global material 所对应的 shader program 的 uniform, default value: true
   */


  drawEntity(entity, useGlobalUniform = false, forceUpdateUniform = true) {
    this.m_renderer.drawEntity(entity, useGlobalUniform, forceUpdateUniform);
  }
  /**
   * add an entity to the renderer process of the renderer instance
   * @param entity IRenderEntity instance(for example: DisplayEntity class instance)
   * @param processid this destination renderer process id
   * @param deferred if the value is true,the entity will not to be immediately add to the renderer process by its id
   */


  addEntity(entity, processIndex = 0, deferred = true) {
    if (entity != null && entity.__$testSpaceEnabled()) {
      if (entity.isPolyhedral()) {
        if (entity.hasMesh()) {
          this.m_renderer.addEntity(entity, this.m_processids[processIndex], deferred);

          if (this.m_rspace != null) {
            this.m_rspace.addEntity(entity);
          }
        } else {
          // wait queue
          if (this.m_nodeWaitLinker == null) {
            this.m_nodeWaitLinker = new Entity3DNodeLinker_1.default();
            this.m_nodeWaitQueue = new EntityNodeQueue_1.default();
          }

          let node = this.m_nodeWaitQueue.addEntity(entity);
          node.rstatus = processIndex;
          this.m_nodeWaitLinker.addNode(node);
        }
      } else {
        this.m_renderer.addEntity(entity, this.m_processids[processIndex], deferred);

        if (this.m_rspace != null) {
          this.m_rspace.addEntity(entity);
        }
      }
    }
  } // 这是真正的完全将entity从world中清除


  removeEntity(entity) {
    if (entity != null) {
      let node = null;

      if (this.m_nodeWaitLinker != null) {
        let node = this.m_nodeWaitQueue.getNodeByEntity(entity);

        if (node != null) {
          this.m_nodeWaitLinker.removeNode(node);
          this.m_nodeWaitQueue.removeEntity(entity);
        }
      }

      if (node == null) {
        this.m_renderer.removeEntity(entity);

        if (this.m_rspace != null) {
          this.m_rspace.removeEntity(entity);
        }
      }
    }
  }

  updateMaterialUniformToCurrentShd(material) {
    this.m_renderer.updateMaterialUniformToCurrentShd(material);
  } // 首先要锁定Material才能用这种绘制方式,再者这个entity已经完全加入渲染器了渲染资源已经准备完毕,这种方式比较耗性能，只能用在特殊的地方
  // drawEntityByLockMaterial(entity: IRenderEntity): void {
  //     this.m_renderer.drawEntityByLockMaterial(entity);
  // }


  showInfoAt(index) {
    this.m_renderer.showInfoAt(index);
  }

  updateCameraData(camera) {
    this.m_rcontext.updateCameraDataFromCamera(this.m_renderProxy.getCamera());
  }
  /**
   * the function only resets the renderer instance rendering status.
   * you should use it before the run or runAt function is called.
   */


  renderBegin(contextBeginEnabled = false) {
    if (contextBeginEnabled) {
      this.m_rcontext.renderBegin();
    }

    if (this.m_renderProxy.getCamera() != this.m_camera) {
      //let boo: boolean = this.m_renderProxy.testViewPortChanged(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH);
      if (this.m_renderProxy.isAutoSynViewAndStage()) {
        this.m_viewX = this.m_renderProxy.getViewX();
        this.m_viewY = this.m_renderProxy.getViewY();
        this.m_viewW = this.m_renderProxy.getViewWidth();
        this.m_viewH = this.m_renderProxy.getViewHeight();
      }

      this.m_camera.setViewXY(this.m_viewX, this.m_viewY);
      this.m_camera.setViewSize(this.m_viewW, this.m_viewH);
      this.m_renderProxy.setRCViewPort(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH, this.m_renderProxy.isAutoSynViewAndStage());
      this.m_renderProxy.reseizeRCViewPort();
    }

    this.m_camera.update();
    this.m_rcontext.updateCameraDataFromCamera(this.m_camera);
    this.m_shader.renderBegin();

    if (this.m_accessor != null) {
      this.m_accessor.renderBegin(this);
    }
  }
  /**
   * the function resets the renderer scene status.
   * you should use it on the frame starting time.
   */


  runBegin(autoCycle = true, contextBeginEnabled = false) {
    if (autoCycle && this.m_autoRunning) {
      if (this.m_runFlag >= 0) this.runEnd();
      this.m_runFlag = 0;
    }

    this.renderBegin(contextBeginEnabled);

    if (this.m_rspace != null) {
      //this.m_rspace.setCamera(camFlag ? this.m_renderProxy.getCamera() : this.m_currCamera);
      this.m_rspace.setCamera(this.m_camera);
      this.m_rspace.runBegin();
    }
  }

  setRayTestEanbled(enabled) {
    this.m_rayTestEnabled = enabled;
  }
  /**
   * @param evtFlowPhase  0(none phase),1(capture phase),2(bubble phase)
   * @param status: 1(default process),1(deselect ray pick target)
   * @requires 1 is send evt yes,0 is send evt no,-1 is event nothing
   */


  runMouseTest(evtFlowPhase, status) {
    let flag = -1;

    if (this.m_evt3DCtr != null && this.m_mouseEvtEnabled) {
      if (this.m_rayTestFlag && this.m_evt3DCtr.getEvtType() > 0) {
        // 是否对已经获得的拾取列表做进一步的gpu拾取
        let selector = this.m_rspace.getRaySelector();

        if (selector != null) {
          if (this.m_rayTestEnabled) {
            this.mouseRayTest();
          } else {
            selector.clear();
          } // 如果有gpu拾取则进入这个管理器, 这个管理器得到最终的拾取结果再和前面的计算结果做比较


          let total = selector.getSelectedNodesTotal();

          if (total > 1) {
            let i = 0;
            let list = selector.getSelectedNodes();
            let node = null;

            for (; i < total; ++i) {
              node = list[i];

              if (node.entity.isPolyhedral()) {//this.m_renderer.drawEntityByLockMaterial(node.entity);
              }
            }
          }
        }

        this.m_rayTestFlag = false;
      }

      flag = this.m_evt3DCtr.run(evtFlowPhase, status);
    }

    this.m_mouseTestBoo = false;
    return flag;
  }
  /**
   * update all data or status of the renderer runtime
   * should call this function per frame
   */


  update(autoCycle = true, mouseEventEnabled = true) {
    if (this.m_currStage3D != null) this.m_currStage3D.enterFrame();

    if (autoCycle && this.m_autoRunning) {
      if (this.m_runFlag != 0) this.runBegin();
      this.m_runFlag = 1;
    }

    this.m_mouseTestBoo = true;
    this.m_cullingTestBoo = true;
    this.m_rayTestFlag = true; // wait mesh data ready to finish

    if (this.m_nodeWaitLinker != null) {
      let nextNode = this.m_nodeWaitLinker.getBegin();

      if (nextNode != null) {
        let pnode;
        let entity;
        let status;

        while (nextNode != null) {
          if (nextNode.entity.hasMesh()) {
            pnode = nextNode;
            nextNode = nextNode.next;
            entity = pnode.entity;
            status = pnode.rstatus;
            this.m_nodeWaitLinker.removeNode(pnode);
            this.m_nodeWaitQueue.removeEntity(pnode.entity); //console.log("RenderScene::update(), ready a mesh data that was finished.");

            this.addEntity(entity, status);
          } else {
            nextNode = nextNode.next;
          }
        }
      }
    } //  this.m_renderer.update();


    let i = 0;

    for (; i < this.m_containersTotal; ++i) {
      this.m_containers[i].update();
    } // space update


    if (this.m_rspace != null) {
      this.m_rspace.update();
    }

    if (this.m_rspace != null && this.m_cullingTestBoo) {
      if (this.m_evt3DCtr != null || this.m_rspace.getRaySelector() != null) {
        this.m_rspace.run();
      }
    }

    if (this.m_mouseTestBoo && !this.m_evtFlowEnabled) {
      if (mouseEventEnabled) {
        this.runMouseTest(1, 0);
      } else if (this.m_evt3DCtr != null) {
        this.m_evt3DCtr.mouseOutEventTarget();
      }
    }
  } // 渲染可见性裁剪测试


  cullingTest() {
    if (this.m_rspace != null) {
      this.m_rspace.run();
    }

    this.m_cullingTestBoo = false;
  } // 鼠标位置的射线拾取测试


  mouseRayTest() {
    if (this.m_rspace != null) {
      this.getMouseXYWorldRay(this.m_mouse_rlpv, this.m_mouse_rltv);
      this.m_rspace.rayTest(this.m_mouse_rlpv, this.m_mouse_rltv);
    }
  }

  runRenderNodes(nodes) {
    if (nodes != null) {
      // console.log("CoSC runRenderNodes(), nodes.length: ", nodes.length);
      for (let i = 0; i < nodes.length; ++i) {
        nodes[i].render();
      }
    }
  }

  addRenderNodes(node, nodes) {
    for (let i = 0; i < nodes.length; ++i) {
      if (node == nodes[i]) {
        return;
      }
    }

    nodes.push(node);
  }

  prependRenderNode(node) {
    if (node != null && node != this) {
      if (this.m_prependNodes == null) this.m_prependNodes = [];
      this.addRenderNodes(node, this.m_prependNodes);
    }
  }

  appendRenderNode(node) {
    if (node != null && node != this) {
      // console.log("CoSC appendRenderNode(), node: ", node);
      if (this.m_appendNodes == null) this.m_appendNodes = [];
      let ls = this.m_appendNodes;

      for (let i = 0; i < ls.length; ++i) {
        if (node == ls[i]) {
          return;
        }
      }

      ls.push(node);
    }
  }

  removeRenderNode(node) {
    if (node != null) {
      let ls = this.m_prependNodes;

      if (ls != null) {
        for (let i = 0; i < ls.length; ++i) {
          if (node == ls[i]) {
            ls.splice(i, 1);
            break;
          }
        }
      }
    }
  } // rendering running


  run(autoCycle = false) {
    if (this.m_enabled) {
      //console.log("rendererSubScene::run...");
      if (autoCycle && this.m_autoRunning) {
        if (this.m_runFlag != 1) this.update();
        this.m_runFlag = 2;
      }

      this.runnableQueue.run();
      this.runRenderNodes(this.m_prependNodes);

      for (let i = 0; i < this.m_processidsLen; ++i) {
        this.m_renderer.runAt(this.m_processids[i]);
      }

      this.runRenderNodes(this.m_appendNodes);

      if (autoCycle) {
        this.runEnd();
      }
    }
  }

  runAt(index) {
    this.m_renderer.runAt(this.m_processids[index]);
  }

  runEnd() {
    if (this.m_evt3DCtr != null) {
      this.m_evt3DCtr.runEnd();
    }

    if (this.m_rspace != null) {
      this.m_rspace.runEnd();
    }

    if (this.m_autoRunning) {
      this.m_runFlag = -1;
    }

    if (this.m_accessor != null) {
      this.m_accessor.renderEnd(this);
    }
  }

  render() {
    if (this.m_renderProxy != null) {
      this.run(true);
    }
  }

  useCamera(camera, syncCamView = false) {
    this.m_parent.useCamera(camera, syncCamView);
  }

  useMainCamera() {
    this.m_parent.useMainCamera();
  }

  updateCamera() {
    if (this.m_camera != null) {
      this.m_camera.update();
    }
  }

  setClearUint24Color(colorUint24, alpha = 1.0) {
    this.m_renderProxy.setClearUint24Color(colorUint24, alpha);
  }

  setClearRGBColor3f(pr, pg, pb) {
    this.m_renderProxy.setClearRGBColor3f(pr, pg, pb);
  }

  setClearRGBAColor4f(pr, pg, pb, pa) {
    this.m_renderProxy.setClearRGBAColor4f(pr, pg, pb, pa);
  }

  setClearColor(color) {
    this.m_renderProxy.setClearRGBAColor4f(color.r, color.g, color.b, color.a);
  }

  setRenderToBackBuffer() {
    this.m_renderProxy.setRenderToBackBuffer();
  }

  destroy() {
    this.runnableQueue.destroy();
  }

}

RendererSubScene.s_uid = 0;
exports.default = RendererSubScene;

/***/ }),

/***/ "710f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ROVtxBufUidStore {
  constructor() {
    this.m_useidList = [];
    this.m_removeidList = [];

    if (ROVtxBufUidStore.s_ins != null) {
      throw Error("ROVtxBufUidStore is a singleton class!!");
    }

    ROVtxBufUidStore.s_ins = this;
  }

  static GetInstance() {
    return ROVtxBufUidStore.s_ins;
  }

  __$getRemovedListLen() {
    return this.m_removeidList.length;
  }

  __$getRemovedList() {
    return this.m_removeidList;
  }

  __$attachAt(index) {
    if (index < this.m_useidList.length) {
      ++this.m_useidList[index];
    } else {
      // 这里的内存管理需要优化
      let i = this.m_useidList.length;

      for (; i <= index; ++i) {
        this.m_useidList.push(0);
      }

      ++this.m_useidList[index];
    } //console.log("ROVtxBufUidStore::__$attachAt() list["+index+"]: "+this.m_useidList[index]);

  }

  __$detachAt(index) {
    --this.m_useidList[index]; //console.log("ROVtxBufUidStore::__$detachAt() list["+index+"]: "+this.m_useidList[index]);

    if (this.m_useidList[index] < 1) {
      this.m_useidList[index] = 0;
      console.log("ROVtxBufUidStore::__$detachAt(" + index + ") tex useCount value is 0.");
      this.m_removeidList.push(index);
    }
  }

  getAttachCountAt(uid) {
    if (uid < this.m_useidList.length) {
      return this.m_useidList[uid];
    }

    return 0;
  }

  getAttachAllCount() {
    let total = 0;
    let i = 0;
    let len = this.m_useidList.length;

    for (; i < len; ++i) {
      if (this.m_useidList[i] > 0) {
        total += this.m_useidList[i];
      }
    }

    return total;
  }

}

ROVtxBufUidStore.s_ins = null;
exports.default = ROVtxBufUidStore;

/***/ }),

/***/ "7126":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class DropFileController {
  constructor() {
    this.m_canvas = null;
    this.m_listener = null;
  }

  initialize(canvas, listener) {
    if (this.m_canvas == null) {
      this.m_canvas = canvas;
      this.m_listener = listener;
      this.initDrop(this.m_canvas);
    }
  }

  initDrop(canvas) {
    // --------------------------------------------- 阻止必要的行为 begin
    canvas.addEventListener("dragenter", e => {
      e.preventDefault();
      e.stopPropagation();
    }, false);
    canvas.addEventListener("dragover", e => {
      e.preventDefault();
      e.stopPropagation();
    }, false);
    canvas.addEventListener("dragleave", e => {
      e.preventDefault();
      e.stopPropagation();
    }, false);
    canvas.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      console.log("canvas drop evt.", e);
      this.receiveDropFile(e);
    }, false);
  }

  receiveDropFile(e) {
    if (this.m_listener.isDropEnabled()) {
      let dt = e.dataTransfer; // 只能拽如一个文件或者一个文件夹里面的所有文件。如果文件夹里面有子文件夹则子文件夹中的文件不会载入

      let files = [];
      let filesTotal = 0;
      let filesCurrTotal = 0;

      if (dt.items !== undefined) {
        let items = dt.items; // Chrome有items属性，对Chrome的单独处理

        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let entity = item.webkitGetAsEntry();

          if (entity != null) {
            if (entity.isFile) {
              let file = item.getAsFile(); // console.log("drop a file: ", file);

              files.push(file);
              this.m_listener.initFileLoad(files);
              filesTotal = 1;
            } else if (entity.isDirectory) {
              // let file = item.getAsFile();
              let dr = entity.createReader(); // console.log("drop a dir, dr: ", dr);

              dr.readEntries(entries => {
                filesTotal = entries.length;

                if (filesTotal > 0) {
                  // 循环目录内容
                  entries.forEach(entity => {
                    if (entity.isFile) {
                      entity.file(file => {
                        files.push(file);
                        filesCurrTotal++;

                        if (filesTotal == filesCurrTotal) {
                          this.m_listener.initFileLoad(files);
                        }
                      });
                    }
                  });
                } else {
                  this.alertShow(31);
                }
              });
              break;
            }
          }

          if (filesTotal > 0) {
            break;
          }
        }
      }
    }
  }

  alertShow(flag) {
    switch (flag) {
      case 31:
        alert("没有找到对应的模型文件");
        break;

      default:
        break;
    }
  }

}

exports.DropFileController = DropFileController;

/***/ }),

/***/ "7181":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ImgTexData {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.data = null;
    this.miplevel = 0; // 0表示 更新纹理数据而不会重新开辟空间, 1表示需要重新开辟空间并更新纹理数据, -1表示不需要更新

    this.status = 1;
    this.offsetx = 0;
    this.offsety = 0;
  }

  updateToGpu(gl, samplerTarget, interType, format, type, force) {
    if (this.status == 1 || force) {
      gl.texImage2D(samplerTarget, this.miplevel, interType, format, type, this.data);
    } else if (this.status == 0) {
      gl.texSubImage2D(samplerTarget, this.miplevel, this.offsetx, this.offsety, format, type, this.data);
    }

    this.status = -1;
  }

  static Create() {
    if (ImgTexData.s_list.length > 0) {
      return ImgTexData.s_list.pop();
    }

    return new ImgTexData();
  }

  static Restore(tsd) {
    if (tsd != null) {
      tsd.data = null;
      ImgTexData.s_list.push(tsd);
    }
  }

}

ImgTexData.s_list = [];
exports.default = ImgTexData;

/***/ }),

/***/ "722e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RenderFilter {}

RenderFilter.NEAREST = 4001;
RenderFilter.LINEAR = 4002;
RenderFilter.LINEAR_MIPMAP_LINEAR = 4003;
RenderFilter.NEAREST_MIPMAP_NEAREST = 4004;
RenderFilter.LINEAR_MIPMAP_NEAREST = 4005;
RenderFilter.NEAREST_MIPMAP_LINEAR = 4006;
exports.default = RenderFilter;

/***/ }),

/***/ "7279":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const ShaderUniform_1 = __importDefault(__webpack_require__("d53d"));

class ShaderGlobalUniform extends ShaderUniform_1.default {
  constructor(slot) {
    super();
    this.m_slot = null;
    this.m_slotFlags = null;
    this.m_slotDatas = null;
    this.slotId = 0;
    this.slotIndex = 0;
    this.uniformsTotal = 0;
    this.locationIndexList = null;
    this.locations = null;
    this.rst = 0;
    this.always = false;
    this.m_slot = slot;
    this.m_slotFlags = this.m_slot.flagList;
    this.m_slotDatas = this.m_slot.dataList;
  }

  applyData() {}

  clone() {
    let guniform = new ShaderGlobalUniform(this.m_slot);
    guniform.types = this.types.slice(0);
    guniform.uniformNameList = this.uniformNameList.slice(0);
    guniform.dataSizeList = this.dataSizeList.slice(0);
    guniform.slotIndex = this.slotIndex;
    guniform.uniformsTotal = this.uniformsTotal;
    guniform.slotId = this.slotId;
    guniform.always = this.always;
    guniform.rst = this.rst;
    return guniform;
  } // for multi uniforms data src, for example: camera, lightGroup


  copyDataFromProbe(probe) {
    this.types = probe.uniformTypes.slice(0);
    this.dataSizeList = probe.dataSizeList.slice(0);
    this.slotIndex = probe.getSlotBeginIndex();
    this.uniformsTotal = probe.uniformsTotal;
    this.slotId = probe.getRCUid();
  }

  copyDataFromProbeAt(i, probe) {
    if (this.types == null) {
      this.types = [];
      this.dataSizeList = [];
    }

    this.slotIndex = probe.getSlotBeginIndex() + i;
    this.uniformsTotal = 1;
    this.slotId = probe.getRCUid();
    this.types[0] = probe.uniformTypes[i];
    this.dataSizeList[0] = probe.dataSizeList[i];
  }

  use(rc) {
    //let slot: UniformDataSlot = UniformDataSlot.GetSlotAt(rc.getRCUid());
    if (this.always || this.rst != this.m_slotFlags[this.slotIndex]) {
      //  if(rc.getGPUProgram() == null) {
      //      console.warn("current gpu shader program is null");
      //  }
      //  if(this.program != null) {
      //      console.log("have gpu shader program in this global uniform, program: ",this.program,this.locations);
      //  }
      //  if(this.program != null && rc.getGPUProgram() != this.program) {
      //      console.warn("current gpu shader program can't match this global uniform.");
      //  }
      this.rst = this.m_slotFlags[this.slotIndex];
      let i = 0;
      let datas = this.m_slotDatas;

      if (RendererDevice_1.default.IsWebGL1()) {
        for (; i < this.uniformsTotal; ++i) {
          rc.useUniformV1(this.locations[i], this.types[i], datas[this.slotIndex + i], this.dataSizeList[i]);
        }
      } else {
        //console.log(this.uns, ", GlobalUniform this.uniformsTotal: ",this.uniformsTotal,this.dataSizeList);
        for (; i < this.uniformsTotal; ++i) {
          // if(this.types[i] == MaterialConst.SHADER_VEC4FV) {
          //     console.log("SHADER_VEC4FV, slot.dataList["+(this.slotIndex + i)+"]: ",slot.dataList[this.slotIndex + i]);
          // }
          rc.useUniformV2(this.locations[i], this.types[i], datas[this.slotIndex + i], this.dataSizeList[i], 0);
        }
      }
    }
  }

  destroy() {
    this.types = null;
    this.dataSizeList = null;
    this.slotIndex = -1;
    this.uniformsTotal = 0;
    this.m_slot = null;
    this.m_slotFlags = null;
    this.m_slotDatas = null;
  }

}

exports.default = ShaderGlobalUniform;

/***/ }),

/***/ "73f9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const GeometryDataUnit_1 = __webpack_require__("aeff");

const CTMParseTask_1 = __webpack_require__("7dbf");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

class CTMParserListerner {
  constructor(unitPool, threadSchedule, module, receiverSchedule) {
    this.m_parseTask = null;
    this.m_moduleUrl = module.url;
    this.m_unitPool = unitPool;
    this.m_threadSchedule = threadSchedule;
    this.m_receiverSchedule = receiverSchedule;
  }

  addUrlToTask(url) {
    if (!this.m_unitPool.hasUnitByUrl(url)) {
      if (this.m_parseTask == null) {
        let parseTask = new CTMParseTask_1.CTMParseTask(this.m_moduleUrl); // 绑定当前任务到多线程调度器

        this.m_threadSchedule.bindTask(parseTask);
        parseTask.setListener(this);
        this.m_parseTask = parseTask;
      }

      new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
        DivLog_1.default.ShowLogOnce("正在解析CTM数据...");
        this.m_parseTask.addBinaryData(new Uint8Array(buf), url);
      }, (progress, url) => {
        let k = Math.round(100 * progress);
        DivLog_1.default.ShowLogOnce("ctm file loading " + k + "%");
      }, (status, url) => {
        console.error("load ctm mesh data error, url: ", url);
      });
    }
  } // 一个任务数据处理完成后的侦听器回调函数


  ctmParseFinish(model, url) {
    // console.log("CTMParserListerner::ctmParseFinish(), model: ", model, ", url: ", url);
    if (this.m_unitPool.hasUnitByUrl(url)) {
      let unit = this.m_unitPool.getUnitByUrl(url);

      if (unit != null) {
        unit.lossTime = Date.now() - unit.lossTime;
        unit.data.models = [model];
        GeometryDataUnit_1.DataUnitLock.lockStatus = 209;
        unit.toCpuPhase();

        if (unit.immediate) {
          // console.log("geom data receive at once.");
          this.m_receiverSchedule.testUnit(unit);
        }
      }
    }
  }

  destroy() {
    if (this.m_parseTask != null) {
      this.m_parseTask.destroy();
      this.m_parseTask = null;
    }

    this.m_unitPool = null;
    this.m_threadSchedule = null;
    this.m_receiverSchedule = null;
  }

}

exports.CTMParserListerner = CTMParserListerner;

/***/ }),

/***/ "7499":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RenderMaterialProxy {
  constructor() {
    this.m_dispBuilder = null;
    this.m_shader = null;
    this.m_texRes = null;
  }

  setDispBuilder(builder) {
    if (this.m_dispBuilder == null) {
      this.m_dispBuilder = builder;
      this.m_shader = builder.getRenderShader();
      this.m_texRes = builder.getTextureResource();
    }
  }

  unlockMaterial() {
    this.m_shader.unlock();
    this.m_texRes.unlocked = true;
  }

  lockMaterial() {
    this.m_shader.lock();
    this.m_texRes.unlocked = false;
  }

  isUnlockMatrial() {
    return this.m_texRes.unlocked;
  }

  unlockTexture() {
    this.m_shader.textureUnlock();
  }

  lockTexture() {
    this.m_shader.textureLock();
  }

  renderBegin() {
    this.m_shader.renderBegin();
    this.m_texRes.renderBegin();
  }

  resetUniform() {
    this.m_shader.resetUniform();
  }

  useGlobalMaterial(material, materialUniformUpdate = false) {
    if (material != null) {
      this.m_dispBuilder.updateGlobalMaterial(material, materialUniformUpdate);
    }
  }

  updateMaterialUniform(material) {
    this.m_shader.updateUniform(material.__$uniform);
  }

}

exports.default = RenderMaterialProxy;

/***/ }),

/***/ "74c3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
}); // gpu vertex buffer renderer resource

class ROVertexResource {
  constructor(rcuid, gl, vtxBuilder) {
    this.m_resMap = new Map();
    this.m_freeMap = new Map();
    this.m_updateIds = []; // 显存的vtx buffer的总数

    this.m_vtxResTotal = 0;
    this.m_attachTotal = 0;
    this.m_delay = 128;
    this.m_haveDeferredUpdate = false;
    /**
     * updating times total, the min value is 4, the default value is 16
     */

    this.m_vtxUpdateTotal = 16; // renderer context unique id

    this.m_rcuid = 0;
    this.m_gl = null;
    this.m_vtxBuilder = null;
    this.unlocked = true;
    this.m_rcuid = rcuid;
    this.m_gl = gl;
    this.m_vtxBuilder = vtxBuilder;
  }
  /**
   * set the updating times total that update vertex data to gpu in one frame time
   * @param total updating times total, the min value is 4, the default value is 16
   */


  setVtxUpdateTimesTotal(total) {
    this.m_vtxUpdateTotal = total > 4 ? total : 4;
  }

  createResByParams3(resUid, param0, param1, param2) {
    return false;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_gl;
  }
  /**
   * check whether the renderer runtime resource(by renderer runtime resource unique id) exists in the current renderer context
   * @param resUid renderer runtime resource unique id
   * @returns has or has not resource by unique id
   */


  hasResUid(resUid) {
    return this.m_resMap.has(resUid);
  }
  /**
   * bind the renderer runtime resource(by renderer runtime resource unique id) to the current renderer context
   * @param resUid renderer runtime resource unique id
   */


  bindToGpu(resUid) {}
  /**
   * get system gpu context resource buf
   * @param resUid renderer runtime resource unique id
   * @returns system gpu context resource buf
   */


  getGpuBuffer(resUid) {
    return null;
  }

  renderBegin() {
    this.m_vtxBuilder.renderBegin();
  }

  getVertexResTotal() {
    return this.m_vtxResTotal;
  }

  updateDataToGpu(resUid, deferred) {
    if (deferred) {
      this.m_updateIds.push(resUid);
      this.m_haveDeferredUpdate = true;
    } else {
      if (this.m_resMap.has(resUid)) {
        this.m_resMap.get(resUid).updateToGpu(this.m_vtxBuilder);
      }
    }
  }

  addVertexRes(object) {
    if (!this.m_resMap.has(object.resUid)) {
      object.waitDelTimes = 0; //console.log("ROTextureResource add a texture buffer(resUid="+object.resUid+")");

      this.m_resMap.set(object.resUid, object);
      this.m_vtxResTotal++;
    }
  }

  getVertexRes(resUid) {
    return this.m_resMap.get(resUid);
  }

  destroyRes(resUid) {
    if (this.m_resMap.has(resUid)) {
      this.m_resMap.get(resUid).destroy(this.m_vtxBuilder);
    }
  }

  __$attachRes(resUid) {
    if (this.m_resMap.has(resUid)) {
      this.m_attachTotal++;
      let object = this.m_resMap.get(resUid);

      if (object.getAttachCount() < 1) {
        if (this.m_freeMap.has(resUid)) {
          this.m_freeMap.delete(resUid);
        }
      }

      object.waitDelTimes = 0;

      object.__$attachThis();
    }
  }

  __$detachRes(resUid) {
    if (this.m_resMap.has(resUid)) {
      if (this.m_resMap.has(resUid)) {
        let object = this.m_resMap.get(resUid);

        if (object.getAttachCount() > 0) {
          this.m_attachTotal--;

          object.__$detachThis();

          if (object.getAttachCount() < 1) {
            // 将其加入待清理的map
            this.m_freeMap.set(resUid, object);
          }
        }
      }
    }
  }

  getVROByResUid(resUid, shdp, vaoEnabled) {
    let vtxObj = this.m_resMap.get(resUid);

    if (vtxObj != null) {
      return vtxObj.createVRO(this.m_vtxBuilder, shdp, vaoEnabled);
    }

    return null;
  }

  update() {
    if (this.m_haveDeferredUpdate) {
      let len = this.m_updateIds.length;

      if (len > 0) {
        if (len > this.m_vtxUpdateTotal) len = this.m_vtxUpdateTotal;
        let resUid;

        for (let i = 0; i < len; ++i) {
          resUid = this.m_updateIds.shift();

          if (this.m_resMap.has(resUid)) {
            //console.log("ROvtxRes("+resUid+") update vtx("+resUid+") data to gpu with deferred mode.");
            this.m_resMap.get(resUid).updateToGpu(this.m_vtxBuilder);
          }
        }
      } else {
        this.m_haveDeferredUpdate = false;
      }
    }

    this.m_delay--;

    if (this.m_delay < 1) {
      this.m_delay = 128;

      for (const [key, value] of this.m_freeMap) {
        value.waitDelTimes++;

        if (value.getAttachCount() < 1) {
          if (value.waitDelTimes > 5) {
            console.log("ROVertexResource remove a vertex buffer(resUid=" + value.resUid + ")");
            this.m_resMap.delete(value.resUid);
            this.m_freeMap.delete(value.resUid);
            value.destroy(this.m_vtxBuilder);
            this.m_vtxResTotal--;
          }
        } else {
          console.log("ROVertexResource repeat use a vertex buffer(resUid=" + value.resUid + ") from freeMap.");
          this.m_freeMap.delete(value.resUid);
        }
      }
    }
  }

}

exports.ROVertexResource = ROVertexResource;
exports.default = ROVertexResource;

/***/ }),

/***/ "74ee":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataPhaseFlag_1 = __webpack_require__("698b");

const DataFormat_1 = __webpack_require__("7a08");

exports.DataFormat = DataFormat_1.DataFormat;
var DataClass;

(function (DataClass) {
  DataClass[DataClass["Geometry"] = 0] = "Geometry";
  DataClass[DataClass["Texture"] = 1] = "Texture";
  DataClass[DataClass["Undefined"] = 2] = "Undefined";
})(DataClass || (DataClass = {}));

exports.DataClass = DataClass;

class DataUnitLock {}
/**
 * f防止误操作故意为之
 */


DataUnitLock.lockStatus = 0;
exports.DataUnitLock = DataUnitLock;

class DataUnit {
  constructor() {
    // 表示 none/net/cpu/gpu 三个阶段的信息, 初始值必须是DataPhaseFlag.PHASE_NONE, 外部用户不能操作
    this.m_dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.PHASE_NONE;
    /**
     * 当数据结果生成之后，是否立即向接收者发送数据结果
     */

    this.immediate = false;
    /**
     * 数据生成过程耗时
     */

    this.lossTime = 0; // 故意写成这样，防止误操作

    if (DataUnitLock.lockStatus !== 207) {
      throw Error("illegal operation !!!");
    }

    this.m_uuid = DataUnit.s_uuid++;
    DataUnitLock.lockStatus = 0;
  }

  getUUID() {
    return this.m_uuid;
  }

  clone() {
    return null;
  }

  test() {}
  /**
   * @returns 返回CPU端数据是否可用
   */


  isNetPhase() {
    return DataPhaseFlag_1.DataPhaseFlag.isCpuPhase(this.m_dataPhaseFlag);
  }
  /**
   * @returns 返回CPU端数据是否可用
   */


  isCpuPhase() {
    return DataPhaseFlag_1.DataPhaseFlag.isCpuPhase(this.m_dataPhaseFlag);
  }
  /**
   * @returns 返回GPU端数据是否可用
   */


  isGpuPhase() {
    return DataPhaseFlag_1.DataPhaseFlag.isGpuPhase(this.m_dataPhaseFlag);
  }

  clearAllPhase() {
    this.m_dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.clearAllPhase(this.m_dataPhaseFlag);
  }

  toNetPhase() {
    if (DataUnitLock.lockStatus !== 208) {
      throw Error('illegal operation !!!');
    }

    this.m_dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.addNetPhase(this.m_dataPhaseFlag);
  }

  toCpuPhase() {
    if (DataUnitLock.lockStatus !== 209) {
      throw Error("illegal operation !!!");
    }

    this.m_dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.addCpuPhase(this.m_dataPhaseFlag);
  }

  toGpuPhase() {
    if (DataUnitLock.lockStatus !== 210) {
      throw Error('illegal operation !!!');
    }

    this.m_dataPhaseFlag = DataPhaseFlag_1.DataPhaseFlag.addGpuPhase(this.m_dataPhaseFlag);
  }

}

DataUnit.s_uuid = 0;
exports.DataUnit = DataUnit;

/***/ }),

/***/ "7566":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class ThrDataPool {
  constructor() {
    this.m_dataList = []; // wait calc data queue

    this.m_waitingDataList = [];
    this.m_dataTotal = 0;
    this.m_dataHaveTotal = 0;
    this.m_startupFlag = 0;
  }

  sendDataTo(thread) {
    if (this.m_dataTotal > 0) {
      let data = null; // 等待队列有数据，就优先发送这个队列里面的数据

      let len = this.m_waitingDataList.length;

      if (len > 0) {
        data = this.m_waitingDataList[0];
        thread.sendDataTo(data);

        if (data.sendStatus == 1) {
          this.m_dataTotal--;
          len--;
          this.m_waitingDataList.shift();
          return true;
        }
      }

      len = this.m_dataTotal - len;

      if (len > 0) {
        data = this.m_dataList.shift();
        thread.sendDataTo(data);

        if (data.sendStatus == 1) {
          this.m_dataTotal--;
          return true;
        } else {
          // 因为相关计算模块还没准备好,需先加入等待队列
          this.m_waitingDataList.push(data);
        }
      }
    }

    return false;
  }

  addData(thrData) {
    if (thrData.sendStatus < 0) {
      thrData.sendStatus = 0;
      this.m_dataTotal++;
      this.m_dataHaveTotal++;
      this.m_startupFlag = 1;
      this.m_dataList.push(thrData);
    } else {
      console.error("thrData.sendStatus value is " + thrData.sendStatus);
    }
  }

  getDataTotal() {
    return this.m_dataTotal;
  }

  isEnabled() {
    // console.log(this.m_dataHaveTotal,this.m_dataTotal,this.m_startupFlag);
    return this.m_dataTotal * this.m_startupFlag > 0;
  }

  isStartup() {
    return this.m_startupFlag > 0;
  }

}

exports.ThrDataPool = ThrDataPool;

/***/ }),

/***/ "7577":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const DisplayEntity_1 = __importDefault(__webpack_require__("402a"));

const DataMesh_1 = __importDefault(__webpack_require__("519e"));

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const EntityLayout_1 = __webpack_require__("fbd5");

const NormalCheckMaterial_1 = __webpack_require__("015b");

const SurfaceNormalCalc_1 = __importDefault(__webpack_require__("35fa"));

class SceneNode {
  constructor() {
    this.m_delay = 2;
    this.m_vtxTotal = 0;
    this.m_partsTotal = 0;
    this.m_wait_entities = [];
    this.m_cospace = null;
    this.m_rscene = null;
    this.m_scaleV = new Vector3D_1.default(1.0, 1.0, 1.0);
    this.m_time = 0;
    this.m_modelsTotal = 0;
    this.m_showTotal = 0;
    this.m_waitPartsTotal = -1;
    this.m_entities = [];
    this.m_transforms = [];
    this.m_transes = [];
    this.m_transles = [];
    this.m_models = [];
    this.m_entityLayout = new EntityLayout_1.EntityLayout();
    this.m_frameBox = null;
    this.m_sizeScale = 1.0;
    this.m_lossTime = 0;
    this.m_verticesTotal = 0;
    this.m_errModelTotal = 0;
    this.m_normalErrInfo = "";
    this.m_rotV = new Vector3D_1.default();
  }

  initialize(rscene, cospace) {
    if (this.m_rscene == null) {
      this.m_rscene = rscene;
      this.m_cospace = cospace;
    }
  }

  mouseDown(evt) {}

  load(urls) {
    DivLog_1.default.ShowLogOnce("正在解析原数据...");
    this.m_time = Date.now();
  }

  showInfo(info) {
    DivLog_1.default.ShowLogOnce(info);
  }

  fitToCenter() {
    this.m_entityLayout.fixToPosition(this.m_transes, this.m_transforms, Vector3D_1.default.ZERO, 300.0);
    this.m_sizeScale = this.m_entityLayout.getSizeScale(); // //this.m_entityLayout.calcAABB(this.m_entities, this.m_transforms);
    // if(this.m_frameBox == null) {
    // 	this.m_frameBox = new BoxFrame3D();
    // 	this.m_frameBox.initializeByAABB( this.m_entityLayout.getAABB() );
    // 	this.m_rscene.addEntity( this.m_frameBox );
    // } else {
    // 	this.m_frameBox.updateFrameByAABB(this.m_entityLayout.getAABB());
    // 	this.m_frameBox.updateMeshToGpu();
    // }
  }

  initEntityFinish() {
    let es = this.m_transes;
    this.m_transles = new Array(es.length);
    let dis = 5.0 / this.m_sizeScale;
    /*
    // console.log("XXXXXXXXXXXX this.m_sizeScale: ",this.m_sizeScale);
    for (let k: number = 0; k < es.length; ++k) {
        const entity = this.buildModelNVLine(this.m_models[k], dis);
        entity.getTransform().setParentMatrix(es[k].getMatrix());
        entity.update();
    }
    //*/
  }

  initEntity(model, transform = null, index = 0) {
    if (model != null) {
      this.m_partsTotal++;

      if (model.vertices == null || model.vertices.length < 3) {
        //this.m_modelsTotal--;
        // this.m_errInfo = "注意: 子模型数据有错误"
        this.m_errModelTotal++;
        return;
      }

      if (model.normals == null) {
        this.m_normalErrInfo = "当前模型法线数据丢失!!!";
        console.error(this.m_normalErrInfo);
      }

      this.m_models.push(model); // this.buildModelNVLine( model );

      this.m_verticesTotal += model.vertices.length / 3; // let correct = this.normalCorrectionTest( model );

      this.m_lossTime = Date.now() - this.m_time; // console.log("initEntity lossTime: ", (Date.now() - this.m_time) + " ms");

      this.m_vtxTotal += model.vertices.length;
      let vs = model.vertices;
      let ivs = model.indices;
      let trisNumber = ivs.length / 3;
      let nvs2 = new Float32Array(vs.length);
      SurfaceNormalCalc_1.default.ClacTrisNormal(vs, vs.length, trisNumber, ivs, nvs2);
      let mb = new NormalCheckMaterial_1.NormalCheckMaterial();
      mb.applyDifference(true); // let material = new NormalViewerMaterial();

      let material = mb.create();
      material.initializeByCodeBuf();
      let dataMesh = new DataMesh_1.default(); // dataMesh.wireframe = true;

      dataMesh.vbWholeDataEnabled = false;
      dataMesh.setVS(model.vertices); // dataMesh.setUVS(model.uvsList[0]);

      dataMesh.setUVS(nvs2);
      dataMesh.setNVS(model.normals);
      dataMesh.setIVS(model.indices);
      dataMesh.setVtxBufRenderData(material);
      dataMesh.initialize(); // console.log(index, ",dataMesh.bounds.radius: ", dataMesh.bounds.radius);
      // console.log("build lossTime: ", (Date.now() - time) + " ms");
      // console.log("this.m_vtxTotal: ", this.m_vtxTotal + "个顶点， tris: ", dataMesh.trisNumber, ",vtCount: ", dataMesh.vtCount);
      // console.log("this.m_vtxTotal: ", this.m_vtxTotal + "个顶点， tris: ",this.m_vtxTotal/3);
      // DivLog.ShowLog("三角面数量: " + dataMesh.trisNumber + "个");

      let entity = new DisplayEntity_1.default(); // entity.setRenderState(RendererState.FRONT_CULLFACE_NORMAL_STATE);
      // entity.setRenderState(RendererState.NORMAL_STATE);

      entity.setRenderState(RendererState_1.default.NONE_CULLFACE_NORMAL_STATE);
      entity.setMesh(dataMesh);
      entity.setMaterial(material);
      entity.setVisible(false);
      this.m_transforms.push(transform);
      this.m_transes.push(entity);
      this.fitToCenter();
      this.m_wait_entities.push(entity);
      this.m_entities.push(entity);
      this.m_rscene.addEntity(entity);
      entity.update();
    }
  }

  isFinish() {
    return this.m_modelsTotal > 0 && this.m_showTotal + this.m_errModelTotal == this.m_modelsTotal;
  }

  clear() {
    if (this.isFinish()) {
      if (this.m_frameBox != null) {
        this.m_rscene.removeEntity(this.m_frameBox);
        this.m_frameBox = null;
      }

      this.m_normalErrInfo = "";
      this.m_verticesTotal = 0;
      this.m_transforms = [];
      this.m_transes = [];
      this.m_transles = [];

      if (this.m_entities != null) {
        let entities = this.m_entities;

        for (let k = 0; k < entities.length; ++k) {
          entities[k].setVisible(false);
        }

        this.m_entities = null;
      }

      this.m_models = [];
      this.m_rscene = null;
      this.m_cospace = null;
    }
  }

  run() {
    // if(this.m_entity != null) {
    // 	this.m_entity.setRotation3(this.m_rotV);
    // 	this.m_entity.update();
    // 	this.m_rotV.x += 0.5;
    // 	this.m_rotV.y += 0.5;
    // }
    if (!this.isFinish()) {
      // if (this.m_waitPartsTotal == 0) {
      // 	this.m_waitPartsTotal = -1;
      // 	this.m_delay = 2;
      // 	this.fitToCenter();
      // }
      if (this.m_delay < 1) {
        if (this.m_wait_entities.length > 0) {
          let entity = this.m_wait_entities[this.m_wait_entities.length - 1];
          let tot = Math.floor(entity.getMesh().vtxTotal / 20000);
          tot = Math.min(tot, 10);
          this.m_delay = tot + 1;
          entity = this.m_wait_entities.pop();
          entity.setVisible(true);
          this.m_entity = entity; // if(this.m_showTotal == 0) {
          // 	console.log("############# show geom begin.");
          // }

          this.m_showTotal++;
          let info = "initialize entity loss time: " + this.m_lossTime + "ms";
          info += "</br>顶点数量: " + this.m_verticesTotal + "个";
          info += "</br>子模型数量: " + this.m_showTotal + "/" + this.m_modelsTotal + "个";

          if (this.isFinish()) {
            info += "</br>当前模型加载展示完成";

            if (this.m_errModelTotal > 0) {
              info += "</br>注意: 有" + this.m_errModelTotal + "个子模型数据有问题";
            }

            if (this.m_normalErrInfo != "") {
              info += "</br><font color='#ee00aa'>注意: " + this.m_normalErrInfo + ",当前所见的法线由此程序生成</font>";
            }

            this.initEntityFinish();
          }

          DivLog_1.default.ShowLogOnce(info);
        }
      } else if (this.m_delay > 0) {
        this.m_delay--;
      }
    }
  }

}

exports.SceneNode = SceneNode;

/***/ }),

/***/ "765c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 渲染场景内物体的鼠标事件控制类

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

class MouseEvt3DController {
  constructor() {
    this.m_uid = 0;
    this.m_mainStage = null;
    this.m_currStage = null;
    this.m_raySelector = null;
    this.m_unlockBoo = true;
    this.m_mouseEvt = new MouseEvent_1.default();
    this.m_mouseOverEvt = new MouseEvent_1.default();
    this.m_mouseOutEvt = new MouseEvent_1.default();
    this.m_evtTypes = new Float32Array(64);
    this.m_evtXList = new Float32Array(64);
    this.m_evtYList = new Float32Array(64);
    this.m_evtWheelDeltaYs = new Float32Array(64);
    this.m_evtTotal = 0;
    this.m_evtEntity = null;
    this.m_evtContainer = null;
    this.m_evtFlowPhase = -1;
    this.m_uid = MouseEvt3DController.s_uid++;
  }

  initialize(mainStage, currStage) {
    //console.log("MouseEvt3DController::initialize()......");
    if (this.m_mainStage == null) {
      this.m_mainStage = mainStage;
      this.m_currStage = currStage;
      let ME = MouseEvent_1.default;
      mainStage.addEventListener(ME.MOUSE_DOWN, this, this.mouseDownListener, true, false);
      mainStage.addEventListener(ME.MOUSE_UP, this, this.mouseUpListener, true, false);
      mainStage.addEventListener(ME.MOUSE_CLICK, this, this.mouseClickListener, true, false);
      mainStage.addEventListener(ME.MOUSE_MOVE, this, this.mouseMoveListener, true, false);
      mainStage.addEventListener(ME.MOUSE_WHEEL, this, this.mouseWheeelListener, true, false);
      mainStage.addEventListener(ME.MOUSE_RIGHT_DOWN, this, this.mouseDownListener, true, false);
      mainStage.addEventListener(ME.MOUSE_RIGHT_UP, this, this.mouseUpListener, true, false);
      mainStage.addEventListener(ME.MOUSE_MIDDLE_DOWN, this, this.mouseDownListener, true, false);
      mainStage.addEventListener(ME.MOUSE_MIDDLE_UP, this, this.mouseUpListener, true, false);
    }
  }

  setRaySelector(raySelector) {
    this.m_raySelector = raySelector;
  }

  mouseWheeelListener(evt) {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    this.m_evtTypes[this.m_evtTotal] = evt.type;
    this.m_evtXList[this.m_evtTotal] = evt.mouseX;
    this.m_evtYList[this.m_evtTotal] = evt.mouseY;
    this.m_evtWheelDeltaYs[this.m_evtTotal] = evt.wheelDeltaY;
    this.m_mouseEvt.type = evt.type;
    this.m_evtTotal++;
  } // 鼠标动了, 摄像机动了, 被渲染对象本身动了,都可能形成mouse move事件


  mouseMoveListener(evt) {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    this.m_evtTypes[this.m_evtTotal] = evt.type;
    this.m_evtXList[this.m_evtTotal] = evt.mouseX;
    this.m_evtYList[this.m_evtTotal] = evt.mouseY;
    this.m_evtWheelDeltaYs[this.m_evtTotal] = 0;
    this.m_mouseEvt.type = evt.type;
    this.m_evtTotal++;
  }

  mouseDownListener(evt) {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    if (MouseEvt3DController.s_unlockMouseEvt) {
      this.m_evtTypes[this.m_evtTotal] = evt.type;
      this.m_evtXList[this.m_evtTotal] = evt.mouseX;
      this.m_evtYList[this.m_evtTotal] = evt.mouseY;
      this.m_evtWheelDeltaYs[this.m_evtTotal] = 0;
      this.m_mouseEvt.type = evt.type;
      this.m_evtTotal++;
    }
  }

  mouseUpListener(evt) {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    if (MouseEvt3DController.s_unlockMouseEvt) {
      this.m_evtTypes[this.m_evtTotal] = evt.type;
      this.m_evtXList[this.m_evtTotal] = evt.mouseX;
      this.m_evtYList[this.m_evtTotal] = evt.mouseY;
      this.m_evtWheelDeltaYs[this.m_evtTotal] = 0;
      this.m_mouseEvt.type = evt.type;
      this.m_evtTotal++;
    }
  }

  mouseClickListener(evt) {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    if (MouseEvt3DController.s_unlockMouseEvt) {
      this.m_evtTypes[this.m_evtTotal] = evt.type;
      this.m_evtXList[this.m_evtTotal] = evt.mouseX;
      this.m_evtYList[this.m_evtTotal] = evt.mouseY;
      this.m_evtWheelDeltaYs[this.m_evtTotal] = 0;
      this.m_mouseEvt.type = evt.type;
      this.m_evtTotal++;
    }
  }

  mouseOutEventTarget() {
    if (this.m_currStage != null) {
      this.m_currStage.mouseX = this.m_mainStage.mouseX;
      this.m_currStage.mouseY = this.m_mainStage.mouseY;
    }

    if (this.m_evtEntity != null) {
      let dispatcher = this.m_evtEntity.getEvtDispatcher(MouseEvent_1.default.EventClassType);

      if (dispatcher != null) {
        this.m_mouseOutEvt.phase = this.m_evtFlowPhase;
        this.m_mouseOutEvt.type = MouseEvent_1.default.MOUSE_OUT;
        this.m_mouseOutEvt.mouseX = this.m_mouseEvt.mouseX;
        this.m_mouseOutEvt.mouseY = this.m_mouseEvt.mouseY;
        this.m_mouseOutEvt.target = this.m_evtEntity;
        this.m_raySelector.getRay(this.m_mouseOutEvt.raypv, this.m_mouseOutEvt.raytv);
        this.m_evtEntity = null;
        return dispatcher.dispatchEvt(this.m_mouseOutEvt);
      }

      this.m_evtEntity = null;
    }

    return 0;
  }
  /**
   * @param       evtFlowPhase: 0(none phase),1(capture phase),2(bubble phase)
   * @param       status: 1(default process),1(deselect ray pick target)
   * @return      1 is send evt yes,0 is send evt no,-1 is event nothing
   */


  run(evtFlowPhase, status) {
    let flag = -1;

    if (this.m_unlockBoo) {
      this.m_evtFlowPhase = evtFlowPhase;
      let i = 0;
      flag = this.m_evtTotal > 0 ? 0 : -1;
      let dispatcher = null;
      let node;
      let lpv;
      let wpv;

      if (flag > -1) {
        if (this.m_currStage != this.m_mainStage && this.m_currStage != null) {
          MouseEvt3DController.s_unlockMouseEvt = false;

          for (i = 0; i < this.m_evtTotal; i++) {
            switch (this.m_evtTypes[i]) {
              case MouseEvent_1.default.MOUSE_DOWN:
                this.m_currStage.mouseDown(1);
                break;

              case MouseEvent_1.default.MOUSE_UP:
                this.m_currStage.mouseUp(1);
                break;

              case MouseEvent_1.default.MOUSE_RIGHT_DOWN:
                this.m_currStage.mouseRightDown(1);
                break;

              case MouseEvent_1.default.MOUSE_RIGHT_UP:
                this.m_currStage.mouseRightUp(1);
                break;

              case MouseEvent_1.default.MOUSE_MIDDLE_DOWN:
                this.m_currStage.mouseMiddleDown(1);
                break;

              case MouseEvent_1.default.MOUSE_MIDDLE_UP:
                this.m_currStage.mouseMiddleUp(1);
                break;

              case MouseEvent_1.default.MOUSE_MOVE:
                this.m_currStage.mouseMove();
                break;

              default:
                break;
            }
          }

          MouseEvt3DController.s_unlockMouseEvt = true;
        }

        node = status < 1 ? this.m_raySelector.getSelectedNode() : null;

        if (node != null) {
          lpv = node.lpv;
          wpv = node.wpv;
          let entity = node.entity;
          dispatcher = entity.getEvtDispatcher(MouseEvent_1.default.EventClassType);

          let container = entity.__$getParent();

          let containerFlag = container != null && container.mouseEnabled;
          let tttFlag = 0;

          if (!containerFlag) {
            flag += this.mouseOutContainer(evtFlowPhase, null, null, null); // // for test
            // if(this.m_evtContainer != null) {
            //     tttFlag ++;
            // }

            this.m_evtContainer = null;
          }

          let preEvtEvent = this.m_evtEntity;

          for (let i = 0; i < this.m_evtTotal; i++) {
            this.m_mouseEvt.type = this.m_evtTypes[i];
            this.m_mouseEvt.mouseX = this.m_evtXList[i];
            this.m_mouseEvt.mouseY = this.m_evtYList[i];
            this.m_mouseEvt.wheelDeltaY = this.m_evtWheelDeltaYs[i];

            if (this.m_mouseEvt.type > 0) {
              if (node != null) {
                if (dispatcher != null) {
                  this.m_mouseEvt.target = entity;
                  this.m_mouseEvt.currentTarget = entity;
                  this.m_mouseEvt.phase = evtFlowPhase;
                  this.m_mouseEvt.lpos.copyFrom(lpv);
                  this.m_mouseEvt.wpos.copyFrom(wpv);
                  this.m_raySelector.getRay(this.m_mouseEvt.raypv, this.m_mouseEvt.raytv);
                  flag += this.mouseOutEntity(evtFlowPhase, entity, lpv, wpv);

                  if (this.m_evtEntity != entity) {
                    this.m_mouseOverEvt.phase = evtFlowPhase;
                    this.m_mouseOverEvt.type = MouseEvent_1.default.MOUSE_OVER;
                    this.m_mouseOverEvt.mouseX = this.m_mouseEvt.mouseX;
                    this.m_mouseOverEvt.mouseY = this.m_mouseEvt.mouseY;
                    this.m_mouseOverEvt.target = entity;
                    this.m_mouseOverEvt.currentTarget = entity;
                    this.m_mouseOverEvt.lpos.copyFrom(lpv);
                    this.m_mouseOverEvt.wpos.copyFrom(wpv);
                    this.m_raySelector.getRay(this.m_mouseOverEvt.raypv, this.m_mouseOverEvt.raytv);
                    flag += dispatcher.dispatchEvt(this.m_mouseOverEvt);
                  }

                  flag += dispatcher.dispatchEvt(this.m_mouseEvt);
                  this.m_evtEntity = entity;
                }
              }
            }
          }

          if (containerFlag) {
            if (preEvtEvent != null && preEvtEvent.__$getParent() == null) {
              this.m_evtEntity = preEvtEvent;
              flag += this.mouseOutEntity(evtFlowPhase, null, null, null);
              this.m_evtEntity = null;
            }

            for (let i = 0; i < this.m_evtTotal; i++) {
              this.m_mouseEvt.type = this.m_evtTypes[i];
              this.m_mouseEvt.mouseX = this.m_evtXList[i];
              this.m_mouseEvt.mouseY = this.m_evtYList[i];
              this.m_mouseEvt.wheelDeltaY = this.m_evtWheelDeltaYs[i];

              if (this.m_mouseEvt.type > 0) {
                if (node != null) {
                  this.m_mouseEvt.target = container;
                  this.m_mouseEvt.currentTarget = entity;
                  this.m_mouseEvt.phase = evtFlowPhase;
                  this.m_mouseEvt.lpos.copyFrom(lpv);
                  this.m_mouseEvt.wpos.copyFrom(wpv);
                  this.m_raySelector.getRay(this.m_mouseEvt.raypv, this.m_mouseEvt.raytv);
                  flag += this.mouseOutContainer(evtFlowPhase, container, lpv, wpv);

                  if (this.m_evtContainer != container) {
                    this.m_mouseOverEvt.phase = evtFlowPhase;
                    this.m_mouseOverEvt.type = MouseEvent_1.default.MOUSE_OVER;
                    this.m_mouseOverEvt.mouseX = this.m_mouseEvt.mouseX;
                    this.m_mouseOverEvt.mouseY = this.m_mouseEvt.mouseY;
                    this.m_mouseOverEvt.target = container;
                    this.m_mouseOverEvt.currentTarget = entity;
                    this.m_mouseOverEvt.lpos.copyFrom(lpv);
                    this.m_mouseOverEvt.wpos.copyFrom(wpv);
                    this.m_raySelector.getRay(this.m_mouseOverEvt.raypv, this.m_mouseOverEvt.raytv);
                    flag += container.dispatchEvt(this.m_mouseOverEvt);
                  }

                  flag += container.dispatchEvt(this.m_mouseEvt);
                  this.m_evtContainer = container;
                }
              }
            }
          }
        } else {
          this.mouseOutEntity(evtFlowPhase, null, null, null);
          this.mouseOutContainer(evtFlowPhase, null, null, null);
          this.m_evtEntity = null;
          this.m_evtContainer = null;
          flag += this.mouseOutEventTarget();

          if (this.m_currStage != null) {
            for (i = 0; i < this.m_evtTotal; i++) {
              switch (this.m_evtTypes[i]) {
                case MouseEvent_1.default.MOUSE_DOWN:
                  this.m_currStage.mouseBgDown();
                  break;

                case MouseEvent_1.default.MOUSE_UP:
                  this.m_currStage.mouseBgUp();
                  break;

                case MouseEvent_1.default.MOUSE_CLICK:
                  this.m_currStage.mouseBgClick();
                  break;

                case MouseEvent_1.default.MOUSE_RIGHT_DOWN:
                  this.m_currStage.mouseBgRightDown();
                  break;

                case MouseEvent_1.default.MOUSE_RIGHT_UP:
                  this.m_currStage.mouseBgRightUp();
                  break;

                case MouseEvent_1.default.MOUSE_MIDDLE_DOWN:
                  this.m_currStage.mouseBgMiddleDown();
                  break;

                case MouseEvent_1.default.MOUSE_MIDDLE_UP:
                  this.m_currStage.mouseBgMiddleUp();
                  break;

                default:
                  break;
              }
            }
          }
        }

        if (this.m_currStage != null) {
          MouseEvt3DController.s_unlockMouseEvt = false;

          for (i = 0; i < this.m_evtTotal; i++) {
            switch (this.m_evtTypes[i]) {
              case MouseEvent_1.default.MOUSE_DOWN:
                this.m_currStage.mouseDown(2);
                break;

              case MouseEvent_1.default.MOUSE_UP:
                this.m_currStage.mouseUp(2);
                break;

              case MouseEvent_1.default.MOUSE_RIGHT_DOWN:
                this.m_currStage.mouseRightDown(2);
                break;

              case MouseEvent_1.default.MOUSE_RIGHT_UP:
                this.m_currStage.mouseRightUp(2);
                break;

              case MouseEvent_1.default.MOUSE_MIDDLE_DOWN:
                this.m_currStage.mouseMiddleDown(2);
                break;

              case MouseEvent_1.default.MOUSE_MIDDLE_UP:
                this.m_currStage.mouseMiddleUp(2);
                break;

              default:
                break;
            }
          }

          MouseEvt3DController.s_unlockMouseEvt = true;
        }
      }

      if (flag == 0 && dispatcher != null) {
        //任何 在 evtFlowPhase 值所代表的阶段的事件能被接收，则表示这个事件应该无法穿透到下一个过程
        flag = dispatcher.passTestPhase(evtFlowPhase);
      }
    }

    return flag > 0 ? 1 : 0;
  }

  mouseOutEntity(evtFlowPhase, entity, lpv, wpv) {
    if (this.m_evtEntity != null && this.m_evtEntity != entity) {
      let dispatcher = this.m_evtEntity.getEvtDispatcher(MouseEvent_1.default.EventClassType);

      if (dispatcher != null) {
        this.m_mouseOutEvt.phase = evtFlowPhase;
        this.m_mouseOutEvt.type = MouseEvent_1.default.MOUSE_OUT;
        this.m_mouseOutEvt.mouseX = this.m_mouseEvt.mouseX;
        this.m_mouseOutEvt.mouseY = this.m_mouseEvt.mouseY;
        this.m_mouseOutEvt.target = this.m_evtEntity;
        this.m_mouseOverEvt.currentTarget = this.m_evtEntity;
        if (lpv != null) this.m_mouseOutEvt.lpos.copyFrom(lpv);
        if (wpv != null) this.m_mouseOutEvt.wpos.copyFrom(wpv);
        this.m_raySelector.getRay(this.m_mouseOutEvt.raypv, this.m_mouseOutEvt.raytv);
        return dispatcher.dispatchEvt(this.m_mouseOutEvt);
      }
    }

    return 0;
  }

  mouseOutContainer(evtFlowPhase, container, lpv, wpv) {
    if (this.m_evtContainer != null && this.m_evtContainer != container) {
      this.m_mouseOutEvt.phase = evtFlowPhase;
      this.m_mouseOutEvt.type = MouseEvent_1.default.MOUSE_OUT;
      this.m_mouseOutEvt.mouseX = this.m_mouseEvt.mouseX;
      this.m_mouseOutEvt.mouseY = this.m_mouseEvt.mouseY;
      this.m_mouseOutEvt.target = this.m_evtContainer;
      this.m_mouseOutEvt.currentTarget = null;
      if (lpv != null) this.m_mouseOutEvt.lpos.copyFrom(lpv);
      if (wpv != null) this.m_mouseOutEvt.wpos.copyFrom(wpv);
      this.m_raySelector.getRay(this.m_mouseOutEvt.raypv, this.m_mouseOutEvt.raytv); //console.log("mouse out 01."+this.m_evtEntity.name);

      return this.m_evtContainer.dispatchEvt(this.m_mouseOutEvt);
    }

    return 0;
  }

  runEnd() {
    this.m_evtTotal = 0;
    this.m_mouseEvt.type = 0;
  }

  reset() {
    this.m_evtTotal = 0;
  }

  getEvtType() {
    return this.m_mouseEvt.type;
  }

  isSelected() {
    return this.m_raySelector.getSelectedNode() != null;
  }

  lock() {
    this.m_unlockBoo = false;
  }

  unlock() {
    this.m_unlockBoo = true;
  }

  isUnlock() {
    return this.m_unlockBoo;
  }

}

MouseEvt3DController.s_unlockMouseEvt = true;
MouseEvt3DController.s_uid = 0;
exports.default = MouseEvt3DController;

/***/ }),

/***/ "7696":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// RenderProcess 实例实际上可以被外部功能块直接使用,以便实现具体渲染目的
// 只能在 RenderWorld 中创建

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderSortBlock_1 = __importDefault(__webpack_require__("264c"));

const RPOBlock_1 = __importDefault(__webpack_require__("5f3c"));

const ROTransPool_1 = __importDefault(__webpack_require__("9156"));

class RenderProcess {
  constructor(shader, rpoNodeBuilder, rpoUnitBuilder, vtxResource, batchEnabled, processFixedState) {
    // 记录自身所在的 rendererInstance id
    this.m_rcuid = -1; // 记录自身所在 rendererInstance 中分配到的process index

    this.m_rpIndex = -1;
    this.m_nodesLen = 0;
    this.m_enabled = true;
    this.m_blockList = []; // 记录以相同shader的node为一个集合对象(RPOBlock) 的数组

    this.m_blockListLen = 0;
    this.m_blockFList = new Int8Array(RenderProcess.s_max_shdTotal); // 记录以相同shader的node为一个集合对象(RPOBlock)的构建状态 的数组

    this.m_blockFListLen = RenderProcess.s_max_shdTotal; // 假定引擎中同时存在的最多的shader 有1024种

    this.m_shader = null;
    this.m_rpoNodeBuilder = null;
    this.m_rpoUnitBuilder = null;
    this.m_vtxResource = null; // 用于制定对象的绘制

    this.m_fixBlock = null;
    this.m_sortBlock = null;
    this.m_sorter = null;
    this.m_batchEnabled = true;
    this.m_fixedState = true;
    this.m_sortEnabled = false;
    this.m_version = 0;
    this.uid = -1;
    this.m_shader = shader;
    this.m_rpoNodeBuilder = rpoNodeBuilder;
    this.m_rpoUnitBuilder = rpoUnitBuilder;
    this.m_vtxResource = vtxResource;
    this.m_fixBlock = this.createBlock();
    this.m_batchEnabled = batchEnabled;
    this.m_fixedState = processFixedState;

    for (let k = 0; k < this.m_blockFListLen; ++k) {
      this.m_blockFList[k] = -1;
    }
  }

  createBlock() {
    let block = new RPOBlock_1.default(this.m_shader);
    block.rpoNodeBuilder = this.m_rpoNodeBuilder;
    block.rpoUnitBuilder = this.m_rpoUnitBuilder;
    block.vtxResource = this.m_vtxResource;
    return block;
  }

  setRenderParam(batchEnabled, processFixedState) {
    if (this.m_blockListLen < 1) {
      this.m_batchEnabled = batchEnabled;
      this.m_fixedState = processFixedState;
    }
  }

  setRendererParam(rc, rpIndex) {
    this.m_rc = rc;
    this.m_rcuid = rc.getRCUid();
    this.m_rpIndex = rpIndex;
  }

  getUid() {
    return this.uid;
  }

  getRCUid() {
    return this.m_rcuid;
  }

  getRPIndex() {
    return this.m_rpIndex;
  }

  hasSorter() {
    return this.m_sorter != null;
  }

  setSorter(sorter) {
    this.m_sorter = sorter;

    if (this.m_sortBlock != null) {
      this.m_sortBlock.setSorter(sorter);
    }
  }

  setSortEnabled(sortEnabled) {
    if (this.m_nodesLen < 1) {
      this.m_sortEnabled = sortEnabled;
    } else if (this.m_sortBlock != null) {
      this.m_sortBlock.sortEnabled = sortEnabled;
    }
  }

  getSortEnabled() {
    return this.m_sortEnabled;
  }

  getUnitsTotal() {
    return this.m_nodesLen;
  }

  addNodeToBlock(node) {
    //  注意，这里可以管理组合方式, 例如可以做更多条件的排序
    //  这里依赖的是 shader program 和 vtx uid 来分类
    let block = null; //console.log("RenderProcess::addDisp(),uid: "+this.m_rpIndex+" node.shdUid: "+node.shdUid+", index: "+this.uid);

    if (node.shdUid >= RenderProcess.s_max_shdTotal) {
      throw Error("Shader uid >= " + RenderProcess.s_max_shdTotal);
    }

    if (this.m_blockFList[node.shdUid] < 0) {
      block = this.createBlock();
      block.batchEnabled = this.m_batchEnabled;
      block.fixedState = this.m_fixedState;

      if (block.batchEnabled) {
        if (block.fixedState) {
          block.runMode = 2;
        } else {
          block.runMode = 1;
        }
      } else {
        block.runMode = 0;
      }

      block.shdUid = node.shdUid;
      block.index = this.m_blockListLen;
      block.procuid = this.m_rpIndex;
      this.m_blockList.push(block);
      this.m_blockFList[node.shdUid] = this.m_blockListLen;
      ++this.m_blockListLen; //  console.log("RenderProcess::addDisp(), this.uid: ",this.getUid());
      //  console.log("RenderProcess::addDisp(), create a new RPOBlock instance, block: ",block);
      //  console.log("RenderProcess::addDisp(), create a new RPOBlock instance, this.m_blockList: ",this.m_blockList);
    } else {
      //console.log("RenderProcess::addDisp(), use old RPOBlock instance, m_blockFList["+node.shdUid+"]: "+this.m_blockFList[node.shdUid]);
      block = this.m_blockList[this.m_blockFList[node.shdUid]];
    }

    node.index = block.index;
    block.addNode(node);
  }

  rejoinRunitForTro(runit) {
    let node = this.m_rpoNodeBuilder.getNodeByUid(runit.__$rpuid);

    if (node != null) {
      node.tro = runit.tro;
      node.texMid = node.unit.texMid;
      this.m_blockList[node.index].rejoinNode(node);
    }
  }

  rejoinRunitForVro(runit) {
    let node = this.m_rpoNodeBuilder.getNodeByUid(runit.__$rpuid);

    if (node != null) {
      node.drawMode = runit.drawMode;
      node.ivsIndex = runit.ivsIndex;
      node.ivsCount = runit.ivsCount;
      node.insCount = runit.insCount;
      runit.drawOffset = runit.ivsIndex * runit.ibufStep;
      node.vtxUid = runit.vtxUid;
      node.vro = runit.vro;
      this.m_blockList[node.index].rejoinNode(node);
      this.m_version++;
    }
  }

  addDisp(disp) {
    if (disp != null) {
      if (disp.__$$runit != null && disp.__$$runit.getRPROUid() < 0) {
        if (disp.__$$runit.getRPROUid() != this.uid) {
          //console.log("RenderProcess("+this.uid+"), addDisp: ",disp.ivsCount,disp,disp.drawMode);
          let node = this.m_rpoNodeBuilder.create();
          node.unit = this.m_rpoUnitBuilder.getNodeByUid(disp.__$ruid);
          node.unit.shader = this.m_shader;
          node.unit.__$rprouid = this.uid;
          disp.__$rpuid = node.uid;
          node.__$ruid = disp.__$ruid;
          node.unit.__$rpuid = node.uid;
          node.updateData();
          ++this.m_nodesLen; //this.m_rpoUnitBuilder.setRPNodeParam(disp.__$ruid, this.m_rpIndex, node.uid);

          this.m_rpoUnitBuilder.setRPNodeParam(disp.__$ruid, this.getUid(), node.uid);

          if (this.m_sortEnabled) {
            console.log("sort process add a disp...");

            if (this.m_sortBlock != null) {
              this.m_sortBlock.addNode(node);
            } else {
              this.m_sortBlock = new RenderSortBlock_1.default(this.m_shader);
              this.m_sortBlock.setSorter(this.m_sorter);
              this.m_sortBlock.addNode(node);
            }
          } else {
            this.addNodeToBlock(node);
          }

          this.m_version++;
        } else {
          console.log("RenderProcess::addDisp(), Warn: add entity repeat in processid(" + this.m_rpIndex + ").");
        }
      }
    }
  }

  updateDispMateiral(disp) {
    if (disp.__$$runit != null) {
      let nodeUId = disp.__$$runit.getRPOUid();

      let node = this.m_rpoNodeBuilder.getNodeByUid(nodeUId); // material info etc.

      node.shdUid = node.unit.shdUid;
      node.texMid = node.unit.texMid;
      node.tro = node.unit.tro;
      let block = this.m_blockList[node.index];
      block.removeNode(node);
      this.addNodeToBlock(node);
    }
  }

  removeDisp(disp) {
    if (disp != null) {
      if (disp.__$$runit != null) {
        let nodeUId = disp.__$$runit.getRPOUid();

        let node = this.m_rpoNodeBuilder.getNodeByUid(nodeUId); //  console.log("removeDisp(), nodeUId: ",nodeUId, ", this.uid: ",this.getUid());
        //  console.log("removeDisp(), node != null: "+(node != null),", this.m_blockList: ",this.m_blockList);

        if (node != null) {
          let runit = node.unit;
          let transU = runit.transUniform;

          if (transU != null) {
            ROTransPool_1.default.RemoveTransUniform(transU.key);
          }

          if (this.m_sortBlock == null) {
            let block = this.m_blockList[node.index];
            block.removeNode(node);
          } else {
            this.m_sortBlock.removeNode(node);
          } // this.m_rpoUnitBuilder.setRPNodeParam(disp.__$ruid, this.m_rpIndex, -1);


          this.m_rpoUnitBuilder.setRPNodeParam(disp.__$ruid, this.getUid(), -1);
          --this.m_nodesLen;

          if (this.m_rpoNodeBuilder.restore(node)) {
            this.m_rpoUnitBuilder.restore(runit);
          }

          this.m_vtxResource.__$detachRes(disp.vbuf.getUid());

          disp.__$$runit = null;
          disp.__$ruid = -1;
          this.m_version++;
        } else {
          console.error("There is no this display instance.");
        }
      }
    }
  }

  getStatus() {
    return this.m_version;
  }
  /**
   * remoev display unit from this render process
   */


  removeDispUnit(disp) {
    if (disp != null) {
      if (disp.__$ruid > -1) {
        let nodeUId = disp.__$$runit.getRPOUid();

        let node = this.m_rpoNodeBuilder.getNodeByUid(nodeUId);

        if (node != null) {
          if (this.m_sortBlock == null) {
            let block = this.m_blockList[node.index];
            block.removeNode(node);
          } else {
            this.m_sortBlock.removeNode(node);
          }

          this.m_rpoUnitBuilder.setRPNodeParam(disp.__$ruid, this.m_rpIndex, -1);
          node.unit.__$rprouid = -1;
          --this.m_nodesLen;
          this.m_rpoNodeBuilder.restore(node);
        }
      }
    }
  }

  update() {
    if (this.m_enabled && this.m_nodesLen > 0) {
      if (this.m_sortBlock != null) {
        this.m_sortBlock.update();
      }
    }
  }

  run() {
    if (this.m_enabled && this.m_nodesLen > 0) {
      let rc = this.m_rc;

      if (this.m_sortBlock == null) {
        if (this.m_shader.isUnLocked()) {
          for (let i = 0; i < this.m_blockListLen; ++i) {
            this.m_blockList[i].run(rc);
          }
        } else {
          for (let i = 0; i < this.m_blockListLen; ++i) {
            this.m_blockList[i].runLockMaterial(rc);
          }
        }
      } else {
        if (this.m_shader.isUnLocked()) {
          this.m_sortBlock.run(rc);
        } else {
          this.m_sortBlock.runLockMaterial(rc);
        }
      }
    }
  }

  drawDisp(disp, useGlobalUniform = false, forceUpdateUniform = true) {
    if (disp != null) {
      let unit = disp.__$$runit;

      if (unit != null) {
        if (this.m_shader.isUnLocked()) {
          if (forceUpdateUniform) {
            this.m_shader.resetUniform();
          }

          this.m_fixBlock.drawUnit(this.m_rc, unit, disp);
        } else {
          this.m_fixBlock.drawLockMaterialByUnit(this.m_rc, unit, disp, useGlobalUniform, forceUpdateUniform);
        }
      }
    }
  }
  /**
   * Deprecated(不推荐使用)
   */


  drawLockMaterialByDisp(disp, useGlobalUniform = false, forceUpdateUniform = true) {
    if (disp != null) {
      let unit = disp.__$$runit;

      if (unit != null) {
        this.m_fixBlock.drawLockMaterialByUnit(this.m_rc, unit, disp, useGlobalUniform, forceUpdateUniform);
      }
    }
  }

  reset() {
    this.m_sortEnabled = false;
    this.m_nodesLen = 0;
    this.uid = -1;
    this.m_rpIndex = -1;
    this.m_rcuid = -1;
    this.m_rpIndex = -1;
    let i = 0;

    for (; i < this.m_blockListLen; ++i) {
      this.m_blockList[i].reset();
    }

    this.m_blockListLen = 0;
    this.m_blockList = [];
    this.m_rpoNodeBuilder = null;
    this.m_rpoUnitBuilder = null;
    this.m_vtxResource = null;
    this.m_rc = null;

    if (this.m_sortBlock != null) {
      this.m_sortBlock.clear();
      this.m_sortBlock = null;
    }
  }

  showInfo() {
    let i = 0;

    for (; i < this.m_blockListLen; ++i) {
      this.m_blockList[i].showInfo();
    }
  }

  destroy() {
    this.reset();
  }

  setEnabled(boo) {
    this.m_enabled = boo;
  }

  getEnabled() {
    return this.m_enabled;
  }

  toString() {
    return "[RenderProcess(uid = " + this.m_rpIndex + ")]";
  }

}

RenderProcess.s_max_shdTotal = 1024;
exports.default = RenderProcess;

/***/ }),

/***/ "78e9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MaterialConst_1 = __importDefault(__webpack_require__("644c"));

class UniformLine {
  constructor() {
    this.type = -1;
    this.typeName = "";
    this.name = "";
    this.isArray = false;
    this.arrLength = 0;
    this.isTex = false;
    this.location = null;
  }

  parseCode(codeStr) {
    const SEMICOLON = ";";
    let i = codeStr.indexOf(SEMICOLON);

    if (i < 0) {
      return false;
    }

    const SPACE = " ";
    codeStr = codeStr.replace(/^\s*|\s*$/g, "");
    if (i > 0) codeStr = codeStr.slice(0, i);
    let arr = codeStr.split(SPACE);
    this.typeName = arr[arr.length - 2];
    this.name = arr[arr.length - 1];
    i = this.name.indexOf("[");
    this.isArray = i > 0;
    this.arrLength = 0;

    if (this.isArray) {
      this.arrLength = parseInt(this.name.slice(i + 1, this.name.indexOf("]", i + 1)));
      this.name = this.name.slice(0, i);
      this.typeName += "[]";
    }

    this.type = MaterialConst_1.default.GetTypeByTypeNS(this.typeName); //console.log("#### this.type: ",this.type,", this.typeName: ",this.typeName);

    if (this.type < 0) {
      return false;
    }

    this.isTex = this.type == MaterialConst_1.default.SHADER_SAMPLER2D || this.type == MaterialConst_1.default.SHADER_SAMPLERCUBE || this.type == MaterialConst_1.default.SHADER_SAMPLER3D;
    return true;
  }

}

exports.default = UniformLine;

/***/ }),

/***/ "7918":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var TextureProxyType;

(function (TextureProxyType) {
  TextureProxyType[TextureProxyType["Default"] = 0] = "Default";
  /**
   * for DepthTextureProxy class
   */

  TextureProxyType[TextureProxyType["Depth"] = 1] = "Depth";
  /**
   * for WrapperTextureProxy class
   */

  TextureProxyType[TextureProxyType["Wrapper"] = 2] = "Wrapper";
  /**
   * for RTTTextureProxy class
   */

  TextureProxyType[TextureProxyType["RTT"] = 3] = "RTT";
  /**
   * for ImageTextureProxy class
   */

  TextureProxyType[TextureProxyType["Image"] = 4] = "Image";
  /**
   * for FloatTextureProxy class
   */

  TextureProxyType[TextureProxyType["Float"] = 5] = "Float";
  /**
   * for Uint16TextureProxy class
   */

  TextureProxyType[TextureProxyType["Uint16"] = 6] = "Uint16";
  /**
   * for FloatCubeTextureProxy class
   */

  TextureProxyType[TextureProxyType["FloatCube"] = 7] = "FloatCube";
  /**
   * for BytesTextureProxy class
   */

  TextureProxyType[TextureProxyType["Bytes"] = 8] = "Bytes";
  /**
   * for BytesCubeTextureProxy class
   */

  TextureProxyType[TextureProxyType["BytesCube"] = 9] = "BytesCube";
  /**
   * for ImageCubeTextureProxy class
   */

  TextureProxyType[TextureProxyType["ImageCube"] = 10] = "ImageCube";
  /**
   * for Texture3DProxy class
   */

  TextureProxyType[TextureProxyType["Texture3D"] = 11] = "Texture3D";
})(TextureProxyType || (TextureProxyType = {}));

exports.TextureProxyType = TextureProxyType;

/***/ }),

/***/ "7a04":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufID_1 = __importDefault(__webpack_require__("f044"));

class VtxSeparatedBuf {
  constructor() {
    this.m_uid = -1;
    this.m_total = 0;
    this.layoutBit = 0x0;
    this.m_fOffsetList = null; //private m_pOffsetList:number[] = null;

    this.m_f32List = null;
    this.m_f32SizeList = null; //private m_f32PreSizeList: number[] = null;

    this.m_f32ChangedList = null;
    this.m_f32Bufs = null;
    this.m_bufersTotal = 0;
    this.m_uid = VtxBufID_1.default.CreateNewID();
  }

  getUid() {
    return this.m_uid;
  }

  getType() {
    return 1;
  } // private m_stepFloatsTotal: number = 0;


  getBuffersTotal() {
    return this.m_bufersTotal;
  }

  getAttribsTotal() {
    return this.m_bufersTotal;
  }

  getF32DataAt(index) {
    return this.m_f32List[index];
  }

  setF32DataAt(index, float32Arr, stepFloatsTotal, setpOffsets) {
    if (index < 1) this.m_bufersTotal = 1;else this.m_bufersTotal = index + 1;

    if (this.m_f32List == null) {
      this.m_f32List = [null, null, null, null, null, null, null, null];
      this.m_f32ChangedList = [false, false, false, false, false, false, false, false];
      this.m_f32SizeList = [0, 0, 0, 0, 0, 0, 0, 0]; //this.m_f32PreSizeList = [0, 0, 0, 0, 0, 0, 0, 0];
    }

    this.m_f32List[index] = float32Arr;

    if (this.m_f32Bufs != null && float32Arr != null) {
      this.m_f32ChangedList[index] = true;
    }

    if (setpOffsets != null) this.m_fOffsetList = setpOffsets; // console.log("VtxSeparatedBuf::setF32DataAt(), this.m_bufersTotal: ",this.m_bufersTotal);

    if (float32Arr != null) {
      this.m_f32SizeList[index] = float32Arr.length;
    }
  }

  setData4fAt(vertexI, attribI, px, py, pz, pw) {
    vertexI *= this.m_fOffsetList[attribI];
    this.m_f32List[attribI][vertexI++] = px;
    this.m_f32List[attribI][vertexI++] = py;
    this.m_f32List[attribI][vertexI++] = pz;
    this.m_f32List[attribI][vertexI++] = pw;
  }

  setData3fAt(vertexI, attribI, px, py, pz) {
    vertexI *= this.m_fOffsetList[attribI];
    this.m_f32List[attribI][vertexI++] = px;
    this.m_f32List[attribI][vertexI++] = py;
    this.m_f32List[attribI][vertexI++] = pz;
  }

  setData2fAt(vertexI, attribI, px, py) {
    vertexI *= this.m_fOffsetList[attribI];
    this.m_f32List[attribI][vertexI++] = px;
    this.m_f32List[attribI][vertexI++] = py;
  }

  destroy() {
    this.m_f32List = null;
    this.m_f32ChangedList = null;
    this.m_f32SizeList = null; //this.m_f32PreSizeList = null;

    console.log("VtxSeparatedBuf::__$destroy()... ", this);
    this.m_f32List = null;
  }

  toString() {
    return "VtxSeparatedBuf(uid = " + this.m_uid + ")";
  }

}

exports.default = VtxSeparatedBuf;

/***/ }),

/***/ "7a08":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 数据文件类型，例如 ctm, draco
 */

var DataFormat;

(function (DataFormat) {
  DataFormat["CTM"] = "ctm";
  DataFormat["Draco"] = "draco";
  DataFormat["OBJ"] = "obj";
  DataFormat["FBX"] = "fbx";
  DataFormat["GLB"] = "glb";
  DataFormat["Jpg"] = "jpg";
  DataFormat["Png"] = "png";
  DataFormat["Gif"] = "gif";
})(DataFormat || (DataFormat = {}));

exports.DataFormat = DataFormat;

/***/ }),

/***/ "7b0e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererConst_1 = __importDefault(__webpack_require__("bbf4"));

class Entity3DNode {
  constructor() {
    this.uid = -1;
    this.rstatus = 0;
    /**
     * project occlusion culling test enabled
     */

    this.pcoEnabled = false;
    this.drawEnabled = true;
    this.prev = null;
    this.next = null;
    this.entity = null;
    this.bounds = null;
    this.rayTestState = 0;
    this.rpoNode = null;
    this.spaceId = -1; // 记录上一次摄像机裁剪自身的状态

    this.camVisiSt = 0; // 记录摄像机可见状态,大于0表示不可见

    this.camVisi = RendererConst_1.default.CAMERA_VISIBLE_ENABLE;
  }

  reset() {
    this.rayTestState = 0;
    this.uid = -1;
    this.rstatus = 0;
    this.pcoEnabled = false;
    this.drawEnabled = true;
    this.prev = null;
    this.next = null;
    this.entity = null;
    this.bounds = null;
    this.rpoNode = null;
    this.spaceId = -1;
    this.camVisi = 0;
  }

  static GetFreeId() {
    if (Entity3DNode.m_freeIds.length > 0) {
      return Entity3DNode.m_freeIds.pop();
    }

    return -1;
  }

  static GetByUid(uid) {
    if (uid > -1 && uid < Entity3DNode.m_nodesLen) {
      return Entity3DNode.m_nodes[uid];
    }

    return null;
  }

  static SetCamVisiByUid(uid, status) {
    Entity3DNode.m_nodes[uid].camVisi = status;
  }

  static GetCamVisiByUid(uid) {
    return Entity3DNode.m_nodes[uid].camVisi;
  }

  static Create() {
    let node = null;
    let index = Entity3DNode.GetFreeId();

    if (index >= 0) {
      node = Entity3DNode.m_nodes[index];
      node.uid = index;
      Entity3DNode.m_flags[index] = Entity3DNode.s_b;
    } else {
      // create a new nodeIndex
      node = new Entity3DNode();
      Entity3DNode.m_nodes.push(node);
      Entity3DNode.m_flags.push(Entity3DNode.s_b);
      node.uid = Entity3DNode.m_nodesLen;
      Entity3DNode.m_nodesLen++;
    }

    return node;
  }

  static Restore(pnode) {
    if (pnode != null && pnode.uid >= 0 && Entity3DNode.m_flags[pnode.uid] == Entity3DNode.s_b) {
      Entity3DNode.m_freeIds.push(pnode.uid);
      Entity3DNode.m_flags[pnode.uid] = Entity3DNode.s_f;
      pnode.reset();
    }
  }

} // busy


Entity3DNode.s_b = 1; // free

Entity3DNode.s_f = 0;
Entity3DNode.m_nodesLen = 0;
Entity3DNode.m_nodes = [];
Entity3DNode.m_flags = [];
Entity3DNode.m_freeIds = [];
exports.default = Entity3DNode;

/***/ }),

/***/ "7b29":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("a996"));

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

const MouseEvt3DDispatcher_1 = __importDefault(__webpack_require__("badb"));

class StageBase {
  constructor(rcuid) {
    this.m_rcuid = 0;
    this.m_viewX = 0.0;
    this.m_viewY = 0.0;
    this.m_viewW = 1.0;
    this.m_viewH = 1.0;
    this.m_stW = 800;
    this.m_stH = 600; // mouse event dispatcher

    this.m_dp = new MouseEvt3DDispatcher_1.default(); // 是否舞台尺寸和view自动同步一致

    this.m_autoSynViewAndStageSize = true;
    this.m_preStageWidth = 0;
    this.m_preStageHeight = 0;
    this.m_mouseEvt = new MouseEvent_1.default();
    this.m_baseEvt = new EventBase_1.default();
    this.uProbe = null;
    this.pixelRatio = 1.0;
    this.stageWidth = 800;
    this.stageHeight = 600; // 实际宽高, 和gpu端对齐

    this.stageHalfWidth = 400;
    this.stageHalfHeight = 300;
    this.mouseX = 0;
    this.mouseY = 0; // sdiv页面实际占据的像素宽高

    this.viewWidth = 800;
    this.viewHeight = 600;
    this.mouseViewX = 0;
    this.mouseViewY = 0;
    this.m_rcuid = rcuid;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }

  getViewX() {
    return this.m_viewX;
  }

  getViewY() {
    return this.m_viewY;
  }

  getViewWidth() {
    return this.m_viewW;
  }

  getViewHeight() {
    return this.m_viewH;
  }

  dispatchMouseEvt(phase, tar = null) {
    const evt = this.m_mouseEvt;
    evt.mouseX = this.mouseX;
    evt.mouseY = this.mouseY;
    evt.target = tar == null ? this : tar;
    evt.phase = phase;
    this.m_dp.dispatchEvt(this.m_mouseEvt);
  }

  mouseDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseDoubleClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_DOUBLE_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseRightDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseRightUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseMiddleDown(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MIDDLE_DOWN;
    this.dispatchMouseEvt(phase);
  }

  mouseMiddleUp(phase = 1) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MIDDLE_UP;
    this.dispatchMouseEvt(phase);
  }

  mouseBgDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_UP;
    this.dispatchMouseEvt(1);
  }

  mouseBgClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseBgRightDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_RIGHT_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgRightUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_RIGHT_UP;
    this.dispatchMouseEvt(1);
  }

  mouseBgMiddleDown() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_MIDDLE_DOWN;
    this.dispatchMouseEvt(1);
  }

  mouseBgMiddleUp() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_BG_MIDDLE_UP;
    this.dispatchMouseEvt(1);
  }

  mouseRightClick() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_RIGHT_CLICK;
    this.dispatchMouseEvt(1);
  }

  mouseMove() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MOVE;
    this.dispatchMouseEvt(1);
  }

  mouseWheel(evt) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_WHEEL;
    this.m_mouseEvt.wheelDeltaY = evt.wheelDeltaY;
    this.dispatchMouseEvt(1);
  } // 等同于 touchCancle


  mouseCancel() {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_CANCEL;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiDown(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_DOWN;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiUp(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_UP;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  } //param [{x,y},{x,y},...]


  mouseMultiMove(posArray) {
    this.m_mouseEvt.type = MouseEvent_1.default.MOUSE_MULTI_MOVE;
    this.m_mouseEvt.posArray = posArray;
    this.dispatchMouseEvt(1);
  }

  mouseWindowUp(phase = 1) {}

  mouseWindowRightUp(phase = 1) {}

  addTarget(funcs, listeners, target, func) {
    let i = 0;

    for (i = funcs.length - 1; i >= 0; --i) {
      if (target === listeners[i]) {
        break;
      }
    }

    if (i < 0) {
      listeners.push(target);
      funcs.push(func);
    }
  }

  removeTarget(funcs, listeners, target) {
    for (let i = funcs.length - 1; i >= 0; --i) {
      if (target === listeners[i]) {
        listeners.splice(i, 1);
        funcs.splice(i, 1);
        break;
      }
    }
  }

}

exports.default = StageBase;

/***/ }),

/***/ "7b85":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const SceneNode_1 = __webpack_require__("7577");

const DataUnit_1 = __webpack_require__("74ee"); // import { ObjDataParser } from "../../../vox/assets/ObjDataParser";
// import { FileLoader } from "../../modules/loaders/FileLoader";


class OBJSceneNode extends SceneNode_1.SceneNode {
  constructor() {
    super();
  }

  load(urls) {
    if (urls != null) {
      super.load(urls);
      this.m_showTotal = 0; // for (let i: number = 0; i < urls.length; ++i) {
      // 	this.loadOBJByUrl(urls[i]);
      // }

      if (urls.length > 0) {
        this.loadOBJByUrl(urls[0]);
      }
    }
  }

  loadOBJByUrl(url) {
    this.showInfo("正在解析obj模型数据...");
    this.m_cospace.geometry.getCPUDataByUrlAndCallback(url, DataUnit_1.DataFormat.OBJ, (unit, status) => {
      let models = unit.data.models;
      this.m_modelsTotal = models.length;
      let len = this.m_modelsTotal;

      for (let i = 0; i < len; ++i) {
        const model = models[i];

        if (model.vertices != null && model.normals == null) {
          console.error("model.normals == null, url: ", url);
        }

        this.initEntity(model);
      }

      this.m_waitPartsTotal = 0;
    }, true);
  } // private parseFromStr(dataStr: string): void {
  // 	let objParser = new ObjDataParser();
  // 	let objMeshes = objParser.Parse( dataStr );
  // 	this.m_modelsTotal = objMeshes.length;
  // 	let len: number = this.m_modelsTotal;
  // 	for (let i: number = 0; i < len; ++i) {
  // 		const geom: any = objMeshes[i].geometry;
  // 		const model = this.createModel( geom );
  // 		this.initEntity(model);
  // 	}
  // 	this.m_waitPartsTotal = 0;
  // }


  loadOBJByUrl2(url) {
    /*
    const readerBuf = new FileReader();
    readerBuf.onload = (e) => {
        this.showInfo("正在解析obj模型数据...");
        this.parseFromStr( <string>readerBuf.result );
    };
    let fileLoader: FileLoader = new FileLoader();
    fileLoader.load(
        url,
        (buf: ArrayBuffer, url: string): void => {
            readerBuf.readAsText( new Blob([buf]) );
        },
        (evt: ProgressEvent, url: string): void => {
            let k = Math.round(100 * evt.loaded/evt.total);
            this.showInfo("obj file loading " + k + "%");
        },
        (status: number, url: string): void => {
            console.error("load error, request.status: ",status,", url: ",url);
        }
    );
    return;
    const reader = new FileReader();
    reader.onload = (e) => {
        this.showInfo("正在解析obj模型数据...");
        this.parseFromStr( <string>reader.result );
    };
      const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "blob";
      request.onload = (e) => {
        console.log("loaded binary buffer request.status: ", request.status, e, request.response);
        if (request.status <= 206) {
            reader.readAsText(request.response);
        } else {
            console.error("load error, request.status: ",request.status,", url: ",url);
        }
    };
    request.onprogress = (e: ProgressEvent) => {
        let k = Math.round(100 * e.loaded/e.total);
        this.showInfo("obj file loading " + k + "%");
    }
    request.onerror = (e) => {
        console.error("load error, request.status: ",request.status,", url: ",url);
    };
    request.send(null);
    //*/

    /*
    let request: XMLHttpRequest = new XMLHttpRequest();
    request.open('GET', url, true);
    request.onload = () => {
        if (request.status <= 206 && request.responseText.indexOf(" OBJ ") > 0) {
            
            let objParser = new ObjDataParser();
            let objMeshes = objParser.Parse( request.responseText );
            this.m_modelsTotal = objMeshes.length;
            let len: number = this.m_modelsTotal;
            for (let i: number = 0; i < len; ++i) {
                const geom: any = objMeshes[i].geometry;
                const model = this.createModel( geom );
                this.initEntity(model);
            }
            this.m_waitPartsTotal = 0;
            
        }
        else {
            console.error("load obj format module url error: ", url);
        }
    };
    request.onerror = e => {
        console.error("load obj format module url error: ", url);
    };
    request.send(null);
    //*/
  }

}

exports.OBJSceneNode = OBJSceneNode;

/***/ }),

/***/ "7c58":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const TaskDataRouter_1 = __webpack_require__("3964");
/**
 * 处理子线程和主线程之间任务模块之间相互依赖的数据交互
 */


class DracoGeomParseTaskDataRouter extends TaskDataRouter_1.TaskDataRouter {
  constructor(taskclass, wasmUrl) {
    super(taskclass);
    this.m_triggerFlag = true;
    this.m_wasmUrl = wasmUrl;
  }

  setData(data) {
    // 这里不一定是直接赋值，可能要经过处理和转化
    this.m_wasmBinBuf = data.streams[0];
    this.m_dataEnabled = true;
  }
  /**
   * 由线程对象调用，以便启动数据处理的相应， 子类覆盖此函数以便实现具体的功能
   */


  acquireTrigger() {
    if (!this.isTransmission()) {
      if (this.m_triggerFlag) {
        // load wasm bin file
        let wasmXHR = new XMLHttpRequest();
        wasmXHR.open("GET", this.m_wasmUrl, true);
        wasmXHR.responseType = "arraybuffer";

        wasmXHR.onload = () => {
          console.log("loaded wasm binary.");
          this.m_wasmBinBuf = wasmXHR.response;
          this.m_dataEnabled = true;
        };

        wasmXHR.send(null);
        this.m_triggerFlag = false;
      }
    }
  }
  /**
   * 这个过程默认支持异步机制，如果有数据则使用，如果没数据，则进入到等待队列
   * @returns 线程初始化需要的数据。数据可内存共享的方式使用或者复制的方式使用
   */


  getData() {
    // 一旦获取数据就认为这个数据不可用了，直到重新得到数据为止
    this.m_dataEnabled = false; // 如果有，就直接返回，如果没有，则将自己加入到等等队列

    return {
      info: "draco wasm code file",
      streams: [this.m_wasmBinBuf]
    };
  }

  getTransfers() {
    return [this.m_wasmBinBuf];
  }

}

exports.DracoGeomParseTaskDataRouter = DracoGeomParseTaskDataRouter;

/***/ }),

/***/ "7c63":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderConst_1 = __webpack_require__("e08e");

class ROStateUnit {
  constructor() {
    this.stencilMask = -1;
  }

}

class RODrawState {
  constructor() {
    this.m_units = new Array(128);
    this.m_unit = null;
    this.m_blendMode = RenderConst_1.RenderBlendMode.NORMAL;
    this.m_cullMode = RenderConst_1.CullFaceMode.NONE;
    this.m_depthTestType = RenderConst_1.DepthTestMode.DISABLE;
    this.m_cullDisabled = true;
    this.m_context = null;
    this.m_gl = null;
    this.roColorMask = -11;
  }

  reset() {
    this.roColorMask = -11;
  }

  setRenderContext(context) {
    this.m_context = context;
    this.m_gl = context.getRC();
    let rcui = this.m_gl.rcuid;
    this.m_unit = this.m_units[rcui];

    if (this.m_unit == null) {
      this.m_unit = this.m_units[rcui] = new ROStateUnit();
    }
  }

  setColorMask(mr, mg, mb, ma) {
    this.m_gl.colorMask(mr, mg, mb, ma);
  }

  setStencilFunc(func, ref, mask) {
    this.m_gl.stencilFunc(func, ref, mask);
  }

  setStencilMask(mask) {
    if (this.m_unit.stencilMask != mask && mask >= 0) {
      this.m_unit.stencilMask = mask;
      this.m_gl.stencilMask(mask);
    }
  }

  setStencilOp(fail, zfail, zpass) {
    this.m_gl.stencilOp(fail, zfail, zpass);
  }

  setDepthTestEnable(enable) {
    if (enable) {
      this.m_gl.enable(this.m_gl.DEPTH_TEST);
    } else {
      this.m_gl.disable(this.m_gl.DEPTH_TEST);
    }
  }

  setCullFaceEnable(enable) {
    if (enable) {
      this.m_gl.enable(this.m_gl.CULL_FACE);
    } else {
      this.m_gl.disable(this.m_gl.CULL_FACE);
    }
  }

  setBlendEnable(enable) {
    if (enable) {
      this.m_gl.enable(this.m_gl.BLEND);
    } else {
      this.m_gl.disable(this.m_gl.BLEND);
    }
  }

  setCullFaceMode(mode) {
    if (this.m_cullMode != mode) {
      this.m_cullMode = mode;

      if (mode != RenderConst_1.CullFaceMode.NONE) {
        if (this.m_cullDisabled) {
          this.m_cullDisabled = false;
          this.m_gl.enable(this.m_gl.CULL_FACE);
        }

        this.m_gl.cullFace(mode);
      } else if (!this.m_cullDisabled) {
        this.m_cullDisabled = true;
        this.m_gl.disable(this.m_gl.CULL_FACE);
      }
    }
  }

  setBlendMode(mode, params) {
    if (this.m_blendMode != mode) {
      // if(DebugFlag.Flag_0 > 0) {
      //     console.log("this.m_blendMode: ",this.m_blendMode,",mode: ",mode,",params: ", params);
      // }
      this.m_blendMode = mode;

      if (mode > 0) {
        if (params[0] < 1) {
          //FUNC_ADD
          // this.m_gl.blendEquation(this.m_gl.FUNC_ADD);
          // this.m_gl.blendFunc(this.m_gl.ONE, this.m_gl.ZERO);
          this.m_gl.blendEquation(params[1]);
          this.m_gl.blendFunc(params[3], params[4]);
        } else {
          this.m_gl.blendEquationSeparate(params[1], params[2]);
          this.m_gl.blendFuncSeparate(params[3], params[4], params[5], params[6]);
        }
      } else {
        this.m_gl.disable(this.m_gl.BLEND);
      }
    }
  }

  getDepthTestMode() {
    return this.m_depthTestType;
  }

  setDepthTestMode(type) {
    if (this.m_depthTestType != type) {
      const gl = this.m_gl;
      const DTM = RenderConst_1.DepthTestMode;
      this.m_depthTestType = type; //trace("RendererBase::setDepthTest(),type：",std::to_string(static_cast<int>(type)));

      switch (type) {
        case DTM.ALWAYS:
          //console.log("ALWAYS type: ", type,gl.ALWAYS);
          gl.depthMask(false);
          gl.depthFunc(gl.ALWAYS);
          break;

        case DTM.SKY:
          gl.depthMask(true);
          gl.depthFunc(gl.LEQUAL);
          break;

        case DTM.OPAQUE:
          //console.log("OPAQUE type: ", type,gl.LESS);
          gl.depthMask(true);
          gl.depthFunc(gl.LESS);
          break;

        case DTM.OPAQUE_OVERHEAD:
          gl.depthMask(false);
          gl.depthFunc(gl.EQUAL);
          break;

        case DTM.DECALS:
          gl.depthMask(false);
          gl.depthFunc(gl.LEQUAL);
          break;

        case DTM.BLEND:
          gl.depthMask(false);
          gl.depthFunc(gl.LESS);
          break;

        case DTM.WIRE_FRAME:
          gl.depthMask(true);
          gl.depthFunc(gl.LEQUAL);
          break;

        case DTM.NEXT_LAYER:
          gl.depthMask(false);
          gl.depthFunc(gl.ALWAYS);
          break;

        case DTM.TRUE_EQUAL:
          gl.depthMask(true);
          gl.depthFunc(gl.EQUAL);
          break;

        case DTM.TRUE_GREATER:
          gl.depthMask(true);
          gl.depthFunc(gl.GREATER);
          break;

        case DTM.TRUE_GEQUAL:
          gl.depthMask(true);
          gl.depthFunc(gl.GEQUAL);
          break;

        case DTM.WIRE_FRAME_NEXT:
          break;

        default:
          break;
      }
    }
  }

}

exports.RODrawState = RODrawState;

/***/ }),

/***/ "7dbf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadTask_1 = __webpack_require__("83a3");

const TaskDependency_1 = __webpack_require__("3b80");

const CTMTaskCMD_1 = __webpack_require__("1f9e");
/**
 * ctm 几何模型数据加载/解析任务对象
 */


class CTMParseTask extends ThreadTask_1.ThreadTask {
  /**
   * @param src 子线程中代码模块的js文件url 或者 依赖的唯一名称
   */
  constructor(src) {
    super();
    this.m_listener = null;

    if (src.indexOf("/") > 0) {
      this.dependency = new TaskDependency_1.TaskJSFileDependency(src);
    } else {
      this.dependency = new TaskDependency_1.TaskUniqueNameDependency(src);
    }
  }

  setListener(l) {
    this.m_listener = l;
  }

  addBinaryData(buffer, url) {
    if (buffer != null) {
      this.addDataWithParam(CTMTaskCMD_1.CTMTaskCMD.PARSE, [buffer], {
        url: url
      });
    }
  }

  addURL(url) {
    if (url != "") {
      this.addDataWithParam(CTMTaskCMD_1.CTMTaskCMD.LOAD_AND_PARSE, null, {
        url: url
      });
    }
  } // return true, task finish; return false, task continue...


  parseDone(data, flag) {
    // console.log("CTMParseTask::parseDone(), this.m_listener != null:", this.m_listener != null, data);
    if (this.m_listener != null) {
      let model = data.data;
      if (model.normals == undefined) model.normals = null;
      if (model.uvsList == undefined) model.uvsList = null;
      this.m_listener.ctmParseFinish(model, data.descriptor.url);
    }

    return true;
  }

  destroy() {
    super.destroy();
    this.m_listener = null;
  }

}

exports.CTMParseTask = CTMParseTask;

/***/ }),

/***/ "7de1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnitPool_1 = __webpack_require__("a092");

const DataReceiverBase_1 = __webpack_require__("2033");
/**
 * 内置的资源接收器
 */


class ResourceReceiver extends DataReceiverBase_1.DataReceiverBase {
  constructor() {
    super();
    ResourceReceiver.s_total++; // console.log("### ResourceReceiver.s_total: ",ResourceReceiver.s_total);
  }

  receiveDataUnit(unit, status) {
    // console.log("ResourceReceiver::receiveDataUnit(), unit: ", unit);
    let callback = this.callback;
    this.callback = null;

    if (callback != null) {
      callback(unit, status);
    }
  }

}

ResourceReceiver.s_total = 0;

class ReqNode {
  constructor() {}

  reset() {
    this.receiver = null;
    this.unit = null;
  }

}
/**
 * 数据资源调度器基类
 */


class ResourceSchedule {
  constructor() {
    this.m_receiverSchedule = null;
    this.m_unitPool = new DataUnitPool_1.DataUnitPool(); // private m_taskModuleUrls: string[] = null;

    this.m_taskModules = null;
    this.m_reqNodes = [];
  }
  /**
   * 被子类覆盖，以便实现具体功能
   */


  createDataUnit(url, dataFormat, immediate = false) {
    return null;
  }
  /**
   * 被子类覆盖，以便实现具体功能
   */


  initTask(unitPool, threadSchedule, receiverSchedule, taskModules) {}

  setTaskModuleParams(taskModules) {
    if (taskModules != null) {
      // this.m_taskModuleUrls = taskModuleUrls.slice(0);
      this.m_taskModules = taskModules.slice(0);
    }
  }

  isInitialized() {
    return this.m_receiverSchedule != null;
  }

  initialize(receiverSchedule, threadSchedule, taskModules = null) {
    if (this.m_receiverSchedule == null && this.m_threadSchedule == null) {
      this.m_receiverSchedule = receiverSchedule;
      this.m_threadSchedule = threadSchedule; // this.initTask( this.m_unitPool, threadSchedule, receiverSchedule, this.m_taskModuleUrls != null ? this.m_taskModuleUrls: taskModuleUrls);

      this.initTask(this.m_unitPool, threadSchedule, receiverSchedule, this.m_taskModules != null ? this.m_taskModules : taskModules);
      let ls = this.m_reqNodes;

      for (let i = 0; i < ls.length; i++) {
        const node = ls[i]; // console.log("XXXXXXXX UUUUU --- YYYYY, ResourceSchedule::initialize(), unit:", node.unit);

        this.m_unitPool.addUnit(node.unit.url, node.unit);
        this.m_receiverSchedule.addReceiver(node.receiver, node.unit);
      }
    }
  }

  hasDataUnit(url) {
    return this.m_unitPool.hasUnitByUrl(url);
  }
  /**
   * 注意: 不建议过多使用这个函数,因为回调函数不安全如果是lambda表达式则由性能问题。
   * 立即获得CPU侧的数据单元实例, 但是数据单元中的数据可能是空的, 因为数据获取的操作实际是异步的。
   * 需要通过 isCpuPhase() 或者 isGpuPhase() 等函数来判定具体数据情况
   * @param url 数据资源url
   * @param dataFormat 数据资源类型
   * @param callback 数据资源接收回调函数, 其值建议为lambda函数表达式
   * @param immediate 是否立即返回数据, 默认是false
   * @returns 数据单元实例，用户只能访问不能更改这个实例内部的数据状态，如果必要则可以申请复制一份
   */


  getCPUDataByUrlAndCallback(url, dataFormat, callback, immediate = false) {
    let unit = this.m_unitPool.getUnitByUrl(url);

    if (unit != null) {
      if (callback != null) {
        if (unit.isCpuPhase()) {
          console.log("getCPUDataUnitByUrlAndCallback(), the data unit is already available.");
          unit.lossTime = 0;
          callback(unit, 1);
          return unit;
        }
      }
    }

    if (unit == null) {
      let r = new ResourceReceiver();
      r.callback = callback;
      unit = this.getCPUDataByUrl(url, dataFormat, r, immediate);
    }

    return unit;
  }
  /**
   * 立即获得CPU侧的数据单元实例, 但是数据单元中的数据可能是空的, 因为数据获取的操作实际是异步的。
   * 需要通过 isCpuPhase() 或者 isGpuPhase() 等函数来判定具体数据情况
   * @param url 数据资源url
   * @param dataFormat 数据资源类型
   * @param receiver 数据资源接收者,默认值是 null
   * @param immediate 是否立即返回数据, 默认是false
   * @returns 数据单元实例，用户只能访问不能更改这个实例内部的数据状态，如果必要则可以申请复制一份
   */


  getCPUDataByUrl(url, dataFormat, receiver = null, immediate = false) {
    let unit = this.m_unitPool.getUnitByUrl(url);

    if (unit != null) {
      if (receiver != null) {
        if (unit.isCpuPhase()) {
          console.log("getCPUDataUnitByUrl(), the data unit is already available.");
          unit.lossTime = 0;
          receiver.receiveDataUnit(unit, 1);
          return unit;
        }
      }
    }

    if (unit == null) {
      unit = this.createDataUnit(url, dataFormat, immediate);
      unit.lossTime = Date.now();
      unit.url = url;
      console.log("           unitPool.addUnit: ", url, unit);

      if (this.m_receiverSchedule != null) {
        this.m_unitPool.addUnit(url, unit);
      }
    }

    if (this.m_receiverSchedule != null) {
      this.m_receiverSchedule.addReceiver(receiver, unit);
    } else {
      let node = new ReqNode();
      node.receiver = receiver;
      node.unit = unit;
      this.m_reqNodes.push(node);
    }

    return unit;
  }

  getGPUDataByUrlAndCallback(url, dataFormat, callback, immediate = false) {
    return null;
  }

  getGPUDataByUrl(url, dataFormat, receiver = null, immediate = false) {
    return null;
  }

  getGPUDataByUUIDAndCallback(uuid, callback) {
    return null;
  }

  getGPUDataByUUID(uuid, receiver = null) {
    return null;
  }
  /**
   * 销毁当前实例
   */


  destroy() {
    if (this.m_receiverSchedule != null) {
      this.m_receiverSchedule = null;
      this.m_threadSchedule = null;
    }
  }

}

exports.ResourceSchedule = ResourceSchedule;

/***/ }),

/***/ "7ebf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadCMD_1 = __webpack_require__("1e86");

const ThreadSendData_1 = __webpack_require__("2356");

const ThrDataPool_1 = __webpack_require__("7566");

const ThreadCodeSrcType_1 = __webpack_require__("d2d9");

const ThreadConfigure_1 = __webpack_require__("fce7");

const TDRParam_1 = __webpack_require__("60cd");

const ThreadWFST_1 = __webpack_require__("9d01");

class ThreadBase {
  constructor(tdrManager, taskPool, graphJsonStr = "") {
    this.m_uid = -1;
    this.m_worker = null;
    this.m_taskItems = [];
    this.m_free = false;
    this.m_enabled = false;
    this.m_initBoo = true;
    this.m_thrData = null;
    this.m_commonModuleMap = new Map();
    this.autoSendData = false;
    this.localDataPool = new ThrDataPool_1.ThrDataPool();
    this.globalDataPool = null;
    this.unlock = true;
    this.m_tdrManager = tdrManager;
    this.m_taskPool = taskPool; // this.m_taskReg = taskReg;

    this.m_graphJsonStr = graphJsonStr;
    this.m_uid = ThreadBase.s_uid++;
    this.m_taskfs = new Array(ThreadConfigure_1.ThreadConfigure.MAX_TASKS_TOTAL);
    this.m_taskfs.fill(-1);
  }

  getUid() {
    return this.m_uid;
  }

  isEnabled() {
    return this.m_enabled;
  }

  isFree() {
    return this.m_free && this.unlock;
  }

  hasDataToThread() {
    return this.localDataPool.isEnabled() || this.globalDataPool.isEnabled();
  }

  sendPoolDataToThread() {
    if (this.m_free) {
      let boo = this.localDataPool.isEnabled();

      if (boo) {
        boo = this.localDataPool.sendDataTo(this);
      }

      if (!boo) {
        boo = this.globalDataPool.sendDataTo(this);
      }

      return boo;
    }

    return false;
  } // send parse data to thread


  sendDataTo(thrData) {
    if (this.m_free && this.m_taskfs[thrData.taskclass] > 0) {
      // console.log("ThreadBase::sendDataTo(),this.m_free: "+this.m_free,thrData+",uid: "+this.getUid());
      thrData.buildThis(true);
      let sendData = {
        streams: null
      };
      sendData.descriptor = thrData.descriptor;
      sendData.taskCmd = thrData.taskCmd;
      sendData.taskclass = thrData.taskclass;
      sendData.srcuid = thrData.srcuid;
      sendData.dataIndex = thrData.dataIndex;
      sendData.wfst = thrData.wfst;
      sendData.streams = thrData.streams;
      sendData.cmd = ThreadCMD_1.ThreadCMD.DATA_PARSE;
      sendData.threadIndex = this.m_uid; // this.m_time = Date.now();

      if (thrData.streams != null) {
        let ls = thrData.streams;
        let transfers = new Array(ls.length);

        for (let i = 0; i < ls.length; ++i) {
          if (ls[i] instanceof ArrayBuffer) {
            transfers[i] = ls[i];
          } else {
            transfers[i] = ls[i].buffer;
          }
        }

        this.m_worker.postMessage(sendData, transfers);
      } else {
        this.m_worker.postMessage(sendData);
      }

      thrData.sendStatus = 1;
      thrData.streams = null;
      sendData.descriptor = null;
      sendData.streams = null;
      this.m_thrData = thrData;
      this.m_free = false;
    } else {
      let flag = this.m_taskfs[thrData.taskclass];

      if (flag == 0 && this.isFree()) {
        let len = this.m_taskItems.length;

        for (let i = 0; i < len; ++i) {
          const task = this.m_taskItems[i];

          if (task.info.taskClass == thrData.taskclass) {
            this.initThreadTask(task);
            this.m_taskItems.splice(i, 1);
            break;
          }
        }
      } else if (flag < 0) {
        console.error("task class(" + thrData.taskclass + ") module is undeifned in the Thread(" + this.m_uid + ")");
      }
    }
  }

  initModuleByTaskDescriptor(task) {
    // console.log("ThreadBase::initModuleByTaskDescriptor(), A, task: ", task);
    if (task != null) {
      let taskclass = task.info.taskClass;
      console.log("ThreadBase::initModuleByTaskDescriptor(), task.info: ", task.info, "in the Thread(" + this.m_uid + ")");

      if (taskclass >= 0 && taskclass < this.m_taskfs.length) {
        if (this.m_taskfs[taskclass] < 0) {
          this.m_taskfs[taskclass] = 0;
          this.m_taskItems.push(task);
        }
      }
    }
  }

  initModules(moduleUrls) {
    let urls = [];

    for (let i = 0; i < moduleUrls.length; ++i) {
      if (!this.m_commonModuleMap.has(moduleUrls[i])) {
        this.m_commonModuleMap.set(moduleUrls[i], 1);
        urls.push(moduleUrls[i]);
      }
    } // console.log("XXXX thread initModules urls.length: ",urls.length);


    if (urls.length > 0) {
      this.m_worker.postMessage({
        cmd: ThreadCMD_1.ThreadCMD.INIT_COMMON_MODULE,
        threadIndex: this.getUid(),
        modules: urls,
        type: ThreadCodeSrcType_1.ThreadCodeSrcType.JS_FILE_CODE
      });
    }
  }

  initModuleByCodeString(codeStr) {
    this.m_worker.postMessage({
      cmd: ThreadCMD_1.ThreadCMD.INIT_COMMON_MODULE,
      threadIndex: this.getUid(),
      src: codeStr,
      type: ThreadCodeSrcType_1.ThreadCodeSrcType.STRING_CODE
    });
  }

  initThreadTask(task) {
    this.m_free = false;
    this.m_enabled = false; // let task = this.m_taskItems.pop();
    // type 为0 表示task js 文件是外部加载的, 如果为 1 则表示是由运行时字符串构建的任务可执行代码

    console.log("Main worker(" + this.getUid() + ") updateInitTask(), task: ", task); // let info: {taskClass:number, keyuns: string} = this.m_taskReg.getTaskInfo(task);
    // console.log("task info: ", info);

    this.m_worker.postMessage({
      cmd: ThreadCMD_1.ThreadCMD.INIT_TASK,
      threadIndex: this.getUid(),
      param: task,
      info: task.info
    });
  }

  updateInitTask() {
    console.log("Main worker(" + this.getUid() + ") updateInitTask() this.m_taskItems.length: ", this.m_taskItems.length);

    if (this.m_taskItems.length > 0) {
      let task = this.m_taskItems.pop();
      this.initThreadTask(task); // this.m_free = false;
      // this.m_enabled = false;
      // let task = this.m_taskItems.pop();
      // // type 为0 表示task js 文件是外部加载的, 如果为 1 则表示是由运行时字符串构建的任务可执行代码
      // console.log("Main worker("+this.getUid()+") updateInitTask(), task: ",task);
      // // let info: {taskClass:number, keyuns: string} = this.m_taskReg.getTaskInfo(task);
      // // console.log("task info: ", info);
      // this.m_worker.postMessage({ cmd: ThreadCMD.INIT_TASK, threadIndex: this.getUid(), param: task, info: task.info });
    }
  }

  receiveData(data) {
    let wfst = data.wfst;
    let transST = ThreadWFST_1.ThreadWFST.GetTransStatus(wfst);
    this.m_free = transST == ThreadWFST_1.TransST.None || transST == ThreadWFST_1.TransST.Finish;
    console.log("Main worker(" + this.getUid() + ") recieve data, transST: ", transST, ", free: ", this.m_free, ", autoSendData: ", this.autoSendData); // 下面这个逻辑要慎用，用了可能会对时间同步(例如帧同步)造成影响

    if (this.autoSendData) {
      this.sendPoolDataToThread();
    } // let task: ThreadTask = ThreadTask.GetTaskByUid(data.srcuid);


    let task = this.m_taskPool.getTaskByUid(data.srcuid); // console.log("task != null: ",(task != null),", data.srcuid: ",data.srcuid,", thread uid: ",this.m_uid);
    // console.log("data: ",data);

    let finished = true;

    if (task != null) {
      finished = task.parseDone(data, 0);
    }

    this.updateInitTask();
  }

  sendRouterDataTo(router) {
    let param = router.param; // console.log("#### A thread("+this.m_uid+"), sendRouterDataTo(), param: ", param);

    if (router != null && router.isTransmission() && param.threadIndex == this.m_uid) {
      router.param = null; // console.log("#### B thread("+this.m_uid+"), sendRouterDataTo(), param: ", param);

      this.m_worker.postMessage({
        cmd: param.cmd,
        taskCmd: param.taskCmd,
        threadIndex: this.getUid(),
        taskclass: param.taskclass,
        data: router.getData()
      }, router.getTransfers());
    }
  }

  terminate() {
    if (this.m_worker != null) {
      this.m_worker.terminate();
      this.m_worker = null;
      this.m_free = false;
      this.m_enabled = false;
    }
  }

  destroy() {
    if (this.m_worker != null) {
      this.terminate();
      this.m_taskPool = null;
      this.m_tdrManager = null;
      this.m_graphJsonStr = "";
      this.localDataPool = null;
      this.globalDataPool = null;
    }
  }

  isDestroyed() {
    return this.m_taskPool == null;
  }

  initialize(blob) {
    if (this.m_initBoo && blob != null && this.m_worker == null) {
      this.m_initBoo = false;
      let worker = new Worker(URL.createObjectURL(blob));
      this.m_worker = worker;

      this.m_worker.onmessage = evt => {
        if (this.m_thrData != null) {
          ThreadSendData_1.ThreadSendData.Restore(this.m_thrData);
          this.m_thrData.sendStatus = -1;
          this.m_thrData = null;
        } // console.log("Main worker("+this.getUid()+") recieve data, event.data: ",evt.data,",uid: "+this.m_uid);


        let data = evt.data; // console.log("Main Worker received worker cmd: ",data.cmd);

        switch (data.cmd) {
          case ThreadCMD_1.ThreadCMD.DATA_PARSE:
            this.receiveData(data);
            break;

          case ThreadCMD_1.ThreadCMD.THREAD_INIT:
            worker.postMessage({
              cmd: ThreadCMD_1.ThreadCMD.INIT_PARAM,
              threadIndex: this.getUid(),
              graphJsonStr: this.m_graphJsonStr,
              total: ThreadConfigure_1.ThreadConfigure.MAX_TASKS_TOTAL
            });
            break;

          case ThreadCMD_1.ThreadCMD.INIT_TASK:
            if (this.m_taskfs[data.taskclass] < 0) {
              throw Error("sub worker taskclass and main worker logic taskClass are not equal !!!");
            }

            this.m_taskfs[data.taskclass] = 1;
            this.m_free = true;
            this.m_enabled = true; // console.log("Main Worker("+this.getUid()+") INIT_TASK data.taskclass: ", data.taskclass);

            this.updateInitTask();
            break;

          case ThreadCMD_1.ThreadCMD.INIT_PARAM:
            this.m_free = true;
            this.m_enabled = true; //console.log("Main worker INIT_PARAM.");

            this.updateInitTask();
            break;

          case ThreadCMD_1.ThreadCMD.THREAD_ACQUIRE_DATA:
            console.log("ThreadCMD.THREAD_ACQUIRE_DATA, data.taskclass: ", data.taskclass);
            let tdrParam = new TDRParam_1.TDRParam(data.taskclass, data.cmd, data.taskCmd, this.getUid());
            let router1 = this.m_tdrManager.getRouterByTaskClass(data.taskclass);

            if (router1 != null) {
              router1.acquireTrigger(); // console.log("#####$$$ Main worker("+this.getUid()+") ThreadCMD.THREAD_ACQUIRE_DATA, router: ", router1.isDataEnabled() && !router1.isTransmission(), router1);

              if (router1.isDataEnabled() && !router1.isTransmission()) {
                router1.param = tdrParam;
                this.sendRouterDataTo(router1);
              } else {
                router1 = null;
              }
            }

            if (router1 == null) {
              this.m_tdrManager.waitRouterByParam(tdrParam);
            }

            break;

          case ThreadCMD_1.ThreadCMD.THREAD_TRANSMIT_DATA:
            let router2 = this.m_tdrManager.getRouterByTaskClass(data.taskclass); // console.log("#### ThreadCMD.THREAD_TRANSMIT_DATA, router2: ", router2.isDataEnabled() && !router2.isTransmission(), router2);

            if (router2 != null) {
              if (router2.isDataEnabled()) {
                console.error("router have old data, can not reset new data.");
              }

              router2.setData(data.data);
            }

            break;

          case ThreadCMD_1.ThreadCMD.INIT_COMMON_MODULE:
            break;

          default:
            break;
        }
      };
    }
  }

}

ThreadBase.s_uid = 0;
exports.ThreadBase = ThreadBase;

/***/ }),

/***/ "80fa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadTask_1 = __webpack_require__("83a3");

const TaskDependency_1 = __webpack_require__("3b80");

const PNGDescriptorType_1 = __webpack_require__("8df7");

exports.PNGDescriptorType = PNGDescriptorType_1.PNGDescriptorType;
/**
 * png 解析任务对象
 */

class PNGParseTask extends ThreadTask_1.ThreadTask {
  /**
   * @param src 子线程中代码模块的js文件url 或者 依赖的唯一名称
   */
  constructor(src) {
    super();
    this.m_listener = null;

    if (src.indexOf("/") > 0) {
      this.dependency = new TaskDependency_1.TaskJSFileDependency(src);
    } else {
      this.dependency = new TaskDependency_1.TaskUniqueNameDependency(src);
    }
  }

  setListener(l) {
    this.m_listener = l;
  }

  addBinaryData(buffer, url) {
    if (buffer != null) {
      this.addDataWithParam("", [buffer], {
        url: url,
        width: 0,
        height: 0,
        filterType: 4
      });
    }
  } // return true, task finish; return false, task continue...


  parseDone(data, flag) {
    // console.log("CTMParseTask::parseDone(), this.m_listener != null:", this.m_listener != null, data);
    if (this.m_listener != null) {
      this.m_listener.pngParseFinish(data.data, data.descriptor);
    }

    return true;
  }

  destroy() {
    super.destroy();
    this.m_listener = null;
  }

}

exports.PNGParseTask = PNGParseTask;

/***/ }),

/***/ "8171":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class Stencil {
  constructor(rstate) {
    this.m_rstate = null;
    this.m_rstate = rstate;
  }

  setDepthTestEnable(enable) {
    this.m_rstate.setDepthTestEnable(enable);
  }
  /**
   * 设置 gpu stencilFunc 状态
   * @param func Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
   * @param ref a GLint type number, value range: [0,2n−1];
   * @param mask GLint type number
   */


  setStencilFunc(func, ref, mask) {
    this.m_rstate.setStencilFunc(func, ref, mask);
  }
  /**
   * 设置 gpu stencilMask 状态
   * @param mask GLint type number
   */


  setStencilMask(mask) {
    this.m_rstate.setStencilMask(mask);
  }
  /**
   * 设置 gpu stencilOp 状态
   * @param fail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
   * @param zfail Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
   * @param zpass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
   */


  setStencilOp(fail, zfail, zpass) {
    this.m_rstate.setStencilOp(fail, zfail, zpass);
  }

}

exports.Stencil = Stencil;

/***/ }),

/***/ "81ce":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class GLSLConverter {
  static Es2VtxShderToES3(glslStr) {
    let codeStr = glslStr; //attribute

    const ATTRIBUTE = "attribute"; //const POSY_OUTPUT = "out";
    //const POSY_INPUT = "in";

    const VARYING = "varying ";
    let i = codeStr.indexOf(ATTRIBUTE);
    let j = 0;

    while (i >= 0) {
      codeStr = codeStr.slice(0, i) + "layout(location=" + j + ") in" + codeStr.slice(i + 9);
      i = codeStr.indexOf(ATTRIBUTE);
      j++;
    }

    let regex = new RegExp(VARYING, "g");
    codeStr = codeStr.replace(regex, "out "); //i = codeStr.indexOf(ATTRIBUTE);

    return "#version 300 es\n" + codeStr;
  }

  static Es2FragShderToES3(glslStr) {
    let codeStr = glslStr; //attribute

    const GL1_OUTPUT = "gl_FragColor";
    const VARYING = "varying ";
    let i = codeStr.indexOf(GL1_OUTPUT);
    let j = 0;
    let outFragColor = "FragColorOut_" + j;
    if (i >= 0) codeStr = codeStr.slice(0, i) + outFragColor + codeStr.slice(i + 12);
    i = codeStr.indexOf("void ");
    codeStr = codeStr.slice(0, i) + "out vec4 " + outFragColor + ";\n" + codeStr.slice(i);
    let regex = new RegExp(VARYING, "g");
    codeStr = codeStr.replace(regex, "in ");
    regex = new RegExp(" texture2D", "g");
    codeStr = codeStr.replace(regex, " texture");
    regex = new RegExp(" textureCube", "g");
    codeStr = codeStr.replace(regex, " texture");
    return "#version 300 es\n" + codeStr;
  }

  static Es3VtxShaderToES2(codeStr) {
    const regExp0 = /^#.+(\bes|core\b)/;
    codeStr = codeStr.replace(regExp0, "");
    const regExp1 = /\blayout\b.+\bin\b/g;
    codeStr = codeStr.replace(regExp1, "attribute");
    const regExp2 = /\bout\b/g;
    codeStr = codeStr.replace(regExp2, "varying");
    const regExp3 = /\btexture\b/g;
    codeStr = codeStr.replace(regExp3, "texture2D");

    if (codeStr.indexOf("#version") >= 0) {
      codeStr = codeStr.replace("#version", "//#version");
    } //*


    let j = 0;
    let k = 0;
    let i = codeStr.indexOf("inverse(");

    if (i < 0) {
      i = codeStr.indexOf("inverse (");
    }

    let subStr = "";
    let invMat3Boo = false;
    let invMat4Boo = false;

    while (i > 3) {
      j = codeStr.indexOf(")", i + 2); //get var name

      subStr = codeStr.slice(i + 2, j);

      if (subStr.indexOf("mat3") > 0) {
        invMat3Boo = true;
      } else {
        // 去除空格,得到实际的变量名
        subStr = subStr.replace(/\s+/g, "");
        j = subStr.indexOf("(");
        subStr = subStr.slice(j + 1); // 查找第一次定义的地方

        j = codeStr.indexOf(subStr, 1); // 查找在这位置前面的最近的mat or vec字符                

        k = codeStr.lastIndexOf("mat", j);

        if (k > 0) {
          subStr = codeStr.slice(k, j);
          subStr = subStr.replace(/\s+/g, "");

          switch (subStr) {
            case "mat3":
              invMat3Boo = true;
              break;

            case "mat4":
              invMat4Boo = true;
              break;
          }
        }
      }

      i = codeStr.indexOf("inverse(", i + 5);

      if (i < 0) {
        i = codeStr.indexOf("inverse (", i + 5);
      }

      if (invMat3Boo && invMat4Boo) {
        break;
      }
    }

    j = 0;
    i = codeStr.indexOf("transpose(");

    if (i < 0) {
      i = codeStr.indexOf("transpose (");
    }

    subStr = "";
    let trsMat3Boo = false;
    let trsMat4Boo = false;

    while (i > 3) {
      j = codeStr.indexOf(")", i + 2);
      subStr = codeStr.slice(i + 2, j + 1);

      if (subStr.indexOf("mat3") > 0) {
        trsMat3Boo = true;
      } else {
        // 去除空格,得到实际的变量名
        subStr = subStr.replace(/\s+/g, "");
        j = subStr.indexOf("(");
        subStr = subStr.slice(j + 1); // 查找第一次定义的地方

        j = codeStr.indexOf(subStr, 1); // 查找在这位置前面的最近的mat or vec字符                

        k = codeStr.lastIndexOf("mat", j);

        if (k > 0) {
          subStr = codeStr.slice(k, j);
          subStr = subStr.replace(/\s+/g, ""); //trace("Var Name B: "+subStr);

          switch (subStr) {
            case "mat3":
              trsMat3Boo = true;
              break;

            case "mat4":
              trsMat4Boo = true;
              break;
          }
        }
      }

      i = codeStr.indexOf("transpose(", i + 5);

      if (i < 0) {
        i = codeStr.indexOf("transpose (", i + 5);
      }

      if (trsMat3Boo && trsMat4Boo) {
        //trsMat3Boo = trsMat4Boo = true;
        break;
      }
    }

    if (invMat3Boo || invMat4Boo) {
      i = codeStr.indexOf("void ");

      if (i > 10) {
        if (invMat3Boo && invMat4Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslInverseMat3 + GLSLConverter.__glslInverseMat4 + codeStr.slice(i);
        } else if (invMat3Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslInverseMat3 + codeStr.slice(i);
        } else if (invMat4Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslInverseMat4 + codeStr.slice(i);
        }
      }
    }

    if (trsMat3Boo || trsMat4Boo) {
      i = codeStr.indexOf("void ");

      if (i > 10) {
        if (trsMat3Boo && trsMat4Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslTransposeMat3 + GLSLConverter.__glslTransposeMat4 + codeStr.slice(i);
        } else if (trsMat3Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslTransposeMat3 + codeStr.slice(i);
        } else if (trsMat4Boo) {
          codeStr = codeStr.slice(0, i) + GLSLConverter.__glslTransposeMat4 + codeStr.slice(i);
        }
      }
    }

    return codeStr;
  }

  static Es3FragShaderToES2(codeStr) {
    const regExp0 = /^#.+(\bes|core\b)/;
    codeStr = codeStr.replace(regExp0, ""); // 防止函数中的in 被替换
    //const regExpFuncIn:RegExp = /\b in \b/g;

    const regExpFuncIn = new RegExp(" in ", "g");
    codeStr = codeStr.replace(regExpFuncIn, "_fref_");
    const regExp1 = /\bin\b/g;
    codeStr = codeStr.replace(regExp1, "varying"); // 防止函数中的in 被替换

    const regExpToFuncIn = new RegExp("_fref_", "g");
    codeStr = codeStr.replace(regExpToFuncIn, " in "); //codeStr = codeStr.replace(regExp1, "varying");

    const regExp2 = /\btexture\b/g;
    codeStr = codeStr.replace(regExp2, "texture2D");
    const regExp3 = /" "/g;
    let shaderStr = codeStr; // 替换 frag (layout) out

    const semicolon = ";";
    const out_flag = "layout";
    let i = shaderStr.indexOf(out_flag);
    let j = 0;
    let t = 0;
    let subStr = "";
    let keyName = "";
    let keyIndex = 0;
    let tempReg = null;
    let keys = [];
    let indexList = [];

    while (i >= 0) {
      j = shaderStr.indexOf(semicolon, i + 1);
      subStr = shaderStr.slice(i + 1, j);
      keyName = subStr.slice(subStr.lastIndexOf(" ") + 1);
      keyIndex = subStr.indexOf(")");
      i = subStr.lastIndexOf("=", keyIndex) + 1;
      subStr = subStr.slice(i + 1, keyIndex);
      keyIndex = parseInt(subStr.replace(regExp3, ""));
      keys.push(keyName);
      indexList.push(keyIndex);
      i = shaderStr.indexOf(out_flag, j);
    }

    let len = keys.length;

    if (len > 0) {
      tempReg = /layout/g;
      codeStr = codeStr.replace(tempReg, "//layout");

      if (len > 1) {
        i = 0;

        while (i < len) {
          tempReg = new RegExp(keys[i], "g");
          codeStr = codeStr.replace(tempReg, "gl_FragData[" + indexList[i] + "]");
          ++i;
        }
      } else {
        tempReg = new RegExp(keyName, "g");
        codeStr = codeStr.replace(tempReg, "gl_FragColor");
      }
    } else {
      i = shaderStr.indexOf("out ");

      if (i > 0) {
        j = shaderStr.indexOf(semicolon, i + 1);
        subStr = shaderStr.slice(i + 1, j);
        keyName = subStr.slice(subStr.lastIndexOf(" ") + 1);
        tempReg = new RegExp(keyName, "g");
        codeStr = codeStr.replace(tempReg, "gl_FragColor");
        tempReg = /\bout\b/g;
        codeStr = codeStr.replace(tempReg, "//out");
      }
    }

    if (len > 1) {
      codeStr = "#extension GL_EXT_draw_buffers: require\n" + codeStr;
    }

    if (codeStr.indexOf("#version") >= 0) {
      codeStr = codeStr.replace("#version", "//#version");
    } // correct samplerCube sampler


    i = 0; ///*

    for (let k = 0; k < 16; ++k) {
      i = codeStr.indexOf("samplerCube ", i);

      if (i > 0) {
        j = codeStr.indexOf(";", i);
        subStr = shaderStr.slice(i + 12, j);
        keyName = "";
        let arr = subStr.split(" ");

        for (let t = 0; t < 16; ++t) {
          if (arr[t] != "") {
            // find samplerCube uniform name
            keyName = arr[t];
            break;
          }
        }

        for (len = 0; len < 16; ++len) {
          j = codeStr.indexOf(keyName, j + 1);

          if (j > 0) {
            t = codeStr.lastIndexOf("texture2D", j - 1);

            if (t < 0) {
              break;
            }

            subStr = codeStr.slice(t, j);
            codeStr = codeStr.slice(0, t) + "textureCube(" + codeStr.slice(j);
          } else {
            break;
          }

          j += 2;
        }
      } else {
        break;
      }

      i += 4;
    } //*/


    return codeStr;
  }

}

GLSLConverter.__glslTransposeMat3 = `
    mat3 transpose(mat3 m) {
        return mat3(m[0][0],m[1][0],m[2][0],
            m[0][1],m[1][1],m[2][1],
            m[0][2],m[1][2],m[2][2]);
    }
    `;
GLSLConverter.__glslTransposeMat4 = `
    mat4 transpose(mat4 m) {
        return mat4(m[0][0],m[1][0],m[2][0],m[3][0],
            m[0][1],m[1][1],m[2][1],m[3][1],
            m[0][2],m[1][2],m[2][2],m[3][2],
            m[0][3],m[1][3],m[2][3],m[3][3]);
    }
    `;
GLSLConverter.__glslInverseMat3 = `
    mat3 inverse(mat3 m) {
        float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
        float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
        float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];  
        float b01 = a22 * a11 - a12 * a21;
        float b11 = -a22 * a10 + a12 * a20;
        float b21 = a21 * a10 - a11 * a20;  
        float det = a00 * b01 + a01 * b11 + a02 * b21;  
        return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
                    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
                    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
    }
    `;
GLSLConverter.__glslInverseMat4 = `
    mat4 inverse(mat4 m) {
        float
            a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
            a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
            a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
            a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],
            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        return mat4(
            a11 * b11 - a12 * b10 + a13 * b09,
            a02 * b10 - a01 * b11 - a03 * b09,
            a31 * b05 - a32 * b04 + a33 * b03,
            a22 * b04 - a21 * b05 - a23 * b03,
            a12 * b08 - a10 * b11 - a13 * b07,
            a00 * b11 - a02 * b08 + a03 * b07,
            a32 * b02 - a30 * b05 - a33 * b01,
            a20 * b05 - a22 * b02 + a23 * b01,
            a10 * b10 - a11 * b08 + a13 * b06,
            a01 * b08 - a00 * b10 - a03 * b06,
            a30 * b04 - a31 * b02 + a33 * b00,
            a21 * b02 - a20 * b04 - a23 * b00,
            a11 * b07 - a10 * b09 - a12 * b06,
            a00 * b09 - a01 * b07 + a02 * b06,
            a31 * b01 - a30 * b03 - a32 * b00,
            a20 * b03 - a21 * b01 + a22 * b00) / det;
        }
    `;
exports.default = GLSLConverter;

/***/ }),

/***/ "8310":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class FBXBufferObject {
  constructor() {
    this.id = -1;
    this.ID = "";
    this.userData = {};
    this.parent = null;
    this.i3 = 0;
    this.i2 = 0;
    this.uvs = [];
    this.normal = null;
    this.vertex = null;
    this.indices = null;
    this.colors = null;
    this.materialIndex = [];
    this.vertexWeights = [];
    this.weightsIndices = [];
    this.isEntity = false;
    this.transform = null;
  }

  toGeometryModel() {
    let indices = this.indices;

    if (indices == null) {
      let vtxTotal = this.vertex.length;
      let vtCount = vtxTotal / 3;
      indices = vtCount > 65535 ? new Uint32Array(vtCount) : new Uint16Array(vtCount);

      for (let i = 0; i < vtCount; ++i) {
        indices[i] = i;
      }
    }

    let model = {
      uvsList: this.uvs,
      vertices: this.vertex,
      normals: this.normal,
      indices: indices
    }; // console.log("model: ",model);

    return model;
  }

  destroy() {
    this.uvs = null;
    this.vertex = null;
    this.normal = null;
    this.colors = null;
    this.indices = null;
  }

}

exports.FBXBufferObject = FBXBufferObject;
;

/***/ }),

/***/ "8333":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RenderMaskBitfield {}

RenderMaskBitfield.COLOR_BUFFER_BIT = 131;
RenderMaskBitfield.DEPTH_BUFFER_BIT = 132;
RenderMaskBitfield.STENCIL_BUFFER_BIT = 133;
exports.default = RenderMaskBitfield;

/***/ }),

/***/ "839a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SpecularMode;

(function (SpecularMode) {
  /**
   * 使用设置的纯色 rgb 作为镜面光的颜色系数
   */
  SpecularMode[SpecularMode["Default"] = 1] = "Default";
  /**
   * 使用 之前计算出来的 片段 color rgb 作为镜面光的颜色系数
   */

  SpecularMode[SpecularMode["FragColor"] = 2] = "FragColor";
  /**
   * 使用 SpecularMap color rgb 作为镜面光的颜色系数
   */

  SpecularMode[SpecularMode["SpecularMapColor"] = 3] = "SpecularMapColor";
})(SpecularMode || (SpecularMode = {}));

exports.SpecularMode = SpecularMode;

/***/ }),

/***/ "83a3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadSendData_1 = __webpack_require__("2356");

class ThreadTask {
  constructor() {
    this.m_uid = -1;
    this.m_globalDataPool = null;
    this.m_localDataPool = null;
    this.m_taskPool = null;
    this.m_info = null;
    this.m_parseIndex = 0;
    this.m_parseTotal = 0;
    /**
     * 当前任务对于线程中相关代码模块的依赖关系
     */

    this.dependency = null;
    console.log("XXXX ThreadTask::constructor() ...");
  }

  attach(taskPool) {
    if (this.m_uid < 0 && this.m_taskPool == null && taskPool != null) {
      this.m_taskPool = taskPool;
      let uid = taskPool.attachTask(this);

      if (uid > 0) {
        this.m_uid = uid;
        return true;
      } else {
        throw Error("illegal operation!!!");
      }
    }

    return false;
  }

  detach() {
    if (this.m_uid > 0 && this.m_taskPool != null) {
      this.m_taskPool.detachTask(this);
      this.m_uid = -1;
    }
  }

  setTaskInfo(info) {
    console.log("XXXX ThreadTask::setTaskInfo() info: ", info);
    this.m_info = info;
  }

  setDataPool(globalDataPool, localDataPool = null) {
    this.m_globalDataPool = globalDataPool;
    this.m_localDataPool = localDataPool;
  } // 被子类覆盖后便能实现更细节的相关功能


  reset() {
    this.m_parseIndex = 0;
  }

  setParseTotal(total) {
    this.m_parseTotal = total;
  }

  isFinished() {
    return this.m_parseIndex >= this.m_parseTotal;
  }

  getParsedTotal() {
    return this.m_parseIndex >= this.m_parseTotal ? this.m_parseTotal : this.m_parseIndex + 1;
  }

  getParseTotal() {
    return this.m_parseTotal;
  }

  getParsedIndex() {
    return this.m_parseIndex;
  }

  getUid() {
    return this.m_uid;
  }
  /**
   * 必须被覆盖, return true, task finish; return false, task continue...
   * @param data 存放处理结果的数据对象
   * @param flag 表示多线程任务的处理状态, 这里的flag是一个uint型。用4个8位来表示4种标识分类, 最低8位用来表示任务的处理阶段相关的状态
   * @returns 返回这个函数的处理状态，默认返回false
   */


  parseDone(data, flag) {
    throw Error("ThreadTask::parseDone(), Need Override it!");
    return true;
  }
  /**
   * 创建发所给子线程的数据对象
   * @returns 默认返回 ThreadSendData 实例, 这个实例由系统自行管理
   */


  createSendData() {
    let sd = ThreadSendData_1.ThreadSendData.Create();
    sd.srcuid = this.getUid();
    sd.taskclass = this.m_info.taskClass;
    sd.wfst = 0;
    return sd;
  }
  /**
   * 通过参数, 創建发送给子线程的数据
   * @param taskCmd 处理当前数据的任务命令名字符串
   * @param streams 用于内存所有权转换的数据流数组, 例如 Float32Array 数组, 默认值是null
   * @param descriptor 会发送到子线程的用于当前数据处理的数据描述对象, for example: {flag : 0, type: 12, name: "First"}, 默认值是 null
   */


  createSendDataWithParam(taskCmd, streams = null, descriptor = null) {
    let sd = ThreadSendData_1.ThreadSendData.Create();
    sd.srcuid = this.getUid();
    sd.taskclass = this.m_info.taskClass;
    sd.taskCmd = taskCmd;
    sd.streams = streams;
    sd.descriptor = null;
    return sd;
  }
  /**
   * 通过参数, 添加发送给子线程的数据
   * @param taskCmd 处理当前数据的任务命令名字符串
   * @param streams 用于内存所有权转换的数据流数组, 例如 Float32Array 数组, 默认值是null
   * @param descriptor 会发送到子线程的用于当前数据处理的数据描述对象, for example: {flag : 0, type: 12, name: "First"}, 默认值是 null
   * @param threadBindingData 是否是线程直接绑定的数据，默认是false
   */


  addDataWithParam(taskCmd, streams = null, descriptor = null, threadBindingData = false) {
    let sd = this.createSendData();
    sd.taskCmd = taskCmd;
    sd.streams = streams;
    sd.descriptor = descriptor;
    this.addData(sd, threadBindingData);
  }
  /**
   * 通过参数, 添加发送给子线程的数据
   * @param data 符合IThreadSendData行为规范的数据对象
   * @param threadBindingData 是否是线程直接绑定的数据，默认是false
   */


  addData(data, threadBindingData = false) {
    if (this.m_uid >= 0) {
      data.srcuid = this.m_uid;
      data.taskclass = this.m_info.taskClass; // console.log("task addData, ",threadBindingData, this.m_localDataPool != null, this.m_globalDataPool != null);

      if (threadBindingData) {
        if (this.m_localDataPool != null) {
          this.m_localDataPool.addData(data);
        }
      } else {
        if (this.m_globalDataPool != null) {
          this.m_globalDataPool.addData(data);
        }
      }
    } else {
      throw Error("Need attach this task !");
    }
  }

  getWorkerSendDataAt(i) {
    throw Error("ThreadTask::getWorkerSendDataAt(), Need Override !");
    return null;
  }
  /**
   * 获得自身动态分配到的 task class 值，不可被子类覆盖
   * @returns task class value
   */


  getTaskClass() {
    return this.m_info.taskClass;
  }

  destroy() {
    this.detach();
    this.m_info = null;
    this.m_globalDataPool = null;
    this.m_localDataPool = null;
    this.dependency = null; // ThreadTask.DetachTask(this);
  }

}

exports.ThreadTask = ThreadTask;

/***/ }),

/***/ "83d1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class StageParamUniformBuilder {
  create(rc, shdp) {
    let param = UniformConst_1.default.StageParam;

    if (shdp.hasUniformByName(param.name)) {
      return rc.uniformContext.createShaderGlobalUniformFromProbe(rc.getStage3D().uProbe, param.name, [param.name]);
    }

    return null;
  }

  getIDNS() {
    return "StageParamUniformBuilder";
  }

}

exports.default = StageParamUniformBuilder;

/***/ }),

/***/ "857b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class CameraPosUniformBuilder {
  create(rc, shdp) {
    let param = UniformConst_1.default.CameraPosParam;
    if (shdp.hasUniformByName(param.name)) return rc.uniformContext.createShaderGlobalUniformFromProbe(rc.getCamera().ucameraPosProbe, param.name, [param.name]);
    return null;
  }

  getIDNS() {
    return "CameraPosUniformBuilder";
  }

}

exports.default = CameraPosUniformBuilder;

/***/ }),

/***/ "85b6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class WrapperTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_tex = null;
    this.m_type = TextureProxyType_1.TextureProxyType.Wrapper;
  }
  /**
   * @returns 返回自己的 纹理资源 unique id, 这个id会被对应的资源管理器使用, 此方法子类不可以覆盖
   */


  getResUid() {
    return this.m_tex.getResUid();
  } // gpu texture buf size


  getBufWidth() {
    return this.m_tex.getBufWidth();
  }

  getBufHeight() {
    return this.m_tex.getBufHeight();
  } // logic texture size


  getWidth() {
    return this.m_tex.getWidth();
  }

  getHeight() {
    return this.m_tex.getHeight();
  }
  /**
   * @returns 返回true, 表示当前纹理对象是渲染直接使用其对应的显存资源的对象
   *          返回false, 表示不能直接使用对应的显存资源
   */


  isDirect() {
    return false;
  }

  getAttachTex() {
    return this.m_tex;
  }

  attachTex(tex) {
    if (this.m_tex != tex) {
      if (this.m_tex != null) {
        this.m_tex.__$detachThis();
      }

      if (tex != null) {
        tex.__$attachThis();
      }

      this.m_tex = tex;
    }
  }

  detachTex() {
    if (this.m_tex != null) {
      this.m_tex.__$detachThis();
    }

    this.m_tex = null;
  }
  /**
   * 被引用计数加一
   */


  __$attachThis() {
    super.__$attachThis();

    if (this.m_tex != null) {
      this.m_tex.__$attachThis();
    }
  }
  /**
   * 被引用计数减一
   */


  __$detachThis() {
    super.__$detachThis();

    if (this.m_tex != null) {
      this.m_tex.__$detachThis();
    }
  }
  /**
   * This function only be be called by the renderer inner system.
   */


  __$$use(resTex) {
    this.m_tex.__$$use(resTex);
  }
  /**
   * @returns the texture gpu resource is enabled or not.
   */


  isGpuEnabled() {
    return this.m_tex.isGpuEnabled();
  }
  /**
   * @returns The fragment processor texture sampler type.
   */


  getSampler() {
    return this.m_tex.getSampler();
  }

  __$updateToGpu(texRes) {
    this.m_tex.__$updateToGpu(texRes);
  }
  /**
   * This function only be be called by the renderer inner system.
   * if sub class override this function, it must does call this function.
   */


  __$$upload(texRes) {
    this.m_tex.__$$upload(texRes);
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      if (this.m_tex != null) {
        this.m_tex.__$detachThis();
      }

      this.m_tex = null;

      super.__$destroy();
    }
  }
  /**
   * @returns the texture data is enough or not.
   */


  isDataEnough() {
    return this.m_tex.isDataEnough();
  }
  /**
   * @returns return value is TextureConst.TEXTURE_2D or TextureConst.TEXTURE_CUBE or TextureConst.TEXTURE_3D
   */


  getTargetType() {
    return this.m_tex.getTargetType();
  }

}

exports.default = WrapperTextureProxy;

/***/ }),

/***/ "85f5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * TaskDataRouter 管理器
 */

class TDRManager {
  constructor(taskClassTotal) {
    this.m_waitParams = [];
    this.m_enabledParams = [];
    this.m_threads = null;
    this.m_taskClassTotal = taskClassTotal > 1024 ? taskClassTotal : 1024;
    this.m_routers = new Array(taskClassTotal);
    this.m_routers.fill(null);
    this.m_rfs = new Array(taskClassTotal);
    this.m_rfs.fill(0);
  }

  setThreads(threads) {
    this.m_threads = threads;
  }

  hasRouterByTaskClass(taskclass) {
    if (taskclass >= 0 && taskclass < this.m_taskClassTotal) {
      return this.m_routers[taskclass] != null;
    }

    return false;
  }

  getRouterByTaskClass(taskclass) {
    if (taskclass >= 0 && taskclass < this.m_taskClassTotal) {
      return this.m_routers[taskclass];
    } else {
      console.log("illegal taskclass value: " + taskclass + " !!!");
    }
  }

  setRouter(router) {
    let taskclass = router.getTaskClass();

    if (taskclass >= 0 && taskclass < this.m_taskClassTotal) {
      if (this.m_routers[taskclass] == null) {
        this.m_routers[taskclass] = router;
      }
    } else {
      throw Error("illegal object !!!");
    }
  }

  waitRouterByParam(param) {
    if (param.status != 0) {
      throw Error("illegal param !!!");
    }

    let taskclass = param.taskclass;

    if (taskclass >= 0 && taskclass < this.m_taskClassTotal) {
      this.m_waitParams.push(param);
      param.status = 1;
    } else {
      throw Error("illegal object !!!");
    }
  }

  run() {
    let len = this.m_waitParams.length;

    if (len > 0) {
      let params = this.m_waitParams;
      let router = null;
      let param = null;

      for (let i = 0; i < len; ++i) {
        param = params[i];
        router = this.m_routers[param.taskclass];

        if (router != null && router.isDataEnabled() && !router.isTransmission()) {
          router.acquireTrigger();
          router.param = param;
          this.m_enabledParams.push(param);
          param.status = 2;
          params.splice(i, 1);
          --i;
          --len;
        }
      }

      len = this.m_enabledParams.length;

      if (len > 0) {
        params = this.m_enabledParams;
        let ths = this.m_threads;
        let tn = ths.length;

        for (let i = 0; i < len; ++i) {
          const pm = params[i];

          for (let j = 0; j < tn; ++j) {
            const th = ths[j];

            if (th.getUid() == pm.threadIndex) {
              th.sendRouterDataTo(this.getRouterByTaskClass(pm.taskclass));
            }
          }
        }

        this.m_enabledParams = [];
      }
    }
  }

  getEnabledParams() {
    if (this.m_enabledParams.length > 0) {
      let list = this.m_enabledParams;
      this.m_enabledParams = [];
      return list;
    }

    return null;
  }

  destroy() {
    this.m_taskClassTotal = 0;
    this.m_routers.length = 0;
  }

}

exports.TDRManager = TDRManager;

/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8a0a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const BitConst_1 = __importDefault(__webpack_require__("ca6c"));

class VtxBufConst {
  //
  static ToGL(gl, param) {
    const vbc = VtxBufConst;

    switch (param) {
      case vbc.VTX_STATIC_DRAW:
        return gl.STATIC_DRAW;
        break;

      case vbc.VTX_DYNAMIC_DRAW:
        return gl.DYNAMIC_DRAW;
        break;

      case vbc.VTX_STREAM_DRAW:
        return gl.STREAM_DRAW;
        break;

      case vbc.VTX_STATIC_READ:
        return gl.STATIC_READ;
        break;

      case vbc.VTX_DYNAMIC_READ:
        return gl.DYNAMIC_READ;
        break;

      case vbc.VTX_STREAM_READ:
        return gl.STREAM_READ;
        break;

      case vbc.VTX_STATIC_COPY:
        return gl.STATIC_COPY;
        break;

      case vbc.VTX_DYNAMIC_COPY:
        return gl.DYNAMIC_COPY;
        break;

      case vbc.VTX_STREAM_COPY:
        return gl.STREAM_COPY;
        break;

      default:
        break;
    }

    return gl.STATIC_DRAW;
  }

  static GetVBufTypeByNS(pns) {
    const vbc = VtxBufConst;

    switch (pns) {
      case vbc.VBUF_VS_NS:
        return vbc.VBUF_VS;
        break;

      case vbc.VBUF_UVS_NS:
        return vbc.VBUF_UVS;
        break;

      case vbc.VBUF_NVS_NS:
        return vbc.VBUF_NVS;
        break;

      case vbc.VBUF_CVS_NS:
        return vbc.VBUF_CVS;
        break;
      ///////////////////

      case vbc.VBUF_VS2_NS:
        return vbc.VBUF_VS2;
        break;

      case vbc.VBUF_UVS2_NS:
        return vbc.VBUF_UVS2;
        break;

      case VtxBufConst.VBUF_NVS2_NS:
        return VtxBufConst.VBUF_NVS2;
        break;

      case vbc.VBUF_CVS2_NS:
        return vbc.VBUF_CVS2;
        break;

      case vbc.VBUF_TVS_NS:
        return vbc.VBUF_TVS;
        break;

      case vbc.VBUF_TVS2_NS:
        return vbc.VBUF_TVS2;
        break;

      default:
    }

    return -1;
  }

  static GetVBufNSByType(type) {
    const vbc = VtxBufConst;

    switch (type) {
      case vbc.VBUF_VS:
        return vbc.VBUF_VS_NS;
        break;

      case vbc.VBUF_UVS:
        return vbc.VBUF_UVS_NS;
        break;

      case vbc.VBUF_NVS:
        return vbc.VBUF_NVS_NS;
        break;

      case vbc.VBUF_CVS:
        return vbc.VBUF_CVS_NS;
        break;
      ///////////////////

      case vbc.VBUF_VS2:
        return vbc.VBUF_VS2_NS;
        break;

      case vbc.VBUF_UVS2:
        return vbc.VBUF_UVS2_NS;
        break;

      case vbc.VBUF_NVS2:
        return vbc.VBUF_NVS2_NS;
        break;

      case vbc.VBUF_CVS2:
        return vbc.VBUF_CVS2_NS;
        break;

      case vbc.VBUF_TVS:
        return vbc.VBUF_TVS_NS;
        break;

      case vbc.VBUF_TVS2:
        return vbc.VBUF_TVS2_NS;
        break;

      default:
    }

    return "";
  }

  static GetVBufAttributeTypeByNS(pns) {
    return VtxBufConst.GetVBufTypeByNS(pns) - 3000;
  }

  static GetVBufAttributeTypeByVBufType(vbufType) {
    return vbufType - 3000;
  }

}

VtxBufConst.VTXTYPE_GL_POINTS = 101;
VtxBufConst.VTXTYPE_GL_LINES = 102;
VtxBufConst.VTXTYPE_GL_LINE_STRIP = 103;
VtxBufConst.VTXTYPE_GL_TRIANGLES = 111;
VtxBufConst.VTX_STATIC_DRAW = 0;
VtxBufConst.VTX_DYNAMIC_DRAW = 1;
VtxBufConst.VTX_STREAM_DRAW = 2;
VtxBufConst.VTX_STATIC_READ = 3;
VtxBufConst.VTX_DYNAMIC_READ = 4;
VtxBufConst.VTX_STREAM_READ = 5;
VtxBufConst.VTX_STATIC_COPY = 6;
VtxBufConst.VTX_DYNAMIC_COPY = 7;
VtxBufConst.VTX_STREAM_COPY = 8;
VtxBufConst.VBUF_VS = 3001;
VtxBufConst.VBUF_UVS = 3002;
VtxBufConst.VBUF_NVS = 3003;
VtxBufConst.VBUF_CVS = 3004;
VtxBufConst.VBUF_TVS = 3005;
VtxBufConst.VBUF_VS2 = 3006;
VtxBufConst.VBUF_UVS2 = 3007;
VtxBufConst.VBUF_NVS2 = 3008;
VtxBufConst.VBUF_CVS2 = 3009;
VtxBufConst.VBUF_TVS2 = 3010;
VtxBufConst.VBUF_VS_INDEX = BitConst_1.default.BIT_ONE_0;
VtxBufConst.VBUF_UVS_INDEX = BitConst_1.default.BIT_ONE_1;
VtxBufConst.VBUF_NVS_INDEX = BitConst_1.default.BIT_ONE_2;
VtxBufConst.VBUF_CVS_INDEX = BitConst_1.default.BIT_ONE_3;
VtxBufConst.VBUF_TVS_INDEX = BitConst_1.default.BIT_ONE_4;
VtxBufConst.VBUF_VS2_INDEX = BitConst_1.default.BIT_ONE_5;
VtxBufConst.VBUF_UVS2_INDEX = BitConst_1.default.BIT_ONE_6;
VtxBufConst.VBUF_NVS2_INDEX = BitConst_1.default.BIT_ONE_7;
VtxBufConst.VBUF_CVS2_INDEX = BitConst_1.default.BIT_ONE_8;
VtxBufConst.VBUF_TVS2_INDEX = BitConst_1.default.BIT_ONE_9; // name

VtxBufConst.VBUF_VS_NS = "a_vs";
VtxBufConst.VBUF_VS2_NS = "a_vs2";
VtxBufConst.VBUF_UVS_NS = "a_uvs";
VtxBufConst.VBUF_UVS2_NS = "a_uvs2";
VtxBufConst.VBUF_NVS_NS = "a_nvs";
VtxBufConst.VBUF_NVS2_NS = "a_nvs2";
VtxBufConst.VBUF_CVS_NS = "a_cvs";
VtxBufConst.VBUF_CVS2_NS = "a_cvs2";
VtxBufConst.VBUF_TVS_NS = "a_tvs";
VtxBufConst.VBUF_TVS2_NS = "a_tvs2";

class VtxNormalType {}

VtxNormalType.FLAT = 210;
VtxNormalType.GOURAND = 310;
exports.VtxNormalType = VtxNormalType;
exports.default = VtxBufConst;

/***/ }),

/***/ "8ae4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ROIndicesRes {
  constructor() {
    this.m_uid = 0;
    this.m_vtx = null;
    this.m_vtxUid = 0;
    this.m_gpuBuf = null;
    this.m_ivsSize = 0;
    this.ibufStep = 0;
    this.m_uid = ROIndicesRes.s_uid + 1;
  }

  getUid() {
    return this.m_uid;
  }

  getVtxUid() {
    return this.m_vtxUid;
  }

  getGpuBuf() {
    return this.m_gpuBuf;
  }

  getVTCount() {
    return this.m_ivsSize;
  }

  updateToGpu(rc) {
    if (this.m_gpuBuf != null && this.m_ivsSize > 0) {
      let vtx = this.m_vtx; // console.log("indeces updateToGpu vtx.getUId(): ",vtx.getUid(), ", this.version != vtx.indicesVer: ", this.version != vtx.indicesVer);

      if (this.version != vtx.indicesVer) {
        this.m_ivs = vtx.getIvsData();
        rc.bindEleBuf(this.m_gpuBuf);

        if (this.m_ivsSize >= this.m_ivs.length) {
          //console.log("A indeces updateToGpu vtx.getUId(): ",vtx.getUid(), ", ivs.length", this.m_ivs.length);
          rc.eleBufSubData(this.m_ivs, vtx.getBufDataUsage());
        } else {
          //console.log("B indeces updateToGpu vtx.getUId(): ",vtx.getUid(), ", ivs.length", this.m_ivs.length);
          rc.eleBufData(this.m_ivs, vtx.getBufDataUsage());
        }

        this.m_ivsSize = this.m_ivs.length;
        this.version = vtx.indicesVer;
      }
    }
  }

  initialize(rc, vtx) {
    if (this.m_gpuBuf == null && vtx.getIvsData() != null) {
      this.version = vtx.indicesVer;
      this.m_vtx = vtx;
      this.m_vtxUid = vtx.getUid();
      this.m_ivs = vtx.getIvsData();
      this.m_gpuBuf = rc.createBuf();
      rc.bindEleBuf(this.m_gpuBuf);

      if (vtx.bufData == null) {
        rc.eleBufData(this.m_ivs, vtx.getBufDataUsage());
        this.m_ivsSize = this.m_ivs.length;
      } else {
        rc.eleBufDataMem(vtx.bufData.getIndexDataTotalBytes(), vtx.getBufDataUsage());
        let uintArr = null;
        let offset = 0;
        this.m_ivsSize = 0;

        for (let i = 0, len = vtx.bufData.getIndexDataTotal(); i < len; ++i) {
          uintArr = vtx.bufData.getIndexDataAt(i);
          rc.eleBufSubData(uintArr, offset);
          offset += uintArr.byteLength;
          this.m_ivsSize += uintArr.length;
        }
      }
    }
  }

  destroy(rc) {
    if (this.m_gpuBuf != null) {
      this.m_vtx = null;
      rc.deleteBuf(this.m_gpuBuf);
      this.m_gpuBuf = null;
      this.m_ivs = null;
      this.m_ivsSize = 0;
    }
  }

}

ROIndicesRes.s_uid = 0;
exports.ROIndicesRes = ROIndicesRes;

/***/ }),

/***/ "8b17":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const Utils_1 = __webpack_require__("f689");

const GeometryBufferParser_1 = __webpack_require__("1280");

class FBXTreeBufferParser {
  constructor() {}

  parse(fbxTree, reader) {
    this.m_connections = this.parseConnections(fbxTree.map);
    const deformers = this.parseDeformers(fbxTree.map, this.m_connections);
    let parser = new GeometryBufferParser_1.GeometryBufferParser();
    parser.setReader(reader);
    const geometryMap = parser.parseGeomBuf(deformers, fbxTree.map, this.m_connections);
    this.parseScene(deformers, geometryMap, this.m_connections, fbxTree.map);
    return geometryMap;
  }

  parseScene(deformers, geometryMap, connections, fbxTree) {
    const modelMap = this.parseModels(geometryMap, connections, fbxTree);
  }

  parseModels(geometryMap, connections, fbxTree) {
    const modelMap = new Map();
    const modelNodes = fbxTree.Objects.Model;

    for (const nodeID in modelNodes) {
      const id = parseInt(nodeID);
      const node = modelNodes[nodeID];
      const relationships = connections.get(id); // let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );

      let model = null;

      if (true) {
        switch (node.attrType) {
          case 'Camera':
            // model = this.createCamera( relationships );
            break;

          case 'Light':
            // model = this.createLight( relationships );
            break;

          case 'Mesh':
            //model = this.createMesh( relationships, geometryMap, materialMap );
            break;

          case 'NurbsCurve':
            // model = this.createCurve( relationships, geometryMap );
            break;

          case 'LimbNode':
          case 'Root':
            // model = new Bone();
            break;

          case 'Null':
          default:
            // model = new Group();
            break;
        } //model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';


        model.ID = id;
      }

      this.getTransformData(model, node);
      modelMap.set(id, model);
    }

    return modelMap;
  }

  parseBufObjTransData(bufObj, modelID, connections, fbxTree) {
    // console.log("parseBufObjTransData(), modelID: ",modelID);
    const modelNodes = fbxTree.Objects.Model; // console.log("parseBufObjTransData(), modelNodes: ",modelNodes);

    const node = modelNodes[modelID];
    this.getTransformData(bufObj, node);

    if (bufObj.parent) {
      bufObj.userData.transformData.parentMatrix = node.parent.matrix;
      bufObj.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
    }

    const transform = Utils_1.generateTransform(bufObj.userData.transformData);
    bufObj.transform = transform; // if(bufObj.isEntity) {
    // 	console.log("### ### bufObj.userData: ", bufObj.userData);
    // 	console.log("### ### bufObj apply transform, transform: ", transform);
    // }
  } // parse the model node for transform data


  getTransformData(model, modelNode) {
    const transformData = {};
    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ('RotationOrder' in modelNode) transformData.eulerOrder = Utils_1.getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';
    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;
    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;
    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value; // console.log("XXXXXXXXXX getTransformData(),...");

    model.userData.transformData = transformData;
  }

  parseBegin(fbxTree, reader) {
    this.m_fbxTree = fbxTree;
    this.m_connections = this.parseConnections(fbxTree.map);
    const deformers = this.parseDeformers(fbxTree.map, this.m_connections);
    this.m_geomParser = new GeometryBufferParser_1.GeometryBufferParser();
    this.m_geomParser.setReader(reader);
    this.m_geomParser.parseGeomBufBegin(deformers, fbxTree.map, this.m_connections);
  }

  getGeomBufId() {
    if (this.m_geomParser != null) {
      return this.m_geomParser.getGeomBufId();
    }

    return -1;
  }

  parseGeomBufNext() {
    let obj;

    if (this.m_geomParser != null) {
      obj = this.m_geomParser.parseGeomBufNext();
      let ID = obj.ID; // console.log("this.m_fbxTree.map: ", this.m_fbxTree.map);
      // console.log("parseGeomBufNext(), ID, id: ", ID,obj.id);

      const relationships = this.m_connections.get(obj.id); // console.log("this.m_connections: ",this.m_connections);
      // console.log("relationships: ",relationships);

      let modelID = "";
      modelID = relationships.parents[0].ID + "";
      this.parseBufObjTransData(obj, modelID, this.m_connections, this.m_fbxTree.map);
    }

    return obj;
  }

  parseGeomBufAt(i) {
    let obj;

    if (this.m_geomParser != null) {
      obj = this.m_geomParser.parseGeomBufAt(i);
      const relationships = this.m_connections.get(obj.id);
      let modelID = "";
      modelID = relationships.parents[0].ID + "";
      this.parseBufObjTransData(obj, modelID, this.m_connections, this.m_fbxTree.map);
    }

    return obj;
  }

  isParsing() {
    if (this.m_geomParser != null) return this.m_geomParser.isParsing();
    return false;
  }

  getParseTotal() {
    if (this.m_geomParser != null) return this.m_geomParser.getParseTotal();
    return 0;
  } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type


  parseConnections(fbxTree) {
    const connectionMap = new Map();

    if ('Connections' in fbxTree) {
      const rawConnections = fbxTree.Connections.connections; // console.log("parseConnections(), begin...");

      rawConnections.forEach(function (rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1]; // console.log("parseConnections(), fromID, toID: ", fromID, toID);

        const relationship = rawConnection[2]; // let boo: boolean = false;

        if (!connectionMap.has(fromID)) {
          // if(fromID == 985892303) {
          // 	boo = true;
          // 	console.log("parseConnections(), ! connectionMap.has( 985892303 ), fromID: ", fromID);
          // }
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }

        const parentRelationship = {
          ID: toID,
          relationship: relationship
        };
        connectionMap.get(fromID).parents.push(parentRelationship); // if(fromID == 985892303) {
        // 	console.log("XXXXX ! connectionMap.has( toID ): ", ! connectionMap.has( toID ));
        // }

        if (!connectionMap.has(toID)) {
          // if(fromID == 985892303) {
          // 	console.log("XXXXX parseConnections(), build toID: ", toID);
          // }
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }

        const childRelationship = {
          ID: fromID,
          relationship: relationship
        };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }

    return connectionMap;
  } // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.


  parseDeformers(fbxTree, connections) {
    const skeletons = {};
    const morphTargets = {};
    return {
      skeletons: skeletons,
      morphTargets: morphTargets
    };
  }

}

exports.FBXTreeBufferParser = FBXTreeBufferParser;

/***/ }),

/***/ "8d98":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class TextureConst {
  static GetConst(gl, param) {
    switch (param) {
      case TextureConst.NEAREST:
        return gl.NEAREST;
        break;

      case TextureConst.LINEAR:
        return gl.LINEAR;
        break;

      case TextureConst.LINEAR_MIPMAP_LINEAR:
        return gl.LINEAR_MIPMAP_LINEAR;
        break;

      case TextureConst.NEAREST_MIPMAP_NEAREST:
        return gl.NEAREST_MIPMAP_NEAREST;
        break;

      case TextureConst.LINEAR_MIPMAP_NEAREST:
        return gl.LINEAR_MIPMAP_NEAREST;
        break;

      case TextureConst.NEAREST_MIPMAP_LINEAR:
        return gl.NEAREST_MIPMAP_LINEAR;
        break;

      case TextureConst.WRAP_REPEAT:
        return gl.REPEAT;
        break;

      case TextureConst.WRAP_CLAMP_TO_EDGE:
        return gl.CLAMP_TO_EDGE;
        break;

      case TextureConst.WRAP_MIRRORED_REPEAT:
        return gl.MIRRORED_REPEAT;
        break;

      default:
        break;
    }

    return -1;
  }

}

TextureConst.WRAP_REPEAT = 3001;
TextureConst.WRAP_CLAMP_TO_EDGE = 3002;
TextureConst.WRAP_MIRRORED_REPEAT = 3003;
TextureConst.NEAREST = 4001;
TextureConst.LINEAR = 4002;
TextureConst.LINEAR_MIPMAP_LINEAR = 4003;
TextureConst.NEAREST_MIPMAP_NEAREST = 4004;
TextureConst.LINEAR_MIPMAP_NEAREST = 4005;
TextureConst.NEAREST_MIPMAP_LINEAR = 4006;
exports.default = TextureConst;

/***/ }),

/***/ "8def":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VROBase_1 = __importDefault(__webpack_require__("919c"));

class VertexRenderObj extends VROBase_1.default {
  constructor() {
    super();
    this.shdp = null;
    this.vbufs = null;
    this.vbuf = null;
    this.attribTypes = null;
    this.wholeOffsetList = null;
    this.attribTypesLen = 0;
    this.updateUnlocked = true;
    this.wholeStride = 0;
    this.m_uid = VertexRenderObj.s_uid++;
  }

  run() {
    if (this.m_rc.testVROUid(this.m_uid)) {
      //console.log("VertexRenderObj::run(), B:",rc.getUid(),this.m_vtxUid,this.m_uid);
      if (this.vbuf != null) {
        this.m_rc.useVtxAttribsPtrTypeFloat(this.shdp, this.vbuf, this.attribTypes, this.attribTypesLen, this.wholeOffsetList, this.wholeStride);
      } else {
        this.m_rc.useVtxAttribsPtrTypeFloatMulti(this.shdp, this.vbufs, this.attribTypes, this.attribTypesLen, this.wholeOffsetList, this.wholeStride);
      }

      if (this.m_rc.testRIOUid(this.m_vtxUid)) {
        this.m_rc.bindEleBuf(this.ibuf);
      }
    }
  }

  __$destroy() {
    console.log("VertexRenderObj::__$destroy()..., " + this);
    VROBase_1.default.s_midMap.delete(this.m_mid);
    this.m_mid = 0;
    this.m_vtxUid = -1;
    this.m_rc = null;
    this.shdp = null;
    this.vbufs = null;
    this.vbuf = null;
    this.ibuf = null;
    this.attribTypes = null;
    this.attribTypesLen = 0;
    this.wholeStride = 0;
  }

  restoreThis() {
    VertexRenderObj.Restore(this);
  }

  toString() {
    return "VertexRenderObj(uid = " + this.m_uid + ", type=" + this.m_mid + ")";
  } //  private static s_midMap:Map<number,VertexRenderObj> = new Map();


  static HasMid(mid) {
    return VROBase_1.default.s_midMap.has(mid);
  }

  static GetByMid(mid) {
    return VROBase_1.default.s_midMap.get(mid);
  }

  static GetFreeId() {
    if (VertexRenderObj.s_freeIdList.length > 0) {
      return VertexRenderObj.s_freeIdList.pop();
    }

    return -1;
  }

  static Create(rc, mid, pvtxUid) {
    let unit = null;
    let index = VertexRenderObj.GetFreeId(); //console.log("VertexRenderObj::Create(), VertexRenderObj.s_unitList.length: "+VertexRenderObj.s_unitList.length);

    if (index >= 0) {
      unit = VertexRenderObj.s_unitList[index];
      VertexRenderObj.s_unitFlagList[index] = VertexRenderObj.s_FLAG_BUSY;
      unit.setMidAndBufUid(mid, pvtxUid);
    } else {
      unit = new VertexRenderObj();
      unit.setMidAndBufUid(mid, pvtxUid);
      VertexRenderObj.s_unitList.push(unit);
      VertexRenderObj.s_unitFlagList.push(VertexRenderObj.s_FLAG_BUSY);
      VertexRenderObj.s_unitListLen++;
    }

    unit.setRC(rc);
    VROBase_1.default.s_midMap.set(mid, unit);
    return unit;
  }

  static Restore(pobj) {
    if (pobj != null && pobj.m_attachCount < 1 && VertexRenderObj.s_unitFlagList[pobj.getUid()] == VertexRenderObj.s_FLAG_BUSY) {
      let uid = pobj.getUid();
      VertexRenderObj.s_freeIdList.push(uid);
      VertexRenderObj.s_unitFlagList[uid] = VertexRenderObj.s_FLAG_FREE;

      pobj.__$destroy();
    }
  }

}

VertexRenderObj.s_uid = 0;
VertexRenderObj.s_FLAG_BUSY = 1;
VertexRenderObj.s_FLAG_FREE = 0;
VertexRenderObj.s_unitFlagList = [];
VertexRenderObj.s_unitListLen = 0;
VertexRenderObj.s_unitList = [];
VertexRenderObj.s_freeIdList = [];
exports.default = VertexRenderObj;

/***/ }),

/***/ "8df7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "8e17":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const v_m_180pk = 180.0 / Math.PI;
const v_m_minp = 1e-7;

class Vector3D {
  constructor(px = 0.0, py = 0.0, pz = 0.0, pw = 1.0) {
    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0;
    this.w = 0.0;
    this.x = px;
    this.y = py;
    this.z = pz;
    this.w = pw;
  }

  clone() {
    return new Vector3D(this.x, this.y, this.z, this.w);
  }

  setTo(px, py, pz, pw = 1.0) {
    this.x = px;
    this.y = py;
    this.z = pz;
    this.w = pw;
    return this;
  }

  fromArray(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.z = arr[offset + 2];
    return this;
  }

  toArray(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.z;
    return this;
  }

  fromArray4(arr, offset = 0) {
    this.x = arr[offset];
    this.y = arr[offset + 1];
    this.z = arr[offset + 2];
    this.w = arr[offset + 3];
    return this;
  }

  toArray4(arr, offset = 0) {
    arr[offset] = this.x;
    arr[offset + 1] = this.y;
    arr[offset + 2] = this.z;
    arr[offset + 3] = this.w;
    return this;
  }

  setXYZ(px, py, pz) {
    this.x = px;
    this.y = py;
    this.z = pz;
    return this;
  }

  copyFrom(v3) {
    this.x = v3.x;
    this.y = v3.y;
    this.z = v3.z;
    return this;
  }

  dot(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  }

  multBy(a) {
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  }

  normalize() {
    let d = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    if (d > v_m_minp) {
      this.x /= d;
      this.y /= d;
      this.z /= d;
    }

    return this;
  }

  normalizeTo(a) {
    let d = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

    if (d > v_m_minp) {
      a.x = this.x / d;
      a.y = this.y / d;
      a.z = this.z / d;
    } else {
      a.x = this.x;
      a.y = this.y;
      a.z = this.z;
    }
  }

  scaleVector(s) {
    this.x *= s.x;
    this.y *= s.y;
    this.z *= s.z;
    return this;
  }

  scaleBy(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  equalsXYZ(a) {
    return Math.abs(this.x - a.x) < v_m_minp && Math.abs(this.y - a.y) < v_m_minp && Math.abs(this.z - a.z) < v_m_minp;
  }

  equalsAll(a) {
    return Math.abs(this.x - a.x) < v_m_minp && Math.abs(this.y - a.y) < v_m_minp && Math.abs(this.z - a.z) < v_m_minp && Math.abs(this.w - a.w) < v_m_minp;
  }

  project() {
    let t = 1.0 / this.w;
    this.x *= t;
    this.y *= t;
    this.z *= t;
  }

  getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  getLengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  addBy(a) {
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  }

  subtractBy(a) {
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  }

  subtract(a) {
    return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
  }

  add(a) {
    return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z);
  }

  crossProduct(a) {
    return new Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
  }

  crossBy(a) {
    let px = this.y * a.z - this.z * a.y;
    let py = this.z * a.x - this.x * a.z;
    let pz = this.x * a.y - this.y * a.x;
    this.x = px;
    this.y = py;
    this.z = pz;
    return this;
  }

  reflectBy(nv) {
    let idotn2 = (this.x * nv.x + this.y * nv.y + this.z * nv.z) * 2.0;
    this.x = this.x - idotn2 * nv.x;
    this.y = this.y - idotn2 * nv.y;
    this.z = this.z - idotn2 * nv.z;
    return this;
  }

  scaleVecTo(va, scale) {
    this.x = va.x * scale;
    this.y = va.y * scale;
    this.z = va.z * scale;
    return this;
  }

  subVecsTo(va, vb) {
    this.x = va.x - vb.x;
    this.y = va.y - vb.y;
    this.z = va.z - vb.z;
    return this;
  }

  addVecsTo(va, vb) {
    this.x = va.x + vb.x;
    this.y = va.y + vb.y;
    this.z = va.z + vb.z;
    return this;
  }

  crossVecsTo(va, vb) {
    this.x = va.y * vb.z - va.z * vb.y;
    this.y = va.z * vb.x - va.x * vb.z;
    this.z = va.x * vb.y - va.y * vb.x;
    return this;
  }

  toString() {
    return "Vector3D(" + this.x + "" + this.y + "" + this.z + ")";
  }
  /**
   * 右手法则(为正)
   */


  static Cross(a, b, result) {
    result.x = a.y * b.z - a.z * b.y;
    result.y = a.z * b.x - a.x * b.z;
    result.z = a.x * b.y - a.y * b.x;
  } // (va1 - va0) 叉乘 (vb1 - vb0), 右手法则(为正)


  static CrossSubtract(va0, va1, vb0, vb1, result) {
    v_m_v0.x = va1.x - va0.x;
    v_m_v0.y = va1.y - va0.y;
    v_m_v0.z = va1.z - va0.z;
    v_m_v1.x = vb1.x - vb0.x;
    v_m_v1.y = vb1.y - vb0.y;
    v_m_v1.z = vb1.z - vb0.z;
    va0 = v_m_v0;
    vb0 = v_m_v1;
    result.x = va0.y * vb0.z - va0.z * vb0.y;
    result.y = va0.z * vb0.x - va0.x * vb0.z;
    result.z = va0.x * vb0.y - va0.y * vb0.x;
  }

  static Subtract(a, b, result) {
    result.x = a.x - b.x;
    result.y = a.y - b.y;
    result.z = a.z - b.z;
  }

  static DistanceSquared(a, b) {
    v_m_v0.x = a.x - b.x;
    v_m_v0.y = a.y - b.y;
    v_m_v0.z = a.z - b.z;
    return v_m_v0.getLengthSquared();
  }

  static DistanceXYZ(x0, y0, z0, x1, y1, z1) {
    v_m_v0.x = x0 - x1;
    v_m_v0.y = y0 - y1;
    v_m_v0.z = z0 - z1;
    return v_m_v0.getLength();
  }

  static Distance(v0, v1) {
    v_m_v0.x = v0.x - v1.x;
    v_m_v0.y = v0.y - v1.y;
    v_m_v0.z = v0.z - v1.z;
    return v_m_v0.getLength();
  }
  /**
   * get angle degree between two Vector3D objects
   * @param v0 src Vector3D object
   * @param v1 dst Vector3D object
   * @returns angle degree
   */


  static AngleBetween(v0, v1) {
    v0.normalizeTo(v_m_v0);
    v1.normalizeTo(v_m_v1);
    return Math.acos(v_m_v0.dot(v_m_v1)) * v_m_180pk;
  }
  /**
   * get angle radian between two Vector3D objects
   * @param v0 src Vector3D object
   * @param v1 dst Vector3D object
   * @returns angle radian
   */


  static RadianBetween(v0, v1) {
    v0.normalizeTo(v_m_v0);
    v1.normalizeTo(v_m_v1);
    return Math.acos(v_m_v0.dot(v_m_v1));
  }

  static RadianBetween2(v0, v1) {
    //  // c^2 = a^2 + b^2 - 2*a*b * cos(x)
    //  // cos(x) = (a^2 + b^2 - c^2) / 2*a*b
    let pa = v0.getLengthSquared();
    let pb = v1.getLengthSquared();
    v_m_v0.x = v0.x - v1.x;
    v_m_v0.y = v0.y - v1.y;
    v_m_v0.z = v0.z - v1.z;
    return Math.acos((pa + pb - v_m_v0.getLengthSquared()) / (2.0 * Math.sqrt(pa) * Math.sqrt(pb)));
  }

  static Reflect(iv, nv, rv) {
    let idotn2 = (iv.x * nv.x + iv.y * nv.y + iv.z * nv.z) * 2.0;
    rv.x = iv.x - idotn2 * nv.x;
    rv.y = iv.y - idotn2 * nv.y;
    rv.z = iv.z - idotn2 * nv.z;
  }
  /**
   * 逆时针转到垂直
   */


  static VerticalCCWOnXOY(v) {
    const x = v.x;
    v.x = -v.y;
    v.y = x;
  }
  /**
   * 顺时针转到垂直
   */


  static VerticalCWOnXOY(v) {
    const y = v.y;
    v.y = -v.x;
    v.x = y;
  }

}

Vector3D.X_AXIS = new Vector3D(1, 0, 0);
Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
Vector3D.ZERO = new Vector3D(0, 0, 0);
Vector3D.ONE = new Vector3D(1, 1, 1);
exports.default = Vector3D;
const v_m_v0 = new Vector3D();
const v_m_v1 = new Vector3D();

/***/ }),

/***/ "8eb0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ModuleNS;

(function (ModuleNS) {
  ModuleNS["ctmParser"] = "ctmGeomParser";
  ModuleNS["objParser"] = "objGeomParser";
  ModuleNS["dracoParser"] = "dracoGeomParser";
  ModuleNS["pngParser"] = "pngParser";
  ModuleNS["fbxFastParser"] = "fbxFastParser";
  ModuleNS["threadCore"] = "threadCore";
  ModuleNS["coSpaceApp"] = "coSpaceApp";
})(ModuleNS || (ModuleNS = {}));

exports.ModuleNS = ModuleNS;

/***/ }),

/***/ "8f7d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const GeometryDataUnit_1 = __webpack_require__("aeff");

const FBXParseTask_1 = __webpack_require__("e12d");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

class ModelNode {
  constructor() {
    this.models = null;
    this.transforms = null;
  }

  destroy() {
    this.models = null;
    this.transforms = null;
  }

}

class FBXParserListerner {
  constructor(unitPool, threadSchedule, module, receiverSchedule) {
    this.m_parseTask = null;
    this.m_nodeMap = new Map();
    this.m_moduleUrl = module.url;
    this.m_unitPool = unitPool;
    this.m_threadSchedule = threadSchedule;
    this.m_receiverSchedule = receiverSchedule; // console.log("XXXXX >>>> FBXParserListerner::constructor(), this.m_moduleUrl: ",this.m_moduleUrl);
  }

  addUrlToTask(url) {
    // console.log("XXXXX >>>> FBXParserListerner::addUrlToTask(), url: ", url, !this.m_unitPool.hasUnitByUrl(url));
    if (!this.m_unitPool.hasUnitByUrl(url)) {
      if (this.m_parseTask == null) {
        // 创建ctm 加载解析任务
        let parseTask = new FBXParseTask_1.FBXParseTask(this.m_moduleUrl); // 绑定当前任务到多线程调度器

        this.m_threadSchedule.bindTask(parseTask);
        parseTask.setListener(this);
        this.m_parseTask = parseTask;
      }

      new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
        console.log("正在解析fbx数据...");
        DivLog_1.default.ShowLogOnce("正在解析fbx数据...");
        this.m_parseTask.addBinaryData(buf, url);
      }, (progress, url) => {
        let k = Math.round(100 * progress);
        DivLog_1.default.ShowLogOnce("fbx file loading " + k + "%");
      }, (status, url) => {
        console.error("load fbx mesh data error, url: ", url);
      });
    }
  } // 一个任务数据处理完成后的侦听器回调函数


  fbxParseFinish(models, transform, url, index, total) {
    // console.log("### FbxParserListerner::fbxParseFinish(), models: ", models, ", url: ", url);
    // console.log("AAAYYYT01 this.m_unitPool.hasUnitByUrl(url): ", this.m_unitPool.hasUnitByUrl(url));
    // let unit = this.m_unitPool.hasUnitByUrl(url);
    if (this.m_unitPool.hasUnitByUrl(url)) {
      let unit = this.m_unitPool.getUnitByUrl(url);
      let m = this.m_nodeMap;

      if (m.has(url)) {
        let node = m.get(url); //ls = ls.concat(models);

        for (let i = 0; i < models.length; ++i) {
          node.models.push(models[i]);
          node.transforms.push(transform);
        }
      } else {
        let node = new ModelNode();
        node.models = models;
        node.transforms = [transform];
        m.set(url, node);
      }

      if (unit.data.modelReceiver != null) {
        unit.data.modelReceiver(models, [transform], index, total);
      }

      if (index + 1 < total) {
        return;
      } // console.log("AAAYYYT02 unit != null: ", unit != null, index, total);


      if (unit != null) {
        let node = m.get(url);
        unit.lossTime = Date.now() - unit.lossTime;
        unit.data.dataFormat = GeometryDataUnit_1.DataFormat.FBX;
        unit.data.models = node.models;
        unit.data.transforms = node.transforms;
        node.destroy();
        m.delete(url); //if (transform != null) unit.data.transforms = [transform];

        GeometryDataUnit_1.DataUnitLock.lockStatus = 209;
        unit.toCpuPhase();

        if (unit.immediate) {
          // console.log("geom data receive at once.");
          this.m_receiverSchedule.testUnit(unit); // this.m_receiverSchedule.testUnitForce(unit);
        }
      }
    }
  }

  destroy() {
    if (this.m_parseTask != null) {
      this.m_parseTask.destroy();
      this.m_parseTask = null;
    }

    this.m_unitPool = null;
    this.m_threadSchedule = null;
    this.m_receiverSchedule = null;
  }

}

exports.FBXParserListerner = FBXParserListerner;

/***/ }),

/***/ "9156":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ROTransPool {
  // private static s_tcountMap: Map<number, number> = new Map();
  static SetTransUniform(mat, uniform, shdp) {
    let k = (mat.getUid() + 1) * 131 + shdp.getUid();

    if (!ROTransPool.s_transMap.has(k)) {
      ROTransPool.s_transMap.set(k, uniform);
      uniform.key = k; // let count = ROTransPool.s_tcountMap.get(mat.getUid());
      // ROTransPool.s_tcountMap.set(mat.getUid(), count+1);
    } // ROTransPool.s_transMap.set(mat.getUid(), uniform);

  }

  static GetTransUniform(mat, shdp) {
    if (mat.getUid() < 0) {
      throw Error("mat.getUid() < 0");
    }

    let k = (mat.getUid() + 1) * 131 + shdp.getUid();
    if (ROTransPool.s_transMap.has(k)) return ROTransPool.s_transMap.get(k); // if (ROTransPool.s_transMap.has(mat.getUid())) return ROTransPool.s_transMap.get(mat.getUid());

    return null;
  }

  static HasTransUniform(mat, shdp) {
    let k = (mat.getUid() + 1) * 131 + shdp.getUid();
    return ROTransPool.s_transMap.has(k); // return ROTransPool.s_transMap.has(mat.getUid());
  }

  static RemoveTransUniform(key) {
    if (ROTransPool.s_transMap.has(key)) {
      console.log("ROTransPool::RemoveTransUniform(), key: ", key);
      ROTransPool.s_transMap.delete(key);
    } // ROTransPool.s_transMap.delete(mat.getUid());

  }

}

ROTransPool.s_transMap = new Map();
exports.default = ROTransPool;

/***/ }),

/***/ "919c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class VROBase {
  constructor() {
    this.m_uid = 0; // vtx attribute hash map id

    this.m_mid = 0;
    this.m_vtxUid = 0;
    this.m_rc = null;
    this.indicesRes = null;
    this.ibuf = null;
    /**
     * be used by the renderer runtime, the value is 2 or 4.
     */

    this.ibufStep = 2;
    this.m_attachCount = 0;
  }

  getVTCount() {
    if (this.indicesRes != null) return this.indicesRes.getVTCount();
    return 0;
  }

  setRC(rc) {
    this.m_rc = rc;
  }

  setMidAndBufUid(mid, pvtxUid) {
    this.m_mid = mid;
    this.m_vtxUid = pvtxUid;
    this.m_attachCount = 0;
  }

  getUid() {
    return this.m_uid;
  }

  getVtxUid() {
    return this.m_vtxUid;
  }

  getMid() {
    return this.m_mid;
  }
  /**
   * 被子类覆盖之后才有效
   */


  run() {}

  __$attachThis() {
    ++this.m_attachCount;
  }

  __$detachThis() {
    --this.m_attachCount;

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0; //console.log("VROBase::__$detachThis() this.m_attachCount value is 0.");
    }
  }

  __$destroy() {
    //console.log("VROBase::__$destroy()..., ("+this.m_uid+")this.m_attachCount: "+this.m_attachCount);
    VROBase.s_midMap.delete(this.m_mid);
    this.m_mid = 0;
    this.m_vtxUid = -1;
    this.ibuf = null;
    this.m_rc = null;
    this.indicesRes = null;
  }

  restoreThis() {}

  static HasMid(mid) {
    return VROBase.s_midMap.has(mid);
  }

  static GetByMid(mid) {
    return VROBase.s_midMap.get(mid);
  } // static Reset(): void {
  //     VROBase.s_mid = -1;
  // }


  __$resetVRO() {
    VROBase.s_mid = -1;
  }

}

VROBase.s_mid = 0;
VROBase.s_midMap = new Map();
exports.default = VROBase;

/***/ }),

/***/ "9259":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const FBXTree_1 = __webpack_require__("9a2d");

const Utils_1 = __webpack_require__("f689"); // parse an FBX file in ASCII format


class TextParser {
  constructor() {
    this.currentIndent = 0;
    this.allNodes = new FBXTree_1.FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = '';
  }

  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }

  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }

  getCurrentProp() {
    return this.currentProp;
  }

  pushStack(node) {
    this.nodeStack.push(node);
    this.currentIndent += 1;
  }

  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }

  setCurrentProp(val, name) {
    this.currentProp = val;
    this.currentPropName = name;
  }

  parse(text) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree_1.FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = '';
    const scope = this;
    const split = text.split(/[\r\n]+/);
    split.forEach(function (line, i) {
      const matchComment = line.match(/^[\s\t]*;/);
      const matchEmpty = line.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty) return; // const matchBeginning = line.match( '^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '' );

      const matchBeginning = line.match('^\\t{' + scope.currentIndent + '}(\\w+):(.*){');
      const matchProperty = line.match('^\\t{' + scope.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)');
      const matchEnd = line.match('^\\t{' + (scope.currentIndent - 1) + '}}');

      if (matchBeginning) {
        scope.parseNodeBegin(line, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line, matchProperty, split[++i]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line.match(/^[^\s\t}]/)) {
        // large arrays are split over multiple lines terminated with a ',' character
        // if this is encountered the line needs to be joined to the previous line
        scope.parseNodePropertyContinued(line);
      }
    });
    return this.allNodes;
  }

  parseNodeBegin(line, property) {
    const nodeName = property[1].trim().replace(/^"/, '').replace(/"$/, '');
    const nodeAttrs = property[2].split(',').map(function (attr) {
      return attr.trim().replace(/^"/, '').replace(/"$/, '');
    });
    const node = {
      name: nodeName
    };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode(); // a top node

    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node);
    } else {
      // a subnode
      // if the subnode already exists, append it
      if (nodeName in currentNode) {
        // special case Pose needs PoseNodes as an array
        if (nodeName === 'PoseNode') {
          currentNode.PoseNode.push(node);
        } else if (currentNode[nodeName].id !== undefined) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }

        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;
      } else if (typeof attrs.id === 'number') {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node;
      } else if (nodeName !== 'Properties70') {
        if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;
      }
    }

    if (typeof attrs.id === 'number') node.id = attrs.id;
    if (attrs.name !== '') node.attrName = attrs.name;
    if (attrs.type !== '') node.attrType = attrs.type;
    this.pushStack(node);
  }

  parseNodeAttr(attrs) {
    let id = attrs[0];

    if (attrs[0] !== '') {
      id = parseInt(attrs[0]);

      if (isNaN(id)) {
        id = attrs[0];
      }
    }

    let name = '',
        type = '';

    if (attrs.length > 1) {
      name = attrs[1].replace(/^(\w+)::/, '');
      type = attrs[2];
    }

    return {
      id: id,
      name: name,
      type: type
    };
  }

  parseNodeProperty(line, property, contentLine) {
    let propName = property[1].replace(/^"/, '').replace(/"$/, '').trim();
    let propValue = property[2].replace(/^"/, '').replace(/"$/, '').trim(); // for special case: base64 image data follows "Content: ," line
    //	Content: ,
    //	 "/9j/4RDaRXhpZgAATU0A..."

    if (propName === 'Content' && propValue === ',') {
      propValue = contentLine.replace(/"/g, '').replace(/,$/, '').trim();
    }

    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;

    if (parentName === 'Properties70') {
      this.parseNodeSpecialProperty(line, propName, propValue);
      return;
    } // Connections


    if (propName === 'C') {
      const connProps = propValue.split(',').slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(',').slice(3);
      rest = rest.map(function (elem) {
        return elem.trim().replace(/^"/, '');
      });
      propName = 'connections';
      propValue = [from, to];
      Utils_1.append(propValue, rest);

      if (currentNode[propName] === undefined) {
        currentNode[propName] = [];
      }
    } // Node


    if (propName === 'Node') currentNode.id = propValue; // connections

    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;
    }

    this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it

    if (propName === 'a' && propValue.slice(-1) !== ',') {
      currentNode.a = Utils_1.parseNumberArray(propValue);
    }
  }

  parseNodePropertyContinued(line) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value
    // so convert the string to an array

    if (line.slice(-1) !== ',') {
      currentNode.a = Utils_1.parseNumberArray(currentNode.a);
    }
  } // parse "Property70"


  parseNodeSpecialProperty(line, propName, propValue) {
    // split this
    // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
    // into array like below
    // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
    const props = propValue.split('",').map(function (prop) {
      return prop.trim().replace(/^\"/, '').replace(/\s/, '_');
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4]; // cast values where needed, otherwise leave as strings

    switch (innerPropType1) {
      case 'int':
      case 'enum':
      case 'bool':
      case 'ULongLong':
      case 'double':
      case 'Number':
      case 'FieldOfView':
        innerPropValue = parseFloat(innerPropValue);
        break;

      case 'Color':
      case 'ColorRGB':
      case 'Vector3D':
      case 'Lcl_Translation':
      case 'Lcl_Rotation':
      case 'Lcl_Scaling':
        innerPropValue = Utils_1.parseNumberArray(innerPropValue);
        break;
    } // CAUTION: these props must append to parent's parent


    this.getPrevNode()[innerPropName] = {
      'type': innerPropType1,
      'type2': innerPropType2,
      'flag': innerPropFlag,
      'value': innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }

}

exports.TextParser = TextParser;

/***/ }),

/***/ "9260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const KeyboardEvent_1 = __importDefault(__webpack_require__("7045"));

class Keyboard {
  static KeyDown(evt) {
    var len = Keyboard.m_down_listener.length; //console.log("KeyDown(), m_down_listener.length: ",len);

    for (var i = 0; i < len; ++i) {
      Keyboard.m_down_listener[i].call(Keyboard.m_down_ers[i], evt);
    }
  }

  static KeyUp(evt) {
    let len = Keyboard.m_up_listener.length; //console.log("KeyUp(), m_up_listener.length: ",len);

    for (let i = 0; i < len; ++i) {
      Keyboard.m_up_listener[i].call(Keyboard.m_up_ers[i], evt);
    }
  }

  static AddEventListener(type, target, func) {
    if (func != null) {
      let i = 0;

      switch (type) {
        case KeyboardEvent_1.default.KEY_DOWN:
          for (i = Keyboard.m_down_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_down_listener[i]) {
              break;
            }
          }

          if (i < 0) {
            Keyboard.m_down_ers.push(target);
            Keyboard.m_down_listener.push(func);
          }

          break;

        case KeyboardEvent_1.default.KEY_UP:
          for (i = Keyboard.m_up_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_up_listener[i]) {
              break;
            }
          }

          if (i < 0) {
            Keyboard.m_up_ers.push(target);
            Keyboard.m_up_listener.push(func);
          }

          break;

        default:
          break;
      }
    }
  }

  static RemoveEventListener(type, func) {
    if (func != null) {
      let i;

      switch (type) {
        case KeyboardEvent_1.default.KEY_DOWN:
          for (i = Keyboard.m_down_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_down_listener[i]) {
              Keyboard.m_down_ers.splice(i, 1);
              Keyboard.m_down_listener.splice(i, 1);
              break;
            }
          }

          break;

        case KeyboardEvent_1.default.KEY_UP:
          for (i = Keyboard.m_up_listener.length - 1; i >= 0; --i) {
            if (func === Keyboard.m_up_listener[i]) {
              Keyboard.m_up_ers.splice(i, 1);
              Keyboard.m_up_listener.splice(i, 1);
              break;
            }
          }

          break;

        default:
          break;
      }
    }
  }

}

Keyboard.SHIFT = 16;
Keyboard.CTRL = 17;
Keyboard.ALT = 18;
Keyboard.ESC = 27;
Keyboard.A = 65;
Keyboard.B = 66;
Keyboard.C = 67;
Keyboard.D = 68;
Keyboard.E = 69;
Keyboard.F = 70;
Keyboard.G = 71;
Keyboard.H = 72;
Keyboard.I = 73;
Keyboard.J = 74;
Keyboard.K = 75;
Keyboard.L = 76;
Keyboard.M = 77;
Keyboard.N = 78;
Keyboard.O = 79;
Keyboard.P = 80;
Keyboard.Q = 81;
Keyboard.R = 82;
Keyboard.S = 83;
Keyboard.T = 84;
Keyboard.U = 85;
Keyboard.V = 86;
Keyboard.W = 87;
Keyboard.X = 88;
Keyboard.Y = 89;
Keyboard.Z = 90;
Keyboard.m_down_ers = [];
Keyboard.m_down_listener = [];
Keyboard.m_up_ers = [];
Keyboard.m_up_listener = [];
exports.default = Keyboard;

/***/ }),

/***/ "937b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const BinaryReader_1 = __webpack_require__("f7ee");

const FBXTree_1 = __webpack_require__("9a2d"); // import * as fflate from '../libs/fflate.module.js';


const BufPropertyParser_1 = __webpack_require__("c758"); // Parse an FBX file in Binary format


class BufferBinaryParser {
  constructor() {
    this.m_reader = null;
    this.m_allNodes = null;
    this.m_version = 0;
    this.m_parsing = false;
    this.m_parsingIndex = 0;
    this.subLossTime = 0;
    this.nodeParsingTotal = 0;
    this.totalBP = 0;
    this.totalBPTime = 0;
    this.m_isObjects = false;
    this.m_isGeometry = false; // private m_ppFlag: number = 0;

    this.m_debug = false;
    this.m_pptParser = new BufPropertyParser_1.BufPropertyParser();
  }

  parse(buffer) {
    const reader = new BinaryReader_1.BinaryReader(buffer);
    reader.skip(23); // skip magic 23 bytes

    const version = reader.getUint32();

    if (version < 6400) {
      throw new Error('FBXLoader: FBX version not supported, FileVersion: ' + version);
    }

    const allNodes = new FBXTree_1.FBXTree();

    while (!this.endOfContent(reader)) {
      const node = this.parseNode(reader, version);
      if (node !== null) allNodes.add(node.name, node);
    }

    return allNodes;
  }

  getFBXTree() {
    return this.m_allNodes;
  }

  getReader() {
    return this.m_reader;
  }

  parseBegin(buffer) {
    let reader = new BinaryReader_1.BinaryReader(buffer);
    reader.skip(23); // skip magic 23 bytes

    const version = reader.getUint32();

    if (version < 6400) {
      throw new Error('FBXLoader: FBX version not supported, FileVersion: ' + version);
    }

    this.m_reader = reader;
    this.m_version = version;
    this.m_parsingIndex = 0;
    let allNodes = new FBXTree_1.FBXTree();
    this.m_allNodes = allNodes;
    this.m_parsing = !this.endOfContent(reader);
    return allNodes;
  }

  parseNext() {
    const allNodes = this.m_allNodes;
    const reader = this.m_reader;
    this.m_parsing = !this.endOfContent(reader);
    this.subLossTime = 0;
    this.nodeParsingTotal = 0;

    if (this.m_parsing) {
      this.m_parsingIndex++;
      let time = Date.now();
      const node = this.parseNode(reader, this.m_version); //console.log("### c0 BufferBinaryParser::parseNext(), lossTime: ", (Date.now() - time), "sub lossTime: ",this.subLossTime);

      if (node != null) {
        let ns = node.name != undefined ? "-" + node.name : "";
        console.log("### parse(" + this.m_parsingIndex + ns + ") BufferBinaryParser::parseNext(), lossTime: ", Date.now() - time + " ms", "nodeParsingTotal: ", this.nodeParsingTotal);
      }

      if (node !== null) allNodes.add(node.name, node);
    }
  }

  isParsing() {
    return this.m_parsing;
  } // Check if reader has reached the end of content.


  endOfContent(reader) {
    // footer size: 160bytes + 16-byte alignment padding
    // - 16bytes: magic
    // - padding til 16-byte alignment (at least 1byte?)
    //	(seems like some exporters embed fixed 15 or 16bytes?)
    // - 4bytes: magic
    // - 4bytes: version
    // - 120bytes: zero
    // - 16bytes: magic
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  } // recursively parse nodes until the end of the file is reached


  parseNode(reader, version) {
    this.nodeParsingTotal++;
    const node = {}; // The first three data sizes depends on version.

    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
    version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

    const nameLen = reader.getUint8();
    const name = reader.getString(nameLen);

    if (this.m_debug) {
      if (name == "Objects") {
        console.log("node have Objects A");
        this.m_isObjects = true;
      }

      if (this.m_isObjects && name == "Geometry") {
        this.m_isGeometry = true;
        console.log("node have Geometry A");
      }

      if (this.m_isGeometry && name != "") {
        console.log("parseNode(), name: ", name);
      }
    } // if(name == "Vertices") {
    // 	console.log("Vertices begin A.");
    // }
    // Regards this node as NULL-record if endOffset is zero


    if (endOffset === 0) return null;
    const propertyList = new Array(numProperties);
    this.m_pptParser.ppFlag = 0; // if(name == "PolygonVertexIndex"){
    // 	this.m_ppFlag = 12;
    // }

    switch (name) {
      case "Vertices":
      case "Normals":
      case "PolygonVertexIndex":
      case "UV":
      case "NormalsIndex":
        this.m_pptParser.ppFlag = 12;
        break;

      case "Edges":
      case "NormalsW":
      case "Materials":
        this.m_pptParser.ppFlag = 131;
        break;

      default:
        break;
    }

    for (let i = 0; i < numProperties; i++) {
      propertyList[i] = this.m_pptParser.parseProperty(reader);
    }
    /*
    if(name == "Vertices") {
        console.log("parseNode name", name, " m_encoding: ", this.m_encoding, ",m_ppType: ",this.m_ppType);
        // console.log("Vertices begin m_encoding: ", this.m_encoding, ",m_ppType: ",this.m_ppType);
        console.log("Vertices begin propertyList: ", propertyList);
          // let u8Arr = reader.getArrayU8BufferByOffset( this.m_ppParams[0], this.m_ppParams[1] );
        // const data = fflate.unzlibSync( u8Arr, null );
        // const r2 = new BinaryReader( data.buffer );
        // let datafs = r2.getFloat64Array( this.m_ppParams[2] );
        // console.log("this.m_ppParams[1]: ",this.m_ppParams[1]);
        // console.log("pptlfs: ",propertyList[0]);
        // console.log("datafs: ",datafs);
      } else if(name == "Normals"){
        console.log("parseNode name", name, " m_encoding: ", this.m_encoding, ",m_ppType: ",this.m_ppType);
        console.log("Normals begin propertyList: ", propertyList);
    } else if(name == "UV"){
        console.log("parseNode name", name, " m_encoding: ", this.m_encoding, ",m_ppType: ",this.m_ppType);
        console.log("UV begin propertyList: ", propertyList);
    }
    //*/
    // if(name == "PolygonVertexIndex"){
    // 	console.log("parseNode name", name, " encoding: ", this.m_pptParser.encoding, ",ppType: ",this.m_pptParser.ppType);
    // 	console.log("PolygonVertexIndex begin propertyList: ", propertyList);
    // }
    // if(name == "PolygonVertexIndex"){
    // 	console.log("parseNode name", name, " m_encoding: ", this.m_encoding, ",m_ppType: ",this.m_ppType);
    // 	console.log("PolygonVertexIndex begin propertyList: ", propertyList);
    // }
    // if(name == "NormalsIndex"){
    // 	console.log("parseNode name", name, " m_encoding: ", this.m_pptParser.encoding, ",m_ppType: ",this.m_pptParser.ppType);
    // 	console.log("NormalsIndex begin propertyList: ", propertyList);
    // }
    //
    // else if(name == "LayerElementUV"){
    // 	console.log("LayerElementUV begin propertyList: ", propertyList);
    // }
    //
    // Regards the first three elements in propertyList as id, attrName, and attrType


    const id = propertyList.length > 0 ? propertyList[0] : '';
    const attrName = propertyList.length > 1 ? propertyList[1] : '';
    const attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property
    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}

    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false; // console.log("endOffset: ",endOffset, ", reader.getOffset(): ", reader.getOffset());
    // let ps = reader.getOffset();
    // while ( endOffset > ps ) {

    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version);
      if (subNode !== null) this.parseSubNode(name, node, subNode);
    }

    node.propertyList = propertyList; // raw property list used by parent

    if (typeof id === 'number') node.id = id;
    if (attrName !== '') node.attrName = attrName;
    if (attrType !== '') node.attrType = attrType;
    if (name !== '') node.name = name;
    /*
    if(name == "Vertices") {
        console.log("Vertices begin B.");
    }
    if(this.m_debug) {
        if(name == "Geometry") {
            console.log("node have Geometry B");
        }
        if(name == "Objects") {
            console.log("node have Objects B");
        }
    }
    //*/

    return node;
  }

  parseSubNode(name, node, subNode) {
    // special case: child node is single property
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];

      if (value.buffer != undefined) {
        console.log("parseSubNode(), value.buffer.byteLength: ", value.buffer.byteLength);
      } //if ( Array.isArray( value ) ) {


      if (value instanceof Array) {
        node[subNode.name] = subNode;
        subNode.a = value;
      } else {
        //console.log("value: ",value, typeof value);
        node[subNode.name] = value;
      }
    } else if (name === 'Connections' && subNode.name === 'C') {
      let ls = subNode.propertyList; // console.log("BinaryParser::parseSubNode(), ls: ",ls);

      let len = ls.length - 1;
      if (len < 0) len = 0;
      const array = new Array(len);

      for (let i = 1, j = 0; i < ls.length; ++i) {
        array[j] = ls[i];
        j++;
      }

      if (node.connections === undefined) {
        node.connections = [];
      } // console.log("BinaryParser::parseSubNode(), node.connections.push( array ): ",array);


      node.connections.push(array);
    } else if (subNode.name === 'Properties70') {
      const keys = Object.keys(subNode);
      keys.forEach(function (key) {
        node[key] = subNode[key];
      });
    } else if (name === 'Properties70' && subNode.name === 'P') {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');
      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');

      if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {
        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
      } else {
        innerPropValue = subNode.propertyList[4];
      } // this will be copied to parent, see above


      node[innerPropName] = {
        'type': innerPropType1,
        'type2': innerPropType2,
        'flag': innerPropFlag,
        'value': innerPropValue
      };
    } else if (node[subNode.name] === undefined) {
      if (typeof subNode.id === 'number') {
        node[subNode.name] = {};
        node[subNode.name][subNode.id] = subNode;
      } else {
        node[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === 'PoseNode') {
        if (!Array.isArray(node[subNode.name])) {
          node[subNode.name] = [node[subNode.name]];
        }

        node[subNode.name].push(subNode);
      } else if (node[subNode.name][subNode.id] === undefined) {
        node[subNode.name][subNode.id] = subNode;
      }
    }
  }

}

exports.BufferBinaryParser = BufferBinaryParser;

/***/ }),

/***/ "9468":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

const SceneNode_1 = __webpack_require__("7577");

class CTMSceneNode extends SceneNode_1.SceneNode {
  constructor() {
    super();
    this.m_index = 0;
  }

  load(urls) {
    if (urls != null) {
      super.load(urls);
      this.m_index = 0;
      this.m_modelsTotal = urls.length;
      this.m_waitPartsTotal = this.m_modelsTotal;
      this.m_showTotal = 0;

      for (let i = 0; i < this.m_modelsTotal; ++i) {
        this.loadCTMByUrl(urls[i]);
      }
    }
  }

  loadCTMByUrl(url) {
    // this.textCTM(url);
    // return;
    this.m_cospace.geometry.getCPUDataByUrlAndCallback(url, DataUnit_1.DataFormat.CTM, (unit, status) => {
      let model = unit.data.models[0];

      if (model.normals == null) {
        console.error("model.normals == null, url: ", url);
      }

      this.initEntity(model, null, this.m_index);
      this.m_index++;

      if (this.m_index == this.m_modelsTotal) {
        this.m_waitPartsTotal = 0;
      }
    }, true);
  }

}

exports.CTMSceneNode = CTMSceneNode;

/***/ }),

/***/ "955e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// gpu射线检测拾取代理对象

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const RaySelectedNode_1 = __importDefault(__webpack_require__("c120"));

const RenderConst_1 = __webpack_require__("e08e");

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const Color4_1 = __importDefault(__webpack_require__("3930"));

const PixelPickIndexMaterial_1 = __importDefault(__webpack_require__("e7ce"));

const AABBCalc_1 = __webpack_require__("e160");

class RayGpuSelector {
  constructor() {
    this.m_initColor = new Color4_1.default();
    this.m_indexMaterial = new PixelPickIndexMaterial_1.default();
    this.m_renderer = null;
    this.m_camera = null;
    this.m_headNode = null;
    this.m_rsn = null; // 最多检测256个对象

    this.m_hitList = new Uint8Array(256);
    this.m_rsnList = null;
    this.m_selectedNode = null;
    this.m_selectedTotal = 0;
    this.m_testMode = 0;
    this.m_invpv = new Vector3D_1.default();
    this.m_invtv = new Vector3D_1.default();
    this.m_rlpv = null;
    this.m_rltv = null;
    this.m_rlsiv = new Uint8Array(4);
    this.m_rlinvtv = new Vector3D_1.default();
    this.m_outv = new Vector3D_1.default();
    this.m_vecs = [null, null];
    this.m_gpuTestEnabled = true;
    this.m_uintArray = new Uint8Array(4);
    this.m_uintList = new Uint8Array(256);
  } //  setGPUTestEnabled(enabled:boolean):void
  //  {
  //      this.m_gpuTestEnabled = enabled;
  //  }


  setRenderer(renderer) {
    this.m_renderer = renderer;
  }

  setRayTestMode(testMode) {
    this.m_testMode = testMode;
  }

  setRay(rlpv, rltv) {
    this.m_rlpv = rlpv;
    this.m_rltv = rltv;
  }

  getRay(out_rlpv, out_rltv) {
    out_rlpv.copyFrom(this.m_rlpv);
    out_rltv.copyFrom(this.m_rltv);
  }

  setCamera(cam) {
    this.m_camera = cam;
  }

  setCullingNodeHead(headNode) {
    this.m_headNode = headNode;

    if (this.m_rsnList == null) {
      this.m_rsnList = [];
      let i = 0;

      for (; i < 256; ++i) {
        this.m_rsnList.push(new RaySelectedNode_1.default());
      }
    }
  }

  getSelectedNode() {
    return this.m_selectedNode;
  }

  getSelectedNodes() {
    return this.m_rsnList;
  }

  getSelectedNodesTotal() {
    return this.m_selectedTotal;
  }

  sorting(low, high) {
    let arr = this.m_rsnList; //标记位置为待排序数组段的low处也就时枢轴值

    this.m_rsn = arr[low];

    while (low < high) {
      //  如果当前数字已经有序的位于我们的枢轴两端，我们就需要移动它的指针，是high或是low
      while (low < high && arr[high].dis >= this.m_rsn.dis) {
        --high;
      } // 如果当前数字不满足我们的需求，我们就需要将当前数字移动到它应在的一侧


      arr[low] = arr[high];

      while (low < high && arr[low].dis <= this.m_rsn.dis) {
        ++low;
      }

      arr[high] = arr[low];
    }

    arr[low] = this.m_rsn;
    return low;
  }

  snsort(low, high) {
    if (low < high) {
      let pos = this.sorting(low, high);
      this.snsort(low, pos - 1);
      this.snsort(pos + 1, high);
    }
  }

  run() {
    let nextNode = this.m_headNode; //console.log("RaySelect run() nextNode != null: "+(nextNode != null));

    if (nextNode != null) {
      let dis = 0.0;
      let rtv = this.m_rltv;
      let rpv = this.m_rlpv;
      let outv = this.m_outv;
      let node = null;
      let total = 0;

      if (Math.abs(rtv.x) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.x = 1.0 / rtv.x;
      } else {
        this.m_rlinvtv.x = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (Math.abs(rtv.y) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.y = 1.0 / rtv.y;
      } else {
        this.m_rlinvtv.y = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (Math.abs(rtv.z) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.z = 1.0 / rtv.z;
      } else {
        this.m_rlinvtv.z = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (this.m_rlinvtv.x < 0) this.m_rlsiv[0] = 1;else this.m_rlsiv[0] = 0;
      if (this.m_rlinvtv.y < 0) this.m_rlsiv[1] = 1;else this.m_rlsiv[1] = 0;
      if (this.m_rlinvtv.z < 0) this.m_rlsiv[2] = 1;else this.m_rlsiv[2] = 0;

      while (nextNode != null) {
        if (nextNode.drawEnabled && nextNode.entity.mouseEnabled) {
          // outv.x = nextNode.bounds.center.x - rpv.x;
          // outv.y = nextNode.bounds.center.y - rpv.y;
          // outv.z = nextNode.bounds.center.z - rpv.z;
          outv.subVecsTo(nextNode.bounds.center, rpv);
          dis = outv.dot(rtv);
          outv.x -= dis * rtv.x;
          outv.y -= dis * rtv.y;
          outv.z -= dis * rtv.z;

          if (outv.getLengthSquared() <= nextNode.bounds.radius2) {
            // 如果只是几何检测(例如球体包围体的检测)就不需要在进入后续的aabb检测
            if (nextNode.rayTestState < 1) {
              this.m_vecs[0] = nextNode.bounds.min;
              this.m_vecs[1] = nextNode.bounds.max;

              if (AABBCalc_1.AABBCalc.IntersectionRL3(this.m_vecs, this.m_rlsiv, this.m_rlinvtv, rtv, rpv, outv)) {
                node = this.m_rsnList[total];
                node.entity = nextNode.entity;
                node.dis = this.m_rlinvtv.w;
                node.wpv.copyFrom(outv); //  console.log("H Hit Dis: "+rtv.dot(outv));
                //console.log("Ray hit test a renderNode.");

                ++total;
              }
            } //  else
            //  {
            //      //其他检测方式
            //  }

          }
        }

        nextNode = nextNode.next;
      }

      this.m_selectedNode = null;
      let i = 0;

      if (total > 0) {
        let invpv = this.m_invpv;
        let invtv = this.m_invtv;
        let entity = null;
        let flag = 0;
        let hitTotal = 0;
        let mat4 = null;
        let rayNode = null;
        let pvdis = rtv.dot(rpv);
        let preDis = 0.0;
        let polyTest = !this.m_gpuTestEnabled;
        let polyTotal = 0;

        if (total > 1) {
          this.snsort(0, total - 1);

          for (i = 0; i < total; ++i) {
            rayNode = this.m_rsnList[i];
            entity = this.m_rsnList[i].entity;

            if (entity.isPolyhedral()) {
              if (polyTest) {
                mat4 = entity.getInvMatrix();
                mat4.transformOutVector3(rpv, invpv);
                mat4.deltaTransformOutVector(rtv, invtv);
                invtv.normalize();
                flag = entity.testRay(invpv, invtv, outv, true);
              } else {
                ++polyTotal;
                flag = 0;
              }
            } else {
              mat4 = entity.getInvMatrix();
              mat4.transformOutVector3(rpv, invpv);
              mat4.deltaTransformOutVector(rtv, invtv);
              invtv.normalize();
              flag = entity.testRay(invpv, invtv, outv, true);
            }

            if (flag > 0) {
              rayNode.lpv.copyFrom(outv);
              entity.getMatrix().transformOutVector3(outv, rayNode.wpv);
              rayNode.dis = rtv.dot(rayNode.wpv) - pvdis;
              this.m_hitList[hitTotal] = i;
              ++hitTotal; //console.log("YYYYYYYYYYYYYYYes multi Ray hit mesh success.");

              if (rayNode.dis > preDis) {
                this.m_selectedNode = rayNode;
                break;
              }
            } else if (flag < 0) {
              //console.log("NNNNNNNNNNNNNNNNo multi Ray hit mesh 没有做进一步的检测.");
              this.m_hitList[hitTotal] = i;
              ++hitTotal;

              if (rayNode.dis > preDis) {
                this.m_selectedNode = rayNode;
                break;
              }
            }

            preDis = rayNode.dis;
          }

          if (this.m_selectedNode == null && hitTotal > 0) {
            this.m_selectedNode = this.m_rsnList[this.m_hitList[0]];
          }
        } else {
          rayNode = this.m_rsnList[0];
          entity = this.m_rsnList[0].entity;
          mat4 = entity.getInvMatrix();
          mat4.transformOutVector3(rpv, invpv);
          mat4.deltaTransformOutVector(rtv, invtv);
          invtv.normalize();

          if (entity.isPolyhedral()) {
            if (polyTest) {
              flag = entity.testRay(invpv, invtv, outv, true);
            } else {
              ++polyTotal;
              flag = 0;
            }
          } else {
            flag = entity.testRay(invpv, invtv, outv, true);
          } //console.log("hit flag: "+flag);


          if (flag > 0) {
            rayNode.lpv.copyFrom(outv);
            entity.getMatrix().transformOutVector3(outv, rayNode.wpv);
            rayNode.dis = rtv.dot(rayNode.wpv) - pvdis;
            this.m_selectedNode = rayNode; //console.log("YYYYYYYYYYYYYYYes Ray hit mesh success.");
          } else if (flag < 0) {
            //console.log("NNNNNNNNNNNNNNNo Ray hit mesh 没有做进一步的检测.");
            this.m_selectedNode = rayNode;
          }
        }

        if (polyTotal > 0) {
          if (this.m_testMode < 1) {
            // 进行gpu pixel 测试
            this.gpuPick(total);
          } else {
            if (this.m_selectedNode == null || this.m_selectedNode.entity.isPolyhedral()) {
              // 进行gpu pixel 测试
              this.gpuPick(total);
            }
          }
        } //console.log("YYYYYYYYYYYYYYYes Ray hit success.");

      }

      i = total;

      for (; i < this.m_selectedTotal; ++i) {
        //console.log("清理多余的 entity i: "+i);
        if (this.m_selectedNode != this.m_rsnList[i]) {
          this.m_rsnList[i].entity = null;
        }
      }

      this.m_selectedTotal = total;
    }
  }

  gpuPick(total) {
    let rcontext = this.m_renderer.getRendererContext();
    let proxy = this.m_renderer.getRenderProxy();
    let pmx = proxy.getStage3D().mouseX; //let pmy:number = proxy.getStage3D().stageHeight - proxy.getStage3D().mouseY;

    let pmy = proxy.getStage3D().mouseY;
    rcontext.vertexRenderBegin();
    rcontext.getClearRGBAColor4f(this.m_initColor);
    rcontext.setClearRGBAColor4f(0.0, 0.0, 0.0, 0.0);
    rcontext.setScissorEnabled(true);
    rcontext.setScissorRect(pmx, pmy, 1, 1);
    rcontext.clearBackBuffer();
    this.m_uintArray[3] = 0;
    RendererState_1.default.LockBlendMode(RenderConst_1.RenderBlendMode.OPAQUE);
    RendererState_1.default.LockDepthTestMode(RenderConst_1.DepthTestMode.OPAQUE);
    rcontext.unlockMaterial();
    rcontext.unlockRenderState();
    rcontext.useGlobalMaterial(this.m_indexMaterial, false, false);
    let rayNode = null;
    let entity = null;
    let j = -1;
    let i = 0;

    for (; i < total; ++i) {
      rayNode = this.m_rsnList[i];
      entity = this.m_rsnList[i].entity;

      if (entity.isPolyhedral()) {
        ++j;
        this.m_indexMaterial.setIndex(j + 2);
        this.m_uintList[j] = i;
        this.m_renderer.updateMaterialUniformToCurrentShd(this.m_indexMaterial);
        this.m_renderer.drawEntity(entity, false, true);
      }
    }

    if (j > -1) {
      proxy.readPixels(pmx, pmy, 1, 1, proxy.RGBA, proxy.UNSIGNED_BYTE, this.m_uintArray);
    }

    RendererState_1.default.UnlockBlendMode();
    RendererState_1.default.UnlockDepthTestMode(); //DivLog.ShowLog("uintArray[3]: "+this.m_uintArray[3]+", "+(((this.m_uintArray[0])<<8) + this.m_uintArray[1] + this.m_uintArray[2]/255.0));

    if (this.m_uintArray[3] > 1) {
      i = this.m_uintList[this.m_uintArray[3] - 2];
      rayNode = this.m_rsnList[i];
      let depth = (this.m_uintArray[0] << 8) + this.m_uintArray[1] + this.m_uintArray[2] / 255.0; //DivLog.ShowLog("depth: "+depth);

      if (this.m_selectedNode != null) {
        let selectedEntity = this.m_selectedNode.entity;

        if (this.m_selectedNode != rayNode && !selectedEntity.isPolyhedral()) {
          // 说明现在鼠标选中的非像素拾取对象更靠近摄像机
          if (this.m_selectedNode.dis < depth) {
            i = -1;
          }
        }
      }

      if (i > -1) {
        // 实际选中的是当前的通过像素拾取得到的对象
        rayNode.dis = depth; // 重新计算wpos和lpos

        this.getWorldPosByRayDistance(depth, this.m_rltv, this.m_camera.getPosition(), rayNode.wpv); //console.log(depth+","+rayNode.wpv.toString());

        this.m_selectedNode = rayNode;
      }
    }

    rcontext.setScissorEnabled(false);
    rcontext.unlockMaterial();
    rcontext.unlockRenderState();
    RendererState_1.default.UnlockBlendMode();
    RendererState_1.default.UnlockDepthTestMode();
    rcontext.setClearRGBAColor4f(this.m_initColor.r, this.m_initColor.g, this.m_initColor.b, this.m_initColor.a);
    rcontext.resetState();
  }

  clear() {
    this.m_selectedNode = null;
  } // @param           the cameraDistance is the distance between camera position and a position


  getWorldPosByRayDistance(cameraDistance, tv, camPv, resultV) {
    resultV.x = tv.x * cameraDistance + camPv.x;
    resultV.y = tv.y * cameraDistance + camPv.y;
    resultV.z = tv.z * cameraDistance + camPv.z; //console.log("### cameraDistance: "+cameraDistance);
    //  console.log("tv: "+tv.toString());
    //  console.log("camPv: "+camPv.toString());
    //  console.log("resultV: "+resultV.toString());
  }

}

exports.default = RayGpuSelector;

/***/ }),

/***/ "9666":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const ShaderData_1 = __importDefault(__webpack_require__("acfe"));

class MaterialResource {
  static CreateShdData(unique_name_str, vshdsrc, fshdSrc, adaptationShaderVersion, preCompileInfo) {
    //console.log("MaterialResource.CreateShdData() begin...");
    if (MaterialResource.s_shdDataDict.has(unique_name_str)) {
      return MaterialResource.s_shdDataDict.get(unique_name_str);
    }

    let p = new ShaderData_1.default();
    p.adaptationShaderVersion = adaptationShaderVersion;
    p.preCompileInfo = preCompileInfo;
    p.initialize(unique_name_str, vshdsrc, fshdSrc);
    MaterialResource.s_shdDataList[p.getUid()] = p;
    ++MaterialResource.s_shdDataListLen;
    MaterialResource.s_shdDataDict.set(unique_name_str, p);

    if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
      console.log("MaterialResource.Create() a new ShaderProgram: ", p.toString());
    }

    return p;
  }

  static FindData(unique_name_str) {
    if (MaterialResource.s_shdDataDict.has(unique_name_str)) {
      return MaterialResource.s_shdDataDict.get(unique_name_str);
    }

    return null;
  }

}

MaterialResource.s_shdDataDict = new Map();
MaterialResource.s_shdDataList = [];
MaterialResource.s_shdDataListLen = 0;
exports.default = MaterialResource;

/***/ }),

/***/ "984e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class GpuTexObect {
  constructor() {
    // wait del times
    this.waitDelTimes = 0; // renderer context unique id

    this.rcuid = 0; // texture resource unique id

    this.resUid = 0; // texture resolution size

    this.width = 0;
    this.height = 0; // for 3d texture

    this.depth = 0;
    this.sampler = 0; // gpu texture buffer

    this.texBuf = null;
    this.m_attachCount = 0;
  }

  __$attachThis() {
    ++this.m_attachCount;
  }

  __$detachThis() {
    --this.m_attachCount; //console.log("GpuTexObect::__$detachThis() this.m_attachCount: "+this.m_attachCount);

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0; //console.log("GpuTexObect::__$detachThis() this.m_attachCount value is 0.");
      // do something
    }
  }
  /**
   * bind the renderer runtime resource  to the current renderer context
   * @param gl system gpu context
   */


  bindToGpu(gl) {
    gl.bindTexture(this.sampler, this.texBuf);
  }

  getAttachCount() {
    return this.m_attachCount;
  }

} // gpu texture buffer renderer resource


class ROTextureResource {
  //readonly updater:ROTexDataUpdater = null;
  constructor(rcuid, gl) {
    this.m_resMap = new Map();
    this.m_freeMap = new Map(); // 显存的纹理buffer的总数

    this.m_texResTotal = 0;
    this.m_attachTotal = 0;
    this.m_delay = 128; // renderer context unique id

    this.m_rcuid = 0;
    this.m_gl = null;
    this.texMid = -1;
    this.unlocked = true;
    this.m_rcuid = rcuid;
    this.m_gl = gl; //  let selfT:any = this;
    //  selfT.updater = new ROTexDataUpdater(rcuid, gl, this.m_resMap);
  }

  createBuf() {
    return this.m_gl.createTexture();
  }

  createResByParams3(resUid, param0, param1, param2) {
    //console.log("TexRes createResByParams3, this.m_resMap.has("+resUid+"): ",this.m_resMap.has(resUid));
    if (!this.m_resMap.has(resUid)) {
      let obj = new GpuTexObect();
      obj.rcuid = this.getRCUid();
      obj.resUid = resUid;
      obj.width = param0;
      obj.height = param1;
      obj.sampler = param2;
      obj.texBuf = this.createBuf();
      obj.texBuf.resUid = resUid;
      this.addTextureRes(obj);
      return true;
    }

    return false;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_gl;
  }
  /**
   * check whether the renderer runtime resource(by renderer runtime resource unique id) exists in the current renderer context
   * @param resUid renderer runtime resource unique id
   * @returns has or has not resource by unique id
   */


  hasResUid(resUid) {
    return this.m_resMap.has(resUid);
  }

  renderBegin() {
    this.texMid = -1;
  }
  /**
   * @returns get renderer runtime texture rexource total number
   */


  getTextureResTotal() {
    return this.m_texResTotal;
  }

  addTextureRes(object) {
    if (!this.m_resMap.has(object.resUid)) {
      object.waitDelTimes = 0; //console.log("ROTextureResource add a texture buffer(resUid="+object.resUid+"),sampler: ",object.sampler,object);

      this.m_resMap.set(object.resUid, object);
      this.m_texResTotal++;
    }
  }
  /**
   * get system gpu context resource buf
   * @param resUid renderer runtime resource unique id
   * @returns system gpu context resource buf
   */


  getGpuBuffer(resUid) {
    if (this.m_resMap.has(resUid)) {
      return this.m_resMap.get(resUid).texBuf;
    }

    return null;
  }
  /**
   * bind the renderer runtime resource(by renderer runtime resource unique id) to the current renderer context
   * @param resUid renderer runtime resource unique id
   */


  bindToGpu(resUid) {
    if (this.m_resMap.has(resUid)) {
      this.m_resMap.get(resUid).bindToGpu(this.m_gl);
    }
  }
  /**
   * @returns get renderer runtime texture rexource reference total number
   */


  getAttachTotal() {
    return this.m_attachTotal;
  }

  __$attachRes(resUid) {
    if (this.m_resMap.has(resUid)) {
      this.m_attachTotal++;
      let object = this.m_resMap.get(resUid);

      if (object.getAttachCount() < 1) {
        if (this.m_freeMap.has(resUid)) {
          this.m_freeMap.delete(resUid);
        }
      }

      object.waitDelTimes = 0;

      object.__$attachThis();
    }
  }

  __$detachRes(resUid) {
    if (this.m_resMap.has(resUid)) {
      if (this.m_resMap.has(resUid)) {
        let object = this.m_resMap.get(resUid);

        if (object.getAttachCount() > 0) {
          this.m_attachTotal--;

          object.__$detachThis();

          if (object.getAttachCount() < 1) {
            // 将其加入待清理的map
            this.m_freeMap.set(resUid, object);
          }
        }
      }
    }
  }

  update() {
    this.m_delay--;

    if (this.m_delay < 1) {
      this.m_delay = 128;

      for (const [key, value] of this.m_freeMap) {
        value.waitDelTimes++;

        if (value.waitDelTimes > 5) {
          //console.log("ROTextureResource remove a texture buffer(resUid="+value.resUid+")");
          this.m_resMap.delete(value.resUid);
          this.m_freeMap.delete(value.resUid);
          this.m_gl.deleteTexture(value.texBuf);
          value.texBuf = null;
          this.m_texResTotal--;
        }
      }
    }
  }

}

exports.default = ROTextureResource;

/***/ }),

/***/ "9a2d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class FBXTree {
  constructor() {
    this.map = {};
  }

  add(key, val) {
    // console.log("FBXTree::add(), key: ", key);
    // if(key == "Objects") {
    // 	console.log("FBXTree::add(), find Objects, val: ",val);
    // }
    this.map[key] = val;
  }

}

exports.FBXTree = FBXTree;

/***/ }),

/***/ "9c3c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const RadialLine_1 = __importDefault(__webpack_require__("38de"));

const AABB_1 = __importDefault(__webpack_require__("fecb"));

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const MeshBase_1 = __importDefault(__webpack_require__("cb29"));

const ROVertexBuffer_1 = __importDefault(__webpack_require__("e7d2"));

const RenderConst_1 = __webpack_require__("e08e");

class DashedLineMesh extends MeshBase_1.default {
  constructor(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    super(bufDataUsage);
    this.m_vs = null;
    this.m_cvs = null;
    this.m_lsTotal = 0; // 用于射线检测

    this.rayTestRadius = 2.0;
  }

  getVS() {
    return this.m_vs;
  }

  setVS(vs) {
    this.m_vs = vs;
  }

  getCVS() {
    return this.m_cvs;
  }

  setCVS(cvs) {
    this.m_cvs = cvs;
  }

  initialize(posarr, colors) {
    if (this.m_vs != null || posarr.length >= 6) {
      if (this.m_vs == null) {
        this.m_vs = new Float32Array(posarr);
      }

      this.vtCount = Math.floor(this.m_vs.length / 3);
      this.m_lsTotal = Math.floor(this.vtCount / 2);

      if (this.bounds == null) {
        this.bounds = new AABB_1.default();
      }

      this.bounds.addXYZFloat32Arr(this.m_vs);
      this.bounds.updateFast();
      ROVertexBuffer_1.default.Reset();
      ROVertexBuffer_1.default.AddFloat32Data(this.m_vs, 3); // console.log("this.m_vs: ",this.m_vs);
      // console.log("colors: ",colors);

      if (this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_CVS_INDEX)) {
        if (this.m_cvs == null) this.m_cvs = new Float32Array(colors);
        ROVertexBuffer_1.default.AddFloat32Data(this.m_cvs, 3);
      }

      ROVertexBuffer_1.default.vbWholeDataEnabled = this.vbWholeDataEnabled;

      if (this.m_vbuf != null) {
        ROVertexBuffer_1.default.UpdateBufData(this.m_vbuf);
      } else {
        this.m_vbuf = ROVertexBuffer_1.default.CreateBySaveData(this.getBufDataUsage());
      }

      this.drawMode = RenderConst_1.RenderDrawMode.ARRAYS_LINES;
      this.buildEnd();
    }
  }

  setVSXYZAt(i, px, py, pz) {
    if (this.m_vbuf != null) {
      this.m_vbuf.setData3fAt(i, 0, px, py, pz);
    }
  }

  toString() {
    return "DashedLineMesh()";
  }

  isPolyhedral() {
    return false;
  } // @boundsHit       表示是否包围盒体已经和射线相交了
  // @rlpv            表示物体坐标空间的射线起点
  // @rltv            表示物体坐标空间的射线朝向
  // @outV            如果检测相交存放物体坐标空间的交点
  // @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
  //


  testRay(rlpv, rltv, outV, boundsHit) {
    let j = 0;
    let vs = this.m_vs;
    let flag = 0;
    let radius = this.rayTestRadius;
    let pv0 = DashedLineMesh.s_pv0;
    let pv1 = DashedLineMesh.s_pv1;

    for (let i = 0; i < this.m_lsTotal; ++i) {
      pv0.setXYZ(vs[j], vs[j + 1], vs[j + 2]);
      pv1.setXYZ(vs[j + 3], vs[j + 4], vs[j + 5]);
      flag = RadialLine_1.default.IntersectionLS(rlpv, rltv, pv0, pv1, outV, radius);

      if (flag > 0) {
        return 1;
      }

      j += 6;
    }

    return 0;
  }

  __$destroy() {
    if (this.isResFree()) {
      this.bounds = null;
      this.m_vs = null;
      this.m_cvs = null;

      super.__$destroy();
    }
  }

}

DashedLineMesh.s_pv0 = new Vector3D_1.default();
DashedLineMesh.s_pv1 = new Vector3D_1.default();
exports.default = DashedLineMesh;

/***/ }),

/***/ "9c4d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class Runner {
  constructor() {
    this.prev = null;
    this.next = null;
    this.flag = 0;
    this.target = null;
  }

  reset() {
    this.flag = 0;
    this.target = null;
  }

}

class RunnerLinker {
  constructor() {
    this.m_begin = null;
    this.m_end = null;
  }

  destroy() {
    this.clear();
  }

  clear() {
    this.m_begin = this.m_end = null;
  }

  getBegin() {
    return this.m_begin;
  }

  isEmpty() {
    return this.m_begin == this.m_end && this.m_end == null;
  }

  addNode(node) {
    if (this.m_begin == null) {
      this.m_end = this.m_begin = node;
    } else {
      if (this.m_end.prev != null) {
        this.m_end.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      } else {
        this.m_begin.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      }
    }

    this.m_end.next = null;
  }

  removeNode(node) {
    if (node == this.m_begin) {
      if (node == this.m_end) {
        this.m_begin = this.m_end = null;
      } else {
        this.m_begin = node.next;
        this.m_begin.prev = null;
      }
    } else if (node == this.m_end) {
      this.m_end = node.prev;
      this.m_end.next = null;
    } else {
      node.next.prev = node.prev;
      node.prev.next = node.next;
    }

    node.prev = null;
    node.next = null;
  }

}

class RunnableQueue {
  constructor() {
    this.m_linker = new RunnerLinker();
    this.m_freeIds = [];
    this.m_runners = [new Runner()];
  }

  getFreeId() {
    if (this.m_freeIds.length > 0) {
      return this.m_freeIds.pop();
    }

    let runner = new Runner();
    runner.flag = this.m_runners.length;
    this.m_runners.push(runner);
    return runner.flag;
  }

  addRunner(runner) {
    if (runner != null && runner.getRunFlag() < 1) {
      let i = this.getFreeId();
      let pr = this.m_runners[i];
      pr.flag = i;
      pr.target = runner;
      runner.setRunFlag(i);
      this.m_linker.addNode(pr);
    }
  }

  removeRunner(runner) {
    if (runner != null && runner.getRunFlag() > 0) {
      let i = runner.getRunFlag();
      this.m_freeIds.push(i);
      let pr = this.m_runners[i];
      pr.flag = i;
      pr.target = null;
      runner.setRunFlag(0);
      this.m_linker.removeNode(pr);
    }
  }

  run() {
    let ro = this.m_linker.getBegin();
    let next = ro;

    while (next != null) {
      ro = next;
      next = ro.next;

      if (ro.target.isRunning()) {
        ro.target.run();
      }
    }
  }

  destroy() {
    let ro = this.m_linker.getBegin();
    let next = ro;

    while (next != null) {
      ro = next;
      next = ro.next;
      ro.target = null;
    }

    this.m_linker.clear();
  }

}

exports.default = RunnableQueue;

/***/ }),

/***/ "9cb6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Deflate", function() { return Deflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncDeflate", function() { return AsyncDeflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflate", function() { return deflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateSync", function() { return deflateSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Inflate", function() { return Inflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncInflate", function() { return AsyncInflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflate", function() { return inflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateSync", function() { return inflateSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gzip", function() { return Gzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncGzip", function() { return AsyncGzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gzip", function() { return gzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gzipSync", function() { return gzipSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gunzip", function() { return Gunzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncGunzip", function() { return AsyncGunzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gunzip", function() { return gunzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gunzipSync", function() { return gunzipSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Zlib", function() { return Zlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncZlib", function() { return AsyncZlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zlib", function() { return zlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zlibSync", function() { return zlibSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Unzlib", function() { return Unzlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncUnzlib", function() { return AsyncUnzlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unzlib", function() { return unzlib; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unzlibSync", function() { return unzlibSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compress", function() { return gzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncCompress", function() { return AsyncGzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressSync", function() { return gzipSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Compress", function() { return Gzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Decompress", function() { return Decompress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncDecompress", function() { return AsyncDecompress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompress", function() { return decompress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decompressSync", function() { return decompressSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecodeUTF8", function() { return DecodeUTF8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EncodeUTF8", function() { return EncodeUTF8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strToU8", function() { return strToU8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strFromU8", function() { return strFromU8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipPassThrough", function() { return ZipPassThrough; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZipDeflate", function() { return ZipDeflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncZipDeflate", function() { return AsyncZipDeflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Zip", function() { return Zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipSync", function() { return zipSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnzipPassThrough", function() { return UnzipPassThrough; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnzipInflate", function() { return UnzipInflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AsyncUnzipInflate", function() { return AsyncUnzipInflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Unzip", function() { return Unzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unzip", function() { return unzip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unzipSync", function() { return unzipSync; });
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
// var ch2 = {};
// var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };
// var cwk = function (u) { return new Worker(u); };
// try {
//     URL.revokeObjectURL(durl(''));
// }
// catch (e) {
//     // We're in Deno or a very old browser
//     durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };
//     // If Deno, this is necessary; if not, this changes nothing
//     cwk = function (u) { return new Worker(u, { type: 'module' }); };
// }
// var wk = (function (c, id, msg, transfer, cb) {
//     var w = cwk(ch2[id] || (ch2[id] = durl(c)));
//     w.onerror = function (e) { return cb(e.error, null); };
//     w.onmessage = function (e) { return cb(null, e.data); };
//     w.postMessage(msg, transfer);
//     return w;
// });
// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array,
    u16 = Uint16Array,
    u32 = Uint32Array; // fixed length extra bits

var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
/* unused */
0, 0,
/* impossible */
0]); // fixed distance extra bits
// see fleb note

var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
/* unused */
0, 0]); // code length index map

var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // get base, reverse index map from extra bits

var freb = function (eb, start) {
  var b = new u16(31);

  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  } // numbers here are at max 18 bits


  var r = new u32(b[30]);

  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }

  return [b, r];
};

var _a = freb(fleb, 2),
    fl = _a[0],
    revfl = _a[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway


fl[28] = 258, revfl[258] = 28;

var _b = freb(fdeb, 0),
    fd = _b[0],
    revfd = _b[1]; // map of value to reverse (assuming 16 bits)


var rev = new u16(32768);

for (var i = 0; i < 32768; ++i) {
  // reverse table algorithm from SO
  var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
} // create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?


var flt_u8_288 = new u8(288);

var hMap = function (cd, mb, r) {
  var s = cd.length; // index

  var i = 0; // u16 "map": index -> # of codes with bit length = index

  var l = new u16(mb); // length of cd must be 288 (total # of codes)

  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 "map": index -> minimum code for bit length = index


  var le = new u16(mb);

  for (i = 0; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }

  var co;

  if (r) {
    // u16 "map": index -> number of actual bits, symbol for code
    co = new u16(1 << mb); // bits to remove for reverser

    var rvb = 15 - mb;

    for (i = 0; i < s; ++i) {
      // ignore 0 lengths
      if (cd[i]) {
        // num encoding both symbol and bits read
        var sv = i << 4 | cd[i]; // free bits

        var r_1 = mb - cd[i]; // start value

        var v = le[cd[i] - 1]++ << r_1; // m is end value

        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          // every 16 bit value starting with the code yields the same result
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);

    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
      }
    }
  }

  return co;
}; // fixed length tree
// var flt = new u8(288);


var flt = flt_u8_288;

for (var i = 0; i < 144; ++i) flt[i] = 8;

for (var i = 144; i < 256; ++i) flt[i] = 9;

for (var i = 256; i < 280; ++i) flt[i] = 7;

for (var i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree


var fdt = new u8(32);

for (var i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map


var flm = /*#__PURE__*/hMap(flt, 9, 0),
    flrm = /*#__PURE__*/hMap(flt, 9, 1); // fixed distance map

var fdm = /*#__PURE__*/hMap(fdt, 5, 0),
    fdrm = /*#__PURE__*/hMap(fdt, 5, 1); // find max of array

var max = function (a) {
  var m = a[0];

  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m) m = a[i];
  }

  return m;
}; // read d, starting at bit p and mask with m


var bits = function (d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}; // read d, starting at bit p continuing for at least 16 bits


var bits16 = function (d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}; // get end of byte


var shft = function (p) {
  return (p / 8 | 0) + (p & 7 && 1);
}; // typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice


var slc = function (v, s, e) {
  if (s == null || s < 0) s = 0;
  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied

  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};

var slc2 = function (v, s, e) {
  // if (s == null || s < 0)
  //     s = 0;
  // if (e == null || e > v.length)
  //     e = v.length;
  // can't use .constructor in case user-supplied
  //var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  //n.set(v.subarray(s, e));
  return v;
};

var clt_u8_19 = new u8(19);
let ldt_u8_1024 = new u8(1024);

function calcCeilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

let bufPool = new Array(128);
bufPool.fill(null);
let bufCurrSize = 0; // expands raw DEFLATE data

var inflt = function (dat, buf, st) {
  // console.log("$$$$$$ create inflt src buf size: ",dat.length);
  // source length
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5) return buf || new u8(0); // have to estimate size

  var noBuf = !buf || st; // no state

  var noSt = !st || st.i;
  if (!st) st = {}; // Assumes roughly 33% compression ratio average

  if (!buf) {
    //buf = new u8(sl * 3);
    bufCurrSize = sl; //sl * 3;

    let size = calcCeilPowerOfTwo(bufCurrSize);
    let i = Math.log2(size);
    buf = bufPool[i];

    if (buf == null) {
      // console.log("###### create inflt buf sizeA: ",size);
      buf = new u8(size);
      bufPool[i] = buf;
    }
  } // ensure buffer can fit at least l elements


  var cbuf = function (l) {
    var bl = buf.length; // need to increase size to fit

    if (l > bl) {
      // Double or set to necessary, whichever is greater
      // var nbuf = new u8(Math.max(bl * 2, l));
      bufCurrSize = l; //Math.max(bl * 2, l);

      let size = calcCeilPowerOfTwo(bufCurrSize);
      let i = Math.log2(size);
      var nbuf = bufPool[i];

      if (nbuf == null) {
        // 大于五亿的长度则要重新使用新的内存规则, 如果 536870912 乘以2, 则会让内存直接崩溃
        // 这里的内存管理机制需要深入研究
        if (bufCurrSize <= 536870912) {
          // console.log("###### create inflt buf sizeB: ",size,"(",bufCurrSize,")", ",srcLen: ",dat.length);
          nbuf = new u8(size);
          bufPool[i] = nbuf;
        } else {
          size = bufCurrSize + 131072 * 2;
          nbuf = new u8(size); // console.log("###### create inflt buf sizeC: ",size+"("+bufCurrSize+"), srcLen: "+dat.length);
        }
      } //console.log("Math.max(bl * 2, l): ", Math.max(bl * 2, l));


      nbuf.set(buf);
      buf = nbuf;
    }
  }; //  last chunk         bitpos           bytes


  var final = st.f || 0,
      pos = st.p || 0,
      bt = st.b || 0,
      lm = st.l,
      dm = st.d,
      lbt = st.m,
      dbt = st.n; // total bits

  let tbts = sl * 8; // console.log("$$$$$$++ inflt tbts size, sl: ",tbts, sl);

  do {
    if (!lm) {
      // BFINAL - this is only 1 when last chunk is next
      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman

      var type = bits(dat, pos + 1, 3);
      pos += 3;

      if (!type) {
        // go to end of byte boundary
        var s = shft(pos) + 4,
            l = dat[s - 4] | dat[s - 3] << 8,
            t = s + l;

        if (t > sl) {
          if (noSt) throw 'unexpected EOF';
          break;
        } // ensure size


        if (noBuf) {
          cbuf(bt + l);
        } // Copy over uncompressed data


        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count

        st.b = bt += l, st.p = pos = t * 8;
        continue;
      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {
        //  literal                            lengths
        var hLit = bits(dat, pos, 31) + 257,
            hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14; // length+distance tree
        // var ldt = new u8(tl);

        let ldt = ldt_u8_1024.subarray(0, tl);

        for (let i = 0; i < tl; ++i) ldt[i] = 0; // code length tree
        //var clt = new u8(19);


        let clt = clt_u8_19;

        for (let i = 0; i < 19; ++i) clt[i] = 0;

        for (var i = 0; i < hcLen; ++i) {
          // use index map to get real code
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }

        pos += hcLen * 3; // code lengths bits

        var clb = max(clt),
            clbmsk = (1 << clb) - 1; // code lengths map

        var clm = hMap(clt, clb, 1);

        for (var i = 0; i < tl;) {
          var r = clm[bits(dat, pos, clbmsk)]; // bits read

          pos += r & 15; // symbol

          var s = r >>> 4; // code length to copy

          if (s < 16) {
            ldt[i++] = s;
          } else {
            //  copy   count
            var c = 0,
                n = 0;
            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;

            while (n--) ldt[i++] = c;
          }
        } //    length tree                 distance tree


        var lt = ldt.subarray(0, hLit),
            dt = ldt.subarray(hLit); // max length bits

        lbt = max(lt); // max dist bits

        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else throw 'invalid block type';

      if (pos > tbts) {
        if (noSt) throw 'unexpected EOF';
        break;
      }
    } // Make sure the buffer can hold this + the largest possible addition
    // Maximum chunk size (practically, theoretically infinite) is 2^17;


    if (noBuf) {
      // console.log("bt01: ",bt, ", pos: ", pos);
      cbuf(bt + 131072);
    }

    var lms = (1 << lbt) - 1,
        dms = (1 << dbt) - 1;
    var lpos = pos;

    for (;; lpos = pos) {
      // bits read, code
      var c = lm[bits16(dat, pos) & lms],
          sym = c >>> 4;
      pos += c & 15;

      if (pos > tbts) {
        if (noSt) throw 'unexpected EOF';
        break;
      }

      if (!c) throw 'invalid length/literal';
      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254; // no extra bits needed if less

        if (sym > 264) {
          // index
          var i = sym - 257,
              b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        } // dist


        var d = dm[bits16(dat, pos) & dms],
            dsym = d >>> 4;
        if (!d) throw 'invalid distance';
        pos += d & 15;
        var dt = fd[dsym];

        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }

        if (pos > tbts) {
          if (noSt) throw 'unexpected EOF';
          break;
        }

        if (noBuf) {
          // console.log("bt02: ",bt, ", pos: ", pos);
          cbuf(bt + 131072);
        }

        var end = bt + add;

        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }

        bt = end;
      }
    }

    st.l = lm, st.p = lpos, st.b = bt;
    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);

  return bt == buf.length ? buf : slc2(buf, 0, bt);
}; // starting at p, write the minimum number of bits that can hold v to d


var wbits = function (d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
}; // starting at p, write the minimum number of bits (>8) that can hold v to d


var wbits16 = function (d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
}; // creates code lengths from a frequency table


var hTree = function (d, mb) {
  // Need extra info to make a tree
  var t = [];

  for (var i = 0; i < d.length; ++i) {
    if (d[i]) t.push({
      s: i,
      f: d[i]
    });
  }

  var s = t.length;
  var t2 = t.slice();
  if (!s) return [et, 0];

  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return [v, 1];
  }

  t.sort(function (a, b) {
    return a.f - b.f;
  }); // after i2 reaches last ind, will be stopped
  // freq must be greater than largest possible number of symbols

  t.push({
    s: -1,
    f: 25001
  });
  var l = t[0],
      r = t[1],
      i0 = 0,
      i1 = 1,
      i2 = 2;
  t[0] = {
    s: -1,
    f: l.f + r.f,
    l: l,
    r: r
  }; // efficient algorithm from UZIP.js
  // i0 is lookbehind, i2 is lookahead - after processing two low-freq
  // symbols that combined have high freq, will start processing i2 (high-freq,
  // non-composite) symbols instead
  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/

  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = {
      s: -1,
      f: l.f + r.f,
      l: l,
      r: r
    };
  }

  var maxSym = t2[0].s;

  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym) maxSym = t2[i].s;
  } // code lengths


  var tr = new u16(maxSym + 1); // max bits in tree

  var mbt = ln(t[i1 - 1], tr, 0);

  if (mbt > mb) {
    // more algorithms from UZIP.js
    // TODO: find out how this code works (debt)
    //  ind    debt
    var i = 0,
        dt = 0; //    left            cost

    var lft = mbt - mb,
        cst = 1 << lft;
    t2.sort(function (a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });

    for (; i < s; ++i) {
      var i2_1 = t2[i].s;

      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else break;
    }

    dt >>>= lft;

    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;
    }

    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;

      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }

    mbt = mb;
  }

  return [new u8(tr), mbt];
}; // get the max length and assign length codes


var ln = function (n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
}; // length codes generation


var lc = function (c) {
  var s = c.length; // Note that the semicolon was intentional

  while (s && !c[--s]);

  var cl = new u16(++s); //  ind      num         streak

  var cli = 0,
      cln = c[0],
      cls = 1;

  var w = function (v) {
    cl[cli++] = v;
  };

  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s) ++cls;else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138) w(32754);

        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;

        for (; cls > 6; cls -= 6) w(8304);

        if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
      }

      while (cls--) w(cln);

      cls = 1;
      cln = c[i];
    }
  }

  return [cl.subarray(0, cli), s];
}; // calculate the length of output from tree, code lengths


var clen = function (cf, cl) {
  var l = 0;

  for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];

  return l;
}; // writes a fixed block
// returns the new bit pos


var wfblk = function (out, pos, dat) {
  // no need to write 00 as type: TypedArray defaults to 0
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;

  for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];

  return (o + 4 + s) * 8;
};

let lcfreq_u16_19_init = new u16(19);
let lcfreq_u16_19 = new u16(19); // writes a block

var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];

  var _a = hTree(lf, 15),
      dlt = _a[0],
      mlb = _a[1];

  var _b = hTree(df, 15),
      ddt = _b[0],
      mdb = _b[1];

  var _c = lc(dlt),
      lclt = _c[0],
      nlc = _c[1];

  var _d = lc(ddt),
      lcdt = _d[0],
      ndc = _d[1]; // var lcfreq = new u16(19);


  let lcfreq = lcfreq_u16_19;
  lcfreq.set(lcfreq_u16_19_init);

  for (var i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;

  for (var i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;

  var _e = hTree(lcfreq, 7),
      lct = _e[0],
      mlcb = _e[1];

  var nlcc = 19;

  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);

  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;

  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;

    for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);

    p += 3 * nlcc;
    var lcts = [lclt, lcdt];

    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];

      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }

  for (var i = 0; i < li; ++i) {
    if (syms[i] > 255) {
      var len = syms[i] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
      var dst = syms[i] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
    }
  }

  wbits16(out, p, lm[256]);
  return p + ll[256];
}; // deflate options (nice << 13) | chain


var deo = /*#__PURE__*/new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]); // empty

var et = /*#__PURE__*/new u8(0);
let syms_u32_25000_init = new u32(25000);
let syms_u32_25000 = new u32(25000);
let lf_u16_288_init = new u16(288);
let df_u16_32_init = new u16(32);
let lf_u16_288 = new u16(288);
let df_u16_32 = new u16(32); // compresses data into a raw DEFLATE buffer

var dflt = function (dat, lvl, plvl, pre, post, lst) {
  var s = dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post); // writing to this writes to the output buffer

  var w = o.subarray(pre, o.length - post);
  var pos = 0;

  if (!lvl || s < 8) {
    for (var i = 0; i <= s; i += 65535) {
      // end
      var e = i + 65535;

      if (e < s) {
        // write full block
        pos = wfblk(w, pos, dat.subarray(i, e));
      } else {
        // write final block
        w[i] = lst;
        pos = wfblk(w, pos, dat.subarray(i, s));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13,
        c = opt & 8191;
    var msk_1 = (1 << plvl) - 1; //    prev 2-byte val map    curr 2-byte val map

    var prev = new u16(32768),
        head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3),
        bs2_1 = 2 * bs1_1;

    var hsh = function (i) {
      return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
    }; // 24576 is an arbitrary number of maximum symbols per block
    // 424 buffer for last block
    // var syms = new u32(25000);


    let syms = syms_u32_25000;
    syms.set(syms_u32_25000_init); // length/literal freq   distance freq
    // let lf = new u16(288);
    // let df = new u16(32);

    let lf = lf_u16_288;
    lf.set(lf_u16_288_init);
    let df = df_u16_32;
    df.set(df_u16_32_init); //  l/lcnt  exbits  index  l/lind  waitdx  bitpos

    let lc_1 = 0,
        eb = 0,
        i = 0,
        li = 0,
        wi = 0,
        bs = 0;

    for (; i < s; ++i) {
      // hash value
      // deopt when i > s - 3 - at end, deopt acceptable
      var hv = hsh(i); // index mod 32768    previous index mod

      var imod = i & 32767,
          pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod; // We always should modify head and prev, but only add symbols if
      // this data is not yet processed ("wait" for wait index)

      if (wi <= i) {
        // bytes remaining
        var rem = s - i;

        if ((lc_1 > 7000 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;

          for (var j = 0; j < 286; ++j) lf[j] = 0;

          for (var j = 0; j < 30; ++j) df[j] = 0;
        } //  len    dist   chain


        var l = 2,
            d = 0,
            ch_1 = c,
            dif = imod - pimod & 32767;

        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i); // max possible length
          // not capped at dif because decompressors implement "rolling" index population

          var ml = Math.min(258, rem);

          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;

              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);

              if (nl > l) {
                l = nl, d = dif; // break out early when we reach "nice" (we are satisfied enough)

                if (nl > maxn) break; // now, find the rarest 2-byte sequence within this
                // length of literals and search for that instead.
                // Much faster than just using the start

                var mmd = Math.min(dif, nl - 2);
                var md = 0;

                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md) md = cd, pimod = ti;
                }
              }
            } // check the previous match


            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        } // d will be nonzero only when a match was found


        if (d) {
          // store both dist and len data in one Uint32
          // Make sure this is recognized as a len/dist with 28th bit (2^28)
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31,
              din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }

    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos); // this is the easiest way to avoid needing to maintain state

    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);
  }

  return slc(o, 0, pre + shft(pos) + post);
}; // CRC32 table


var crct = /*#__PURE__*/function () {
  var t = new u32(256);

  for (var i = 0; i < 256; ++i) {
    var c = i,
        k = 9;

    while (--k) c = (c & 1 && 0xEDB88320) ^ c >>> 1;

    t[i] = c;
  }

  return t;
}(); // CRC32


var crc = function () {
  var c = -1;
  return {
    p: function (d) {
      // closures have awful performance
      var cr = c;

      for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;

      c = cr;
    },
    d: function () {
      return ~c;
    }
  };
}; // Alder32


var adler = function () {
  var a = 1,
      b = 0;
  return {
    p: function (d) {
      // closures have awful performance
      var n = a,
          m = b;
      var l = d.length;

      for (var i = 0; i != l;) {
        var e = Math.min(i + 2655, l);

        for (; i < e; ++i) m += n += d[i];

        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }

      a = n, b = m;
    },
    d: function () {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
    }
  };
};

; // deflate with opts

var dopt = function (dat, opt, pre, post, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
}; // Walmart object spread


var mrg = function (a, b) {
  var o = {};

  for (var k in a) o[k] = a[k];

  for (var k in b) o[k] = b[k];

  return o;
}; // worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.


var wcln = function (fn, fnStr, td) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');

  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i],
        k = ks[i];

    if (typeof v == 'function') {
      fnStr += ';' + k + '=';
      var st_1 = v.toString();

      if (v.prototype) {
        // for global objects
        if (st_1.indexOf('[native code]') != -1) {
          var spInd = st_1.indexOf(' ', 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
        } else {
          fnStr += st_1;

          for (var t in v.prototype) fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
        }
      } else fnStr += st_1;
    } else td[k] = v;
  }

  return [fnStr, td];
};

var ch = []; // clone bufs

var cbfs = function (v) {
  var tl = [];

  for (var k in v) {
    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
  }

  return tl;
}; // use a worker to execute code


var wrkr = function (fns, init, id, cb) {
  var _a;

  if (!ch[id]) {
    var fnStr = '',
        td_1 = {},
        m = fns.length - 1;

    for (var i = 0; i < m; ++i) _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];

    ch[id] = wcln(fns[m], fnStr, td_1);
  }

  var td = mrg({}, ch[id][1]);
  return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
}; // base async inflate fn


var bInflt = function () {
  return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
};

var bDflt = function () {
  return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
}; // gzip extra


var gze = function () {
  return [gzh, gzhl, wbytes, crc, crct];
}; // gunzip extra


var guze = function () {
  return [gzs, gzl];
}; // zlib extra


var zle = function () {
  return [zlh, wbytes, adler];
}; // unzlib extra


var zule = function () {
  return [zlv];
}; // post buf


var pbf = function (msg) {
  return postMessage(msg, [msg.buffer]);
}; // get u8


var gu8 = function (o) {
  return o && o.size && new u8(o.size);
}; // async helper


var cbify = function (dat, opts, fns, init, id, cb) {
  var w = wrkr(fns, init, id, function (err, dat) {
    w.terminate();
    cb(err, dat);
  });
  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function () {
    w.terminate();
  };
}; // auto stream


var astrm = function (strm) {
  strm.ondata = function (dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };

  return function (ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
}; // async stream attach


var astrmify = function (fns, strm, opts, init, id) {
  var t;
  var w = wrkr(fns, init, id, function (err, dat) {
    if (err) w.terminate(), strm.ondata.call(strm, err);else {
      if (dat[1]) w.terminate();
      strm.ondata.call(strm, err, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);

  strm.push = function (d, f) {
    if (t) throw 'stream finished';
    if (!strm.ondata) throw 'no stream handler';
    w.postMessage([d, t = f], [d.buffer]);
  };

  strm.terminate = function () {
    w.terminate();
  };
}; // read 2 bytes


var b2 = function (d, b) {
  return d[b] | d[b + 1] << 8;
}; // read 4 bytes


var b4 = function (d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};

var b8 = function (d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
}; // write bytes


var wbytes = function (d, b, v) {
  for (; v; ++b) d[b] = v, v >>>= 8;
}; // gzip header


var gzh = function (c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix

  if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));

  if (fn) {
    c[3] = 8;

    for (var i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);
  }
}; // gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start


var gzs = function (d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw 'invalid gzip data';
  var flg = d[3];
  var st = 10;
  if (flg & 4) st += d[10] | (d[11] << 8) + 2;

  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);

  return st + (flg & 2);
}; // gzip length


var gzl = function (d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}; // gzip header length


var gzhl = function (o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
}; // zlib header


var zlh = function (c, o) {
  var lv = o.level,
      fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);
}; // zlib valid


var zlv = function (d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
};

function AsyncCmpStrm(opts, cb) {
  if (!cb && typeof opts == 'function') cb = opts, opts = {};
  this.ondata = cb;
  return opts;
} // zlib footer: -4 to -0 is Adler32

/**
 * Streaming DEFLATE compression
 */


var Deflate = /*#__PURE__*/function () {
  function Deflate(opts, cb) {
    if (!cb && typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
  }

  Deflate.prototype.p = function (c, f) {
    this.ondata(dopt(c, this.o, 0, 0, !f), f);
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Deflate.prototype.push = function (chunk, final) {
    if (this.d) throw 'stream finished';
    if (!this.ondata) throw 'no stream handler';
    this.d = final;
    this.p(chunk, final || false);
  };

  return Deflate;
}();


/**
 * Asynchronous streaming DEFLATE compression
 */

var AsyncDeflate = /*#__PURE__*/function () {
  function AsyncDeflate(opts, cb) {
    astrmify([bDflt, function () {
      return [astrm, Deflate];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }

  return AsyncDeflate;
}();


function deflate(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt], function (ev) {
    return pbf(deflateSync(ev.data[0], ev.data[1]));
  }, 0, cb);
}
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */

function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */

var Inflate = /*#__PURE__*/function () {
  /**
   * Creates an inflation stream
   * @param cb The callback to call whenever data is inflated
   */
  function Inflate(cb) {
    this.s = {};
    this.p = new u8(0);
    this.ondata = cb;
  }

  Inflate.prototype.e = function (c) {
    if (this.d) throw 'stream finished';
    if (!this.ondata) throw 'no stream handler';
    var l = this.p.length;
    var n = new u8(l + c.length);
    n.set(this.p), n.set(c, l), this.p = n;
  };

  Inflate.prototype.c = function (final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt(this.p, this.o, this.s);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  /**
   * Pushes a chunk to be inflated
   * @param chunk The chunk to push
   * @param final Whether this is the final chunk
   */


  Inflate.prototype.push = function (chunk, final) {
    this.e(chunk), this.c(final);
  };

  return Inflate;
}();


/**
 * Asynchronous streaming DEFLATE decompression
 */

var AsyncInflate = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous inflation stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncInflate(cb) {
    this.ondata = cb;
    astrmify([bInflt, function () {
      return [astrm, Inflate];
    }], this, 0, function () {
      var strm = new Inflate();
      onmessage = astrm(strm);
    }, 7);
  }

  return AsyncInflate;
}();


function inflate(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt], function (ev) {
    return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
  }, 1, cb);
}
/**
 * Expands DEFLATE data with no wrapper
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function inflateSync(data, out) {
  return inflt(data, out);
} // before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.

/**
 * Streaming GZIP compression
 */

var Gzip = /*#__PURE__*/function () {
  function Gzip(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  /**
   * Pushes a chunk to be GZIPped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Gzip.prototype.push = function (chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };

  Gzip.prototype.p = function (c, f) {
    this.c.p(c);
    this.l += c.length;
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
    if (this.v) gzh(raw, this.o), this.v = 0;
    if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };

  return Gzip;
}();


/**
 * Asynchronous streaming GZIP compression
 */

var AsyncGzip = /*#__PURE__*/function () {
  function AsyncGzip(opts, cb) {
    astrmify([bDflt, gze, function () {
      return [astrm, Deflate, Gzip];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Gzip(ev.data);
      onmessage = astrm(strm);
    }, 8);
  }

  return AsyncGzip;
}();


function gzip(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt, gze, function () {
    return [gzipSync];
  }], function (ev) {
    return pbf(gzipSync(ev.data[0], ev.data[1]));
  }, 2, cb);
}
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */

function gzipSync(data, opts) {
  if (!opts) opts = {};
  var c = crc(),
      l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8),
      s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming GZIP decompression
 */

var Gunzip = /*#__PURE__*/function () {
  /**
   * Creates a GUNZIP stream
   * @param cb The callback to call whenever data is inflated
   */
  function Gunzip(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  /**
   * Pushes a chunk to be GUNZIPped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Gunzip.prototype.push = function (chunk, final) {
    Inflate.prototype.e.call(this, chunk);

    if (this.v) {
      var s = this.p.length > 3 ? gzs(this.p) : 4;
      if (s >= this.p.length && !final) return;
      this.p = this.p.subarray(s), this.v = 0;
    }

    if (final) {
      if (this.p.length < 8) throw 'invalid gzip stream';
      this.p = this.p.subarray(0, -8);
    } // necessary to prevent TS from using the closure value
    // This allows for workerization to function correctly


    Inflate.prototype.c.call(this, final);
  };

  return Gunzip;
}();


/**
 * Asynchronous streaming GZIP decompression
 */

var AsyncGunzip = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous GUNZIP stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncGunzip(cb) {
    this.ondata = cb;
    astrmify([bInflt, guze, function () {
      return [astrm, Inflate, Gunzip];
    }], this, 0, function () {
      var strm = new Gunzip();
      onmessage = astrm(strm);
    }, 9);
  }

  return AsyncGunzip;
}();


function gunzip(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt, guze, function () {
    return [gunzipSync];
  }], function (ev) {
    return pbf(gunzipSync(ev.data[0]));
  }, 3, cb);
}
/**
 * Expands GZIP data
 * @param data The data to decompress
 * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
 * @returns The decompressed version of the data
 */

function gunzipSync(data, out) {
  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
/**
 * Streaming Zlib compression
 */

var Zlib = /*#__PURE__*/function () {
  function Zlib(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  /**
   * Pushes a chunk to be zlibbed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Zlib.prototype.push = function (chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };

  Zlib.prototype.p = function (c, f) {
    this.c.p(c);
    var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
    if (this.v) zlh(raw, this.o), this.v = 0;
    if (f) wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };

  return Zlib;
}();


/**
 * Asynchronous streaming Zlib compression
 */

var AsyncZlib = /*#__PURE__*/function () {
  function AsyncZlib(opts, cb) {
    astrmify([bDflt, zle, function () {
      return [astrm, Deflate, Zlib];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Zlib(ev.data);
      onmessage = astrm(strm);
    }, 10);
  }

  return AsyncZlib;
}();


function zlib(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt, zle, function () {
    return [zlibSync];
  }], function (ev) {
    return pbf(zlibSync(ev.data[0], ev.data[1]));
  }, 4, cb);
}
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */

function zlibSync(data, opts) {
  if (!opts) opts = {};
  var a = adler();
  a.p(data);
  var d = dopt(data, opts, 2, 4);
  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */

var Unzlib = /*#__PURE__*/function () {
  /**
   * Creates a Zlib decompression stream
   * @param cb The callback to call whenever data is inflated
   */
  function Unzlib(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  /**
   * Pushes a chunk to be unzlibbed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Unzlib.prototype.push = function (chunk, final) {
    Inflate.prototype.e.call(this, chunk);

    if (this.v) {
      if (this.p.length < 2 && !final) return;
      this.p = this.p.subarray(2), this.v = 0;
    }

    if (final) {
      if (this.p.length < 4) throw 'invalid zlib stream';
      this.p = this.p.subarray(0, -4);
    } // necessary to prevent TS from using the closure value
    // This allows for workerization to function correctly


    Inflate.prototype.c.call(this, final);
  };

  return Unzlib;
}();


/**
 * Asynchronous streaming Zlib decompression
 */

var AsyncUnzlib = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous Zlib decompression stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncUnzlib(cb) {
    this.ondata = cb;
    astrmify([bInflt, zule, function () {
      return [astrm, Inflate, Unzlib];
    }], this, 0, function () {
      var strm = new Unzlib();
      onmessage = astrm(strm);
    }, 11);
  }

  return AsyncUnzlib;
}();


function unzlib(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt, zule, function () {
    return [unzlibSync];
  }], function (ev) {
    return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
  }, 5, cb);
}
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function unzlibSync(data, out) {
  let zlibValue = (zlv(data), data.subarray(2, -4)); // console.log("zlibValue: ", zlibValue);

  return inflt(zlibValue, out);
} // Default algorithm for compression (used because having a known output size allows faster decompression)

 // Default algorithm for compression (used because having a known output size allows faster decompression)


/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */

var Decompress = /*#__PURE__*/function () {
  /**
   * Creates a decompression stream
   * @param cb The callback to call whenever data is decompressed
   */
  function Decompress(cb) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be decompressed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Decompress.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no stream handler';

    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else this.p = chunk;

      if (this.p.length > 2) {
        var _this_1 = this;

        var cb = function () {
          _this_1.ondata.apply(_this_1, arguments);
        };

        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else this.s.push(chunk, final);
  };

  return Decompress;
}();


/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */

var AsyncDecompress = /*#__PURE__*/function () {
  /**
  * Creates an asynchronous decompression stream
  * @param cb The callback to call whenever data is decompressed
  */
  function AsyncDecompress(cb) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be decompressed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  AsyncDecompress.prototype.push = function (chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };

  return AsyncDecompress;
}();


function decompress(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
}
/**
 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function decompressSync(data, out) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
} // flatten a directory structure

var fltn = function (d, p, t, o) {
  for (var k in d) {
    var val = d[k],
        n = p + k;
    if (val instanceof u8) t[n] = [val, o];else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])];else fltn(val, n + '/', t, o);
  }
}; // text encoder


var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/new TextEncoder(); // text decoder

var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/new TextDecoder(); // text decoder stream

var tds = 0;

try {
  td.decode(et, {
    stream: true
  });
  tds = 1;
} catch (e) {} // decode UTF8


var dutf8 = function (d) {
  for (var r = '', i = 0;;) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length) return [r, slc(d, i - 1)];
    if (!eb) r += String.fromCharCode(c);else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
/**
 * Streaming UTF-8 decoding
 */


var DecodeUTF8 = /*#__PURE__*/function () {
  /**
   * Creates a UTF-8 decoding stream
   * @param cb The callback to call whenever data is decoded
   */
  function DecodeUTF8(cb) {
    this.ondata = cb;
    if (tds) this.t = new TextDecoder();else this.p = et;
  }
  /**
   * Pushes a chunk to be decoded from UTF-8 binary
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  DecodeUTF8.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback';
    final = !!final;

    if (this.t) {
      this.ondata(this.t.decode(chunk, {
        stream: true
      }), final);

      if (final) {
        if (this.t.decode().length) throw 'invalid utf-8 data';
        this.t = null;
      }

      return;
    }

    if (!this.p) throw 'stream finished';
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);

    var _a = dutf8(dat),
        ch = _a[0],
        np = _a[1];

    if (final) {
      if (np.length) throw 'invalid utf-8 data';
      this.p = null;
    } else this.p = np;

    this.ondata(ch, final);
  };

  return DecodeUTF8;
}();


/**
 * Streaming UTF-8 encoding
 */

var EncodeUTF8 = /*#__PURE__*/function () {
  /**
   * Creates a UTF-8 decoding stream
   * @param cb The callback to call whenever data is encoded
   */
  function EncodeUTF8(cb) {
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be encoded to UTF-8
   * @param chunk The string data to push
   * @param final Whether this is the last chunk
   */


  EncodeUTF8.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback';
    if (this.d) throw 'stream finished';
    this.ondata(strToU8(chunk), this.d = final || false);
  };

  return EncodeUTF8;
}();


/**
 * Converts a string into a Uint8Array for use with compression/decompression methods
 * @param str The string to encode
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless decoding a binary string.
 * @returns The string encoded in UTF-8/Latin-1 binary
 */

function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);

    for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);

    return ar_1;
  }

  if (te) return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;

  var w = function (v) {
    ar[ai++] = v;
  };

  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }

    var c = str.charCodeAt(i);
    if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }

  return slc(ar, 0, ai);
}
/**
 * Converts a Uint8Array to a string
 * @param dat The data to decode to string
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless encoding to binary string.
 * @returns The original UTF-8/Latin-1 string
 */

function strFromU8(dat, latin1) {
  if (latin1) {
    var r = '';

    for (var i = 0; i < dat.length; i += 16384) r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));

    return r;
  } else if (td) return td.decode(dat);else {
    var _a = dutf8(dat),
        out = _a[0],
        ext = _a[1];

    if (ext.length) throw 'invalid utf-8 data';
    return out;
  }
}
; // deflate bit flag

var dbf = function (l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
}; // skip local zip header


var slzh = function (d, b) {
  return b + 30 + b2(d, b + 26) + b2(d, b + 28);
}; // read zip header


var zh = function (d, b, z) {
  var fnl = b2(d, b + 28),
      fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)),
      es = b + 46 + fnl,
      bs = b4(d, b + 20);

  var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)],
      sc = _a[0],
      su = _a[1],
      off = _a[2];

  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
}; // read zip64 extra field


var z64e = function (d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2));

  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
}; // extra field length


var exfl = function (ex) {
  var le = 0;

  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535) throw 'extra field too long';
      le += l + 4;
    }
  }

  return le;
}; // write zip header


var wzh = function (d, b, f, fn, u, c, ce, co) {
  var fl = fn.length,
      ex = f.extra,
      col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
  if (ce != null) d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2; // spec compliance? what's that?

  d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime),
      y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119) throw 'date not in range 1980-2099';
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;

  if (c != null) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c);
    wbytes(d, b + 8, f.size);
  }

  wbytes(d, b + 12, fl);
  wbytes(d, b + 14, exl), b += 16;

  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }

  d.set(fn, b);
  b += fl;

  if (exl) {
    for (var k in ex) {
      var exf = ex[k],
          l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }

  if (col) d.set(co, b), b += col;
  return b;
}; // write zip footer (end of central directory)


var wzf = function (o, b, c, d, e) {
  wbytes(o, b, 0x6054B50); // skip disk

  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */


var ZipPassThrough = /*#__PURE__*/function () {
  /**
   * Creates a pass-through stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   */
  function ZipPassThrough(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  /**
   * Processes a chunk and pushes to the output stream. You can override this
   * method in a subclass for custom behavior, but by default this passes
   * the data through. You must call this.ondata(err, chunk, final) at some
   * point in this method.
   * @param chunk The chunk to process
   * @param final Whether this is the last chunk
   */


  ZipPassThrough.prototype.process = function (chunk, final) {
    this.ondata(null, chunk, final);
  };
  /**
   * Pushes a chunk to be added. If you are subclassing this with a custom
   * compression algorithm, note that you must push data from the source
   * file only, pre-compression.
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  ZipPassThrough.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback - add to ZIP archive before pushing';
    this.c.p(chunk);
    this.size += chunk.length;
    if (final) this.crc = this.c.d();
    this.process(chunk, final || false);
  };

  return ZipPassThrough;
}();

 // I don't extend because TypeScript extension adds 1kB of runtime bloat

/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */

var ZipDeflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   * @param opts The compression options
   */
  function ZipDeflate(filename, opts) {
    var _this_1 = this;

    if (!opts) opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function (dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }

  ZipDeflate.prototype.process = function (chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  ZipDeflate.prototype.push = function (chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };

  return ZipDeflate;
}();


/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */

var AsyncZipDeflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   * @param opts The compression options
   */
  function AsyncZipDeflate(filename, opts) {
    var _this_1 = this;

    if (!opts) opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function (err, dat, final) {
      _this_1.ondata(err, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }

  AsyncZipDeflate.prototype.process = function (chunk, final) {
    this.d.push(chunk, final);
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  AsyncZipDeflate.prototype.push = function (chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };

  return AsyncZipDeflate;
}();

 // TODO: Better tree shaking

/**
 * A zippable archive to which files can incrementally be added
 */

var Zip = /*#__PURE__*/function () {
  /**
   * Creates an empty ZIP archive to which files can be added
   * @param cb The callback to call whenever data for the generated ZIP archive
   *           is available
   */
  function Zip(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  /**
   * Adds a file to the ZIP archive
   * @param file The file stream to add
   */


  Zip.prototype.add = function (file) {
    var _this_1 = this;

    if (this.d & 2) throw 'stream finished';
    var f = strToU8(file.filename),
        fl = f.length;
    var com = file.comment,
        o = com && strToU8(com);
    var u = fl != file.filename.length || o && com.length != o.length;
    var hl = fl + exfl(file.extra) + 30;
    if (fl > 65535) throw 'filename too long';
    var header = new u8(hl);
    wzh(header, 0, file, f, u);
    var chks = [header];

    var pAll = function () {
      for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
        var chk = chks_1[_i];

        _this_1.ondata(null, chk, false);
      }

      chks = [];
    };

    var tr = this.d;
    this.d = 0;
    var ind = this.u.length;
    var uf = mrg(file, {
      f: f,
      u: u,
      o: o,
      t: function () {
        if (file.terminate) file.terminate();
      },
      r: function () {
        pAll();

        if (tr) {
          var nxt = _this_1.u[ind + 1];
          if (nxt) nxt.r();else _this_1.d = 1;
        }

        tr = 1;
      }
    });
    var cl = 0;

    file.ondata = function (err, dat, final) {
      if (err) {
        _this_1.ondata(err, dat, final);

        _this_1.terminate();
      } else {
        cl += dat.length;
        chks.push(dat);

        if (final) {
          var dd = new u8(16);
          wbytes(dd, 0, 0x8074B50);
          wbytes(dd, 4, file.crc);
          wbytes(dd, 8, cl);
          wbytes(dd, 12, file.size);
          chks.push(dd);
          uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
          if (tr) uf.r();
          tr = 1;
        } else if (tr) pAll();
      }
    };

    this.u.push(uf);
  };
  /**
   * Ends the process of adding files and prepares to emit the final chunks.
   * This *must* be called after adding all desired files for the resulting
   * ZIP file to work properly.
   */


  Zip.prototype.end = function () {
    var _this_1 = this;

    if (this.d & 2) {
      if (this.d & 1) throw 'stream finishing';
      throw 'stream finished';
    }

    if (this.d) this.e();else this.u.push({
      r: function () {
        if (!(_this_1.d & 1)) return;

        _this_1.u.splice(-1, 1);

        _this_1.e();
      },
      t: function () {}
    });
    this.d = 3;
  };

  Zip.prototype.e = function () {
    var bt = 0,
        l = 0,
        tl = 0;

    for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
      var f = _a[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }

    var out = new u8(tl + 22);

    for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
      var f = _c[_b];
      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }

    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  /**
   * A method to terminate any internal workers used by the stream. Subsequent
   * calls to add() will fail.
   */


  Zip.prototype.terminate = function () {
    for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
      var f = _a[_i];
      f.t();
    }

    this.d = 2;
  };

  return Zip;
}();


function zip(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  var r = {};
  fltn(data, '', r, opts);
  var k = Object.keys(r);
  var lft = k.length,
      o = 0,
      tot = 0;
  var slft = lft,
      files = new Array(lft);
  var term = [];

  var tAll = function () {
    for (var i = 0; i < term.length; ++i) term[i]();
  };

  var cbf = function () {
    var out = new u8(tot + 22),
        oe = o,
        cdl = tot - o;
    tot = 0;

    for (var i = 0; i < slft; ++i) {
      var f = files[i];

      try {
        var l = f.c.length;
        wzh(out, tot, f, f.f, f.u, l);
        var badd = 30 + f.f.length + exfl(f.extra);
        var loc = tot + badd;
        out.set(f.c, loc);
        wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
      } catch (e) {
        return cb(e, null);
      }
    }

    wzf(out, o, files.length, cdl, oe);
    cb(null, out);
  };

  if (!lft) cbf();

  var _loop_1 = function (i) {
    var fn = k[i];
    var _a = r[fn],
        file = _a[0],
        p = _a[1];
    var c = crc(),
        size = file.length;
    c.p(file);
    var f = strToU8(fn),
        s = f.length;
    var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
    var exl = exfl(p.extra);
    var compression = p.level == 0 ? 0 : 8;

    var cbl = function (e, d) {
      if (e) {
        tAll();
        cb(e, null);
      } else {
        var l = d.length;
        files[i] = mrg(p, {
          size: size,
          crc: c.d(),
          c: d,
          f: f,
          m: m,
          u: s != fn.length || m && com.length != ms,
          compression: compression
        });
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
        if (! --lft) cbf();
      }
    };

    if (s > 65535) cbl('filename too long', null);
    if (!compression) cbl(null, file);else if (size < 160000) {
      try {
        cbl(null, deflateSync(file, p));
      } catch (e) {
        cbl(e, null);
      }
    } else term.push(deflate(file, p, cbl));
  }; // Cannot use lft because it can decrease


  for (var i = 0; i < slft; ++i) {
    _loop_1(i);
  }

  return tAll;
}
/**
 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
 * with more than one file.
 * @param data The directory structure for the ZIP archive
 * @param opts The main options, merged with per-file options
 * @returns The generated ZIP archive
 */

function zipSync(data, opts) {
  if (!opts) opts = {};
  var r = {};
  var files = [];
  fltn(data, '', r, opts);
  var o = 0;
  var tot = 0;

  for (var fn in r) {
    var _a = r[fn],
        file = _a[0],
        p = _a[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn),
        s = f.length;
    var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
    var exl = exfl(p.extra);
    if (s > 65535) throw 'filename too long';
    var d = compression ? deflateSync(file, p) : file,
        l = d.length;
    var c = crc();
    c.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c.d(),
      c: d,
      f: f,
      m: m,
      u: s != fn.length || m && com.length != ms,
      o: o,
      compression: compression
    }));
    o += 30 + s + exl + l;
    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
  }

  var out = new u8(tot + 22),
      oe = o,
      cdl = tot - o;

  for (var i = 0; i < files.length; ++i) {
    var f = files[i];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }

  wzf(out, o, files.length, cdl, oe);
  return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */

var UnzipPassThrough = /*#__PURE__*/function () {
  function UnzipPassThrough() {}

  UnzipPassThrough.prototype.push = function (data, final) {
    this.ondata(null, data, final);
  };

  UnzipPassThrough.compression = 0;
  return UnzipPassThrough;
}();


/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */

var UnzipInflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE decompression that can be used in ZIP archives
   */
  function UnzipInflate() {
    var _this_1 = this;

    this.i = new Inflate(function (dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }

  UnzipInflate.prototype.push = function (data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, data, final);
    }
  };

  UnzipInflate.compression = 8;
  return UnzipInflate;
}();


/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */

var AsyncUnzipInflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE decompression that can be used in ZIP archives
   */
  function AsyncUnzipInflate(_, sz) {
    var _this_1 = this;

    if (sz < 320000) {
      this.i = new Inflate(function (dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function (err, dat, final) {
        _this_1.ondata(err, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }

  AsyncUnzipInflate.prototype.push = function (data, final) {
    if (this.i.terminate) data = slc(data, 0);
    this.i.push(data, final);
  };

  AsyncUnzipInflate.compression = 8;
  return AsyncUnzipInflate;
}();


/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */

var Unzip = /*#__PURE__*/function () {
  /**
   * Creates a ZIP decompression stream
   * @param cb The callback to call whenever a file in the ZIP archive is found
   */
  function Unzip(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  /**
   * Pushes a chunk to be unzipped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Unzip.prototype.push = function (chunk, final) {
    var _this_1 = this;

    if (!this.onfile) throw 'no callback';
    if (!this.p) throw 'stream finished';

    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d) this.d.push(toAdd, !this.c);else this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length) return this.push(chunk, final);
    } else {
      var f = 0,
          i = 0,
          is = void 0,
          buf = void 0;
      if (!this.p.length) buf = chunk;else if (!chunk.length) buf = this.p;else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length,
          oc = this.c,
          add = oc && this.d;

      var _loop_2 = function () {
        var _a;

        var sig = b4(buf, i);

        if (sig == 0x4034B50) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6),
              cmp_1 = b2(buf, i + 8),
              u = bf & 2048,
              dd = bf & 8,
              fnl = b2(buf, i + 26),
              es = b2(buf, i + 28);

          if (l > i + 30 + fnl + es) {
            var chks_2 = [];
            this_1.k.unshift(chks_2);
            f = 2;
            var sc_1 = b4(buf, i + 18),
                su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);

            if (sc_1 == 4294967295) {
              _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
            } else if (dd) sc_1 = -1;

            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function () {
                if (!file_1.ondata) throw 'no callback';
                if (!sc_1) file_1.ondata(null, et, true);else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr) throw 'unknown compression type ' + cmp_1;
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);

                  d_1.ondata = function (err, dat, final) {
                    file_1.ondata(err, dat, final);
                  };

                  for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                    var dat = chks_3[_i];
                    d_1.push(dat, false);
                  }

                  if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;else d_1.push(et, true);
                }
              },
              terminate: function () {
                if (d_1 && d_1.terminate) d_1.terminate();
              }
            };
            if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }

          return "break";
        } else if (oc) {
          if (sig == 0x8074B50) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 0x2014B50) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };

      var this_1 = this;

      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();

        if (state_1 === "break") break;
      }

      this.p = et;

      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
        if (add) add.push(dat, !!f);else this.k[+(f == 2)].push(dat);
      }

      if (f & 2) return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }

    if (final) {
      if (this.c) throw 'invalid zip file';
      this.p = null;
    }
  };
  /**
   * Registers a decoder with the stream, allowing for files compressed with
   * the compression type provided to be expanded correctly
   * @param decoder The decoder constructor
   */


  Unzip.prototype.register = function (decoder) {
    this.o[decoder.compression] = decoder;
  };

  return Unzip;
}();


/**
 * Asynchronously decompresses a ZIP archive
 * @param data The raw compressed ZIP file
 * @param cb The callback to call with the decompressed files
 * @returns A function that can be used to immediately terminate the unzipping
 */

function unzip(data, cb) {
  if (typeof cb != 'function') throw 'no callback';
  var term = [];

  var tAll = function () {
    for (var i = 0; i < term.length; ++i) term[i]();
  };

  var files = {};
  var e = data.length - 22;

  for (; b4(data, e) != 0x6054B50; --e) {
    if (!e || data.length - e > 65558) {
      cb('invalid zip file', null);
      return;
    }
  }

  ;
  var lft = b2(data, e + 8);
  if (!lft) cb(null, {});
  var c = lft;
  var o = b4(data, e + 16);
  var z = o == 4294967295;

  if (z) {
    e = b4(data, e - 12);

    if (b4(data, e) != 0x6064B50) {
      cb('invalid zip file', null);
      return;
    }

    c = lft = b4(data, e + 32);
    o = b4(data, e + 48);
  }

  var _loop_3 = function (i) {
    var _a = zh(data, o, z),
        c_1 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);

    o = no;

    var cbl = function (e, d) {
      if (e) {
        tAll();
        cb(e, null);
      } else {
        files[fn] = d;
        if (! --lft) cb(null, files);
      }
    };

    if (!c_1) cbl(null, slc(data, b, b + sc));else if (c_1 == 8) {
      var infl = data.subarray(b, b + sc);

      if (sc < 320000) {
        try {
          cbl(null, inflateSync(infl, new u8(su)));
        } catch (e) {
          cbl(e, null);
        }
      } else term.push(inflate(infl, {
        size: su
      }, cbl));
    } else cbl('unknown compression type ' + c_1, null);
  };

  for (var i = 0; i < c; ++i) {
    _loop_3(i);
  }

  return tAll;
}
/**
 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
 * performance with more than one file.
 * @param data The raw compressed ZIP file
 * @returns The decompressed files
 */

function unzipSync(data) {
  var files = {};
  var e = data.length - 22;

  for (; b4(data, e) != 0x6054B50; --e) {
    if (!e || data.length - e > 65558) throw 'invalid zip file';
  }

  ;
  var c = b2(data, e + 8);
  if (!c) return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295;

  if (z) {
    e = b4(data, e - 12);
    if (b4(data, e) != 0x6064B50) throw 'invalid zip file';
    c = b4(data, e + 32);
    o = b4(data, e + 48);
  }

  for (var i = 0; i < c; ++i) {
    var _a = zh(data, o, z),
        c_2 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);

    o = no;
    if (!c_2) files[fn] = slc(data, b, b + sc);else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));else throw 'unknown compression type ' + c_2;
  }

  return files;
}

/***/ }),

/***/ "9cc2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const ListPoolItem_1 = __webpack_require__("3844");

exports.ListPoolItem = ListPoolItem_1.ListPoolItem;

class ListPool {
  constructor() {
    this.m_list = [null];
    this.m_total = 1;
    this.m_freeUUIDs = [];
  }

  hasItemByUUID(listUUID) {
    if (listUUID > 0 && listUUID < this.m_total) {
      this.m_list[listUUID] != null;
    }

    return false;
  }

  hasItem(item) {
    if (item != null && item.listUUID > 0 && item.listUUID < this.m_total) {
      this.m_list[item.listUUID] == item;
    }

    return false;
  }

  hasnotItem(item) {
    if (item != null && item.listUUID > 0 && item.listUUID < this.m_total) {
      this.m_list[item.listUUID] != item;
    }

    return true;
  }

  getItemByUUID(listUUID) {
    if (listUUID > 0 && listUUID < this.m_total) {
      this.m_list[listUUID];
    }

    return null;
  }

  addItem(item) {
    if (item != null) {
      if (item.listUUID == 0) {
        if (this.m_freeUUIDs.length > 0) {
          item.listUUID = this.m_freeUUIDs.pop();

          if (this.m_list[item.listUUID] != null) {
            throw Error("ListPool::addItem() is the illegal operation !!!");
          }

          this.m_list[item.listUUID] = item;
        } else {
          item.listUUID = this.m_total;
          this.m_total++;
          this.m_list.push(item);
        }
      } else {
        throw Error("ListPool::addItem() is the illegal operation !!!");
      }
    } else {
      console.error("ListPool::addItem() item is null !!!");
    }
  }

  removeItem(item) {
    if (item != null && item.listUUID > 0 && item.listUUID < this.m_total && this.m_list[item.listUUID] != null) {
      if (this.m_list[item.listUUID] != item) {
        throw "ListPool::removeItem() is the illegal operation !!!";
      }

      this.m_freeUUIDs.push(item.listUUID);
      this.m_list[item.listUUID] = null;
      item.listUUID = 0;
    }
  }

}

exports.ListPool = ListPool;

/***/ }),

/***/ "9d01":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * 任务数据在执行过程中的状态(work flow status): 将32位分为4个8位, 分别表示任务执行过程中的四种类别的状态(未知 | 未知 | 未知 | 流转状态)，默认是0x0
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 流转状态
 */

var TransST;

(function (TransST) {
  /**
   * 默认值，标识所有操作结束
   */
  TransST[TransST["None"] = 0] = "None";
  /**
   * 任务正在运行
   */

  TransST[TransST["Running"] = 20] = "Running";
  /**
   * 任务结束
   */

  TransST[TransST["Finish"] = 21] = "Finish";
})(TransST || (TransST = {}));

exports.TransST = TransST;

class ThreadWFST {
  static Build(s0, s1, s2, transStatus) {
    return (s0 << 24) + (s1 << 16) + (s2 << 8) + transStatus;
  }

  static ModifyTransStatus(srcWSFT, transStatus) {
    srcWSFT &= 0xffffff00;
    return srcWSFT + transStatus;
  }

  static GetTransStatus(srcWSFT) {
    srcWSFT &= 0xFF;
    return srcWSFT;
  }

}

exports.ThreadWFST = ThreadWFST;

/***/ }),

/***/ "9f3e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RawDataTextureProxy_1 = __importDefault(__webpack_require__("df25"));

class Uint16TextureProxy extends RawDataTextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_type = TextureProxyType_1.TextureProxyType.Uint16;
    this.minFilter = TextureConst_1.default.LINEAR;
    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT;
  } //  OES_texture_half_float, HALF_FLOAT_OES


  toHalfFloatOes() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.unpackAlignment = 4; // 8 bytes

    this.dataType = TextureDataType_1.default.HALF_FLOAT_OES;
  }

  toUShort565() {
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB; //UNSIGNED_SHORT_5_6_5

    this.unpackAlignment = 3; // 2 bytes

    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT_5_6_5;
  }

  toUShort4444() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA; //UNSIGNED_SHORT_4_4_4_4

    this.unpackAlignment = 4; // 2 bytes

    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT_4_4_4_4;
  }

  toUShort5551() {
    //UNSIGNED_SHORT_5_5_5_1
    this.unpackAlignment = 4; // 2 bytes

    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT_5_5_5_1;
  }

  toUShort() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT; //UNSIGNED_SHORT
  }

  toAlphaFormat() {
    if (this.dataType == TextureDataType_1.default.UNSIGNED_SHORT) {
      this.srcFormat = TextureFormat_1.default.ALPHA;
      this.internalFormat = TextureFormat_1.default.ALPHA;
      this.unpackAlignment = 1;
    }
  }

  toRedFormat() {
    if (this.dataType == TextureDataType_1.default.UNSIGNED_SHORT) {
      this.srcFormat = TextureFormat_1.default.RED;
      this.internalFormat = TextureFormat_1.default.RED;
      this.unpackAlignment = 1;
    }
  }

  toRGBFormat() {
    if (this.dataType == TextureDataType_1.default.UNSIGNED_SHORT) {
      this.srcFormat = TextureFormat_1.default.RGB;
      this.internalFormat = TextureFormat_1.default.RGB;
      this.unpackAlignment = 3;
    }
  }

  toRGBAFormat() {
    if (this.dataType == TextureDataType_1.default.UNSIGNED_SHORT) {
      this.srcFormat = TextureFormat_1.default.RGBA;
      this.internalFormat = TextureFormat_1.default.RGBA;
      this.unpackAlignment = 4;
    }
  }

  uploadFromBytes(bytes, miplevel = 0, imgWidth = -1, imgHeight = -1, offsetx = 0, offsety = 0, rebuild = false) {
    super.setDataFromBytes(bytes, miplevel, imgWidth, imgHeight, offsetx, offsety, rebuild);
  }

  setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel = 0) {
    super.setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel);
  }

  getPixels(px, py, pw, ph, outBytes) {
    super.getPixels(px, py, pw, ph, outBytes);
  }

  toString() {
    return "[Uint16TextureProxy(width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = Uint16TextureProxy;

/***/ }),

/***/ "9f82":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RPStatus {
  constructor() {
    this.sdkVer = 0;
    this.version = 0;
    this.drawCallTimes = 0;
    this.drawTrisNumber = 0;
    this.povNumber = 0;
  }

  reset() {
    this.drawCallTimes = 0;
    this.drawTrisNumber = 0;
    this.povNumber = 0;
  }

}

exports.RPStatus = RPStatus;

/***/ }),

/***/ "a053":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const EulerOrder_1 = __webpack_require__("cc7a");

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

const Quaternion_1 = __webpack_require__("ac89");

const _matrix = new Matrix4_1.default();

const _quaternion = new Quaternion_1.Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.order = order;
  }

  set(x, y, z, order = this.order) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.order = order;
    return this;
  }

  clone() {
    return new Euler(this.x, this.y, this.z, this.order);
  }

  copy(euler) {
    this.x = euler.x;
    this.y = euler.y;
    this.z = euler.z;
    this.order = euler.order;
    return this;
  }

  setFromRotationMatrix(m, order = this.order, update = true) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.getLocalFS32();
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    let clamp = MathConst_1.default.Clamp;

    switch (order) {
      case EulerOrder_1.EulerOrder.XYZ:
        this.y = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this.x = Math.atan2(-m23, m33);
          this.z = Math.atan2(-m12, m11);
        } else {
          this.x = Math.atan2(m32, m22);
          this.z = 0;
        }

        break;

      case EulerOrder_1.EulerOrder.YXZ:
        this.x = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this.y = Math.atan2(m13, m33);
          this.z = Math.atan2(m21, m22);
        } else {
          this.y = Math.atan2(-m31, m11);
          this.z = 0;
        }

        break;

      case EulerOrder_1.EulerOrder.ZXY:
        this.x = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this.y = Math.atan2(-m31, m33);
          this.z = Math.atan2(-m12, m22);
        } else {
          this.y = 0;
          this.z = Math.atan2(m21, m11);
        }

        break;

      case EulerOrder_1.EulerOrder.ZYX:
        this.y = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this.x = Math.atan2(m32, m33);
          this.z = Math.atan2(m21, m11);
        } else {
          this.x = 0;
          this.z = Math.atan2(-m12, m22);
        }

        break;

      case EulerOrder_1.EulerOrder.YZX:
        this.z = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this.x = Math.atan2(-m23, m22);
          this.y = Math.atan2(-m31, m11);
        } else {
          this.x = 0;
          this.y = Math.atan2(m13, m33);
        }

        break;

      case EulerOrder_1.EulerOrder.XZY:
        this.z = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this.x = Math.atan2(m32, m22);
          this.y = Math.atan2(m13, m11);
        } else {
          this.x = Math.atan2(-m23, m33);
          this.y = 0;
        }

        break;

      default:
        console.warn('Euler::setFromRotationMatrix() encountered an unknown order: ', order);
    }

    this.order = order;
    return this;
  }

  setFromQuaternion(q, order, update = true) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order = this.order) {
    return this.set(v.x, v.y, v.z, order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion.setFromEuler(this);

    return this.setFromQuaternion(_quaternion, newOrder);
  }

  equals(euler) {
    return euler.x === this.x && euler.y === this.y && euler.z === this.z && euler.order === this.order;
  }

  fromArray(array) {
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    if (array[3] !== undefined) this.order = array[3];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.order;
    return array;
  }

}

Euler.DefaultOrder = EulerOrder_1.EulerOrder.XYZ;
exports.Euler = Euler;

/***/ }),

/***/ "a054":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeometryModelDataType_1 = __webpack_require__("58fc");

exports.GeometryModelDataType = GeometryModelDataType_1.GeometryModelDataType;

/***/ }),

/***/ "a092":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

const GeometryDataUnit_1 = __webpack_require__("aeff");

class DataUnitWrapper {
  constructor() {}

}

class DataUnitPool {
  constructor() {
    // 因为不是高频操作，所以可以用map
    this.m_urlPool = new Map();
    this.m_idPool = new Map();

    if (DataUnitPool.s_inited) {
      DataUnitPool.s_inited = false; // 这样做的目的是为了让有效uuid从1开始

      this.createUnit();
    }
  }

  createUnit() {
    DataUnit_1.DataUnitLock.lockStatus = 207;
    let unit = new DataUnit_1.DataUnit();
    return unit;
  }

  createGeometryUnit() {
    DataUnit_1.DataUnitLock.lockStatus = 207;
    let unit = new GeometryDataUnit_1.GeometryDataUnit();
    return unit;
  }

  hasUnitByUrl(url) {
    return this.m_urlPool.has(url);
  }

  hasUnitByUUID(uuid) {
    return this.m_idPool.has(uuid);
  }

  addUnit(url, unit) {
    if (url != "" && unit != null && !this.m_urlPool.has(url)) {
      let wrapper = new DataUnitWrapper();
      wrapper.uuid = unit.getUUID();
      wrapper.url = url;
      wrapper.unit = unit;
      this.m_urlPool.set(url, wrapper);
      this.m_idPool.set(unit.getUUID(), wrapper);
    }
  }

  removeUnit(unit) {
    if (unit != null && this.m_idPool.has(unit.getUUID())) {
      let wrapper = this.m_idPool.get(unit.getUUID());
      this.m_idPool.delete(wrapper.uuid);
      this.m_urlPool.delete(wrapper.url); // TODO(lyl): 暂时这样写

      wrapper.unit = null;
    }
  }

  removeUnitByUUID(uuid) {
    if (this.m_idPool.has(uuid)) {
      let wrapper = this.m_idPool.get(uuid);
      this.m_idPool.delete(wrapper.uuid);
      this.m_urlPool.delete(wrapper.url); // TODO(lyl): 暂时这样写

      wrapper.unit = null;
    }
  }

  removeUnitByUrl(url) {
    if (this.m_urlPool.has(url)) {
      let wrapper = this.m_urlPool.get(url);
      this.m_idPool.delete(wrapper.uuid);
      this.m_urlPool.delete(wrapper.url); // TODO(lyl): 暂时这样写

      wrapper.unit = null;
    }
  }

  getUnitByUrl(url) {
    let wrapper = this.m_urlPool.get(url);

    if (wrapper != null) {
      return wrapper.unit;
    }

    return null;
  }

  getUnitByUUID(uuid) {
    let wrapper = this.m_idPool.get(uuid);

    if (wrapper != null) {
      return wrapper.unit;
    }

    return null;
  }

}

DataUnitPool.s_inited = true;
exports.DataUnitPool = DataUnitPool;

/***/ }),

/***/ "a156":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const ShdProgram_1 = __importDefault(__webpack_require__("20ef"));

class ShaderProgramBuilder {
  constructor(rcuid) {
    this.m_shdDict = new Map();
    this.m_shdList = [];
    this.m_shdListLen = 0;
    this.m_sharedUniformList = [];
    this.m_rcuid = -1;
    this.m_rcuid = rcuid;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }
  /**
   * 这里的program生成过程已经能适配多GPU context的情况了
   */


  create(shdData) {
    // console.log("this.Create() begin...");
    let uns = shdData.getUniqueShaderName();

    if (this.m_shdDict.has(uns)) {
      return this.m_shdDict.get(uns);
    }

    let p = new ShdProgram_1.default(this.m_shdListLen);
    p.setShdData(shdData);
    this.m_shdList[p.getUid()] = p;
    this.m_sharedUniformList[p.getUid()] = null;
    ++this.m_shdListLen;
    this.m_shdDict.set(uns, p);

    if (RendererDevice_1.default.SHADERCODE_TRACE_ENABLED) {
      console.log("this.Create() a new ShdProgram: ", p.toString());
    }

    return p;
  }

  findShdProgramByUid(uid) {
    return this.m_shdList[uid];
  }

  findShdProgram(unique_name_str) {
    if (this.m_shdDict.has(unique_name_str)) {
      return this.m_shdDict.get(unique_name_str);
    }

    return null;
  }

  findShdProgramByShdData(shdData) {
    if (shdData != null) {
      if (this.m_shdDict.has(shdData.getUniqueShaderName())) {
        return this.m_shdDict.get(shdData.getUniqueShaderName());
      }
    }

    return null;
  }

  hasUid(resUid) {
    return this.m_shdList[resUid] != null;
  }

  getTotal() {
    return this.m_shdListLen;
  }

  containsUid(uid) {
    return uid > -1 && uid < this.m_shdListLen;
  }

}

exports.ShaderProgramBuilder = ShaderProgramBuilder;

/***/ }),

/***/ "a176":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // import {DemoThread as Demo} from "./cospace/modules/thread/example/DemoThread";
// import {DemoThread as Demo} from "./cospace/demo/DemoThread";
// import {DemoThreadLoadJS as Demo} from "./cospace/demo/DemoThreadLoadJS";
// import { DemoCTMLoadAndParser as Demo } from "./cospace/demo/DemoCTMLoadAndParser";
// import { DemoFBXFastParser as Demo } from "./cospace/demo/DemoFBXFastParser";
// import { DemoOBJParser as Demo } from "./cospace/demo/DemoOBJParser";

Object.defineProperty(exports, "__esModule", {
  value: true
}); // import { DemoCTMLoad as Demo } from "./cospace/demo/DemoCTMLoad";
// import { DemoCTMParser as Demo } from "./cospace/demo/DemoCTMParser";
// import { DemoDracoParser as Demo } from "./cospace/demo/DemoDracoParser";
// import { DemoShowCTMAndDraco as Demo } from "./cospace/demo/DemoShowCTMAndDraco";
// import { DemoCTMToDraco as Demo } from "./cospace/demo/DemoCTMToDraco";
// import { DemoDracoEncode as Demo } from "./cospace/demo/DemoDracoEncode";
// import { DemoDracoParser2 as Demo } from "./cospace/demo/DemoDracoParser2";
// import { DemoFBXParser as Demo } from "./cospace/demo/DemoFBXParser";
// import { DemoGLBParser as Demo } from "./cospace/demo/DemoGLBParser";
// import { DemoPNGParser as Demo } from "./cospace/demo/DemoPNGParser";
// import { DemoMixParser as Demo } from "./cospace/demo/DemoMixParser";
// import { DemoCospace as Demo } from "./cospace/demo/DemoCospace";
// import { DemoCospaceDeferredInit as Demo } from "./cospace/demo/DemoCospaceDeferredInit";
// import { DemoDependenceGraph as Demo } from "./cospace/demo/DemoDependenceGraph";
// import { DemoCTMViewer as Demo } from "./cospace/demo/DemoCTMViewer";
// import { DemoNormalViewer as Demo } from "./cospace/demo/DemoNormalViewer";

const RenderingVerifier_1 = __webpack_require__("d35a"); // import { DemoCoApp as Demo } from "./cospace/demo/DemoCoApp";
// import { DemoCoAppDeferredInit as Demo } from "./cospace/demo/DemoCoAppDeferredInit";
// import { DemoCoRenderer as Demo } from "./cospace/demo/DemoCoRenderer";
// import { DemoCoRendererScene as Demo } from "./cospace/demo/DemoCoRendererScene";
// import { DemoCoRendererSubScene as Demo } from "./cospace/demo/DemoCoRendererSubScene";
// import { DemoCoSimpleRendereScene as Demo } from "./cospace/demo/DemoCoSimpleRendereScene";
// import { DemoCoViewer as Demo } from "./cospace/demo/DemoCoViewer";
// import { DemoVox3DEditor as Demo } from "./cospace/demo/DemoVox3DEditor";
// import { DemoOutline as Demo } from "./cospace/demo/DemoOutline";
// import { DemoPostOutline as Demo } from "./cospace/demo/DemoPostOutline";
// import { DemoCoParticle as Demo } from "./cospace/demo/DemoCoParticle";
// import { DemoCoParticleFlow as Demo } from "./cospace/demo/DemoCoParticleFlow";
// import { DemoCoParticleModule as Demo } from "./cospace/demo/DemoCoParticleModule";
// import { DemoCoEdit as Demo } from "./cospace/demo/DemoCoEdit";
// import { DemoInputText as Demo } from "./cospace/demo/DemoInputText";
// import { DemoCORS as Demo } from "./cospace/demo/DemoCORS";


let demoIns = new RenderingVerifier_1.RenderingVerifier();
let ins = demoIns;

function main() {
  console.log("------ demo --- init ------");
  ins.initialize();

  function mainLoop(now) {
    ins.run();
    window.requestAnimationFrame(mainLoop);
  }

  window.requestAnimationFrame(mainLoop);
  console.log("------ demo --- running ------");
}

main();

/***/ }),

/***/ "a401":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ModuleFileType;

(function (ModuleFileType) {
  ModuleFileType["JS"] = "js-text";
  ModuleFileType["Binasy"] = "binary";
})(ModuleFileType || (ModuleFileType = {}));

exports.ModuleFileType = ModuleFileType;

/***/ }),

/***/ "a446":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 当前渲染场景空间管理的入口类, 鼠标拾取，摄像机裁剪，空间管理遮挡剔除等都是由这个系统来组织完成的

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("11e6"));

const SpaceCullingMask_1 = __webpack_require__("cc48");

const EntityNodeQueue_1 = __importDefault(__webpack_require__("af68"));

const Entity3DNodeLinker_1 = __importDefault(__webpack_require__("a80a"));

const RenderingEntitySet_1 = __importDefault(__webpack_require__("56a9"));

class RendererSpace {
  constructor() {
    this.m_uid = -1;
    this.m_renderer = null;
    this.m_camera = null;
    this.m_stage3d = null;
    this.m_emptyRPONode = null;
    this.m_rpoNodeBuilder = null;
    this.m_nodeQueue = new EntityNodeQueue_1.default();
    this.m_nodeWLinker = new Entity3DNodeLinker_1.default();
    this.m_nodeSLinker = new Entity3DNodeLinker_1.default();
    this.m_cullingor = null;
    this.m_raySelector = null;
    this.m_entitysTotal = 0;
    this.renderingEntitySet = new RenderingEntitySet_1.default();
    this.m_uid = RendererSpace.s_uid++;
    this.m_nodeQueue.initialize(1);
  }

  getUid() {
    return this.m_uid;
  }

  initialize(renderer, camera = null) {
    if (this.m_renderer == null) {
      this.m_renderer = renderer;
      this.m_stage3d = renderer.getStage3D();
      this.m_camera = camera;
      this.m_rpoNodeBuilder = renderer.getRPONodeBuilder();
      this.m_emptyRPONode = this.m_rpoNodeBuilder.createRPONode();
    }
  }

  getStage3D() {
    return this.m_stage3d;
  }

  setCamera(camera) {
    this.m_camera = camera;
  }

  getCamera() {
    return this.m_camera;
  }

  getMouseXYWorldRay(rl_position, rl_tv) {
    this.m_camera.getWorldPickingRayByScreenXY(this.m_stage3d.mouseX, this.m_stage3d.mouseY, rl_position, rl_tv);
  }

  setSpaceCullingor(cullingor) {
    this.m_cullingor = cullingor;
  }

  setRaySelector(raySelector) {
    this.m_raySelector = raySelector;
    this.m_raySelector.setRenderer(this.m_renderer);
  }

  getRaySelector() {
    return this.m_raySelector;
  }

  getPOVNumber() {
    return this.m_cullingor != null ? this.m_cullingor.getPOVNumber() : 0;
  } // 可以添加真正被渲染的实体也可以添加只是为了做检测的实体(不允许有material)


  addEntity(entity) {
    if (entity.getGlobalBounds() != null && entity.spaceCullMask > SpaceCullingMask_1.SpaceCullingMask.NONE) {
      if (RSEntityFlag_1.default.TestSpaceEnabled(entity.__$rseFlag)) {
        entity.update();
        ++this.m_entitysTotal;
        let node = this.m_nodeQueue.addEntity(entity);
        node.bounds = entity.getGlobalBounds();
        node.pcoEnabled = (entity.spaceCullMask & SpaceCullingMask_1.SpaceCullingMask.POV) == SpaceCullingMask_1.SpaceCullingMask.POV;
        let boo = entity.isInRendererProcess() || entity.getMaterial() == null;

        if (boo && (entity.spaceCullMask & SpaceCullingMask_1.SpaceCullingMask.POV) == SpaceCullingMask_1.SpaceCullingMask.POV) {
          node.rstatus = 1;

          if (entity.getMaterial() == null) {
            node.rpoNode = this.m_emptyRPONode;
          }

          if (node.rpoNode == null) {
            node.rpoNode = this.m_rpoNodeBuilder.getNodeByUid(entity.getDisplay().__$rpuid);
          }

          this.m_nodeSLinker.addNode(node);
        } else {
          if (entity.getMaterial() == null) {
            node.rstatus = 1;
            node.rpoNode = this.m_emptyRPONode;
            this.m_nodeSLinker.addNode(node);
          } else {
            node.rstatus = 0;
            this.m_nodeWLinker.addNode(node);
          }
        }
      }
    }
  }

  removeEntity(entity) {
    if (entity != null && RSEntityFlag_1.default.TestSpaceContains(entity.__$rseFlag)) {
      let node = this.m_nodeQueue.getNodeByEntity(entity);

      if (node != null) {
        if (node.rstatus > 0) {
          this.m_nodeSLinker.removeNode(node);
        } else {
          this.m_nodeWLinker.removeNode(node);
        }

        this.m_nodeQueue.removeEntity(entity);
        --this.m_entitysTotal;
      }
    }
  }

  updateEntity(entity) {//  if(RSEntityFlag.TestSpaceContains( entity.__$rseFlag ))
    //  {
    //      let node:Entity3DNode = this.m_nodeQueue.getNodeByEntity(entity);
    //      //  if(node != null)
    //      //  {
    //      //      node.distanceFlag = RSEntityFlag.TestSortEnabled(entity.__$rseFlag);
    //      //  }
    //  }
  }

  update() {}

  runBegin() {}

  run() {
    let nextNode = this.m_nodeWLinker.getBegin();

    if (nextNode != null) {
      let pnode = null;

      while (nextNode != null) {
        if (nextNode.entity.isInRendererProcess()) {
          pnode = nextNode;
          pnode.rstatus = 1;
          nextNode = nextNode.next;
          this.m_nodeWLinker.removeNode(pnode);
          this.m_nodeSLinker.addNode(pnode);

          if (pnode.rpoNode == null) {
            pnode.rpoNode = this.m_rpoNodeBuilder.getNodeByUid(pnode.entity.getDisplay().__$rpuid);
          }
        } else {
          nextNode = nextNode.next;
        }
      }
    }

    nextNode = this.m_nodeSLinker.getBegin();

    if (nextNode != null) {
      let total = 0;

      if (this.m_cullingor != null) {
        this.m_cullingor.setCamera(this.m_camera);
        this.m_cullingor.setCullingNodeHead(nextNode);
        this.m_cullingor.run();
        total = this.m_cullingor.total;
      } else {
        let ab = null;
        let cam = this.m_camera; //let camPos:Vector3D = cam.getPosition();

        while (nextNode != null) {
          if (nextNode.rpoNode.isVsible() && nextNode.entity.isDrawEnabled()) {
            ab = nextNode.bounds;
            const boo = cam.visiTestSphere2(ab.center, ab.radius);
            nextNode.drawEnabled = boo;
            nextNode.entity.drawEnabled = boo;
            nextNode.rpoNode.drawEnabled = boo;
            total += boo ? 1 : 0; //  if(nextNode.drawEnabled && nextNode.distanceFlag)
            //  {
            //      nextNode.rpoNode.setValue(-Vector3D.DistanceSquared(camPos,ab.center));
            //      //console.log((nextNode.entity as any).name,",a runit.value: ",nextNode.rpoNode.unit.value);
            //  }
          } else {
            nextNode.drawEnabled = false;
            nextNode.entity.drawEnabled = false;
            nextNode.rpoNode.drawEnabled = false;
          } // if(DebugFlag.Flag_0 > 0) console.log("nextNode.rpoNode.isVsible(): ",nextNode.rpoNode.isVsible(), nextNode.entity.isDrawEnabled(), nextNode.drawEnabled);


          nextNode = nextNode.next;
        }
      }

      const etset = this.renderingEntitySet;

      if (total > 0) {
        etset.reset(total);
        nextNode = this.m_nodeSLinker.getBegin();

        while (nextNode != null) {
          if (nextNode.drawEnabled) {
            etset.addEntity(nextNode.entity);
          }

          nextNode = nextNode.next;
        }
      } else {
        etset.clear();
      }
    }
  }

  rayTest(rlpv, rltv) {
    if (this.m_raySelector != null) {
      this.m_raySelector.setCamera(this.m_camera);
      this.m_raySelector.setCullingNodeHead(this.m_nodeSLinker.getBegin());
      this.m_raySelector.setRay(rlpv, rltv);
      this.m_raySelector.run();
    }
  }

  runEnd() {}

  getCullingNodeHead() {
    return this.m_nodeSLinker.getBegin();
  }

  toString() {
    return "[RendererSpace(uid = " + this.m_uid + ")]";
  }

}

RendererSpace.s_uid = 0;
exports.default = RendererSpace;

/***/ }),

/***/ "a46e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 摄像机拉近拉远的控制(主要是移动端的多点触摸)

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

class CameraZoomController {
  constructor() {
    this.m_camera = null;
    this.m_touchZoomBoo = false;
    this.m_preDis = 0;
    this.m_touchZoomSpd = 2.0;
    this.m_slideSpd = 1.0;
    this.m_mouseWheelZoomSpd = 6.0;
    this.m_tempa = new Vector3D_1.default();
    this.m_tempb = new Vector3D_1.default();
    this.m_preva = new Vector3D_1.default();
    this.m_prevb = new Vector3D_1.default();
    this.m_va = new Vector3D_1.default();
    this.m_vb = new Vector3D_1.default();
    this.m_lookAt = new Vector3D_1.default();
    this.m_fowardDis = 0;
    this.m_initBoo = true;
    this.m_lookAtCtrlEnabled = true;
    this.m_flagDrag = 0;
    this.m_flagZoom = 0;
    this.m_windowsEnvFlag = true;
    this.syncLookAt = false;
    /**
     * 取值为2, 表示相机的拉近拉远
     * 取值为1, 表示相机的拖动
     */

    this.m_flagType = 2;
    this.m_windowsEnvFlag = !(RendererDevice_1.default.IsMobileWeb() || RendererDevice_1.default.IsSafariWeb());
  }

  setMobileZoomSpeed(spd) {
    this.m_touchZoomSpd = spd;
  }

  seSlideSpeed(spd) {
    this.m_slideSpd = spd;
  }
  /**
   * set mousewheel zoom camera forward speed
   * @param spd default value is 6.0
   */


  setMouseWheelZoomSpd(spd) {
    this.m_mouseWheelZoomSpd = spd;
  }

  bindCamera(camera) {
    this.m_camera = camera;
  }

  initialize(stage3D) {
    if (this.m_initBoo) {
      this.m_initBoo = false;
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_WHEEL, this, this.mouseWheelListener, true, true);
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_MULTI_MOVE, this, this.mouseMultiMoveListener, true, true);
      stage3D.addEventListener(MouseEvent_1.default.MOUSE_MULTI_UP, this, this.mouseMultiUpListener, true, true);
    }
  }

  setLookAtCtrlEnabled(enabled) {
    this.m_lookAtCtrlEnabled = enabled;
  }

  mouseWheelListener(evt) {
    if (evt.wheelDeltaY > 0) {
      this.m_fowardDis += this.m_mouseWheelZoomSpd;
    } else {
      this.m_fowardDis -= this.m_mouseWheelZoomSpd;
    }
  }

  mouseMultiMoveListener(evt) {
    this.setTouchPosArray(evt.posArray);
  }

  mouseMultiUpListener(evt) {
    this.setTouchPosArray(evt.posArray);
  }

  resetState() {
    this.m_flagDrag = 0;
    this.m_flagZoom = 0;
    this.m_flagType = 0;
  }

  setTouchPosArray(posArray) {
    if (posArray != null && posArray.length > 1) {
      let dis = 0;
      this.m_va.setXYZ(posArray[0].x, posArray[0].y, 0);
      this.m_vb.setXYZ(posArray[1].x, posArray[1].y, 0);

      if (this.m_touchZoomBoo) {
        dis = Vector3D_1.default.Distance(this.m_va, this.m_vb);

        if (this.m_flagType < 1) {
          this.m_tempa.copyFrom(this.m_va);
          this.m_tempb.copyFrom(this.m_vb);
          this.m_tempa.subVecsTo(this.m_va, this.m_preva);
          this.m_tempb.subVecsTo(this.m_vb, this.m_prevb);
          this.m_tempa.normalize();
          this.m_tempb.normalize();

          if (this.m_tempa.dot(this.m_tempb) > 0.9) {
            // 可能是拖动
            this.m_flagDrag++;
          } else {
            // 可能是缩放
            this.m_flagZoom++;
          } //DivLog.ShowLog("> "+this.m_flagDrag+","+this.m_flagZoom);


          if (this.m_flagDrag > 3 || this.m_flagZoom > 3) {
            this.m_flagType = this.m_flagDrag > this.m_flagZoom ? 1 : 2;
          }
        } else {
          this.m_tempa.subVecsTo(this.m_va, this.m_preva);
        }

        let dv = Math.abs(this.m_preDis - dis);

        if (dv > 0.1) {
          this.m_fowardDis = (dis - this.m_preDis) * this.m_touchZoomSpd;
          this.m_preDis = dis;
        }
      } else {
        this.m_touchZoomBoo = true;
        this.m_preDis = Vector3D_1.default.Distance(this.m_va, this.m_vb);
        this.resetState();
      }
    } else {
      this.resetState();
      this.m_touchZoomBoo = false;
    }

    this.m_preva.copyFrom(this.m_va);
    this.m_prevb.copyFrom(this.m_vb);
  }

  run(lookAtPos, minDis) {
    let lookAtEnabled = this.m_lookAtCtrlEnabled;

    if (lookAtPos == null) {
      lookAtPos = this.m_lookAt;
    }

    if (this.m_camera != null) {
      if (this.syncLookAt) {
        this.m_camera.setLookAtPosition(lookAtPos);
      }

      if (this.m_flagType == 2) {
        // camera foward update
        if (Math.abs(this.m_fowardDis) > 0.001) {
          let dis = Vector3D_1.default.Distance(this.m_camera.getPosition(), this.m_camera.getLookAtPosition());
          let pd = this.m_fowardDis;

          if (this.m_fowardDis > 0) {
            if (dis > minDis) {
              pd = dis - minDis;
              if (pd > this.m_fowardDis) pd = this.m_fowardDis;
            } else {
              pd = 0;
            }
          }

          if (Math.abs(pd) > 0.1) {
            this.m_camera.forward(pd);
            if (lookAtEnabled) this.m_camera.setLookPosXYZFixUp(lookAtPos.x, lookAtPos.y, lookAtPos.z);
          }

          if (this.m_windowsEnvFlag) {
            this.m_fowardDis *= 0.95;
          } else {
            this.m_fowardDis = 0;
          }
        }
      } else if (this.m_flagType == 1) {
        // drag to slide
        this.m_camera.slideViewOffsetXY(-this.m_tempa.x * this.m_slideSpd, this.m_tempa.y * this.m_slideSpd);
      }
    }
  }

}

exports.default = CameraZoomController;

/***/ }),

/***/ "a567":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RGBColorUtil {
  /**
   * @param uintRGB24, uint 24bit rgb color, example: 0xff003a
   */
  static uint24RGBToCSSHeXRGBColor(uintRGB24) {
    let str = Math.round(uintRGB24).toString(16);

    if (str.length > 6) {
      str = str.slice(-6);
    } else if (str.length < 6) {
      let len = 6 - str.length;
      const s0 = "000000";
      str = s0.slice(0, len) + str;
    }

    return "#" + str;
  }

}

exports.RGBColorUtil = RGBColorUtil;

/***/ }),

/***/ "a5ba":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderConst_1 = __webpack_require__("e08e");

class RenderStateObject {
  constructor(cullFaceMode, blendMode, depthTestMode) {
    this.m_uid = -1;
    this.m_cullFaceMode = 0; // blend mode

    this.m_blendMode = 0; // depth test type mode

    this.m_depthTestMode = 0; // shadow status Mode(receive | make | receive and make | none)

    this.m_shadowMode = 0;
    this.m_uid = RenderStateObject.s_uid++;
    this.m_cullFaceMode = cullFaceMode;
    this.m_blendMode = blendMode;
    this.m_depthTestMode = depthTestMode;
  }

  getUid() {
    return this.m_uid;
  }

  getCullFaceMode() {
    return this.m_cullFaceMode;
  }

  getDepthTestMode() {
    return this.m_depthTestMode;
  }

  getBlendMode() {
    return this.m_blendMode;
  }

  use() {
    if (RenderStateObject.s_state != this.m_uid) {
      //console.log("RenderStateObject this.m_uid: ",this.m_uid);
      RenderStateObject.Rstate.setCullFaceMode(this.m_cullFaceMode); //RenderStateObject.Rstate.setBlendMode(this.m_blendMode);

      let list = RenderStateObject.s_blendModes[RenderStateObject.m_blendMode];

      if (RenderStateObject.m_blendMode < 0) {
        RenderStateObject.Rstate.setBlendMode(this.m_blendMode, RenderStateObject.s_blendModes[this.m_blendMode]);
      } else {
        RenderStateObject.Rstate.setBlendMode(RenderStateObject.m_blendMode, RenderStateObject.s_blendModes[RenderStateObject.m_blendMode]);
      }

      if (RenderStateObject.s_depthTestMode < 0) {
        RenderStateObject.Rstate.setDepthTestMode(this.m_depthTestMode);
      } else {
        RenderStateObject.Rstate.setDepthTestMode(RenderStateObject.s_depthTestMode);
      } //


      RenderStateObject.s_state = this.m_uid;
    }
  }

  static CreateBlendModeSeparate(name, srcRGB, dstRGB, srcAlpha, dstAlpha, equationRGB = 0, equationAlpha = 0) {
    if (name != null && name != "") {
      let b;

      if (RenderStateObject.s_blendModeNameMap.has(name)) {
        b = RenderStateObject.s_blendModeNameMap.get(name);
        return RenderStateObject.s_blendModeIndexMap.get(b);
      }

      if (equationRGB < 1) {
        equationRGB = RenderConst_1.GLBlendEquation.FUNC_ADD;
      }

      if (equationAlpha < 1) {
        equationAlpha = RenderConst_1.GLBlendEquation.FUNC_ADD;
      }

      let type = 1;
      b = 31;
      b = b * 131 + srcRGB;
      b = b * 131 + dstRGB;

      if (srcAlpha > 0 && dstAlpha > 0) {
        b = b * 131 + srcAlpha;
        b = b * 131 + dstAlpha;
        type = 1;
      }

      if (RenderStateObject.s_blendModeIndexMap.has(b)) {
        console.warn("This blendmode value already exists, its name is " + name + ".");
        RenderStateObject.s_blendModeNameMap.set(name, b);
        return RenderStateObject.s_blendModeIndexMap.get(b);
      }

      let index = ++RenderStateObject.s_blendModeIndex;
      RenderStateObject.s_blendModeNameMap.set(name, b);
      RenderStateObject.s_blendModeIndexMap.set(b, index);
      let list = [type, equationRGB, equationAlpha, srcRGB, dstRGB, srcAlpha, dstAlpha];
      RenderStateObject.s_blendModes[index] = list;
      return index;
    }

    return 0;
  }

  static CreateBlendMode(name, srcColor, dstColor, blendEquation = 0) {
    if (name != null && name != "") {
      let b;

      if (RenderStateObject.s_blendModeNameMap.has(name)) {
        b = RenderStateObject.s_blendModeNameMap.get(name);
        return RenderStateObject.s_blendModeIndexMap.get(b);
      }

      if (blendEquation < 1) {
        blendEquation = RenderConst_1.GLBlendEquation.FUNC_ADD;
      }

      let type = 0;
      b = 31;
      b = b * 131 + srcColor;
      b = b * 131 + dstColor;

      if (RenderStateObject.s_blendModeIndexMap.has(b)) {
        return RenderStateObject.s_blendModeIndexMap.get(b);
      }

      let index = ++RenderStateObject.s_blendModeIndex;
      RenderStateObject.s_blendModeNameMap.set(name, b);
      RenderStateObject.s_blendModeIndexMap.set(b, index);
      let list = [type, blendEquation, 0, srcColor, dstColor, 0, 0]; //console.log("list: ",list);

      RenderStateObject.s_blendModes[index] = list;
      return index;
    }

    return 0;
  }

  static Create(objName, cullFaceMode, blendMode, depthTestMode) {
    if (RenderStateObject.s_stsNameMap.has(objName)) {
      let po = RenderStateObject.s_stsNameMap.get(objName);
      return po.getUid();
    } //let key: number = depthTestMode << 8 | blendMode << 4 | cullFaceMode;


    let key = 31;
    key = key * 131 + depthTestMode;
    key = key * 131 + blendMode;
    key = key * 131 + cullFaceMode;

    if (RenderStateObject.s_stsMap.has(key)) {
      let po = RenderStateObject.s_stsMap.get(key);
      key = po.getUid();
    } else {
      let po = new RenderStateObject(cullFaceMode, blendMode, depthTestMode);
      key = po.getUid();
      RenderStateObject.s_stsMap.set(key, po);
      RenderStateObject.s_stsNameMap.set(objName, po);
      RenderStateObject.s_states.push(po);
      ++RenderStateObject.s_statesLen;
    }

    return key;
  }

  static GetRenderStateByName(objName) {
    if (RenderStateObject.s_stsNameMap.has(objName)) {
      let po = RenderStateObject.s_stsNameMap.get(objName);
      return po.getUid();
    }

    return -1;
  } // @param           state come from RODisp::renderState


  static UseRenderState(state) {
    //if(RenderStateObject.s_unlocked && RenderStateObject.Rstate.roState != state)                
    if (RenderStateObject.s_unlocked && RenderStateObject.s_state != state) {
      if (state > -1 && state < RenderStateObject.s_statesLen) {
        RenderStateObject.s_states[state].use();
      }
    }
  }

  static UseRenderStateByName(stateName) {
    if (RenderStateObject.s_unlocked) {
      let state = RenderStateObject.GetRenderStateByName(stateName); //trace("state: "+state+", stateName: "+stateName);
      //if(RenderStateObject.Rstate.roState != state)

      if (RenderStateObject.s_state != state) {
        if (state > -1 && state < RenderStateObject.s_statesLen) {
          RenderStateObject.s_states[state].use();
        }
      }
    }
  }

  static UnlockBlendMode() {
    RenderStateObject.m_blendMode = RenderStateObject.s_preBlendMode;
  }

  static LockBlendMode(blendMode) {
    RenderStateObject.s_preBlendMode = RenderStateObject.m_blendMode;
    RenderStateObject.m_blendMode = blendMode;
  }

  static UnlockDepthTestMode() {
    RenderStateObject.s_depthTestMode = RenderStateObject.s_preDepthTestMode;
  }

  static LockDepthTestMode(depthTestMode) {
    RenderStateObject.s_preDepthTestMode = RenderStateObject.s_depthTestMode;
    RenderStateObject.s_depthTestMode = depthTestMode;
  }

  static Lock() {
    RenderStateObject.s_unlocked = false;
  }

  static Unlock() {
    RenderStateObject.s_unlocked = true;
  }

  static Reset() {
    RenderStateObject.s_state = -1;
  }

}

RenderStateObject.s_uid = 0;
RenderStateObject.s_state = -1;
RenderStateObject.s_states = [];
RenderStateObject.s_statesLen = 1;
RenderStateObject.m_blendMode = -1;
RenderStateObject.s_depthTestMode = -1;
RenderStateObject.s_stsMap = new Map();
RenderStateObject.s_stsNameMap = new Map();
RenderStateObject.s_blendModeNameMap = new Map();
RenderStateObject.s_blendModeIndexMap = new Map();
RenderStateObject.s_blendModeIndex = 0;
RenderStateObject.s_blendModes = new Array(256);
RenderStateObject.s_unlocked = true;
RenderStateObject.Rstate = null;
RenderStateObject.s_preBlendMode = -1;
RenderStateObject.s_preDepthTestMode = -1;
exports.RenderStateObject = RenderStateObject;

/***/ }),

/***/ "a7ed":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class FrustumUniformBuilder {
  create(rc, shdp) {
    let param = UniformConst_1.default.FrustumParam;
    if (shdp.hasUniformByName(param.name)) return rc.uniformContext.createShaderGlobalUniformFromProbe(rc.getCamera().ufrustumProbe, param.name, [param.name]);
    return null;
  }

  getIDNS() {
    return "FrustumUniformBuilder";
  }

}

exports.default = FrustumUniformBuilder;

/***/ }),

/***/ "a80a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class Entity3DNodeLinker {
  constructor() {
    this.m_begin = null;
    this.m_end = null;
  }

  destroy() {
    this.clear();
  }

  clear() {
    this.m_begin = this.m_end = null;
  }

  getBegin() {
    return this.m_begin;
  }

  isEmpty() {
    return this.m_begin == this.m_end && this.m_end == null;
  }

  addNode(node) {
    if (this.m_begin == null) {
      this.m_end = this.m_begin = node;
    } else {
      if (this.m_end.prev != null) {
        this.m_end.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      } else {
        this.m_begin.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      }
    }

    this.m_end.next = null;
  }

  removeNode(node) {
    if (node == this.m_begin) {
      if (node == this.m_end) {
        this.m_begin = this.m_end = null;
      } else {
        this.m_begin = node.next;
        this.m_begin.prev = null;
      }
    } else if (node == this.m_end) {
      this.m_end = node.prev;
      this.m_end.next = null;
    } else {
      node.next.prev = node.prev;
      node.prev.next = node.next;
    }

    node.prev = null;
    node.next = null;
  }

}

exports.default = Entity3DNodeLinker;

/***/ }),

/***/ "a996":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventBase {
  constructor() {
    this.uuid = ""; // phase is event flow phase: 0(none phase),1(capture phase),2(bubble phase)

    this.phase = 0; // 事件类型

    this.type = EventBase.RESIZE; // 元事件发送者

    this.target = null; // 逻辑事件产生者, 例如容器发送了一个mouse down事件, 则容器是target而ray pick到的这个 entity就是currentTarget

    this.currentTarget = null;
    this.data = null;
    this.__$preventBoo = false;
  } //classType:number = 1001;


  getClassType() {
    return EventBase.EventClassType;
  }

  preventDefault() {
    this.__$preventBoo = true;
  }

  reset() {
    this.__$preventBoo = false;
  }

  toString() {
    return "[EventBase]";
  }

}

EventBase.EventClassType = 1001;
EventBase.RESIZE = 3001;
EventBase.ENTER_FRAME = 3002;
exports.default = EventBase;

/***/ }),

/***/ "a9f4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ShadowMode;

(function (ShadowMode) {
  /**
   * default shadow mode
   */
  ShadowMode[ShadowMode["Default"] = 1] = "Default";
  /**
   * vsm shadow mode
   */

  ShadowMode[ShadowMode["VSM"] = 1] = "VSM";
})(ShadowMode || (ShadowMode = {}));

exports.ShadowMode = ShadowMode;

/***/ }),

/***/ "ab73":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class ShadowVSMParams {
  constructor() {
    this.type = "vec4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_vsmParams";
    /**
     * uniform array length
     */

    this.arrayLength = 3;
  }

}

class EnvLightParam {
  constructor() {
    this.type = "vec4";
    this.data = new Float32Array([0.1, 0.1, 0.1, 1.0, 1.0, 0.1, 600.0, 3500.0, 0.3, 0.0, 0.9, 0.0005, 0.0, 0.0, 800.0, 800.0, -500.0, -500.0, 1000.0, 1000.0 // env ambient area width, height
    ]);
    /**
     * uniform name string
     */

    this.name = "u_envLightParams";
    /**
     * uniform array length
     */

    this.arrayLength = 5;
  }

}
/**
 * shadow view matatrix4 float32array data
 */


class ShadowMat4UniformParam {
  constructor() {
    this.type = "mat4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_shadowMat";
    /**
     * uniform array length
     */

    this.arrayLength = 0;
  }

}
/**
 * stage param shader uniform name string, vec4: [2.0/stageWidth,2.0/stageHeight, stageWidth,stageHeight]
 */


class StageUniformParam {
  constructor() {
    this.type = "vec4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_stageParam";
    /**
     * uniform array length
     */

    this.arrayLength = 0;
  }

}
/**
 * view port param shader uniform name string, vec4: [viewPortX, viewPortY, viewPortWidth, viewPortHeight]
 */


class ViewUniformParam {
  constructor() {
    this.type = "vec4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_viewParam";
    /**
     * uniform array length
     */

    this.arrayLength = 0;
  }

}
/**
 * camera frustrum param shader uniform name string,vec4: [camera zNear,camera zFar, camera nearPlaneHalfW, camera nearPlaneHalfH]
 */


class FrustumUniformParam {
  constructor() {
    this.type = "vec4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_frustumParam";
    /**
     * uniform array length
     */

    this.arrayLength = 0;
  }

}
/**
 * camera world position param shader uniform name string,vec4: [x, y, z, w]
 */


class CameraPosUniformParam {
  constructor() {
    this.type = "vec4";
    this.data = null;
    /**
     * uniform name string
     */

    this.name = "u_cameraPosition";
    /**
     * uniform array length
     */

    this.arrayLength = 0;
  }

}

class GlobalLightUniform {
  constructor() {
    this.type = "vec4";
    this.positionName = "u_lightPositions";
    this.colorName = "u_lightColors";
  }

}

class UniformConst {}
/**
 * object local space to world space matrix shader uniform name string
 */


UniformConst.LocalTransformMatUNS = "u_objMat";
/**
 * camera view matrix shader uniform name string
 */

UniformConst.CameraViewMatUNS = "u_viewMat";
/**
 * camera projective matrix shader uniform name string
 */

UniformConst.CameraProjectiveMatUNS = "u_projMat";
/**
 * camera frustrum param shader uniform name string,vec4: [camera zNear,camera zFar, camera nearPlaneHalfW, camera nearPlaneHalfH]
 */

UniformConst.FrustumParam = new FrustumUniformParam();
/**
 * camera world position param shader uniform name string,vec4: [x, y, z, w]
 */

UniformConst.CameraPosParam = new CameraPosUniformParam();
/**
 * stage param shader uniform name string, vec4: [2.0/stageWidth,2.0/stageHeight, stageWidth,stageHeight]
 */

UniformConst.StageParam = new StageUniformParam();
/**
 * view port param shader uniform name string, vec4: [viewPortX, viewPortY, viewPortWidth, viewPortHeight]
 */

UniformConst.ViewportParam = new ViewUniformParam();
UniformConst.ShadowMatrix = new ShadowMat4UniformParam();
UniformConst.ShadowVSMParams = new ShadowVSMParams();
UniformConst.GlobalLight = new GlobalLightUniform();
UniformConst.EnvLightParams = new EnvLightParam();
exports.default = UniformConst;

/***/ }),

/***/ "abdb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class OrientationType {}

OrientationType.AXIS_ANGLE = 0;
OrientationType.QUATERNION = 1;
OrientationType.EULER_ANGLES = 2;
exports.default = OrientationType;

/***/ }),

/***/ "ac89":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EulerOrder_1 = __webpack_require__("cc7a");

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  static Slerp(qa, qb, qm, t) {
    console.warn('Quaternion::Slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
    return qm.slerpQuaternions(qa, qb, t);
  }

  static SlerpFlat(dst, src0, src1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0.x,
        y0 = src0.y,
        z0 = src0.z,
        w0 = src0.w;
    const x1 = src1.x,
          y1 = src1.y,
          z1 = src1.z,
          w1 = src1.w;

    if (t === 0) {
      dst.x = x0;
      dst.y = y0;
      dst.z = z0;
      dst.w = w0;
      return;
    }

    if (t === 1) {
      dst.x = x1;
      dst.y = y1;
      dst.z = z1;
      dst.w = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst.x = x0;
    dst.y = y0;
    dst.z = z0;
    dst.w = w0;
  } // static multiplyQuaternionsFlat( dst: Quaternion, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {
  // 	const x0 = src0[ srcOffset0 ];
  // 	const y0 = src0[ srcOffset0 + 1 ];
  // 	const z0 = src0[ srcOffset0 + 2 ];
  // 	const w0 = src0[ srcOffset0 + 3 ];
  // 	const x1 = src1[ srcOffset1 ];
  // 	const y1 = src1[ srcOffset1 + 1 ];
  // 	const z1 = src1[ srcOffset1 + 2 ];
  // 	const w1 = src1[ srcOffset1 + 3 ];
  // 	dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
  // 	dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
  // 	dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
  // 	dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
  // 	return dst;
  // }


  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }

  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }

  copy(q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
    return this;
  }

  setFromEuler(euler, update = true) {
    if (euler == null) {
      throw new Error('Quaternion::setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    const x = euler.x,
          y = euler.y,
          z = euler.z,
          order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case EulerOrder_1.EulerOrder.XYZ:
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case EulerOrder_1.EulerOrder.YXZ:
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case EulerOrder_1.EulerOrder.ZXY:
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case EulerOrder_1.EulerOrder.ZYX:
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case EulerOrder_1.EulerOrder.YZX:
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case EulerOrder_1.EulerOrder.XZY:
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('Quaternion::setFromEuler() encountered an unknown order: ' + order);
    }

    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(halfAngle);
    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.getLocalFS32(),
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this.w = 0.25 / s;
      this.x = (m32 - m23) * s;
      this.y = (m13 - m31) * s;
      this.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this.w = (m32 - m23) / s;
      this.x = 0.25 * s;
      this.y = (m12 + m21) / s;
      this.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this.w = (m13 - m31) / s;
      this.x = (m12 + m21) / s;
      this.y = 0.25 * s;
      this.z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this.w = (m21 - m12) / s;
      this.x = (m13 + m31) / s;
      this.y = (m23 + m32) / s;
      this.z = 0.25 * s;
    }

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this.x = -vFrom.y;
        this.y = vFrom.x;
        this.z = 0;
        this.w = r;
      } else {
        this.x = 0;
        this.y = -vFrom.z;
        this.z = vFrom.y;
        this.w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this.x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this.y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this.z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this.w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathConst_1.default.Clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  }

  dot(q) {
    return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;
      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }

    return this;
  }

  multiply(q, p) {
    if (p !== undefined) {
      console.warn('Quaternion::multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a.x,
          qay = a.y,
          qaz = a.z,
          qaw = a.w;
    const qbx = b.x,
          qby = b.y,
          qbz = b.z,
          qbw = b.w;
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this.x,
          y = this.y,
          z = this.z,
          w = this.w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

    if (cosHalfTheta < 0) {
      this.w = -qb.w;
      this.x = -qb.x;
      this.y = -qb.y;
      this.z = -qb.z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this.w = s * w + t * this.w;
      this.x = s * x + t * this.x;
      this.y = s * y + t * this.y;
      this.z = s * z + t * this.z;
      this.normalize();
      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this.w = w * ratioA + this.w * ratioB;
    this.x = x * ratioA + this.x * ratioB;
    this.y = y * ratioA + this.y * ratioB;
    this.z = z * ratioA + this.z * ratioB;
    return this;
  }

  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }

  random() {
    // Derived from http://planning.cs.uiuc.edu/node198.html
    // Note, this source uses w, x, y, z ordering,
    // so we swap the order below.
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }

  equals(quaternion) {
    return quaternion.x === this.x && quaternion.y === this.y && quaternion.z === this.z && quaternion.w === this.w;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }

  fromBufferAttribute(attribute, index = 0) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }

}

exports.Quaternion = Quaternion; // /**
//  * vox.math.Quaternion
//  * 
//  * 用于表示基本的四元数对象
//  * 
//  * @author Vily
//  */
// class Quaternion
// {
// 	w:number = 0.0;
// 	x:number = 0.0;
// 	y:number = 0.0;
// 	z:number = 0.0;
// 	private m_sin:number = 0.0;
// 	private m_cos:number = 0.0;
// 	private m_rad:number = 0.0;
// 	constructor(w:number = 0.0, x:number = 0.0, y:number = 0.0, z:number = 0.0)
// 	{
// 		this.w = w;
// 		this.x = x;
// 		this.y = y;
// 		this.z = z;
// 	}
// 	initState(w:number = 0, x:number = 0, y:number = 0, z:number = 0):void
// 	{
// 		this.w = w;
// 		this.x = x;
// 		this.y = y;
// 		this.z = z;
// 	}
// 	setAngRadAndNV(pang:number, nv:Vector3D):void
// 	{
// 		this.m_rad =  pang * MathConst.MATH_PI_OVER_180;
// 		this.m_cos = Math.cos(0.5 * this.m_rad);
// 		this.m_sin = Math.sin(0.5 * this.m_rad);			
// 		this.w = this.m_cos;
// 		this.x = nv.x * this.m_sin;
// 		this.y = nv.y * this.m_sin;
// 		this.z = nv.z * this.m_sin;
// 	}
// 	setRotRadAndNV(prad:number, nv:Vector3D):void
// 	{
// 		this.m_rad = prad;
// 		this.m_cos = Math.cos(0.5 * this.m_rad);
// 		this.m_sin = Math.sin(0.5 * this.m_rad);
// 		this.w = this.m_cos;
// 		this.x = nv.x * this.m_sin;
// 		this.y = nv.y * this.m_sin;
// 		this.z = nv.z * this.m_sin;
// 	}		
// 	setRad(r:number):void
// 	{
// 		this.m_rad = r;
// 		this.m_cos = Math.cos(0.5 * this.m_rad);
// 		this.m_sin = Math.sin(0.5 * this.m_rad);
// 	}
// 	getRad():number
// 	{
// 		return this.m_rad;
// 	}
// 	updateRot():void
// 	{
// 		this.w = this.m_cos;
// 		this.x *= this.m_sin;
// 		this.y *= this.m_sin;
// 		this.z *= this.m_sin;
// 	}
// 	setXYZ(px:number, py:number, pz:number):void
// 	{
// 		this.x = px;
// 		this.y = py;
// 		this.z = pz;
// 	}
// 	add(q:Quaternion):void
// 	{
// 		this.w += q.w;
// 		this.x += q.x;
// 		this.y += q.y;
// 		this.z += q.z;
// 	}
// 	sub(q:Quaternion):void
// 	{
// 		this.w -= q.w;
// 		this.x -= q.x;
// 		this.y -= q.y;
// 		this.z -= q.z;
// 	}
// 	scale(s:number):void
// 	{
// 		this.w *= s;
// 		this.x *= s;
// 		this.y *= s;
// 		this.z *= s;
// 	}		
// 	mulToThis(q1:Quaternion, q2:Quaternion):void
// 	{
// 		let pw:number = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
// 		let px:number = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
// 		let py:number = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;
// 		let pz:number = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;
// 		this.w = pw;
// 		this.x = px;
// 		this.y = py;
// 		this.z = pz;
// 	}		
// 	mul(q:Quaternion):void
// 	{
// 		let pw:number = this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z;
// 		let px:number = this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y;
// 		let py:number = this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x;
// 		let pz:number = this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w;
// 		this.w = pw;
// 		this.x = px;
// 		this.y = py;
// 		this.z = pz;
// 	}
// 	mulNew(q2:Quaternion):Quaternion
// 	{
// 		let q:Quaternion = new Quaternion();
// 		q.w = this.w * q2.w - this.x * q2.x - this.y * q2.y - this.z * q2.z;
// 		q.x = this.w * q2.x + this.x * q2.w + this.y * q2.z - this.z * q2.y;
// 		q.y = this.w * q2.y - this.x * q2.z + this.y * q2.w + this.z * q2.x;
// 		q.z = this.w * q2.z + this.x * q2.y - this.y * q2.x + this.z * q2.w;
// 		return q;
// 	}
// 	/**
// 	 * 四元数乘以3D矢量 Vector3D,实现四元数对一个顶点的旋转
// 	 * @param				q		一个四元数对象
// 	 * @param				v		一个 3D矢量 Vector3D
// 	 * @param				outV	计算结果存放于一个 Vector3D 中
// 	 * */
// 	static quatMulV3(q:Quaternion, v:Vector3D, outV:Vector3D ):void
// 	{
// 		let xx:number = q.x * q.x;
// 		let yy:number = q.y * q.y;
// 		let zz:number = q.z * q.z;
// 		let xy:number = q.x * q.y;
// 		let yz:number = q.y * q.z;
// 		let xz:number = q.x * q.z;
// 		let sx:number = q.w * q.x;
// 		let sy:number = q.w * q.y;
// 		let sz:number = q.w * q.z;
// 		let tx:number = v.x * (0.5 - yy - zz) + v.y * (xy - sz) + v.z * (xz + sy);
// 		let ty:number = v.x * (xy + sz) + v.y * (0.5 - xx - zz) + v.z * (yz - sx);
// 		let tz:number = v.x * (xz - sy) + v.y * (yz + sx) + v.z * (0.5 - xx - yy);
// 		outV.x = tx * 2.0;
// 		outV.y = ty * 2.0;
// 		outV.z = tz * 2.0;
// 	}
// 	rotate(q:Quaternion, v:Vector3D):void
// 	{
// 		let pw:number = -q.x * v.x - q.y * v.y - q.z * v.z;
// 		let px:number = q.w * v.x + q.y * v.z - q.z * v.y;
// 		let py:number = q.w * v.y - q.x * v.z + q.z * v.x;
// 		let pz:number = q.w * v.z + q.x * v.y - q.y * v.x;
// 		this.w = q.w + pw * 0.5;
// 		this.x = q.x + px * 0.5;
// 		this.y = q.y + py * 0.5;
// 		this.z = q.z + pz * 0.5;
// 	}
// 	normalizeFrom(q:Quaternion):void
// 	{
// 		let len:number = Math.sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
// 		if (len > MathConst.MATH_MIN_POSITIVE) len = 1.0 / len;
// 		this.w = q.w * len;
// 		this.x = q.x * len;
// 		this.y = q.y * len;
// 		this.z = q.z * len;
// 	}
// 	normalize():void
// 	{
// 		let len:number = Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
// 		if (len > MathConst.MATH_MIN_POSITIVE) len = 1 / len;
// 		this.w *= len;
// 		this.x *= len;
// 		this.y *= len;
// 		this.z *= len;
// 	}
// 	/*
// 	// 取反
// 	negate():void
// 	{
// 		w *= -1;
// 		x *= -1;
// 		y *= -1;
// 		z *= -1;
// 	}
// 	*/
// 	/**
// 	 * 得到当前 四元数的 逆
// 	 * */
// 	invert():void
// 	{
// 		this.adjoint();
// 		this.normalize();
// 	}
// 	/**
// 	 * 共轭
// 	 * */
// 	adjoint():void
// 	{
// 		this.x *= -1.0;
// 		this.y *= -1.0;
// 		this.z *= -1.0;
// 	}
// 	/**
// 	 * 共轭
// 	 * */
// 	adjointNew():Quaternion
// 	{			
// 		return new Quaternion(this.w,-1 * this.x, -1 * this.y,-1 * this.z);
// 	}
// 	getLength():number
// 	{
// 		return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
// 	}
// 	copyFrom(q:Quaternion):void
// 	{
// 		this.w = q.w;
// 		this.x = q.x;
// 		this.y = q.y;
// 		this.z = q.z;
// 	}
// 	clone():Quaternion
// 	{
// 		return new Quaternion(this.w, this.x, this.y, this.z);
// 	}
// 	toString():String
// 	{
// 		return "Quaternion(" + this.w + ", " + this.x + ", " + this.y+ ", " + this.z + ")";
// 	}
// }

/***/ }),

/***/ "acaa":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RTTTextureProxy_1 = __importDefault(__webpack_require__("cfaf"));

class DepthTextureProxy extends RTTTextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.srcFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.internalFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT;
    this.m_generateMipmap = false;
    this.m_haveRData = true;
    this.mipmapEnabled = false;
    this.m_type = TextureProxyType_1.TextureProxyType.Depth;
  }

  toDepthUnsignedInt() {
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.srcFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.internalFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.dataType = TextureDataType_1.default.UNSIGNED_INT;
    this.m_generateMipmap = false;
    this.m_haveRData = true;
    this.mipmapEnabled = false;
  }

  toDepthUnsignedShort() {
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.srcFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.internalFormat = TextureFormat_1.default.DEPTH_COMPONENT;
    this.dataType = TextureDataType_1.default.UNSIGNED_SHORT;
    this.m_generateMipmap = false;
    this.m_haveRData = true;
    this.mipmapEnabled = false;
  }

  toDepthAndStencil() {
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.srcFormat = TextureFormat_1.default.DEPTH_STENCIL;
    this.internalFormat = TextureFormat_1.default.DEPTH_STENCIL;
    this.dataType = TextureDataType_1.default.UNSIGNED_INT_24_8_WEBGL;
    this.m_generateMipmap = false;
    this.mipmapEnabled = false;
    this.m_haveRData = true;
  }

  uploadData(texRes) {
    console.log("DepthTextureProxy uploadData()...");
    let gl = texRes.getRC();
    gl.texImage2D(this.m_sampler, 0, TextureFormat_1.default.ToGL(gl, this.internalFormat), this.m_texWidth, this.m_texHeight, 0, TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), null);
  }

  toString() {
    return "[DepthTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = DepthTextureProxy;

/***/ }),

/***/ "acfe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const BitConst_1 = __importDefault(__webpack_require__("ca6c"));

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const GLSLConverter_1 = __importDefault(__webpack_require__("81ce"));

const ShaderCodeParser_1 = __importDefault(__webpack_require__("fc07"));

class ShaderData {
  constructor() {
    this.m_uid = -1;
    this.adaptationShaderVersion = true;
    this.preCompileInfo = null;
    this.m_vshdCode = "";
    this.m_fshdCode = "";
    this.m_shdUniqueName = "";
    this.m_texTotal = 0;
    this.m_uniforms = null; // identify use texture

    this.m_useTex = false; // web gl 1.0, attribute namestring list

    this.m_attriNSList = null;
    this.m_attriSizeList = null;
    this.m_aLocationTypes = null;
    this.m_uniformDict = new Map();
    this.m_layoutTypes = null;
    this.m_haveCommonUniform = false;
    this.m_layoutBit = 0x0;
    this.m_mid = 0x0;
    this.m_fragOutputTotal = 1;
    this.m_texUniformNames = null; // recode shader uniform including status

    this.dataUniformEnabled = false;
    this.m_uid = ShaderData.s_uid++;
  }

  getVSCodeStr() {
    return this.m_vshdCode;
  }

  getFSCodeStr() {
    return this.m_fshdCode;
  }

  getLocationTypes() {
    return this.m_layoutTypes;
  }

  getLayoutBit() {
    return this.m_layoutBit;
  }

  getMid() {
    return this.m_mid;
  }

  getFragOutputTotal() {
    return this.m_fragOutputTotal;
  }

  parseCode(vshdsrc, fshdSrc) {
    ShaderData.s_codeParser.reset();
    ShaderData.s_codeParser.parseVShaderCode(vshdsrc);
    ShaderData.s_codeParser.parseFShaderCode(fshdSrc);
    this.m_fragOutputTotal = ShaderData.s_codeParser.fragOutputTotal;
    this.m_uniforms = ShaderData.s_codeParser.uniforms;
  }

  initialize(unique_ns, vshdsrc, fshdSrc) {
    this.m_shdUniqueName = unique_ns;

    if (this.adaptationShaderVersion && this.preCompileInfo == null) {
      if (RendererDevice_1.default.IsWebGL1()) {
        vshdsrc = GLSLConverter_1.default.Es3VtxShaderToES2(vshdsrc);
        fshdSrc = GLSLConverter_1.default.Es3FragShaderToES2(fshdSrc);
      }
    } // 直接使用 preCompileInfo 中的 uniform / attribute 等等关键信息


    if (this.preCompileInfo != null) {}

    this.parseCode(vshdsrc, fshdSrc);
    let pattributes = ShaderData.s_codeParser.attributes;
    let i = 0;
    let len = pattributes.length;
    let attri = null;
    this.m_attriNSList = [];
    this.m_attriSizeList = [];
    this.m_layoutBit = 0x0;
    let locationsTotal = 0;
    let layoutTypes = this.m_layoutTypes = [];

    while (i < len) {
      attri = pattributes[i];

      if (attri != null) {
        this.m_attriNSList.push(attri.name);
        this.m_attriSizeList.push(attri.typeSize);
        locationsTotal += 1;
        let vbufType = VtxBufConst_1.default.GetVBufTypeByNS(attri.name);

        switch (vbufType) {
          case VtxBufConst_1.default.VBUF_VS:
            //mid += mid * 131 + 1;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_0;
            break;

          case VtxBufConst_1.default.VBUF_UVS:
            //mid += mid * 131 + 2;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_1;
            break;

          case VtxBufConst_1.default.VBUF_NVS:
            //mid += mid * 131 + 3;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_2;
            break;

          case VtxBufConst_1.default.VBUF_CVS:
            //mid += mid * 131 + 4;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_3;
            break;

          case VtxBufConst_1.default.VBUF_TVS:
            //mid += mid * 131 + 5;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_4;
            break;

          case VtxBufConst_1.default.VBUF_VS2:
            //mid += mid * 131 + 6;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_5;
            break;

          case VtxBufConst_1.default.VBUF_UVS2:
            //mid += mid * 131 + 7;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_6;
            break;

          case VtxBufConst_1.default.VBUF_NVS2:
            //mid += mid * 131 + 8;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_7;
            break;

          case VtxBufConst_1.default.VBUF_CVS2:
            //mid += mid * 131 + 9;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_8;
            break;

          case VtxBufConst_1.default.VBUF_TVS2:
            //mid += mid * 131 + 11;
            this.m_layoutBit |= BitConst_1.default.BIT_ONE_9;
            break;

          default:
            locationsTotal -= 1;
            vbufType = 0;
            break;
        }

        if (vbufType > 0) {
          layoutTypes.push(VtxBufConst_1.default.GetVBufAttributeTypeByVBufType(vbufType));
        }
      }

      ++i;
    }

    let mid = (locationsTotal << 11) + this.m_layoutBit;

    if (!ShaderData.s_midMap.has(mid)) {
      ShaderData.s_midMap.set(mid, ShaderData.s_mid);
      ShaderData.s_mid++;
    }

    this.m_mid = ShaderData.s_midMap.get(mid); // console.log("shader data, this.m_mid: ",this.m_mid, "locationsTotal: ",locationsTotal);

    this.m_texTotal = ShaderData.s_codeParser.texTotal;
    this.m_useTex = this.m_texTotal > 0;

    if (this.m_useTex) {
      this.m_texUniformNames = ShaderData.s_codeParser.texUniformNameListStr.split(",");
    }

    this.m_haveCommonUniform = this.m_texTotal < this.m_uniforms.length;
    this.m_vshdCode = vshdsrc;
    this.m_fshdCode = fshdSrc;
    this.m_shdUniqueName = unique_ns;
  }

  getAttriSizeList() {
    return this.m_attriSizeList;
  }

  getTexUniformNames() {
    return this.m_texUniformNames;
  }

  getUniforms() {
    return this.m_uniforms;
  }

  haveCommonUniform() {
    return this.m_haveCommonUniform;
  }

  getAttriNSList() {
    return this.m_attriNSList;
  }

  getUid() {
    return this.m_uid;
  }

  getTexTotal() {
    return this.m_texTotal;
  } // use texture true or false


  haveTexture() {
    return this.m_useTex;
  }

  getLocationsTotal() {
    return this.m_aLocationTypes.length;
  }

  getUniformTypeNameByNS(ns) {
    let uniform = this.m_uniformDict.get(ns);

    if (uniform != null) {
      return uniform.typeName;
    }

    return "";
  }

  getUniformTypeByNS(ns) {
    let uniform = this.m_uniformDict.get(ns);

    if (uniform != null) {
      return uniform.type;
    }

    return 0;
  }

  hasUniformByName(ns) {
    return this.m_uniformDict.has(ns);
  }

  getUniformLengthByNS(ns) {
    if (this.m_uniformDict.has(ns)) {
      this.m_uniformDict.get(ns).arrLength;
    }

    return 0;
  }

  getUniqueShaderName() {
    return this.m_shdUniqueName;
  }

  destroy() {
    this.m_texTotal = 0;
  }

}

ShaderData.s_uid = 0;
ShaderData.s_codeParser = new ShaderCodeParser_1.default();
ShaderData.s_midMap = new Map();
ShaderData.s_mid = 1;
exports.default = ShaderData;

/***/ }),

/***/ "aeff":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

exports.DataFormat = DataUnit_1.DataFormat;
exports.DataUnitLock = DataUnit_1.DataUnitLock;
exports.DataUnit = DataUnit_1.DataUnit;

const GeometryModelDataType_1 = __webpack_require__("58fc");

exports.GeometryModelDataType = GeometryModelDataType_1.GeometryModelDataType;

class GeometryDataContainer {
  constructor() {
    this.dataFormat = DataUnit_1.DataFormat.CTM;
    /**
     * 存放所有的model
     */

    this.models = null;
    /**
     * 存放所有的transform
     */

    this.transforms = null;
    /**
     * 每一次新的model的加入都会调用此函数
     */

    this.modelReceiver = null;
  }

  setFormatBUrl(url) {// if(url != "") {
    //   let k = url.lastIndexOf(".");
    //   if(k <= 0) {
    //     throw Error("illegal geometry data url: "+url);
    //   }
    //   switch(url.slice(k+1)) {
    //     case DataFormat.CTM:
    //       this.dataFormat = DataFormat.CTM;
    //       break;
    //     case DataFormat.Draco:
    //       this.dataFormat = DataFormat.Draco;
    //       break;
    //     default:
    //       throw Error("illegal geometry data url: "+url);
    //       break;
    //   }
    // }
  }

  destroy() {
    // this.model = null;
    this.modelReceiver = null;
    this.models = null;
  }

}

exports.GeometryDataContainer = GeometryDataContainer;

class GeometryDataUnit extends DataUnit_1.DataUnit {
  constructor() {
    super();
    this.data = null;
    this.dataClass = DataUnit_1.DataClass.Geometry;
  }

}

exports.GeometryDataUnit = GeometryDataUnit;

/***/ }),

/***/ "af29":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderFilter_1 = __importDefault(__webpack_require__("722e"));

const RenderMaskBitfield_1 = __importDefault(__webpack_require__("8333"));

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const Color4_1 = __importDefault(__webpack_require__("3930"));

const FrameBufferType_1 = __importDefault(__webpack_require__("baae"));

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

class FBOInstance {
  constructor(renderer, texStroe) {
    this.m_backBufferColor = new Color4_1.default();
    this.m_adapter = null;
    this.m_renderProxy = null;
    this.m_rcontext = null;
    this.m_bgColor = new Color4_1.default();
    this.m_renderer = null;
    this.m_runFlag = true;
    this.m_fboIndex = -1;
    this.m_fboType = -1;
    this.m_initW = 128;
    this.m_initH = 128;
    this.m_enableDepth = true;
    this.m_enableStencil = false;
    this.m_multisampleLevel = 0;
    this.m_gMateiral = null;
    this.m_gRState = -1;
    this.m_gRColorMask = -1;
    this.m_rindexs = [];
    this.m_texs = [null, null, null, null, null, null, null, null];
    this.m_texStore = null;
    this.m_texsTot = 0;
    this.m_synFBOSizeWithViewport = true;
    this.m_fboSizeFactor = 1.0;
    this.m_clearDepth = 256.0;
    this.m_clearColorBoo = true;
    this.m_clearDepthBoo = true;
    this.m_clearStencilBoo = false;
    this.m_viewportLock = false;
    this.m_texUnlock = false;
    this.m_tmaterialUniformUpdate = false;
    /**
     * unique name string
     */

    this.uns = "FBOInstance";
    this.m_renderer = renderer;
    this.m_texStore = texStroe;
    this.m_renderProxy = renderer.getRenderProxy();
    this.m_adapter = this.m_renderProxy.getRenderAdapter();
    this.m_rcontext = renderer.getRendererContext();
  }
  /**
   * @returns 获取当前FBOInstance所持有的 FBO 对象的 unique id (也就是序号)
   */


  getFBOUid() {
    return this.m_fboIndex;
  }
  /**
   * 设置当前 FBO控制的渲染过程中所需要的 renderer process 序号(id)列表
   */


  setRProcessIDList(processIDlist) {
    if (processIDlist != null) {
      if (processIDlist.length < 1) {
        throw Error("processIDlist.length < 1, but it must: processIDlist.length >= 1");
      }

      this.m_rindexs = processIDlist.slice(0);
    }
  }
  /**
   * 设置当前 FBO控制的渲染过程中所需要的 renderer process 序号(id)列表
   */


  setRProcessList(list) {
    if (list.length < 1) {
      throw Error("list.length < 1, but must: list.length >= 1");
    }

    this.m_rindexs = new Array(list.length);

    for (let i = 0; i < list.length; ++i) {
      this.m_rindexs[i] = list[i].getRPIndex();
    }
  }

  getRProcessIDAt(i) {
    return this.m_rindexs[i];
  }

  getStage3D() {
    return this.m_renderProxy.getStage3D();
  }

  getCamera() {
    if (this.m_renderProxy != null) {
      return this.m_renderProxy.getCamera();
    }

    return null;
  }

  lockViewport() {
    this.m_viewportLock = true;
  }

  unlockViewport() {
    this.m_viewportLock = false;
  }

  updateCamera() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCamera();
    }
  }

  updateCameraDataFromCamera(cam) {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCameraDataFromCamera(cam);
    }
  } ////////////////////////////////////////////////////// render state conctrl


  useGlobalRenderState(state) {
    this.m_rcontext.useGlobalRenderState(state);
  }

  useGlobalRenderStateByName(stateNS) {
    this.m_rcontext.useGlobalRenderStateByName(stateNS);
  }

  setGlobalRenderState(state) {
    this.m_gRState = state;
  }

  setGlobalRenderStateByName(stateNS) {
    this.m_gRState = this.m_rcontext.getRenderStateByName(stateNS);
  }

  lockRenderState(state = -1) {
    if (this.m_gRState >= 0 || state >= 0) {
      this.m_rcontext.useGlobalRenderState(state < 0 ? this.m_gRState : state);
    } else {
      this.m_renderProxy.lockRenderState();
    }
  }

  unlockRenderState() {
    this.m_renderProxy.unlockRenderState();
  } ////////////////////////////////////////////////////// render color mask conctrl


  useGlobalRenderColorMask(colorMask) {
    this.m_rcontext.useGlobalRenderColorMask(colorMask);
  }

  useGlobalRenderColorMaskByName(colorMaskNS) {
    this.m_rcontext.useGlobalRenderColorMaskByName(colorMaskNS);
  }

  setGlobalRenderColorMask(colorMask) {
    this.m_gRColorMask = colorMask;
  }

  setGlobalRenderColorMaskByName(colorMaskNS) {
    this.m_gRColorMask = this.m_rcontext.getRenderColorMaskByName(colorMaskNS);
  }

  lockColorMask(colorMask = -1) {
    if (this.m_gRColorMask >= 0 || colorMask >= 0) {
      this.m_rcontext.useGlobalRenderColorMask(colorMask < 0 ? this.m_gRColorMask : colorMask);
    } else {
      this.m_renderProxy.lockRenderColorMask();
    }
  }

  unlockRenderColorMask() {
    this.m_rcontext.useGlobalRenderColorMask(RendererState_1.default.COLOR_MASK_ALL_TRUE);
    this.m_renderProxy.unlockRenderColorMask();
  } ////////////////////////////////////////////////////// material conctrl


  useGlobalMaterial(m, texUnlock = false, materialUniformUpdate = false) {
    this.m_texUnlock = texUnlock;
    this.m_tmaterialUniformUpdate = materialUniformUpdate;
    this.m_rcontext.useGlobalMaterial(m, this.m_texUnlock, materialUniformUpdate);
  }
  /**
   *
   * @param material MaterialBase 子类的实例
   * @param texUnlock 是否锁定并使用 material 自身所带的纹理数据
   */


  setGlobalMaterial(material, texUnlock = false, materialUniformUpdate = false) {
    this.m_texUnlock = texUnlock;
    this.m_tmaterialUniformUpdate = materialUniformUpdate;

    if (this.m_gMateiral != material) {
      if (this.m_gMateiral != null) {
        this.m_gMateiral.__$detachThis();
      }

      if (material != null) {
        material.__$attachThis();
      }

      this.m_gMateiral = material;
    }
  }

  lockMaterial() {
    if (this.m_gMateiral != null) {
      this.m_rcontext.useGlobalMaterial(this.m_gMateiral, this.m_texUnlock, this.m_tmaterialUniformUpdate);
    } else {
      this.m_rcontext.lockMaterial();
    }
  }

  unlockMaterial() {
    this.m_rcontext.unlockMaterial();
  }

  updateGlobalMaterialUniform() {
    this.m_rcontext.updateMaterialUniform(this.m_gMateiral);
  }

  clearDepth(clearDepth = 1.0) {
    this.m_adapter.clearFBODepthAt(this.m_fboIndex, clearDepth);
  }

  synFBOSizeWithViewport() {
    this.m_synFBOSizeWithViewport = true;
  }

  asynFBOSizeWithViewport() {
    this.m_synFBOSizeWithViewport = false;
  } // if synFBOSizeWithViewport is true, fbo size = factor * view port size;


  setFBOSizeFactorWithViewPort(factor) {
    this.m_fboSizeFactor = factor;
  }

  createViewportSizeFBOAt(fboIndex, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (this.m_fboIndex < 0) {
      this.m_fboIndex = fboIndex;
      this.m_fboType = FrameBufferType_1.default.FRAMEBUFFER;
      this.m_initW = this.m_adapter.getViewportWidth();
      this.m_initH = this.m_adapter.getViewportHeight();
      this.m_enableDepth = enableDepth;
      this.m_enableStencil = enableStencil;
      this.m_multisampleLevel = multisampleLevel;
      this.m_adapter.createFBOAt(fboIndex, this.m_fboType, this.m_initW, this.m_initH, enableDepth, enableStencil, multisampleLevel);
    }
  }

  createFBO(enableDepth, enableStencil, multisampleLevel = 0) {
    this.m_enableDepth = enableDepth;
    this.m_enableStencil = enableStencil;
    this.m_multisampleLevel = multisampleLevel;
    this.m_adapter.createFBOAt(this.m_fboIndex, this.m_fboType, this.m_initW, this.m_initH, enableDepth, enableStencil, multisampleLevel);
  }
  /**
   * 创建一个指定序号的 FBO(FrameBufferObject) 渲染运行时管理对象,
   * renderer中一个序号只会对应一个唯一的 FBO 对象实例
   * @param fboIndex FBO 对象的序号
   * @param enableDepth FBO 对象的depth读写是否开启
   * @param enableStencil FBO 对象的stencil读写是否开启
   * @param multisampleLevel FBO 对象的multisample level
   */


  createAutoSizeFBOAt(fboIndex, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (fboIndex >= 0 && this.m_fboIndex < 0) {
      this.m_fboType = FrameBufferType_1.default.FRAMEBUFFER;
      this.m_initW = 512;
      this.m_initH = 512;
      this.m_fboIndex = fboIndex;
      this.createFBO(enableDepth, enableStencil, multisampleLevel);
    }
  }
  /**
   * 创建一个指定序号的 FBO(FrameBufferObject) 渲染运行时管理对象,
   * renderer中一个序号只会对应一个唯一的 FBO 对象实例
   * @param fboIndex FBO 对象的序号
   * @param width FBO 对象的viewport width, if width < 1, viewport width is stage width;
   * @param height FBO 对象的viewport height, if height < 1, viewport width is stage height;
   * @param enableDepth FBO 对象的depth读写是否开启
   * @param enableStencil FBO 对象的stencil读写是否开启
   * @param multisampleLevel FBO 对象的multisample level
   */


  createFBOAt(fboIndex, width, height, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (fboIndex >= 0 && this.m_fboIndex < 0) {
      this.m_fboType = FrameBufferType_1.default.FRAMEBUFFER;
      this.m_initW = width;
      this.m_initH = height;
      this.m_fboIndex = fboIndex;
      if (this.m_initW < 1) this.m_initW = this.m_adapter.getRCanvasWidth();
      if (this.m_initH < 1) this.m_initH = this.m_adapter.getRCanvasHeight();
      this.createFBO(enableDepth, enableStencil, multisampleLevel);
    }
  }
  /**
   * 创建一个指定序号的 read FBO(FrameBufferObject) 渲染运行时管理对象,
   * renderer中一个序号只会对应一个唯一的 FBO 对象实例
   * @param fboIndex FBO 对象的序号
   * @param width FBO 对象的viewport width, if width < 1, viewport width is stage width;
   * @param height FBO 对象的viewport height, if height < 1, viewport width is stage height;
   * @param enableDepth FBO 对象的depth读写是否开启
   * @param enableStencil FBO 对象的stencil读写是否开启
   * @param multisampleLevel FBO 对象的multisample level
   */


  createReadFBOAt(fboIndex, width, height, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (fboIndex >= 0 && this.m_fboIndex < 0) {
      this.m_fboType = FrameBufferType_1.default.READ_FRAMEBUFFER;
      this.m_initW = width;
      this.m_initH = height;
      this.m_fboIndex = fboIndex;
      if (this.m_initW < 1) this.m_initW = this.m_adapter.getRCanvasWidth();
      if (this.m_initH < 1) this.m_initH = this.m_adapter.getRCanvasHeight();
      this.createFBO(enableDepth, enableStencil, multisampleLevel);
    }
  }
  /**
   * 创建一个指定序号的 draw FBO(FrameBufferObject) 渲染运行时管理对象,
   * renderer中一个序号只会对应一个唯一的 FBO 对象实例
   * @param fboIndex FBO 对象的序号
   * @param width FBO 对象的viewport width, if width < 1, viewport width is stage width;
   * @param height FBO 对象的viewport height, if height < 1, viewport width is stage height;
   * @param enableDepth FBO 对象的depth读写是否开启
   * @param enableStencil FBO 对象的stencil读写是否开启
   * @param multisampleLevel FBO 对象的multisample level
   */


  createDrawFBOAt(fboIndex, width, height, enableDepth = false, enableStencil = false, multisampleLevel = 0) {
    if (fboIndex >= 0 && this.m_fboIndex < 0) {
      this.m_fboType = FrameBufferType_1.default.DRAW_FRAMEBUFFER;
      this.m_initW = width;
      this.m_initH = height;
      this.m_fboIndex = fboIndex;
      if (this.m_initW < 1) this.m_initW = this.m_adapter.getRCanvasWidth();
      if (this.m_initH < 1) this.m_initH = this.m_adapter.getRCanvasHeight();
      this.createFBO(enableDepth, enableStencil, multisampleLevel);
    }
  }

  resizeFBO(fboBufferWidth, fboBufferHeight) {
    if (this.m_initW != fboBufferWidth || this.m_initH != fboBufferHeight) {
      this.m_initW = fboBufferWidth;
      this.m_initH = fboBufferHeight;
      this.m_adapter.resizeFBOAt(this.m_fboIndex, fboBufferWidth, fboBufferHeight);
    }
  }
  /**
   * @returns get framebuffer output attachment texture by attachment index
   */


  getRTTAt(i) {
    return this.m_texs[i];
  }

  enableMipmapRTTAt(i) {
    this.m_texs[i].enableMipmap();
  }

  generateMipmapTextureAt(i) {
    this.m_texs[i].generateMipmap(this.m_renderProxy.Texture);
  }
  /**
   * 设置渲染到纹理的目标纹理对象(可由用自行创建)和framebuffer output attachment index
   * @param rttTexProxy 作为渲染到目标的目标纹理对象
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToTexture(texture, outputIndex = 0) {
    if (outputIndex == 0) {
      this.m_texsTot = 1;
    } else if (this.m_texsTot < outputIndex + 1) {
      this.m_texsTot = outputIndex + 1;
    }

    this.m_texs[outputIndex] = texture;
    return texture;
  }
  /**
   * 设置渲染到纹理的目标纹理对象(普通 RTT 纹理类型的目标纹理)和framebuffer output attachment index
   * @param systemRTTTexIndex 作为渲染到目标的目标纹理对象在系统普通rtt 纹理中的序号(0 -> 15)
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToRTTTextureAt(systemRTTTexIndex, outputIndex = 0) {
    this.setRenderToTexture(this.m_texStore.getRTTTextureAt(systemRTTTexIndex), outputIndex);
  }
  /**
   * 设置渲染到纹理的目标纹理对象(Float RTT 纹理类型的目标纹理)和framebuffer output attachment index
   * @param systemFloatRTTTexIndex 作为渲染到目标的目标纹理对象在系统float rtt 纹理中的序号(0 -> 15)
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToFloatTextureAt(systemFloatRTTTexIndex, outputIndex = 0) {
    this.setRenderToTexture(this.m_texStore.getRTTFloatTextureAt(systemFloatRTTTexIndex), outputIndex);
  }
  /**
   * 设置渲染到纹理的目标纹理对象(half Float RTT 纹理类型的目标纹理)和framebuffer output attachment index
   * @param systemFloatRTTTexIndex 作为渲染到目标的目标纹理对象在系统float rtt 纹理中的序号(0 -> 15)
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToHalfFloatTexture(texture, outputIndex = 0) {
    if (texture == null) {
      texture = this.m_texStore.createRTTTex2D(128, 128, false);

      texture.__$setRenderProxy(this.m_renderProxy);

      texture.internalFormat = TextureFormat_1.default.RGBA16F;
      texture.srcFormat = TextureFormat_1.default.RGBA;
      texture.dataType = TextureDataType_1.default.FLOAT;
      texture.minFilter = TextureConst_1.default.LINEAR;
      texture.magFilter = TextureConst_1.default.LINEAR;

      texture.__$setRenderProxy(this.m_renderProxy);
    }

    return this.setRenderToTexture(texture, outputIndex);
  }
  /**
   * 设置渲染到纹理的目标纹理对象(RGBA RTT 纹理类型的目标纹理)和framebuffer output attachment index
   * @param systemFloatRTTTexIndex 作为渲染到目标的目标纹理对象在系统float rtt 纹理中的序号(0 -> 15)
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToRGBATexture(texture, outputIndex = 0) {
    if (texture == null) texture = this.createRGBATexture();
    return this.setRenderToTexture(texture, outputIndex);
  }
  /**
   * 设置渲染到纹理的目标纹理对象(depth RTT 纹理类型的目标纹理)和framebuffer output attachment index
   * @param systemDepthRTTTexIndex 作为渲染到目标的目标纹理对象在系统depth rtt 纹理中的序号(0 -> 15)
   * @param outputIndex framebuffer output attachment index
   */


  setRenderToDepthTextureAt(systemDepthRTTTexIndex, outputIndex = 0) {
    return this.setRenderToTexture(this.m_texStore.getDepthTextureAt(systemDepthRTTTexIndex), outputIndex);
  }

  createRGBATexture() {
    let texture = this.m_texStore.createRTTTex2D(32, 32, false);
    texture.internalFormat = TextureFormat_1.default.RGBA;
    texture.srcFormat = TextureFormat_1.default.RGBA;
    texture.dataType = TextureDataType_1.default.UNSIGNED_BYTE;
    texture.minFilter = TextureConst_1.default.LINEAR;
    texture.magFilter = TextureConst_1.default.LINEAR;

    texture.__$setRenderProxy(this.m_renderProxy);

    return texture;
  }

  setClearState(clearColorBoo = true, clearDepthBoo = true, clearStencilBoo = false) {
    this.m_clearColorBoo = clearColorBoo;
    this.m_clearDepthBoo = clearDepthBoo;
    this.m_clearStencilBoo = clearStencilBoo;
  }

  setRenderToBackBuffer() {
    this.m_renderProxy.setClearColor(this.m_backBufferColor);
    this.m_rcontext.setRenderToBackBuffer();
  }

  setClearDepth(depth) {
    this.m_clearDepth = depth;
  }

  getClearDepth() {
    return this.m_adapter.getClearDepth();
  }

  getViewportX() {
    return this.m_adapter.getViewportX();
  }

  getViewportY() {
    return this.m_adapter.getViewportY();
  }

  getViewportWidth() {
    return this.m_adapter.getViewportWidth();
  }

  getViewportHeight() {
    return this.m_adapter.getViewportHeight();
  }

  getFBOWidth() {
    return this.m_adapter.getFBOWidthAt(this.m_fboIndex);
  }

  getFBOHeight() {
    return this.m_adapter.getFBOHeightAt(this.m_fboIndex);
  }

  resetAttachmentMask(boo) {
    this.m_adapter.resetFBOAttachmentMask(boo);
  }

  setAttachmentMaskAt(index, boo) {
    this.m_adapter.setFBOAttachmentMaskAt(index, boo);
  }

  setClearRGBColor3f(pr, pg, pb) {
    this.m_bgColor.setRGB3f(pr, pg, pb);
  }

  setClearColorEnabled(boo) {
    this.m_clearColorBoo = boo;
  }

  setClearDepthEnabled(boo) {
    this.m_clearDepthBoo = boo;
  }

  setClearStencilEnabled(boo) {
    this.m_clearStencilBoo = boo;
  }

  setClearUint24Color(colorUint24, alpha = 1.0) {
    this.m_bgColor.setRGBUint24(colorUint24);
    this.m_bgColor.a = alpha;
  }

  setClearRGBAColor4f(pr, pg, pb, pa) {
    this.m_bgColor.setRGBA4f(pr, pb, pg, pa);
  }
  /**
   * @param			clearType, it is IRenderProxy.COLOR or IRenderProxy.DEPTH or IRenderProxy.STENCIL or IRenderProxy.DEPTH_STENCIL
   */


  blitFrom(fboIns, mask_bitfiled = RenderMaskBitfield_1.default.COLOR_BUFFER_BIT, filter = RenderFilter_1.default.NEAREST, clearType = -1, clearIndex = 0, dataArr = null) {
    if (this.m_fboIndex >= 0) {
      this.m_adapter.setBlitFboSrcRect(0, 0, fboIns.getFBOWidth(), fboIns.getFBOHeight());
      this.m_adapter.setBlitFboSrcRect(0, 0, this.getFBOWidth(), this.getFBOHeight());
      this.m_adapter.blitFBO(fboIns.getFBOUid(), this.m_fboIndex, mask_bitfiled, filter, clearType, clearIndex, dataArr);
    }
  }

  blitColorFrom(fboIns, filter = RenderFilter_1.default.NEAREST, clearType = -1, clearIndex = 0, dataArr = null) {
    if (this.m_fboIndex >= 0) {
      this.m_adapter.setBlitFboSrcRect(0, 0, fboIns.getFBOWidth(), fboIns.getFBOHeight());
      this.m_adapter.setBlitFboSrcRect(0, 0, this.getFBOWidth(), this.getFBOHeight());
      this.m_adapter.blitFBO(fboIns.getFBOUid(), this.m_fboIndex, RenderMaskBitfield_1.default.COLOR_BUFFER_BIT, filter, clearType, clearIndex, dataArr);
    }
  }

  blitDepthFrom(fboIns, filter = RenderFilter_1.default.NEAREST, clearType = -1, clearIndex = 0, dataArr = null) {
    if (this.m_fboIndex >= 0) {
      this.m_adapter.setBlitFboSrcRect(0, 0, fboIns.getFBOWidth(), fboIns.getFBOHeight());
      this.m_adapter.setBlitFboSrcRect(0, 0, this.getFBOWidth(), this.getFBOHeight());
      this.m_adapter.blitFBO(fboIns.getFBOUid(), this.m_fboIndex, RenderMaskBitfield_1.default.COLOR_BUFFER_BIT | RenderMaskBitfield_1.default.DEPTH_BUFFER_BIT, filter, clearType, clearIndex, dataArr);
    }
  }

  blitColorAndDepthFrom(fboIns, filter = RenderFilter_1.default.NEAREST, clearType = -1, clearIndex = 0, dataArr = null) {
    if (this.m_fboIndex >= 0) {
      this.m_adapter.setBlitFboSrcRect(0, 0, fboIns.getFBOWidth(), fboIns.getFBOHeight());
      this.m_adapter.setBlitFboSrcRect(0, 0, this.getFBOWidth(), this.getFBOHeight());
      this.m_adapter.blitFBO(fboIns.getFBOUid(), this.m_fboIndex, RenderMaskBitfield_1.default.COLOR_BUFFER_BIT | RenderMaskBitfield_1.default.DEPTH_BUFFER_BIT, filter, clearType, clearIndex, dataArr);
    }
  }

  blitStencilFrom(fboIns, filter = RenderFilter_1.default.NEAREST, clearType = -1, clearIndex = 0, dataArr = null) {
    if (this.m_fboIndex >= 0) {
      this.m_adapter.setBlitFboSrcRect(0, 0, fboIns.getFBOWidth(), fboIns.getFBOHeight());
      this.m_adapter.setBlitFboSrcRect(0, 0, this.getFBOWidth(), this.getFBOHeight());
      this.m_adapter.blitFBO(fboIns.getFBOUid(), this.m_fboIndex, RenderMaskBitfield_1.default.STENCIL_BUFFER_BIT, filter, clearType, clearIndex, dataArr);
    }
  }

  renderToTextureAt(i, attachmentIndex = 0) {
    this.m_adapter.setRenderToTexture(this.m_texs[i], this.m_enableDepth, this.m_enableStencil, attachmentIndex);
    this.m_adapter.useFBO(this.m_clearColorBoo, this.m_clearDepthBoo, this.m_clearStencilBoo);
  }

  runBeginDo() {
    if (this.m_runFlag) {
      this.m_runFlag = false;
      this.m_renderProxy.getClearRGBAColor4f(this.m_backBufferColor);

      if (this.m_viewportLock) {
        this.m_adapter.lockViewport();
      } else {
        this.m_adapter.unlockViewport();
      }

      this.m_adapter.bindFBOAt(this.m_fboIndex, this.m_fboType);

      if (this.m_synFBOSizeWithViewport) {
        this.m_adapter.synFBOSizeWithViewport();
        this.m_adapter.setFBOSizeFactorWithViewPort(this.m_fboSizeFactor);
      } else {
        this.m_adapter.asynFBOSizeWithViewport();
      }

      if (this.m_clearDepth < 128.0) {
        this.m_adapter.setClearDepth(this.m_clearDepth);
      }

      this.m_renderProxy.setClearColor(this.m_bgColor);
      let i = 0;

      for (; i < this.m_texsTot; ++i) {
        this.m_adapter.setRenderToTexture(this.m_texs[i], this.m_enableDepth, this.m_enableStencil, i);
      }

      this.m_adapter.useFBO(this.m_clearColorBoo, this.m_clearDepthBoo, this.m_clearStencilBoo);

      if (this.m_gMateiral != null) {
        this.m_rcontext.useGlobalMaterial(this.m_gMateiral, this.m_texUnlock, this.m_tmaterialUniformUpdate);
      } else {
        this.m_rcontext.unlockMaterial();
      }
    }
  }

  run(lockRenderState = false, lockMaterial = false, autoEnd = true, autoRunBegin = true) {
    if (lockRenderState) this.lockRenderState();
    if (lockMaterial && !autoRunBegin) this.lockMaterial();

    if (this.m_fboIndex >= 0) {
      if (autoRunBegin) this.runBeginDo();

      if (this.m_rindexs != null) {
        // rendering running
        for (let i = 0, len = this.m_rindexs.length; i < len; ++i) {
          this.m_renderer.runAt(this.m_rindexs[i]);
        }
      }
    } // this.m_runFlag = true;


    if (lockRenderState) this.unlockRenderState();

    if (lockMaterial) {
      this.unlockMaterial();
    }

    if (autoEnd) {
      this.runEnd();
    }
  }

  runAt(index, autoRunBegin = true) {
    if (this.m_fboIndex >= 0 && this.m_rindexs != null) {
      if (index == 0 && autoRunBegin) {
        this.runBeginDo();
      } else {
        this.m_runFlag = true;
      }

      this.m_renderer.runAt(this.m_rindexs[index]);
    }
  }
  /**
   * 单独绘制可渲染对象, 可能是使用了 global material也可能没有。这种方式比较耗性能,只能用在特殊的地方。
   * @param entity 需要指定绘制的 IRenderEntity 实例
   * @param useGlobalUniform 是否使用当前 global material 所携带的 uniform, default value: false
   * @param forceUpdateUniform 是否强制更新当前 global material 所对应的 shader program 的 uniform, default value: true
   */


  drawEntity(entity, useGlobalUniform = false, forceUpdateUniform = true) {
    if (!this.m_runFlag) {
      this.m_renderer.drawEntity(entity, useGlobalUniform, forceUpdateUniform);
    }
  }

  runBegin() {
    if (this.m_fboIndex >= 0 && this.m_rindexs != null) {
      this.m_runFlag = true;
      this.runBeginDo();
    }
  }

  runEnd() {
    this.m_renderProxy.setClearColor(this.m_backBufferColor);
    this.m_runFlag = true;

    if (this.m_viewportLock) {
      this.m_adapter.unlockViewport();
    }
  }

  useCamera(camera, syncCamView = false) {
    this.m_renderer.useCamera(camera, syncCamView);
  }

  useMainCamera() {
    this.m_renderer.useMainCamera();
  }

  reset() {
    this.setGlobalMaterial(null);
    let i = 0;

    for (; i < this.m_texsTot; ++i) {
      this.m_texs[i] = null;
    }

    this.m_runFlag = false;
    this.m_fboIndex = -1;
    this.m_texsTot = 0;
    this.m_rindexs = [];
  }

  clone() {
    let ins = new FBOInstance(this.m_renderer, this.m_texStore);
    ins.m_fboSizeFactor = this.m_fboSizeFactor;
    ins.m_bgColor.copyFrom(this.m_bgColor);
    ins.m_fboIndex = this.m_fboIndex;
    ins.m_fboType = this.m_fboType;
    ins.m_clearDepth = this.m_clearDepth;
    ins.m_texsTot = this.m_texsTot;
    ins.m_enableDepth = this.m_enableDepth;
    ins.m_enableStencil = this.m_enableStencil;
    ins.m_synFBOSizeWithViewport = this.m_synFBOSizeWithViewport;
    ins.m_initW = this.m_initW;
    ins.m_initH = this.m_initH;
    ins.m_multisampleLevel = this.m_multisampleLevel;
    let i = 0;

    for (; i < this.m_texsTot; ++i) {
      ins.m_texs[i] = ins.m_texs[i];
    }

    if (this.m_rindexs != null) {
      let len = this.m_rindexs.length;
      let list = new Array(len);

      for (i = 0; i < len; ++i) {
        list[i] = this.m_rindexs[i];
      }

      ins.setRProcessIDList(list);
    }

    return ins;
  }

}

exports.default = FBOInstance;

/***/ }),

/***/ "af68":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("11e6"));

const Entity3DNode_1 = __importDefault(__webpack_require__("7b0e"));

class EntityNodeQueue {
  constructor() {
    this.m_listLen = 0;
    this.m_ids = [];
    this.m_list = [];
    this.m_entieies = [];
    this.m_fs = []; // free id list

    this.m_fids = [];
  }

  getFreeId() {
    if (this.m_fids.length > 0) {
      return this.m_fids.pop();
    }

    return -1;
  }

  createNode() {
    let index = this.getFreeId();

    if (index >= 0) {
      this.m_fs[index] = 1;
      return this.m_list[index];
    } else {
      // create a new nodeIndex
      index = this.m_listLen;
      let node = Entity3DNode_1.default.Create();
      this.m_list.push(node);
      this.m_entieies.push(null);
      node.spaceId = index; //node.distanceFlag = false;

      this.m_fs.push(1);
      this.m_ids.push(index);
      this.m_fs.push(1);
      this.m_listLen++;
      return node;
    }
  }

  restoreId(id) {
    if (id > 0 && this.m_fs[id] == 1) {
      this.m_fids.push(id);
      this.m_fs[id] = 0;
      this.m_entieies[id] = null;
    }
  } // 可以添加真正被渲染的实体也可以添加只是为了做检测的实体(不允许有material)


  addEntity(entity) {
    let node = this.createNode();
    this.m_entieies[node.spaceId] = entity;
    node.entity = entity;
    entity.__$rseFlag = RSEntityFlag_1.default.AddSpaceUid(entity.__$rseFlag, node.spaceId);
    return node;
  }

  initialize(total) {
    if (total > 0) {
      for (let i = 0; i < total; i++) {
        let node = this.createNode();
        this.m_entieies[node.spaceId] = null;
      }
    }
  }

  getNodeByEntity(entity) {
    if (RSEntityFlag_1.default.TestSpaceContains(entity.__$rseFlag)) {
      let uid = RSEntityFlag_1.default.GetSpaceUid(entity.__$rseFlag);

      if (this.m_entieies[uid] == entity) {
        return this.m_list[uid];
      }
    }

    return null;
  }

  removeEntity(entity) {
    if (RSEntityFlag_1.default.TestSpaceContains(entity.__$rseFlag)) {
      let uid = RSEntityFlag_1.default.GetSpaceUid(entity.__$rseFlag);

      if (this.m_entieies[uid] == entity) {
        this.m_list[uid].reset();
        this.restoreId(uid);
        entity.__$rseFlag = RSEntityFlag_1.default.RemoveSpaceUid(entity.__$rseFlag);
      }
    }
  }

}

exports.default = EntityNodeQueue;

/***/ }),

/***/ "b02c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

function getNearestCeilPow2(int_n) {
  let x = 1;

  while (x < int_n) {
    x <<= 1;
  }

  return x;
}
/**
 * renderer runtime texture resource object
 */


class TextureRenderObj {
  constructor(rcuid, texListHashId) {
    this.m_uid = -1;
    this.m_mid = -1;
    this.m_texTotal = 0; // max texture amount: 8

    this.m_gtexList = null;
    this.m_samplers = null;
    this.m_texList = null; // renderer context uid

    this.m_rcuid = 0;
    this.m_texRes = null; // 是否收集gpu数据直接使用，true表示需要收集

    this.direct = true; // 自身的引用计数器

    this.m_attachCount = 0;
    this.m_rcuid = rcuid;
    this.m_uid = TextureRenderObj.s_uid++;
    this.m_mid = texListHashId;
  }

  __$setParam(rcuid, texListHashId) {
    this.m_rcuid = rcuid;
    this.m_mid = texListHashId;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  getMid() {
    return this.m_mid;
  }

  getTexTotal() {
    return this.m_texTotal;
  }

  collectTexList(texRes, ptexList, shdTexTotal) {
    this.m_texRes = texRes;
    let i = 0;

    if (this.direct) {
      if (this.m_texTotal < 1 && ptexList.length > 0) {
        let len = getNearestCeilPow2(ptexList.length);
        this.m_samplers = new Uint16Array(len);
        this.m_gtexList = new Array(len);
        this.m_texList = ptexList;
        let tex;

        while (i < shdTexTotal) {
          tex = ptexList[i];

          tex.__$attachThis();

          tex.__$$upload(texRes);

          this.m_samplers[i] = tex.getSampler();
          this.m_gtexList[i] = this.m_texRes.getGpuBuffer(tex.getResUid());

          this.m_texRes.__$attachRes(tex.getResUid());

          i++;
        }

        this.m_texTotal = i;
      } else {
        this.m_texTotal = 0;
      }
    } else {
      this.m_texTotal = shdTexTotal;
    }

    while (i < ptexList.length) {
      ptexList[i++].__$attachThis();
    }
  } // 注意: 移动端要注意这里的切换机制是符合移动端低带宽的特点


  run() {
    //console.log("this.m_texRes.unlocked: ",this.m_texRes.unlocked,this.m_texRes.texMid != this.m_mid);
    if (this.m_texRes.unlocked && this.m_texRes.texMid != this.m_mid) {
      this.m_texRes.texMid = this.m_mid; //console.log("this.m_mid: ",this.m_mid,this.m_uid, this.m_texList);

      let gl = this.m_texRes.getRC();
      let texI = gl.TEXTURE0;

      if (this.direct) {
        //console.log("this.m_gtexList: ",this.m_gtexList,", total: "+this.m_texTotal);
        for (let i = 0; i < this.m_texTotal; ++i) {
          gl.activeTexture(texI++);
          gl.bindTexture(this.m_samplers[i], this.m_gtexList[i]);
        }
      } else {
        let list = this.m_texList;

        for (let i = 0; i < this.m_texTotal; ++i) {
          gl.activeTexture(texI++);

          list[i].__$$use(this.m_texRes);
        }
      }
    }
  }

  getUid() {
    return this.m_uid;
  }

  __$attachThis() {
    ++this.m_attachCount;
  }

  __$detachThis() {
    --this.m_attachCount; //console.log("TextureRenderObj::__$detachThis() this.m_attachCount: "+this.m_attachCount);

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0; //console.log("TextureRenderObj::__$detachThis() this.m_attachCount value is 0.");

      TextureRenderObj.Restore(this);
    }
  }

  reset() {
    if (this.m_texList != null) {
      for (let i = 0, len = this.m_texList.length; i < len; ++i) {
        this.m_texList[i].__$detachThis();

        this.m_texRes.__$detachRes(this.m_texList[i].getResUid());

        this.m_gtexList[i] = null;
      }
    }

    this.m_texTotal = 0;
    this.m_texList = null;
    this.m_texRes = null;
  }

  toString() {
    return "TextureRenderObj(uid = " + this.m_uid + ", mid=" + this.m_mid + ")";
  }

  static Create(texRes, texList, shdTexTotal) {
    let texTotal = texList.length;

    if (texTotal > 0 && shdTexTotal > 0) {
      if (texTotal < shdTexTotal) {
        throw Error("There are fewer textures than in the shader : (need " + shdTexTotal + ",but only have " + texTotal + ") !!!");
        return null;
      }

      let key = 31;
      let t = 0;
      let direct = true;

      while (t < shdTexTotal) {
        key = key * 131 + texList[t].getUid();

        if (!texList[t].isDirect()) {
          direct = false;
        }

        ++t;
      }

      let rtoMap = TextureRenderObj.s_troMaps[texRes.getRCUid()];
      let tro = null;

      if (rtoMap.has(key)) {
        tro = rtoMap.get(key);
      } else {
        if (TextureRenderObj.s_freeTROList.length < 1) {
          tro = new TextureRenderObj(texRes.getRCUid(), key); //console.log("TextureRenderObj::Create use a new tex mid: " + tro.getMid(),",total: "+shdTexTotal,",key: "+key);
        } else {
          tro = TextureRenderObj.s_freeTROList.pop(); //console.log("TextureRenderObj::Create use an old tex mid: " + tro.getMid(),",total: "+shdTexTotal,",key: "+key);
        }

        tro.collectTexList(texRes, texList, shdTexTotal);
        rtoMap.set(key, tro);
      }

      tro.__$setParam(texRes.getRCUid(), key);

      tro.direct = direct;
      return tro;
    }

    return null;
  }

  static Restore(tro) {
    if (tro.getMid() > -1) {
      //console.log("TextureRenderObj::Restore tro.getMid(): "+tro.getMid());
      TextureRenderObj.s_troMaps[tro.getRCUid()].delete(tro.getMid());

      tro.__$setParam(0, 0);

      TextureRenderObj.s_freeTROList.push(tro);
      tro.reset();
    }
  }

  static GetByMid(rcuid, uid) {
    return TextureRenderObj.s_troMaps[rcuid].get(uid);
  }

}

TextureRenderObj.s_uid = 0;
TextureRenderObj.s_troMaps = [new Map(), new Map(), new Map(), new Map(), new Map(), new Map(), new Map(), new Map()];
TextureRenderObj.s_freeTROList = [];
TextureRenderObj.s_unloacked = true;
TextureRenderObj.s_preMid = -1;
exports.TextureRenderObj = TextureRenderObj;

class EmptyTexRenderObj {
  constructor(texRes) {
    this.m_texRes = null;
    this.m_texRes = texRes;
  }

  run() {
    this.m_texRes.renderBegin();
  }

  getMid() {
    return 1;
  }

  __$attachThis() {}

  __$detachThis() {}

}

exports.EmptyTexRenderObj = EmptyTexRenderObj;
exports.default = TextureRenderObj;

/***/ }),

/***/ "b0ef":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RViewElement {
  constructor() {
    this.m_canvas = null;
    this.m_div = null;
    this.m_divW = -1;
    this.m_divH = -1;
    this.resized = true;
  }

  setDiv(div) {
    this.m_div = div;
  }

  createViewEle(pdocument, autoResize) {
    if (this.m_div == null) {
      this.m_div = document.getElementById("voxEngineDiv");
    }

    if (this.m_div == null) {
      this.m_div = pdocument.createElement('div');
      this.m_div.style.width = '400px';
      this.m_div.style.height = '300px';
      document.body.appendChild(this.m_div);
    }

    this.m_div.style.display = 'bolck';
    this.m_div.style.position = 'absolute';

    if (this.m_div.style.left == "") {
      this.m_div.style.left = '0px';
      this.m_div.style.top = '0px';
    }

    if (autoResize) {
      this.m_div.style.width = '100%';
      this.m_div.style.height = '100%';
    }

    if (this.m_canvas == null) {
      this.m_canvas = document.createElement('canvas');
      this.m_div.appendChild(this.m_canvas);
      this.m_canvas.width = 800;
      this.m_canvas.height = 600;
      this.m_canvas.style.display = 'bolck';
      this.m_canvas.style.left = '0px';
      this.m_canvas.style.top = '0px';
      this.m_canvas.style.position = 'absolute';
    }
  }

  setDivStyleLeftAndTop(px, py) {
    this.m_div.style.left = px + "px";
    this.m_div.style.top = py + "px";
  }

  setDivStyleSize(pw, ph) {
    if (this.m_divW != pw || this.m_divH != ph) {
      this.m_div.style.width = pw + "px";
      this.m_div.style.height = ph + "px";
      this.resized = true;
    }
  }

  getDiv() {
    return this.m_div;
  }

  getCanvas() {
    return this.m_canvas;
  }

}

exports.default = RViewElement;

/***/ }),

/***/ "b161":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 整个渲染场景的入口类

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const Stage3D_1 = __importDefault(__webpack_require__("3806"));

const CameraBase_1 = __importDefault(__webpack_require__("c51d"));

const RendererParam_1 = __importDefault(__webpack_require__("c497"));

const EntityNodeQueue_1 = __importDefault(__webpack_require__("af68"));

const Entity3DNodeLinker_1 = __importDefault(__webpack_require__("a80a"));

const RunnableQueue_1 = __importDefault(__webpack_require__("9c4d"));

const RendererInstance_1 = __importDefault(__webpack_require__("d958"));

const TextureBlock_1 = __webpack_require__("5d04");

const RendererSpace_1 = __importDefault(__webpack_require__("a446"));

const RaySelector_1 = __importDefault(__webpack_require__("c711"));

const RayGpuSelector_1 = __importDefault(__webpack_require__("955e"));

const MouseEvt3DController_1 = __importDefault(__webpack_require__("765c"));

const FBOInstance_1 = __importDefault(__webpack_require__("af29"));

const CameraDsistanceSorter_1 = __importDefault(__webpack_require__("d7e2"));

const RendererSubScene_1 = __importDefault(__webpack_require__("70f2"));

const Matrix4Pool_1 = __importDefault(__webpack_require__("2139"));

const ShaderProgramBuilder_1 = __webpack_require__("a156");

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

class RendererScene {
  constructor() {
    this.m_uid = -1;
    this.m_adapter = null;
    this.m_renderProxy = null;
    this.m_shader = null;
    this.m_rcontext = null;
    this.m_renderer = null;
    this.m_processids = new Uint8Array(128);
    this.m_processidsLen = 0;
    this.m_rspace = null;
    this.m_mouse_rltv = new Vector3D_1.default();
    this.m_mouse_rlpv = new Vector3D_1.default();
    this.m_accessor = null; // event flow control enable

    this.m_evtFlowEnabled = false;
    this.m_evt3DCtr = null;
    this.m_mouseEvtEnabled = true;
    this.m_viewX = 0.0;
    this.m_viewY = 0.0;
    this.m_viewW = 800.0;
    this.m_viewH = 800.0;
    this.m_nodeWaitLinker = null;
    this.m_nodeWaitQueue = null;
    this.m_camDisSorter = null; // recorde renderer sub scenes

    this.m_subscList = [];
    this.m_subscListLen = 0;
    this.m_runFlag = -1;
    this.m_autoRunning = true;
    this.m_processUpdate = false;
    this.m_tickId = -1;
    this.m_rparam = null;
    this.m_enabled = true;
    this.runnableQueue = new RunnableQueue_1.default();
    this.textureBlock = new TextureBlock_1.TextureBlock();
    this.stage3D = null;
    this.materialBlock = null;
    this.entityBlock = null;
    this.m_containers = [];
    this.m_containersTotal = 0;
    this.m_currCamera = null;
    this.m_mouseTestBoo = true;
    this.m_cullingTestBoo = true;
    this.m_rayTestFlag = true;
    this.m_rayTestEnabled = true;
    this.m_prependNodes = null;
    this.m_appendNodes = null;
    this.m_uid = RendererScene.s_uid++;
  }

  tickUpdate() {
    if (this.m_tickId > -1) {
      clearTimeout(this.m_tickId);
    }

    this.m_tickId = setTimeout(this.tickUpdate.bind(this), this.m_rparam.getTickUpdateTime());
    this.textureBlock.run();
  }

  enable() {
    this.m_enabled = true;
  }

  disable() {
    this.m_enabled = false;
  }

  isEnabled() {
    return this.m_enabled;
  }

  getUid() {
    return this.m_uid;
  }

  getDiv() {
    return this.m_renderProxy.getDiv();
  }

  getCanvas() {
    return this.m_renderProxy.getCanvas();
  }

  getRPONodeBuilder() {
    return null;
  }

  getRenderProxy() {
    return this.m_renderProxy;
  } // set new view port rectangle area


  setViewPort(px, py, pw, ph) {
    if (this.m_renderProxy != null) {
      this.m_viewX = px;
      this.m_viewY = py;
      this.m_viewW = pw;
      this.m_viewH = ph;
      this.m_renderProxy.setViewPort(px, py, pw, ph);
    }
  }

  setViewPortFromCamera(camera) {
    if (this.m_renderProxy != null && camera != null) {
      this.m_viewX = camera.getViewX();
      this.m_viewY = camera.getViewY();
      this.m_viewW = camera.getViewWidth();
      this.m_viewH = camera.getViewHeight();
      this.m_renderProxy.setViewPort(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH);
    }
  } // apply new view port rectangle area


  reseizeViewPort() {
    this.m_renderProxy.reseizeRCViewPort();
  }

  lockViewport() {
    this.m_adapter.lockViewport();
  }

  unlockViewport() {
    this.m_adapter.unlockViewport();
  }

  getRendererAdapter() {
    return this.m_adapter;
  }

  getRenderer() {
    return this.m_renderer;
  }

  getRendererContext() {
    return this.m_rcontext;
  }

  getStage3D() {
    return this.m_renderProxy.getStage3D();
  }
  /**
   * 获取渲染器可渲染对象管理器状态(版本号)
   */


  getRendererStatus() {
    return this.m_renderer.getRendererStatus();
  }

  getViewWidth() {
    return this.m_renderProxy.getStage3D().viewWidth;
  }

  getViewHeight() {
    return this.m_renderProxy.getStage3D().viewHeight;
  }

  getCamera() {
    return this.m_renderProxy.getCamera();
  }

  asynFBOSizeWithViewport() {
    this.m_rcontext.asynFBOSizeWithViewport();
  }

  synFBOSizeWithViewport() {
    this.m_rcontext.synFBOSizeWithViewport();
  }

  cameraLock() {
    this.m_renderProxy.cameraLock();
  }

  cameraUnlock() {
    this.m_renderProxy.cameraUnlock();
  }

  getMouseXYWorldRay(rl_position, rl_tv) {
    this.m_renderProxy.getMouseXYWorldRay(rl_position, rl_tv);
  }

  createCamera() {
    return new CameraBase_1.default();
  }

  createFBOInstance() {
    return new FBOInstance_1.default(this, this.textureBlock.getRTTStrore());
  }

  createMatrix4() {
    return new Matrix4_1.default();
  }

  createVector3D(x = 0.0, y = 0.0, z = 0.0, w = 1.0) {
    return new Vector3D_1.default(x, y, z, w);
  }

  setClearUint24Color(colorUint24, alpha = 1.0) {
    this.m_renderProxy.setClearUint24Color(colorUint24, alpha);
  }

  setClearRGBColor3f(pr, pg, pb) {
    this.m_renderProxy.setClearRGBColor3f(pr, pg, pb);
  }

  setClearRGBAColor4f(pr, pg, pb, pa) {
    this.m_renderProxy.setClearRGBAColor4f(pr, pg, pb, pa);
  }

  setClearColor(color) {
    this.m_renderProxy.setClearRGBAColor4f(color.r, color.g, color.b, color.a);
  }

  setRenderToBackBuffer() {
    this.m_rcontext.setRenderToBackBuffer();
  }

  drawBackBufferToCanvas(dstCanvas) {
    let srcCanvas = this.getCanvas();
    var ctx = dstCanvas.getContext("2d");
    ctx.drawImage(srcCanvas, 0, 0, dstCanvas.width, dstCanvas.height);
  }

  updateRenderBufferSize() {
    this.m_adapter.updateRenderBufferSize();
  }

  setEvt3DController(evt3DCtr) {
    if (evt3DCtr != null) {
      evt3DCtr.initialize(this.getStage3D(), this.getStage3D());
      evt3DCtr.setRaySelector(this.m_rspace.getRaySelector());
    }

    this.m_evt3DCtr = evt3DCtr;
  }

  isRayPickSelected() {
    return this.m_evt3DCtr != null && this.m_evt3DCtr.isSelected();
  }

  enableMouseEvent(gpuTestEnabled = true) {
    if (this.m_evt3DCtr == null) {
      if (gpuTestEnabled) {
        this.m_rspace.setRaySelector(new RayGpuSelector_1.default());
      } else {
        this.m_rspace.setRaySelector(new RaySelector_1.default());
      }

      this.setEvt3DController(new MouseEvt3DController_1.default());
    }

    this.m_mouseEvtEnabled = true;
  }

  disableMouseEvent() {
    this.m_mouseEvtEnabled = false;
  }

  getEvt3DController() {
    return this.m_evt3DCtr;
  }

  getSpace() {
    return this.m_rspace;
  }

  getDevicePixelRatio() {
    return this.m_adapter.getDevicePixelRatio();
  }
  /**
   * very important renderer scene system function
   */


  createSubScene() {
    if (this.m_renderer != null) {
      let subsc = new RendererSubScene_1.default(this, this.m_renderer, this.m_evtFlowEnabled);
      this.m_subscList.push(subsc);
      this.m_subscListLen++;
      let sc = subsc;
      sc.textureBlock = this.textureBlock;
      return subsc;
    }

    return null;
  }

  addEventListener(type, target, func, captureEnabled = true, bubbleEnabled = false) {
    this.stage3D.addEventListener(type, target, func, captureEnabled, bubbleEnabled);
  }

  removeEventListener(type, target, func) {
    this.stage3D.removeEventListener(type, target, func);
  }

  setAccessor(accessor) {
    this.m_accessor = accessor;
  }

  initialize(rparam = null, renderProcessesTotal = 3) {
    if (this.m_renderer == null) {
      if (rparam == null) rparam = new RendererParam_1.default();
      this.m_rparam = rparam;
      let selfT = this;
      selfT.stage3D = new Stage3D_1.default(this.getUid(), document);

      if (renderProcessesTotal < 1) {
        renderProcessesTotal = 1;
      }

      if (renderProcessesTotal > 8) {
        renderProcessesTotal = 8;
      }

      this.m_evtFlowEnabled = rparam.evtFlowEnabled;
      this.m_renderer = new RendererInstance_1.default();

      this.m_renderer.__$setStage3D(this.stage3D);

      Matrix4Pool_1.default.Allocate(rparam.getMatrix4AllocateSize());
      let camera = new CameraBase_1.default();
      this.m_renderer.initialize(rparam, camera, new ShaderProgramBuilder_1.ShaderProgramBuilder(this.m_renderer.getRCUid()));
      this.m_processids[0] = 0;
      this.m_processidsLen++;
      let process = null;

      for (; renderProcessesTotal >= 0;) {
        process = this.m_renderer.appendProcess(rparam.batchEnabled, rparam.processFixedState);
        this.m_processids[this.m_processidsLen] = process.getRPIndex();
        this.m_processidsLen++;
        --renderProcessesTotal;
      }

      this.m_rcontext = this.m_renderer.getRendererContext();
      this.m_renderProxy = this.m_rcontext.getRenderProxy();
      this.m_adapter = this.m_renderProxy.getRenderAdapter();
      let stage3D = this.m_renderProxy.getStage3D();
      this.m_viewW = stage3D.stageWidth;
      this.m_viewH = stage3D.stageHeight;
      this.m_shader = this.m_renderer.getDataBuilder().getRenderShader();
      this.textureBlock.setRenderer(this.m_renderProxy);
      this.m_camDisSorter = new CameraDsistanceSorter_1.default(this.m_renderProxy);

      if (this.m_rspace == null) {
        let space = new RendererSpace_1.default();
        space.initialize(this.m_renderer, this.m_renderProxy.getCamera());
        this.m_rspace = space;
      }

      this.tickUpdate();
    }
  }

  setRendererProcessParam(index, batchEnabled, processFixedState) {
    this.m_renderer.setRendererProcessParam(this.m_processids[index], batchEnabled, processFixedState);
  }

  appendARendererProcess(batchEnabled = true, processFixedState = false) {
    let process = this.m_renderer.appendProcess(batchEnabled, processFixedState);
    this.m_processids[this.m_processidsLen] = process.getRPIndex();
    this.m_processidsLen++;
  }
  /**
   * get the renderer process by process index
   * @param processIndex IRenderProcess instance index in renderer scene instance
   */


  getRenderProcessAt(processIndex) {
    return this.m_renderer.getProcessAt(this.m_processids[processIndex]);
  }

  addContainer(container, processIndex = 0) {
    if (processIndex < 0) {
      processIndex = 0;
    }

    if (container != null && container.__$wuid < 0 && container.__$contId < 1) {
      let i = 0;

      for (; i < this.m_containersTotal; ++i) {
        if (this.m_containers[i] == container) {
          return;
        }
      }

      if (i >= this.m_containersTotal) {
        container.__$wuid = this.m_uid;
        container.wprocuid = processIndex;

        container.__$setRenderer(this);

        this.m_containers.push(container);
        this.m_containersTotal++;
      }
    }
  }

  removeContainer(container) {
    if (container != null && container.__$wuid == this.m_uid && container.getRenderer() == this.m_renderer) {
      let i = 0;

      for (; i < this.m_containersTotal; ++i) {
        if (this.m_containers[i] == container) {
          container.__$wuid = -1;
          container.wprocuid = -1;

          container.__$setRenderer(null);

          this.m_containers.splice(i, 1);
          --this.m_containersTotal;
          break;
        }
      }
    }
  }

  setAutoRunningEnabled(autoRunning) {
    this.m_autoRunning = autoRunning;
  }

  setAutoRenderingSort(sortEnabled) {
    this.m_processUpdate = sortEnabled;
  }

  setProcessSortEnabledAt(processIndex, sortEnabled, sorter = null) {
    this.m_renderer.setProcessSortEnabledAt(processIndex, sortEnabled);

    if (sortEnabled) {
      let process = this.m_renderer.getProcessAt(processIndex);
      sorter = sorter != null ? sorter : this.m_camDisSorter;

      if (process != null) {
        process.setSorter(sorter);
      }
    }
  }

  setProcessSortEnabled(process, sortEnabled, sorter = null) {
    this.m_renderer.setProcessSortEnabled(process, sortEnabled);

    if (sortEnabled && process != null && !process.hasSorter()) {
      sorter = sorter != null ? sorter : this.m_camDisSorter;
      process.setSorter(sorter);
    }
  }
  /**
   * 将已经在渲染运行时中的entity移动到指定 process uid 的 render process 中去
   * move rendering runtime displayEntity to different renderer process
   */


  moveEntityTo(entity, processindex) {
    this.m_renderer.moveEntityToProcessAt(entity, this.m_processids[processindex]);
  }
  /**
   * 单独绘制可渲染对象, 可能是使用了 global material也可能没有。这种方式比较耗性能,只能用在特殊的地方。
   * @param entity 需要指定绘制的 IRenderEntity 实例
   * @param useGlobalUniform 是否使用当前 global material 所携带的 uniform, default value: false
   * @param forceUpdateUniform 是否强制更新当前 global material 所对应的 shader program 的 uniform, default value: true
   */


  drawEntity(entity, useGlobalUniform = false, forceUpdateUniform = true) {
    this.m_renderer.drawEntity(entity, useGlobalUniform, forceUpdateUniform);
  }
  /**
   * add an entity to the renderer process of the renderer instance
   * @param entity IRenderEntity instance(for example: DisplayEntity class instance)
   * @param processid this destination renderer process id
   * @param deferred if the value is true,the entity will not to be immediately add to the renderer process by its id
   */


  addEntity(entity, processid = 0, deferred = true) {
    if (entity != null && entity.__$testSpaceEnabled()) {
      if (entity.isPolyhedral()) {
        if (entity.hasMesh()) {
          this.m_renderer.addEntity(entity, this.m_processids[processid], deferred);

          if (this.m_rspace != null) {
            this.m_rspace.addEntity(entity);
          }
        } else {
          // 这里的等待队列可能会和加入容器的操作冲突
          // wait queue
          if (this.m_nodeWaitLinker == null) {
            this.m_nodeWaitLinker = new Entity3DNodeLinker_1.default();
            this.m_nodeWaitQueue = new EntityNodeQueue_1.default();
          }

          let node = this.m_nodeWaitQueue.addEntity(entity);
          node.rstatus = processid;
          this.m_nodeWaitLinker.addNode(node);
        }
      } else {
        this.m_renderer.addEntity(entity, this.m_processids[processid], deferred);

        if (this.m_rspace != null) {
          this.m_rspace.addEntity(entity);
        }
      }
    }
  }
  /**
   * remove an entity from the rendererinstance
   * @param entity IRenderEntity instance(for example: DisplayEntity class instance)
   */


  removeEntity(entity) {
    if (entity != null) {
      let node = null;

      if (this.m_nodeWaitLinker != null) {
        let node = this.m_nodeWaitQueue.getNodeByEntity(entity);

        if (node != null) {
          this.m_nodeWaitLinker.removeNode(node);
          this.m_nodeWaitQueue.removeEntity(entity);
        }
      }

      if (node == null) {
        this.m_renderer.removeEntity(entity);

        if (this.m_rspace != null) {
          this.m_rspace.removeEntity(entity);
        }
      }
    }
  }

  updateMaterialUniformToCurrentShd(material) {
    this.m_renderer.updateMaterialUniformToCurrentShd(material);
  }

  showInfoAt(index) {
    this.m_renderer.showInfoAt(index);
  }

  getRenderUnitsTotal() {
    return this.m_renderer.getRenderUnitsTotal();
  }

  useCamera(camera, syncCamView = false) {
    this.m_currCamera = camera;

    if (syncCamView) {
      this.m_renderProxy.setRCViewPort(camera.getViewX(), camera.getViewY(), camera.getViewWidth(), camera.getViewHeight(), true);
      this.m_renderProxy.reseizeRCViewPort();
    }

    camera.update();
    this.m_rcontext.resetUniform();
    this.m_renderProxy.updateCameraDataFromCamera(camera);
  }

  useMainCamera() {
    this.m_currCamera = null;
    let camera = this.m_renderProxy.getCamera();
    this.m_renderProxy.setRCViewPort(camera.getViewX(), camera.getViewY(), camera.getViewWidth(), camera.getViewHeight(), true);
    this.m_renderProxy.reseizeRCViewPort();
    this.m_renderProxy.updateCamera();
    this.m_rcontext.resetUniform();
    this.m_renderProxy.updateCameraDataFromCamera(this.m_renderProxy.getCamera());
  }

  updateCameraDataFromCamera(camera) {
    this.m_renderProxy.updateCameraDataFromCamera(camera);
  }
  /**
   * reset renderer rendering state
   */


  resetState() {
    this.m_rcontext.resetState();
  }
  /**
   * reset render shader uniform location
   */


  resetUniform() {
    this.m_rcontext.resetUniform();
  }

  enableSynViewAndStage() {
    this.m_renderProxy.enableSynViewAndStage();
  }
  /**
   * the function only resets the renderer instance rendering status.
   * you should use it before the run or runAt function is called.
   */


  renderBegin(contextBeginEnabled = true) {
    if (this.m_currCamera == null) {
      this.m_adapter.unlockViewport();

      if (this.m_renderProxy.isAutoSynViewAndStage()) {
        let boo = this.m_renderProxy.testViewPortChanged(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH);
        this.m_viewX = this.m_renderProxy.getViewX();
        this.m_viewY = this.m_renderProxy.getViewY();
        this.m_viewW = this.m_renderProxy.getViewWidth();
        this.m_viewH = this.m_renderProxy.getViewHeight();

        if (boo) {
          this.m_renderProxy.setRCViewPort(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH, true);
          this.m_renderProxy.reseizeRCViewPort();
        }
      } else {
        this.m_renderProxy.setViewPort(this.m_viewX, this.m_viewY, this.m_viewW, this.m_viewH);
      }

      this.m_renderProxy.updateCamera();
      this.m_renderProxy.updateCameraDataFromCamera(this.m_renderProxy.getCamera());
    }

    this.m_shader.renderBegin();

    if (contextBeginEnabled) {
      this.m_rcontext.renderBegin(this.m_currCamera == null);
    }

    this.m_currCamera = null;

    if (this.m_accessor != null) {
      this.m_accessor.renderBegin(this);
    }
  }
  /**
   * the function resets the renderer scene status.
   * you should use it on the frame starting time.
   */


  runBegin(autoCycle = true, contextBeginEnabled = true) {
    if (autoCycle && this.m_autoRunning) {
      if (this.m_runFlag >= 0) this.runEnd();
      this.m_runFlag = 0;
    }

    let cam = this.m_currCamera;
    let camFlag = cam == null;
    this.renderBegin(contextBeginEnabled);

    if (this.m_rspace != null) {
      this.m_rspace.setCamera(camFlag ? this.m_renderProxy.getCamera() : cam);
      this.m_rspace.runBegin();
    }
  }

  renderContextBegin() {
    this.m_rcontext.renderBegin();
  }

  setRayTestEanbled(enabled) {
    this.m_rayTestEnabled = enabled;
  } // @param       evtFlowPhase: 0(none phase),1(capture phase),2(bubble phase)
  // @param       status: 1(default process),1(deselect ray pick target)
  // @return      1 is send evt yes,0 is send evt no,-1 is event nothing


  runMouseTest(evtFlowPhase, status) {
    let flag = -1;

    if (this.m_evt3DCtr != null && this.m_mouseEvtEnabled) {
      if (this.m_rayTestFlag && this.m_evt3DCtr.getEvtType() > 0) {
        // 是否对已经获得的拾取列表做进一步的gpu拾取
        let selector = this.m_rspace.getRaySelector();

        if (selector != null) {
          if (this.m_rayTestEnabled) {
            this.mouseRayTest();
          } else {
            selector.clear();
          } // 如果有gpu拾取则进入这个管理器, 这个管理器得到最终的拾取结果再和前面的计算结果做比较


          let total = selector.getSelectedNodesTotal();

          if (total > 1) {
            let i = 0;
            let list = selector.getSelectedNodes();
            let node = null;

            for (; i < total; ++i) {
              node = list[i];

              if (node.entity.isPolyhedral()) {//this.m_renderer.drawEntityByLockMaterial(node.entity);
              }
            }
          }
        }

        this.m_rayTestFlag = false;
      }

      flag = this.m_evt3DCtr.run(evtFlowPhase, status);
    }

    this.m_mouseTestBoo = false;
    return flag;
  }
  /**
   * update all data or status of the renderer runtime
   * should call this function per frame
   */


  update(autoCycle = true, mouseEventEnabled = true) {
    this.stage3D.enterFrame();

    if (autoCycle && this.m_autoRunning) {
      if (this.m_runFlag != 0) this.runBegin();
      this.m_runFlag = 1;
    } // camera visible test, ray cast test, Occlusion Culling test


    this.m_mouseTestBoo = true;
    this.m_cullingTestBoo = true;
    this.m_rayTestFlag = true; // wait mesh data ready to finish

    if (this.m_nodeWaitLinker != null) {
      let nextNode = this.m_nodeWaitLinker.getBegin();

      if (nextNode != null) {
        let pnode;
        let entity;
        let status;

        while (nextNode != null) {
          if (nextNode.entity.hasMesh()) {
            pnode = nextNode;
            nextNode = nextNode.next;
            entity = pnode.entity;
            status = pnode.rstatus;
            this.m_nodeWaitLinker.removeNode(pnode);
            this.m_nodeWaitQueue.removeEntity(pnode.entity); //console.log("RenderScene::update(), ready a mesh data that was finished.");

            this.addEntity(entity, status);
          } else {
            nextNode = nextNode.next;
          }
        }
      }
    }

    let i = 0;

    for (; i < this.m_containersTotal; ++i) {
      this.m_containers[i].update();
    }

    this.m_renderer.update(); // space update

    if (this.m_rspace != null) {
      this.m_rspace.update();

      if (this.m_cullingTestBoo) {
        if (this.m_evt3DCtr != null || this.m_processUpdate || this.m_rspace.getRaySelector() != null) {
          this.m_rspace.run();
          this.m_renderProxy.status.povNumber = this.m_rspace.getPOVNumber();
        }
      }
    }

    if (this.m_processUpdate) {
      this.m_renderer.updateAllProcess();
    }

    if (this.m_mouseTestBoo && !this.m_evtFlowEnabled) {
      if (mouseEventEnabled) {
        this.runMouseTest(1, 0);
      } else if (this.m_evt3DCtr != null) {
        this.m_evt3DCtr.mouseOutEventTarget();
      }
    }
  } // 运行渲染可见性裁剪测试，射线检测等空间管理机制


  cullingTest() {
    if (this.m_rspace != null) {
      this.m_rspace.run();
      this.m_renderProxy.status.povNumber = this.m_rspace.getPOVNumber();
    }

    this.m_cullingTestBoo = false;
  } // 鼠标位置的射线拾取测试


  mouseRayTest() {
    if (this.m_rspace != null) {
      this.m_renderProxy.getMouseXYWorldRay(this.m_mouse_rlpv, this.m_mouse_rltv);
      this.m_rspace.rayTest(this.m_mouse_rlpv, this.m_mouse_rltv);
    }
  }

  runRenderNodes(nodes) {
    if (nodes != null) {
      // console.log("CoSC runRenderNodes(), nodes.length: ", nodes.length);
      for (let i = 0; i < nodes.length; ++i) {
        nodes[i].render();
      }
    }
  }

  addRenderNodes(node, nodes) {
    for (let i = 0; i < nodes.length; ++i) {
      if (node == nodes[i]) {
        return;
      }
    }

    nodes.push(node);
  }

  prependRenderNode(node) {
    if (node != null && node != this) {
      if (this.m_prependNodes == null) this.m_prependNodes = [];
      this.addRenderNodes(node, this.m_prependNodes);
    }
  }

  appendRenderNode(node) {
    if (node != null && node != this) {
      if (this.m_appendNodes == null) this.m_appendNodes = [];
      let ls = this.m_appendNodes;

      for (let i = 0; i < ls.length; ++i) {
        if (node == ls[i]) {
          return;
        }
      }

      ls.push(node);
    }
  }

  removeRenderNode(node) {
    if (node != null) {
      let ls = this.m_prependNodes;

      if (ls != null) {
        for (let i = 0; i < ls.length; ++i) {
          if (node == ls[i]) {
            ls.splice(i, 1);
            break;
          }
        }
      }
    }
  }
  /**
   * run all renderer processes in the renderer instance
   */


  run(autoCycle = true) {
    if (this.m_enabled) {
      if (autoCycle && this.m_autoRunning) {
        if (this.m_runFlag != 1) this.update();
        this.m_runFlag = 2;
      }

      this.runnableQueue.run();
      this.runRenderNodes(this.m_prependNodes);

      if (this.m_subscListLen > 0) {
        for (let i = 0; i < this.m_processidsLen; ++i) {
          this.m_renderer.runAt(this.m_processids[i]);
        }
      } else {
        this.m_renderer.run();
      }

      this.runRenderNodes(this.m_appendNodes);

      if (autoCycle) {
        this.runEnd();
      }
    }
  }
  /**
   * run the specific renderer process by its index in the renderer instance
   * @param index the renderer process index in the renderer instance
   */


  runAt(index) {
    if (this.m_enabled) {
      this.m_renderer.runAt(this.m_processids[index]);
    }
  }

  runEnd() {
    if (this.m_evt3DCtr != null) {
      this.m_evt3DCtr.runEnd();
    }

    this.m_rcontext.runEnd();

    if (this.m_rspace != null) {
      this.m_rspace.runEnd();
    }

    if (this.m_autoRunning) {
      this.m_runFlag = -1;
    }

    if (this.m_accessor != null) {
      this.m_accessor.renderEnd(this);
    }
  }

  render() {}

  renderFlush() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.flush();
    }
  }

  updateCamera() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCamera();
    }
  }

  destroy() {
    this.runnableQueue.destroy();
  }

}

RendererScene.s_uid = 0;
exports.default = RendererScene;

/***/ }),

/***/ "b2a0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const TextureDataUnit_1 = __webpack_require__("bd49");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

const PNGParseTask_1 = __webpack_require__("80fa");

class PNGParserListerner {
  constructor(unitPool, threadSchedule, module, receiverSchedule) {
    this.m_parseTask = null;
    this.m_moduleUrl = module.url;
    this.m_unitPool = unitPool;
    this.m_threadSchedule = threadSchedule;
    this.m_receiverSchedule = receiverSchedule;
  }

  addUrlToTask(url) {
    if (!this.m_unitPool.hasUnitByUrl(url)) {
      if (this.m_parseTask == null) {
        // 创建ctm 加载解析任务
        let parseTask = new PNGParseTask_1.PNGParseTask(this.m_moduleUrl); // 绑定当前任务到多线程调度器

        this.m_threadSchedule.bindTask(parseTask);
        parseTask.setListener(this);
        this.m_parseTask = parseTask;
      }

      new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
        DivLog_1.default.ShowLogOnce("正在解析png数据...");
        this.m_parseTask.addBinaryData(new Uint8Array(buf), url);
      }, (progress, url) => {
        let k = Math.round(100 * progress);
        DivLog_1.default.ShowLogOnce("obj file loading " + k + "%");
      }, (status, url) => {
        console.error("load png img data error, url: ", url);
      });
    }
  } // 一个任务数据处理完成后的侦听器回调函数


  pngParseFinish(pngData, des) {
    // console.log("ObjParserListerner::ctmParseFinish(), models: ", models, ", url: ", url);
    if (this.m_unitPool.hasUnitByUrl(des.url)) {
      let unit = this.m_unitPool.getUnitByUrl(des.url);

      if (unit != null) {
        unit.lossTime = Date.now() - unit.lossTime;
        unit.data.dataFormat = TextureDataUnit_1.DataFormat.Png;
        unit.data.desList = [des];
        unit.data.imageDatas = [pngData];
        TextureDataUnit_1.DataUnitLock.lockStatus = 209;
        unit.toCpuPhase();

        if (unit.immediate) {
          // console.log("geom data receive at once.");
          this.m_receiverSchedule.testUnit(unit);
        }
      }
    }
  }

  destroy() {
    if (this.m_parseTask != null) {
      this.m_parseTask.destroy();
      this.m_parseTask = null;
    }

    this.m_unitPool = null;
    this.m_threadSchedule = null;
    this.m_receiverSchedule = null;
  }

}

exports.PNGParserListerner = PNGParserListerner;

/***/ }),

/***/ "b30a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MaterialConst_1 = __importDefault(__webpack_require__("644c"));
/**
 * 作为渲染器运行时 material shader 资源的管理类
 * renderer runtime material shader resource manager
 */


class RenderShader {
  constructor(rcuid, gl, adapter, shdProgramBuilder) {
    this.m_sharedUniformList = [];
    this.m_unlocked = true;
    this.m_texUnlocked = false;
    this.m_preuid = -1;
    this.m_currShd = null;
    this.m_fragOutputTotal = 1;
    this.m_rcuid = -1;
    this.m_rc = null;
    this.m_gpuProgram = null;
    this.m_adapter = null;
    this.m_guniform = null; // material相关的uniform,默认不包括transform相关的信息

    this.m_uniform = null; // 只有transform相关的信息uniform

    this.m_transformUniform = null;
    this.m_shdProgramBuilder = null; // 用于记录 renderState(低10位)和ColorMask(高10位) 的状态组合

    this.drawFlag = -1;
    this.__$globalUniform = null;
    this.m_rcuid = rcuid;
    this.m_rc = gl;
    this.m_adapter = adapter;
    this.m_shdProgramBuilder = shdProgramBuilder;
  }

  createResByParams3(resUid, param0, param1, param2) {
    return false;
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_rc;
  }
  /**
   * @returns return current gpu shader  program
   */


  getGPUProgram() {
    return this.m_gpuProgram;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  useTransUniform(transUniform) {
    if (this.m_transformUniform != transUniform) {
      this.m_transformUniform = transUniform;
      transUniform.use(this);
    }
  }

  useUniform(uniform) {
    if (this.m_uniform != uniform) {
      this.m_uniform = uniform;
      uniform.use(this);
    }
  }

  updateUniform(uniform) {
    if (uniform != null) {
      uniform.use(this);
    }
  }

  unlock() {
    this.m_unlocked = true;
    this.__$globalUniform = null;
  }

  isUnLocked() {
    return this.m_unlocked;
  }

  lock() {
    this.m_unlocked = false;
  }

  textureUnlock() {
    this.m_texUnlocked = true;
  }

  isTextureUnLocked() {
    return this.m_texUnlocked;
  }

  textureLock() {
    this.m_texUnlocked = false;
  }

  setSharedUniformByShd(shd, uniform) {
    this.m_sharedUniformList[shd.getUid()] = uniform;
  }

  getSharedUniformByShd(shd) {
    return this.m_sharedUniformList[shd.getUid()];
  }

  getCurrFragOutputTotal() {
    return this.m_fragOutputTotal;
  }
  /**
   * check whether the renderer runtime resource(by renderer runtime resource unique id) exists in the current renderer context
   * @param resUid renderer runtime resource unique id
   * @returns has or has not resource by unique id
   */


  hasResUid(resUid) {
    // return this.m_shdList[resUid] != null;
    return this.m_shdProgramBuilder.hasUid(resUid);
  }
  /**
   * bind the renderer runtime resource(by renderer runtime resource unique id) to the current renderer context
   * @param resUid renderer runtime resource unique id
   */


  bindToGpu(resUid) {
    //if (this.m_unlocked && resUid > -1 && resUid < this.m_shdListLen) {
    if (this.m_unlocked && this.m_shdProgramBuilder.containsUid(resUid)) {
      if (this.m_preuid != resUid) {
        this.m_preuid = resUid; //let shd: IShdProgram = this.m_shdList[resUid];

        let shd = this.m_shdProgramBuilder.findShdProgramByUid(resUid);
        this.m_fragOutputTotal = shd.getFragOutputTotal();

        if (this.m_fragOutputTotal != this.getActiveAttachmentTotal()) {
          //if(RendererDevice.SHOWLOG_ENABLED) {
          console.log("shd.getUniqueShaderName(): string: " + shd.getUniqueShaderName());
          console.log("this.m_fragOutputTotal: " + this.m_fragOutputTotal + ", rc.getActiveAttachmentTotal(): " + this.getActiveAttachmentTotal());
          console.error("Error: MRT output amount is not equal to current shader( " + shd.toString() + " ) frag shader output amount !!!"); //}
        }

        this.m_gpuProgram = shd.getGPUProgram();
        this.m_rc.useProgram(this.m_gpuProgram);
        shd.useTexLocation(); //console.log("use a new shader uid: ",shd.getUid(),",uns: ",shd.getUniqueShaderName());
        // use global shared uniform

        let uniform = this.m_sharedUniformList[shd.getUid()]; //  let boo: boolean = false;
        //  if((uniform as any).uns == "u_projMat") {
        //      console.log("only use projMat begin");
        //      boo = true;
        //  }

        this.m_guniform = uniform;

        while (uniform != null) {
          uniform.use(this);
          uniform = uniform.next;
        }

        this.m_currShd = shd; //  if( boo ) {
        //      console.log("only use projMat end");
        //  }
      } else if (this.m_guniform == null && this.m_currShd != null) {
        let uniform = this.m_sharedUniformList[this.m_currShd.getUid()];
        this.m_guniform = uniform;

        while (uniform != null) {
          uniform.use(this);
          uniform = uniform.next;
        }
      }
    }
  }
  /**
   * get system gpu context resource buf
   * @param resUid renderer runtime resource unique id
   * @returns system gpu context resource buf
   */


  getGpuBuffer(resUid) {
    return null;
  }

  getCurrentShd() {
    return this.m_currShd;
  }

  getCurrentShdUid() {
    return this.m_preuid;
  }

  resetUniform() {
    this.m_uniform = null;
    this.m_transformUniform = null;
    this.m_guniform = null;
  }
  /**
   * frame begin run this function
   */


  renderBegin() {
    this.m_fragOutputTotal = 1;
    this.m_preuid = -1;
    this.m_currShd = null;
    this.drawFlag = -1; //this.resetUniform();
  }
  /**
   * frame update
   */


  update() {}

  destroy() {
    this.m_rc = null;
    this.m_adapter = null;
  }

  useUniformToCurrentShd(uniform) {
    if (this.m_uniform != uniform) {
      this.m_uniform != uniform;
      uniform.useByShd(this, this.m_currShd);
    }
  }

  useUniform2ToCurrentShd(uniform, transUniform) {
    if (this.m_uniform != uniform) {
      this.m_uniform != uniform;
      uniform.useByShd(this, this.m_currShd);
    }

    if (this.m_transformUniform != transUniform) {
      this.m_transformUniform != transUniform;
      transUniform.useByShd(this, this.m_currShd);
    }
  }
  /**
   * 仅仅更新单个matrix4的uniforms数据
  */


  useUniformMat4(ult, mat4f32Arr) {
    this.m_rc.uniformMatrix4fv(ult, false, mat4f32Arr);
  }

  useUniformV2(ult, type, f32Arr, dataSize, offset) {
    const mc = MaterialConst_1.default;
    const rc = this.m_rc;

    switch (type) {
      case mc.SHADER_MAT4:
        rc.uniformMatrix4fv(ult, false, f32Arr, offset, dataSize * 16);
        break;

      case mc.SHADER_MAT3:
        rc.uniformMatrix3fv(ult, false, f32Arr, 0, dataSize * 9);
        break;

      case mc.SHADER_VEC4FV:
        //console.log("MaterialConst.SHADER_VEC4FV dataSize: ",dataSize);
        //console.log(f32Arr);
        rc.uniform4fv(ult, f32Arr, offset, dataSize * 4);
        break;

      case mc.SHADER_VEC3FV:
        rc.uniform3fv(ult, f32Arr, offset, dataSize * 3);
        break;

      case mc.SHADER_VEC4:
        rc.uniform4f(ult, f32Arr[0], f32Arr[1], f32Arr[2], f32Arr[3]);
        break;

      case mc.SHADER_VEC3:
        rc.uniform3f(ult, f32Arr[0], f32Arr[1], f32Arr[2]);
        break;

      case mc.SHADER_VEC2:
        rc.uniform2f(ult, f32Arr[0], f32Arr[1]);
        break;

      default:
        break;
    }
  }

  useUniformV1(ult, type, f32Arr, dataSize) {
    const mc = MaterialConst_1.default;
    const rc = this.m_rc;

    switch (type) {
      case mc.SHADER_MAT4:
        rc.uniformMatrix4fv(ult, false, f32Arr);
        break;

      case mc.SHADER_MAT3:
        rc.uniformMatrix3fv(ult, false, f32Arr);
        break;

      case mc.SHADER_VEC4FV:
        rc.uniform4fv(ult, f32Arr, dataSize * 4);
        break;

      case mc.SHADER_VEC3FV:
        rc.uniform3fv(ult, f32Arr, dataSize * 3);
        break;

      case mc.SHADER_VEC4:
        rc.uniform4f(ult, f32Arr[0], f32Arr[1], f32Arr[2], f32Arr[3]);
        break;

      case mc.SHADER_VEC3:
        rc.uniform3f(ult, f32Arr[0], f32Arr[1], f32Arr[2]);
        break;

      case mc.SHADER_VEC2:
        rc.uniform2f(ult, f32Arr[0], f32Arr[1]);
        break;

      default:
        break;
    }
  }

  getActiveAttachmentTotal() {
    return this.m_adapter.getActiveAttachmentTotal();
  }

}

exports.default = RenderShader;

/***/ }),

/***/ "b3bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ShaderUniformData {
  constructor() {
    this.uns = "";
    this.types = null;
    this.uniformSize = 0;
    this.uniformNameList = null;
    this.locations = null;
    this.dataList = null;
    this.calcModels = null;
    this.always = true;
    this.next = null;
  } // for fast data's operation


  getDataRefFromUniformName(ns) {
    if (this.uniformNameList != null) {
      let list = this.uniformNameList;
      let len = list.length;

      for (let i = 0; i < len; ++i) {
        if (ns == list[i]) {
          return this.dataList[i];
        }
      }
    }

    return null;
  } // for fast data's operation


  setDataRefFromUniformName(ns, dataRef) {
    if (this.uniformNameList != null) {
      let list = this.uniformNameList;
      let len = list.length;

      for (let i = 0; i < len; ++i) {
        if (ns == list[i]) {
          this.dataList[i] = dataRef;
          break;
        }
      }
    }
  } //


  copyDataFromProbe(probe) {
    this.types = [];

    for (let i = 0; i < probe.uniformsTotal; ++i) {
      this.types.push(probe.uniformTypes[i]);
    }

    this.uniformSize = probe.uniformsTotal;
  }

  destroy() {
    let i = 0;
    let len = this.dataList.length;

    for (; i < len; ++i) {
      this.dataList[i] = null;
    }

    if (this.calcModels != null) {
      len = this.calcModels.length;

      for (i = 0; i < len; ++i) {
        this.calcModels[i].destroy();
        this.calcModels[i] = null;
      }
    }

    this.dataList = null;
    this.types = null;
    this.locations = null;
    this.calcModels = null;
  }

}

exports.default = ShaderUniformData;

/***/ }),

/***/ "b406":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * (引擎)数据/资源协同空间运行时，用以管理运行时的相关程序或功能
 */

class CoRuntime {
  constructor() {}
  /**
   */


  initialize() {}
  /**
   * 通过唯一标识名添加一个动态模块, 依赖关系管理器会自动加载添加其他被依赖的模块
   * @param uniqueName 主线程功能模块唯一标识名
   */


  addModuleByUniqueName(uniqueName) {}
  /**
   * 通过唯一标识名启动一个动态模块
   * @param uniqueName 主线程功能模块唯一标识名
   */


  startupModuleByUniqueName(uniqueName) {}

  destroy() {}

}

exports.CoRuntime = CoRuntime;

/***/ }),

/***/ "b627":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const FBXBufferLoader_1 = __webpack_require__("026b");

const SceneNode_1 = __webpack_require__("7577");

class FBXSceneNode extends SceneNode_1.SceneNode {
  constructor() {
    super();
    this.m_mi = 0;
  }

  load(urls) {
    super.load(urls);
    this.loadFBXBySteps(urls[0]);
  }

  loadFBXBySteps(url) {
    this.m_partsTotal = 0;
    this.m_showTotal = 0;
    let fbxBufLoader = new FBXBufferLoader_1.FBXBufferLoader();
    this.m_fbxBufLoader = fbxBufLoader;
    fbxBufLoader.loadBySteps(url, (model, bufObj, index, total, url) => {
      this.m_modelsTotal = total;
      this.m_waitPartsTotal = total;
      this.initEntity(model, bufObj.transform, index);

      if (index + 1 == total) {
        this.m_waitPartsTotal = 0;
      }
    }, (progress, url) => {
      let k = Math.round(100 * progress);
      this.showInfo("fbx file loading " + k + "%");
    });
  }

  mouseDown(evt) {// console.log("mouse down");
    // this.m_fbxBufLoader.parseModelAt( this.m_mi );
    // this.m_mi ++;
  }

  loadFBX() {
    let url = "static/assets/fbx/test01.fbx"; // url = "static/assets/fbx/box.fbx";
    // url = "static/private/fbx/test_500W.fbx";
    // url = "static/private/fbx/Samba_Dancing.fbx";

    let fbxBufLoader = new FBXBufferLoader_1.FBXBufferLoader();
    fbxBufLoader.load(url, (modelMap, url) => {
      // this.m_scaleV.setXYZ(-2.0, -2.0, 2.0);
      // this.m_scaleV.setXYZ(56.0, 56.0, 56.0);
      // this.m_scaleV.setXYZ(2.0, 2.0, 2.0);
      // console.log("loadFBX(), modelMap: ",modelMap);
      this.m_partsTotal = 0;

      for (let [key, value] of modelMap) {
        this.m_partsTotal++;
        this.initEntity(value);
      }

      console.log("partsTotal: ", this.m_partsTotal); // 

      this.m_waitPartsTotal = 0;
    });
  }

}

exports.FBXSceneNode = FBXSceneNode;

/***/ }),

/***/ "b9b5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const DashedLineMesh_1 = __importDefault(__webpack_require__("9c3c"));

const DisplayEntity_1 = __importDefault(__webpack_require__("402a"));

const Color4_1 = __importDefault(__webpack_require__("3930"));

const Line3DMaterial_1 = __importDefault(__webpack_require__("32cc"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class Axis3DEntity extends DisplayEntity_1.default {
  constructor() {
    super(); // 用于射线检测

    this.rayTestRadius = 8.0;
    this.colorX = new Color4_1.default(1.0, 0.0, 0.0, 1.0);
    this.colorY = new Color4_1.default(0.0, 1.0, 0.0, 1.0);
    this.colorZ = new Color4_1.default(0.0, 0.0, 1.0, 1.0);
    this.m_posarr = [0, 0, 0, 100.0, 0, 0, 0, 0, 0, 0, 100.0, 0, 0, 0, 0, 0, 0, 100.0];
  }

  setLineWidth(lineW) {//if(this.getMesh())
    //{
    //    //this.getMesh().vbuf.lineWidth = lineW;
    //}
  }

  createMaterial() {
    if (this.getMaterial() == null) {
      let cm = new Line3DMaterial_1.default();
      this.setMaterial(cm);
    }
  }

  __activeMesh(material) {
    if (this.getMesh() == null) {
      let colorarr = [this.colorX.r, this.colorX.g, this.colorX.b, this.colorX.r, this.colorX.g, this.colorX.b, this.colorY.r, this.colorY.g, this.colorY.b, this.colorY.r, this.colorY.g, this.colorY.b, this.colorZ.r, this.colorZ.g, this.colorZ.b, this.colorZ.r, this.colorZ.g, this.colorZ.b];
      let mesh = new DashedLineMesh_1.default();
      mesh.rayTestRadius = this.rayTestRadius;
      mesh.vbWholeDataEnabled = false;
      mesh.setBufSortFormat(material.getBufSortFormat());
      mesh.initialize(this.m_posarr, colorarr);
      this.setMesh(mesh);
    }
  }
  /**
   * initialize the axis entity mesh and geometry data
   * @param axisSize the X/Y/Z axis length
   */


  initialize(axisSize = 100.0) {
    if (axisSize < 1) {
      axisSize = 1;
    }

    this.m_posarr[3] = axisSize;
    this.m_posarr[10] = axisSize;
    this.m_posarr[17] = axisSize;
    this.createMaterial();
    this.activeDisplay();
  }
  /**
   * initialize the axis entity mesh and geometry data
   * @param sizeX the X axis length
   * @param sizeY the Y axis length
   * @param sizeZ the Z axis length
   */


  initializeSizeXYZ(sizeX, sizeY, sizeZ) {
    this.m_posarr[3] = sizeX;
    this.m_posarr[10] = sizeY;
    this.m_posarr[17] = sizeZ;
    this.createMaterial();
    this.activeDisplay();
  }

  initializeCorssSizeXYZ(sizeX, sizeY, sizeZ) {
    //  this.m_posarr[3] = sizeX;
    //  this.m_posarr[10] = sizeY;
    //  this.m_posarr[17] = sizeZ;
    sizeX *= 0.5;
    sizeY *= 0.5;
    sizeZ *= 0.5;
    this.m_posarr[0] = -sizeX;
    this.m_posarr[7] = -sizeY;
    this.m_posarr[14] = -sizeZ;
    this.m_posarr[3] = sizeX;
    this.m_posarr[10] = sizeY;
    this.m_posarr[17] = sizeZ;
    this.createMaterial();
    this.activeDisplay();
  }
  /**
   * initialize the cross axis entity mesh and geometry data
   * @param axisSize the X/Y/Z axis length
   */


  initializeCross(axisSize = 100.0, offset = null) {
    if (axisSize < 2) {
      axisSize = 2;
    }

    axisSize *= 0.5;

    if (offset == null) {
      offset = new Vector3D_1.default();
    }

    this.m_posarr[0] = -axisSize + offset.x;
    this.m_posarr[7] = -axisSize + offset.y;
    this.m_posarr[14] = -axisSize + offset.z;
    this.m_posarr[3] = axisSize + offset.x;
    this.m_posarr[10] = axisSize + offset.y;
    this.m_posarr[17] = axisSize + offset.z;
    this.createMaterial();
    this.activeDisplay();
  }

  toString() {
    return "Axis3DEntity(name=" + this.name + ",uid = " + this.getUid() + ", rseFlag = " + this.__$rseFlag + ")";
  }

}

exports.default = Axis3DEntity;

/***/ }),

/***/ "baae":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class FrameBufferType {}

FrameBufferType.FRAMEBUFFER = 71;
FrameBufferType.DRAW_FRAMEBUFFER = 72;
FrameBufferType.READ_FRAMEBUFFER = 73;
exports.default = FrameBufferType;

/***/ }),

/***/ "badb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

const EvtNode_1 = __importDefault(__webpack_require__("ee5a"));

class MouseEvt3DDispatcher {
  constructor() {
    this.m_evtNodes = null;
    this.m_evtNodesLen = 24;
    this.uuid = "";
    this.data = null;
    this.currentTarget = null;
    this.enabled = true;
    this.m_evtNodesLen = MouseEvent_1.default.GetMouseEvtTypeValuesTotal();
    this.m_evtNodes = new Array(this.m_evtNodesLen);
  }

  getClassType() {
    return MouseEvent_1.default.EventClassType;
  }

  destroy() {
    console.log("VVVVVVVVVV this.m_evtNodesLen: ", this.m_evtNodesLen);

    for (let i = 0; i < this.m_evtNodesLen; ++i) {
      if (this.m_evtNodes[i] != null) {
        this.m_evtNodes[i].destroy();
      }
    }

    this.data = null;
    this.currentTarget = null;
  } // @return      1 is send evt yes,0 is send evt no


  dispatchEvt(evt) {
    if (this.enabled && evt != null) {
      if (this.uuid != "") evt.uuid = this.uuid;
      if (this.data != null) evt.data = this.data;
      if (this.currentTarget != null) evt.currentTarget = this.currentTarget;
      let t = evt.type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        if (this.m_evtNodes[t] != null) return this.m_evtNodes[t].dispatch(evt);
      } else {
        console.log("MouseEvt3DDispatcher::dispatchEvt(), Warn: undefined Event type.");
      }
    }

    return 0;
  } //@return if the evt can be dispatched in this node,it returns 1,otherwise it returns 0


  passTestEvt(evt) {
    if (evt != null) {
      let t = evt.type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        return this.m_evtNodes[t].passTestEvt(evt);
      }
    }

    return 0;
  } //@return if the evt phase is in this node,it returns 1,otherwise it returns 0


  passTestPhase(phase) {
    let len = MouseEvent_1.default.GetMouseEvtTypeValuesTotal();

    for (let i = 0; i < len; ++i) {
      if (this.m_evtNodes[i] != null && this.m_evtNodes[i].passTestPhase(phase) == 1) {
        return 1;
      }
    }

    return 0;
  } // 注意: 一个 target 只能有一个回调函授对应一个类型的事件


  addEventListener(type, target, func, captureEnabled = true, bubbleEnabled = false) {
    if (func != null && target != null) {
      let t = type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        //(capture phase),2(bubble phase)
        let phase = 0;

        if (captureEnabled != bubbleEnabled) {
          if (captureEnabled) {
            phase = 1;
          } else {
            phase = 2;
          }
        }

        if (this.m_evtNodes[t] != null) {
          this.m_evtNodes[t].addListener(target, func, phase);
        } else {
          this.m_evtNodes[t] = new EvtNode_1.default();
          this.m_evtNodes[t].addListener(target, func, phase);
        }
      } else {
        console.log("MouseEvt3DDispatcher::addEventListener(), Warn: undefined Event type.");
      }
    }
  }

  removeEventListener(type, target, func) {
    if (func != null && target != null) {
      let t = type - MouseEvent_1.default.GetMouseEvtTypeValueBase();

      if (t >= 0 && t < MouseEvent_1.default.GetMouseEvtTypeValuesTotal()) {
        if (this.m_evtNodes[t] != null) {
          this.m_evtNodes[t].removeListener(target, func);
        }
      } //  else
      //  {
      //      console.log("MouseEvt3DDispatcher::removeEventListener(), Warn: undefined Event type.");
      //  }

    }
  }

}

exports.default = MouseEvt3DDispatcher;

/***/ }),

/***/ "bbf4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RendererConst {}

RendererConst.CAMERA_VISIBLE_ENABLE = 0;
RendererConst.CAMERA_VISIBLE_DISABLE = 1;
exports.default = RendererConst;

/***/ }),

/***/ "bcac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class CameraDragSwinger {
  constructor() {
    this.m_stage3D = null;
    this.m_camera = null;
    this.m_mouseX = 0.0;
    this.m_mouseY = 0.0;
    this.m_enabled = false;
    this.m_rotationSpeed = 0.0;
    this.m_aotuRotationDelay = 100.0;
    this.autoRotationEnabled = false;
    this.autoRotationSpeed = 0.2;
    this.rotationAttenuationEnabled = false;
    this.rotationSpeed = 0.2;
  }

  initialize(stage3D, camera) {
    if (this.m_stage3D == null) {
      this.m_stage3D = stage3D;
      this.m_camera = camera;
    }
  }

  attach() {
    this.m_mouseX = this.m_stage3D.mouseX;
    this.m_mouseY = this.m_stage3D.mouseY;
    this.m_enabled = true;
    this.m_aotuRotationDelay = 100;
  }

  detach() {
    this.m_enabled = false;
  }

  runWithYAxis() {
    this.runWithAxis(Vector3D_1.default.Y_AXIS);
  }

  runWithZAxis() {
    this.runWithAxis(Vector3D_1.default.Z_AXIS);
  }
  /*
      if (this.m_enabled) {
          let dx: number = this.m_mouseX - this.m_stage3D.mouseX;
          let dy: number = this.m_mouseY - this.m_stage3D.mouseY;
          let abs_dx: number = Math.abs(dx);
          let abs_dy: number = Math.abs(dy);
          if (abs_dx > abs_dy) {
              this.m_rotationSpeed = dx * this.rotationSpeed;
              if (abs_dx > 0.5) {
                  (this.m_camera as any).swingHorizontalWithAxis(this.m_rotationSpeed, Vector3D.Y_AXIS);
              }
          }
          else {
              this.m_rotationSpeed = 0.0;
              if (abs_dy > 0.5) {
                  (this.m_camera as any).swingVertical(-dy * this.rotationSpeed);
              }
          }
          this.m_mouseX = this.m_stage3D.mouseX;
          this.m_mouseY = this.m_stage3D.mouseY;
      }
      else if( this.autoRotationEnabled ) {
          if(this.m_aotuRotationDelay < 0) {
              (this.m_camera as any).swingHorizontalWithAxis(this.autoRotationSpeed, Vector3D.Y_AXIS);
          }
          else {
              this.m_aotuRotationDelay --;
          }
      }
  }
  //*/


  runWithAxis(axis) {
    if (this.m_enabled) {
      let dx = this.m_mouseX - this.m_stage3D.mouseX;
      let dy = this.m_mouseY - this.m_stage3D.mouseY;
      let abs_dx = Math.abs(dx);
      let abs_dy = Math.abs(dy);

      if (abs_dx > abs_dy) {
        if (abs_dx > 0.5) {
          this.m_camera.swingHorizontalWithAxis(dx * 0.2, axis);
        }
      } else {
        if (abs_dy > 0.5) {
          this.m_camera.swingVertical(dy * -0.2);
        }
      }

      this.m_mouseX = this.m_stage3D.mouseX;
      this.m_mouseY = this.m_stage3D.mouseY;
    } else if (this.autoRotationEnabled) {
      if (this.m_aotuRotationDelay < 0) {
        this.m_camera.swingHorizontalWithAxis(this.autoRotationSpeed, axis);
      } else {
        this.m_aotuRotationDelay--;
      }
    }
  }

  runWithCameraAxis() {
    if (this.m_enabled) {
      let dx = this.m_mouseX - this.m_stage3D.mouseX;
      let dy = this.m_mouseY - this.m_stage3D.mouseY;
      let abs_dx = Math.abs(dx);
      let abs_dy = Math.abs(dy);

      if (abs_dx > abs_dy) {
        if (abs_dx > 0.5) {
          this.m_camera.swingHorizontal(dx * 0.2);
        }
      } else {
        if (abs_dy > 0.5) {
          this.m_camera.swingVertical(dy * -0.2);
        }
      }

      this.m_mouseX = this.m_stage3D.mouseX;
      this.m_mouseY = this.m_stage3D.mouseY;
    } else if (this.autoRotationEnabled) {
      if (this.m_aotuRotationDelay < 0) {
        this.m_camera.swingHorizontal(this.autoRotationSpeed);
      } else {
        this.m_aotuRotationDelay--;
      }
    }
  }

}

exports.CameraDragSwinger = CameraDragSwinger;

/***/ }),

/***/ "bd49":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

exports.DataFormat = DataUnit_1.DataFormat;
exports.DataUnitLock = DataUnit_1.DataUnitLock;
exports.DataUnit = DataUnit_1.DataUnit;

class TextureDataContainer {
  constructor() {
    this.dataFormat = DataUnit_1.DataFormat.Png;
    this.desList = null;
    this.images = null;
    this.imageDatas = null;
  }

  setFormatBUrl(url) {}

}

exports.TextureDataContainer = TextureDataContainer;

class TextureDataUnit extends DataUnit_1.DataUnit {
  constructor() {
    super();
    this.data = null;
    this.dataClass = DataUnit_1.DataClass.Texture;
  }

}

exports.TextureDataUnit = TextureDataUnit;

/***/ }),

/***/ "c120":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// Ray pick selection obj

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class RaySelectedNode {
  constructor() {
    this.entity = null; // object space hit position

    this.lpv = new Vector3D_1.default(); // world space hit position

    this.wpv = new Vector3D_1.default();
    this.dis = 0.0;
    this.flag = 0;
  }

}

exports.default = RaySelectedNode;

/***/ }),

/***/ "c164":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class MathShaderCode {
  constructor() {}

}

MathShaderCode.BasePredefined = `
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
`;
exports.MathShaderCode = MathShaderCode;

class ShaderCode {
  constructor() {}

}

ShaderCode.BasePredefined = `
vec4 localPosition = vec4(0.0,0.0,0.0,1.0);
vec4 worldPosition = vec4(0.0,0.0,0.0,1.0);
// view space position
vec4 viewPosition = vec4(0.0,0.0,0.0,1.0);
vec3 worldNormal = vec3(0.0, 0.0, 1.0);
`;
ShaderCode.FragPredefined = `
`;
ShaderCode.FragDefined = `
`;
ShaderCode.VertPredefined = `
// origin world position
vec4 oWorldPosition = vec4(0.0,0.0,0.0,1.0);
`;
ShaderCode.VertDefined = `
`;
exports.ShaderCode = ShaderCode;

/***/ }),

/***/ "c497":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class RendererParam {
  constructor(div = null) {
    this.m_matrix4AllocateSize = 8192;
    this.m_mainDiv = null;
    this.m_renderContextAttri = {
      depth: true,
      premultipliedAlpha: false,
      alpha: true,
      antialias: false,
      stencil: false,
      preserveDrawingBuffer: true,
      powerPreference: "high-performance" //"default"

    };
    this.m_tickUpdateTime = 20; // delay 50 ms

    this.m_polygonOffsetEnabled = false;
    this.m_ditherEnabled = false; // display 3d view buf size auto sync window size

    this.autoSyncRenderBufferAndWindowSize = true;
    this.maxWebGLVersion = 2;
    this.cameraPerspectiveEnabled = true; // event flow control enable

    this.evtFlowEnabled = false; // x: fov, y: near, z: far

    this.camProjParam = new Vector3D_1.default(45.0, 10.0, 5000.0);
    this.camPosition = new Vector3D_1.default(2000.0, 2000.0, 2000.0);
    this.camLookAtPos = new Vector3D_1.default(0.0, 0.0, 0.0);
    this.camUpDirect = new Vector3D_1.default(0.0, 1.0, 0.0);
    this.batchEnabled = true;
    this.processFixedState = false;
    this.m_mainDiv = div;
    this.autoSyncRenderBufferAndWindowSize = div == null;
  }
  /**
   * @param   tickUpdateTime default value 50 ms delay
   */


  setTickUpdateTime(tickUpdateTime) {
    tickUpdateTime = Math.round(tickUpdateTime);
    this.m_tickUpdateTime = tickUpdateTime > 5 ? tickUpdateTime : 5;
  }

  getTickUpdateTime() {
    return this.m_tickUpdateTime;
  }

  setPolygonOffsetEanbled(polygonOffsetEnabled) {
    this.m_polygonOffsetEnabled = polygonOffsetEnabled;
  }

  getPolygonOffsetEanbled() {
    return this.m_polygonOffsetEnabled;
  }

  setDitherEanbled(ditherEnabled) {
    this.m_ditherEnabled = ditherEnabled;
  }

  getDitherEanbled() {
    return this.m_ditherEnabled;
  }

  getDiv() {
    return this.m_mainDiv;
  }

  getRenderContextAttri() {
    return this.m_renderContextAttri;
  }

  setAttriDepth(boo) {
    this.m_renderContextAttri.depth = boo;
  }

  setAttriStencil(boo) {
    this.m_renderContextAttri.stencil = boo;
  }

  setAttriAlpha(boo) {
    this.m_renderContextAttri.alpha = boo;
  }

  setAttriPremultipliedAlpha(boo) {
    this.m_renderContextAttri.premultipliedAlpha = boo;
  }

  setAttriAntialias(boo) {
    this.m_renderContextAttri.antialias = boo;
  }

  setAttripreserveDrawingBuffer(boo) {
    this.m_renderContextAttri.preserveDrawingBuffer = boo;
  }

  setAttriHightPowerPreference(boo) {
    this.m_renderContextAttri.powerPreference = boo ? "high-performance" : "default";
  }

  setMatrix4AllocateSize(total) {
    if (total < 1024) {
      total = 1024;
    }

    this.m_matrix4AllocateSize = total;
  }

  getMatrix4AllocateSize() {
    return this.m_matrix4AllocateSize;
  }
  /**
   * @param fov_angle_degree the default value is 45.0
   * @param near the default value is 10.0
   * @param far the default value is 5000.0
   */


  setCamProject(fov_angle_degree, near, far) {
    if (near >= far) {
      throw Error("Error Camera cear > far !!!");
    }

    this.camProjParam.setTo(fov_angle_degree, near, far);
  } //  setCamOrthoProject(bottom:number, top:number, left:number, right:number, near:number, far:number):void
  //  {
  //      if(near >= far)
  //      {
  //          throw Error("Error Camera cear > far !!!");
  //      }
  //      this.camProjParam.setTo(0.0,near,far);
  //      this.camOrthoParam.x = bottom;
  //      this.camOrthoParam.y = top;
  //      this.camOrthoParam.z = left;
  //      this.camOrthoParam.w = right;
  //  }


  setCamPosition(px, py, pz) {
    this.camPosition.setTo(px, py, pz);
  }

  setCamLookAtPos(px, py, pz) {
    this.camLookAtPos.setTo(px, py, pz);
  }

  setCamUpDirect(px, py, pz) {
    this.camUpDirect.setTo(px, py, pz);
  }

}

exports.default = RendererParam;

/***/ }),

/***/ "c51d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

const Plane_1 = __importDefault(__webpack_require__("e214"));

const AABB_1 = __importDefault(__webpack_require__("fecb"));

class CameraBase {
  constructor() {
    this.version = 0;
    this.matUProbe = null;
    this.ufrustumProbe = null;
    this.uniformEnabled = false;
    this.name = "Camera"; //

    this.m_tempV = new Vector3D_1.default();
    this.m_tempV1 = new Vector3D_1.default();
    this.m_initRV = new Vector3D_1.default();
    this.m_initUP = new Vector3D_1.default();
    this.m_lookRHEnabled = true; //

    this.m_matrix = new Matrix4_1.default();
    this.m_viewMat = new Matrix4_1.default();
    this.m_viewInvertMat = new Matrix4_1.default();
    this.m_vpMat = new Matrix4_1.default();
    this.m_tempMat = new Matrix4_1.default();
    this.m_projMat = new Matrix4_1.default();
    this.m_camPos = new Vector3D_1.default();
    this.m_lookAtPos = new Vector3D_1.default();
    this.m_up = new Vector3D_1.default();
    this.m_lookDirectNV = new Vector3D_1.default();
    this.m_lookAtDirec = new Vector3D_1.default(); //

    this.m_nearPlaneWidth = 1.0;
    this.m_nearPlaneHeight = 1.0; //

    this.m_viewX = 0.0;
    this.m_viewY = 0.0;
    this.m_viewW = 800.0;
    this.m_viewH = 600.0;
    this.m_viewHalfW = 400.0;
    this.m_viewHalfH = 300.0;
    this.m_fovRadian = 0.0;
    this.m_aspect = 1.0;
    this.m_zNear = 0.1;
    this.m_zFar = 1000.0;
    this.m_b = 0.0;
    this.m_t = 0.0;
    this.m_l = 0.0;
    this.m_r = 0.0;
    this.m_perspectiveEnabled = false;
    this.m_project2Enabled = false;
    this.m_rightHandEnabled = true;
    this.m_rotV = new Vector3D_1.default(0.0, 0.0, 0.0);
    this.m_viewFieldZoom = 1.0;
    this.m_changed = true;
    this.m_unlock = true;
    this.m_tempNV = new Vector3D_1.default();
    this.m_tempUPV = new Vector3D_1.default();
    this.m_tempRV = new Vector3D_1.default();
    this.m_tempCamPos = new Vector3D_1.default();
    this.m_tempLookAtPos = new Vector3D_1.default();
    this.m_rotDegree = 0.0;
    this.m_rotAxis = new Vector3D_1.default();
    this.m_rotPivotPoint = null;
    this.m_axisRotEnabled = false;
    this.m_frustumWAABB = new AABB_1.default();
    this.m_invViewMat = null;
    this.m_nearPlaneHalfW = 0.5;
    this.m_nearPlaneHalfH = 0.5;
    this.m_nearWCV = new Vector3D_1.default();
    this.m_farWCV = new Vector3D_1.default();
    this.m_wNV = new Vector3D_1.default(); // 4 far point, 4 near point 

    this.m_wFrustumVtxArr = [new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), null, null, null]; // world space front,back ->(view space -z,z), world space left,right ->(view space -x,x),world space top,bottm ->(view space y,-y)

    this.m_wFruPlaneList = [new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default(), new Plane_1.default()];
    this.m_fpNVArr = [new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default(), new Vector3D_1.default()];
    this.m_fpDisArr = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    this.m_viewMatrix = null;
  } // 不允许外界修改camera数据


  lock() {
    this.m_unlock = false;
  } // 允许外界修改camera数据


  unlock() {
    this.m_unlock = true;
  }

  lookAtLH(camPos, lookAtPos, up) {
    if (this.m_unlock) {
      this.m_camPos.copyFrom(camPos);
      this.m_lookAtPos.copyFrom(lookAtPos);
      this.m_up.copyFrom(up);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = false;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize();
      this.m_initUP.copyFrom(up);
      this.m_initUP.normalize();
      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);
      this.m_initRV.normalize();
      this.m_changed = true;
    }
  }

  lookAtRH(camPos, lookAtPos, up) {
    if (this.m_unlock) {
      this.m_camPos.copyFrom(camPos);
      this.m_lookAtPos.copyFrom(lookAtPos);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize();
      Vector3D_1.default.Cross(this.m_lookAtDirec, up, this.m_initRV);
      Vector3D_1.default.Cross(this.m_initRV, this.m_lookAtDirec, this.m_initUP);
      this.m_initUP.normalize();
      this.m_initRV.normalize();
      this.m_up.copyFrom(this.m_initUP);
      this.m_changed = true;
    }
  }

  getLookAtLHToCamera(camera) {
    camera.lookAtLH(this.m_camPos, this.m_lookAtPos, this.m_up);
  }

  getLookAtRHToCamera(camera) {
    camera.lookAtRH(this.m_camPos, this.m_lookAtPos, this.m_up);
  }
  /**
   * left-hand axis perspective projection
   * @param fovRadian radian value
   * @param aspect the value is the view port width / height
   * @param zNear the camera near plane distance
   * @param zFar the camera far plane distance
   */


  perspectiveLH(fovRadian, aspect, zNear, zFar) {
    if (this.m_unlock) {
      this.m_project2Enabled = false;
      this.m_aspect = aspect;
      this.m_fovRadian = fovRadian;
      this.m_zNear = zNear;
      this.m_zFar = zFar;
      this.m_projMat.perspectiveLH(fovRadian, aspect, zNear, zFar);
      this.m_viewFieldZoom = Math.tan(fovRadian * 0.5);
      this.m_perspectiveEnabled = true;
      this.m_rightHandEnabled = false;
      this.m_changed = true;
    }
  }
  /**
   * right-hand axis perspective projection
   * @param fovRadian radian value
   * @param aspect the value is the view port width / height
   * @param zNear the camera near plane distance
   * @param zFar the camera far plane distance
   */


  perspectiveRH(fovRadian, aspect, zNear, zFar) {
    if (this.m_unlock) {
      this.m_aspect = aspect;
      this.m_fovRadian = fovRadian;
      this.m_zNear = zNear;
      this.m_zFar = zFar;
      this.m_projMat.perspectiveRH(fovRadian, aspect, zNear, zFar);
      this.m_viewFieldZoom = Math.tan(fovRadian * 0.5);
      this.m_project2Enabled = false;
      this.m_perspectiveEnabled = true;
      this.m_rightHandEnabled = true;
      this.m_changed = true;
    }
  }

  perspectiveRH2(fovRadian, pw, ph, zNear, zFar) {
    if (this.m_unlock) {
      this.m_aspect = pw / ph;
      this.m_fovRadian = fovRadian;
      this.m_zNear = zNear;
      this.m_zFar = zFar;
      this.m_projMat.perspectiveRH2(fovRadian, pw, ph, zNear, zFar);
      this.m_viewFieldZoom = Math.tan(fovRadian * 0.5);
      this.m_perspectiveEnabled = true;
      this.m_project2Enabled = true;
      this.m_rightHandEnabled = true;
      this.m_changed = true;
    }
  }

  getAspect() {
    return this.m_aspect;
  }

  getViewFieldZoom() {
    return this.m_viewFieldZoom;
  }

  orthoRH(zNear, zFar, b, t, l, r) {
    if (this.m_unlock) {
      this.m_zNear = zNear;
      this.m_zFar = zFar;
      this.m_b = b;
      this.m_t = t;
      this.m_l = l;
      this.m_r = r;
      this.m_projMat.orthoRH(b, t, l, r, zNear, zFar);
      this.m_perspectiveEnabled = false;
      this.m_rightHandEnabled = true;
      this.m_changed = true;
    }
  }

  orthoLH(zNear, zFar, b, t, l, r) {
    if (this.m_unlock) {
      this.m_zNear = zNear;
      this.m_zFar = zFar;
      this.m_b = b;
      this.m_t = t;
      this.m_l = l;
      this.m_r = r;
      this.m_projMat.orthoLH(b, t, l, r, zNear, zFar);
      this.m_perspectiveEnabled = false;
      this.m_rightHandEnabled = false;
      this.m_changed = true;
    }
  }

  isPerspectiveEnabled() {
    return this.m_perspectiveEnabled;
  }

  isRightHandEnabled() {
    return this.m_rightHandEnabled;
  }

  setViewXY(px, py) {
    if (this.m_unlock) {
      this.m_viewX = px;
      this.m_viewY = py;
    }
  }

  setViewSize(pw, ph) {
    if (this.m_unlock) {
      if (pw != this.m_viewW || ph != this.m_viewH) {
        this.m_viewW = pw;
        this.m_viewH = ph;
        this.m_viewHalfW = pw * 0.5;
        this.m_viewHalfH = ph * 0.5; //console.log("setViewSize, pw:"+pw+",ph:"+ph);

        if (this.m_perspectiveEnabled) {
          if (this.m_project2Enabled) {
            if (this.m_rightHandEnabled) this.perspectiveRH2(this.m_fovRadian, pw, ph, this.m_zNear, this.m_zFar);
          } else {
            if (this.m_rightHandEnabled) this.perspectiveRH(this.m_fovRadian, pw / ph, this.m_zNear, this.m_zFar);else this.perspectiveLH(this.m_fovRadian, pw / ph, this.m_zNear, this.m_zFar);
          }
        } else {
          this.orthoRH(this.m_zNear, this.m_zFar, -0.5 * ph, 0.5 * ph, -0.5 * pw, 0.5 * pw);
        }
      }
    }
  }

  getViewX() {
    return this.m_viewX;
  }

  getViewY() {
    return this.m_viewY;
  }

  getViewWidth() {
    return this.m_viewW;
  }

  getViewHeight() {
    return this.m_viewH;
  }

  translation(v3) {
    if (this.m_unlock) {
      this.m_camPos.copyFrom(v3);
      this.m_lookAtPos.x = v3.x + this.m_lookAtDirec.x;
      this.m_lookAtPos.y = v3.y + this.m_lookAtDirec.y;
      this.m_lookAtPos.z = v3.z + this.m_lookAtDirec.z;
      this.m_changed = true;
    }
  }

  translationXYZ(px, py, pz) {
    this.m_tempV.setXYZ(px, py, pz);

    if (this.m_unlock && Vector3D_1.default.DistanceSquared(this.m_camPos, this.m_tempV) > 0.00001) {
      this.m_camPos.setTo(px, py, pz);
      this.m_lookAtPos.x = px + this.m_lookAtDirec.x;
      this.m_lookAtPos.y = py + this.m_lookAtDirec.y;
      this.m_lookAtPos.z = pz + this.m_lookAtDirec.z;
      this.m_changed = true;
    }
  }

  forward(dis) {
    if (this.m_unlock) {
      this.m_camPos.x += this.m_lookDirectNV.x * dis;
      this.m_camPos.y += this.m_lookDirectNV.y * dis;
      this.m_camPos.z += this.m_lookDirectNV.z * dis;
      this.m_lookAtPos.x = this.m_camPos.x + this.m_lookAtDirec.x;
      this.m_lookAtPos.y = this.m_camPos.y + this.m_lookAtDirec.y;
      this.m_lookAtPos.z = this.m_camPos.z + this.m_lookAtDirec.z;
      this.m_changed = true;
    }
  }
  /**
   * 在平行于远平面的平面上滑动， 垂直于此平面的方向上不变
   * @param dx 摄像机 view 空间内 x方向偏移量
   * @param dy 摄像机 view 空间内 y方向偏移量
   */


  slideViewOffsetXY(dx, dy) {
    if (this.m_unlock) {
      this.m_tempV.setXYZ(dx, dy, 0);
      this.m_invViewMat.transformVectorSelf(this.m_tempV);
      dx = this.m_tempV.x - this.m_camPos.x;
      dy = this.m_tempV.y - this.m_camPos.y;
      let dz = this.m_tempV.z - this.m_camPos.z;
      this.m_camPos.x += dx;
      this.m_camPos.y += dy;
      this.m_camPos.z += dz;
      this.m_lookAtPos.x += dx;
      this.m_lookAtPos.y += dy;
      this.m_lookAtPos.z += dz;
      this.m_changed = true;
    }
  }

  forwardFixPos(dis, pos) {
    if (this.m_unlock) {
      this.m_camPos.x = pos.x + this.m_lookDirectNV.x * dis;
      this.m_camPos.y = pos.y + this.m_lookDirectNV.y * dis;
      this.m_camPos.z = pos.z + this.m_lookDirectNV.z * dis;
      this.m_lookAtPos.x = this.m_camPos.x + this.m_lookAtDirec.x;
      this.m_lookAtPos.y = this.m_camPos.y + this.m_lookAtDirec.y;
      this.m_lookAtPos.z = this.m_camPos.z + this.m_lookAtDirec.z;
      this.m_changed = true;
    }
  }

  swingHorizontalWithAxis(rad, axis) {
    if (this.m_unlock) {
      this.m_tempMat.identity();

      if (axis != null) {
        this.m_tempMat.appendRotation(rad * MathConst_1.default.MATH_PI_OVER_180, axis);
      } else {
        this.m_tempMat.appendRotation(rad * MathConst_1.default.MATH_PI_OVER_180, Vector3D_1.default.Y_AXIS);
      }

      this.m_lookAtDirec.x = this.m_camPos.x - this.m_lookAtPos.x;
      this.m_lookAtDirec.y = this.m_camPos.y - this.m_lookAtPos.y;
      this.m_lookAtDirec.z = this.m_camPos.z - this.m_lookAtPos.z;
      this.m_tempMat.transformVectorSelf(this.m_lookAtDirec);
      this.m_camPos.x = this.m_lookAtDirec.x + this.m_lookAtPos.x;
      this.m_camPos.y = this.m_lookAtDirec.y + this.m_lookAtPos.y;
      this.m_camPos.z = this.m_lookAtDirec.z + this.m_lookAtPos.z;
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      this.m_tempMat.transformVectorSelf(this.m_initRV);
      this.m_initRV.normalize(); //Vector3D.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);

      Vector3D_1.default.Cross(this.m_initRV, this.m_lookAtDirec, this.m_up);
      this.m_up.normalize();
      this.m_changed = true;
    }
  }

  swingHorizontal(degree) {
    if (this.m_unlock) {
      this.m_tempMat.identity();
      this.m_tempMat.appendRotation(degree * MathConst_1.default.MATH_PI_OVER_180, this.m_up);
      this.m_lookAtDirec.x = this.m_camPos.x - this.m_lookAtPos.x;
      this.m_lookAtDirec.y = this.m_camPos.y - this.m_lookAtPos.y;
      this.m_lookAtDirec.z = this.m_camPos.z - this.m_lookAtPos.z;
      this.m_tempMat.transformVectorSelf(this.m_lookAtDirec);
      this.m_camPos.x = this.m_lookAtDirec.x + this.m_lookAtPos.x;
      this.m_camPos.y = this.m_lookAtDirec.y + this.m_lookAtPos.y;
      this.m_camPos.z = this.m_lookAtDirec.z + this.m_lookAtPos.z;
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);
      this.m_initRV.normalize();
      this.m_changed = true;
    }
  }

  swingVertical(degree) {
    if (this.m_unlock) {
      this.m_tempMat.identity();
      this.m_tempMat.appendRotation(degree * MathConst_1.default.MATH_PI_OVER_180, this.m_initRV);
      this.m_lookAtDirec.x = this.m_camPos.x - this.m_lookAtPos.x;
      this.m_lookAtDirec.y = this.m_camPos.y - this.m_lookAtPos.y;
      this.m_lookAtDirec.z = this.m_camPos.z - this.m_lookAtPos.z;
      this.m_tempMat.transformVectorSelf(this.m_lookAtDirec);
      this.m_camPos.x = this.m_lookAtDirec.x + this.m_lookAtPos.x;
      this.m_camPos.y = this.m_lookAtDirec.y + this.m_lookAtPos.y;
      this.m_camPos.z = this.m_lookAtDirec.z + this.m_lookAtPos.z;
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_initRV, this.m_lookAtDirec, this.m_up);
      this.m_up.normalize();
      this.m_initUP.copyFrom(this.m_up);
      this.m_changed = true;
    }
  }

  setPosition(v3) {
    if (this.m_unlock) {
      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_tempV);
      let dot = this.m_tempV.dot(this.m_initUP);
      this.m_tempV1.copyFrom(this.m_initUP);
      this.m_tempV1.scaleBy(dot);
      this.m_tempV.subtractBy(this.m_tempV1); //m_tempV.y = 0;

      this.m_camPos.copyFrom(v3);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_tempV, this.m_lookAtDirec, this.m_up);
      this.m_up.normalize();
      this.m_changed = true;
    }
  }

  setPositionXYZ(px, py, pz) {
    if (this.m_unlock) {
      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_tempV);
      var dot = this.m_tempV.dot(this.m_initUP);
      this.m_tempV1.copyFrom(this.m_initUP);
      this.m_tempV1.scaleBy(dot);
      this.m_tempV.subtractBy(this.m_tempV1);
      this.m_camPos.setTo(px, py, pz);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_tempV, this.m_lookAtDirec, this.m_up);
      this.m_up.normalize();
      this.m_changed = true;
    }
  }

  setLookPosXYZFixUp(px, py, pz) {
    if (this.m_unlock) {
      this.m_lookAtPos.setTo(px, py, pz);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);
      this.m_initRV.normalize();
      this.m_changed = true;
    }
  }

  setPositionXYZFixUp(px, py, pz) {
    if (this.m_unlock) {
      this.m_camPos.setTo(px, py, pz);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize(); //

      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);
      this.m_initRV.normalize();
      this.m_changed = true;
    }
  }

  setPositionFixUp(v3) {
    if (this.m_unlock) {
      this.m_camPos.copyFrom(v3);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookRHEnabled = true;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize();
      Vector3D_1.default.Cross(this.m_lookAtDirec, this.m_up, this.m_initRV);
      this.m_initRV.normalize();
      this.m_changed = true;
    }
  }

  copyFrom(tarCam) {
    let pv = tarCam.getPosition();
    this.m_camPos.copyFrom(pv);
    pv = tarCam.getLookAtPosition();
    this.m_lookAtPos.copyFrom(pv);
    this.setZNear(tarCam.getZNear());
    this.setZFar(tarCam.getZFar());
    this.setNearPlaneWidth(tarCam.getNearPlaneWidth());
    this.setNearPlaneHeight(tarCam.getNearPlaneHeight());
    this.setPerspectiveEnabled(tarCam.getPerspectiveEnabled());
    this.m_viewInvertMat.copyFrom(tarCam.getViewInvMatrix());
  } // view space axis z


  getNV() {
    this.m_tempNV.copyFrom(this.m_lookDirectNV);
    return this.m_tempNV;
  } // view space axis y


  getUV() {
    this.m_tempUPV.copyFrom(this.m_up);
    return this.m_tempUPV;
  } // view space axis x


  getRV() {
    this.m_tempRV.copyFrom(this.m_initRV);
    return this.m_tempRV;
  }

  getPosition() {
    this.m_tempCamPos.copyFrom(this.m_camPos);
    return this.m_tempCamPos;
  }

  getLookAtPosition() {
    this.m_tempLookAtPos.copyFrom(this.m_lookAtPos);
    return this.m_tempLookAtPos;
  }

  setLookAtPosition(pv) {
    if (this.m_unlock) {
      this.m_lookAtPos.copyFrom(pv);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize();
      this.m_changed = true;
    }
  }

  setLookAtXYZ(px, py, pz) {
    if (this.m_unlock) {
      this.m_lookAtPos.setTo(px, py, pz);
      this.m_lookAtDirec.x = this.m_lookAtPos.x - this.m_camPos.x;
      this.m_lookAtDirec.y = this.m_lookAtPos.y - this.m_camPos.y;
      this.m_lookAtDirec.z = this.m_lookAtPos.z - this.m_camPos.z;
      this.m_lookDirectNV.copyFrom(this.m_lookAtDirec);
      this.m_lookDirectNV.normalize();
      this.m_changed = true;
    }
  }

  getPerspectiveEnabled() {
    return this.m_perspectiveEnabled;
  }

  setPerspectiveEnabled(boo) {
    this.m_perspectiveEnabled = boo;
  }

  appendRotationByAxis(degree, axis, pivotPoint = null) {
    if (this.m_unlock) {
      this.m_rotDegree = degree;
      this.m_changed = true;
      this.m_rotAxis.copyFrom(axis);
      this.m_rotPivotPoint = pivotPoint;
      this.m_axisRotEnabled = true;
    }
  }

  setRotationX(degree) {
    this.m_rotV.x = degree;
    this.m_changed = true;
    this.m_axisRotEnabled = false;
  }

  getRotationX() {
    return this.m_rotV.x;
  }

  setRotationY(degree) {
    this.m_rotV.y = degree;
    this.m_changed = true;
    this.m_axisRotEnabled = false;
  }

  getRotationY() {
    return this.m_rotV.y;
  }

  setRotationZ(degree) {
    this.m_rotV.z = degree;
    this.m_changed = true;
    this.m_axisRotEnabled = false;
  }

  getRotationZ() {
    return this.m_rotV.z;
  }

  setRotationXYZ(rx, ry, rz) {
    if (this.m_unlock) {
      this.m_rotV.setXYZ(rx, ry, rz);
      this.m_changed = true;
      this.m_axisRotEnabled = false;
    }
  }

  screenXYToViewXYZ(px, py, outV) {
    px -= this.m_viewX;
    py -= this.m_viewY;

    if (this.m_perspectiveEnabled) {
      px = this.m_nearPlaneWidth * (px - this.m_viewHalfW) / this.m_viewHalfW;
      py = this.m_nearPlaneHeight * (this.m_viewHalfH - py) / this.m_viewHalfH;
    }

    outV.setTo(px, py, -this.m_zNear); //
  }

  screenXYToWorldXYZ(px, py, outV) {
    px -= this.m_viewX;
    py -= this.m_viewY;

    if (this.m_perspectiveEnabled) {
      px = 0.5 * this.m_nearPlaneWidth * (px - this.m_viewHalfW) / this.m_viewHalfW;
      py = 0.5 * this.m_nearPlaneHeight * (this.m_viewHalfH - py) / this.m_viewHalfH;
    }

    outV.setTo(px, py, -this.m_zNear);
    outV.w = 1.0;
    this.m_viewInvertMat.transformVectorSelf(outV);
  }

  getWorldPickingRayByScreenXY(screenX, screenY, ray_pos, ray_tv) {
    //console.log("screenX,screenY: ",screenX,screenY,this.m_viewHalfW,this.m_viewHalfH);
    screenX -= this.m_viewX;
    screenY -= this.m_viewY;

    if (this.m_perspectiveEnabled) {
      screenX = 0.5 * this.m_nearPlaneWidth * (screenX - this.m_viewHalfW) / this.m_viewHalfW;
      screenY = 0.5 * this.m_nearPlaneHeight * (screenY - this.m_viewHalfH) / this.m_viewHalfH;
      ray_pos.setTo(screenX, screenY, -this.m_zNear);
      ray_pos.w = 1.0;
      this.m_viewInvertMat.transformVectorSelf(ray_pos);
      ray_tv.copyFrom(ray_pos);
      ray_tv.subtractBy(this.m_camPos);
      ray_tv.normalize();
    } else {
      screenX -= this.m_viewHalfW;
      screenY -= this.m_viewHalfH;
      ray_pos.setTo(screenX, screenY, -this.m_zNear);
      ray_pos.w = 1.0;
      this.m_viewInvertMat.transformVectorSelf(ray_pos);
      ray_tv.copyFrom(this.m_lookDirectNV);
    }
  }

  calcScreenNormalizeXYByWorldPos(pv3, scPV3) {
    scPV3.copyFrom(pv3);
    this.m_vpMat.transformVectorSelf(scPV3);
    scPV3.x /= scPV3.w;
    scPV3.y /= scPV3.w;
  }

  worldPosToScreen(pv) {
    this.m_viewMat.transformVector3Self(pv);
    this.m_projMat.transformVectorSelf(pv);
    pv.x /= pv.w;
    pv.y /= pv.w;
    pv.x *= this.m_viewHalfW;
    pv.y *= this.m_viewHalfH;
    pv.x += this.m_viewX;
    pv.y += this.m_viewY;
  } // 计算3D空间的球体在屏幕空间的最小包围矩形, outV的x,y表示矩形的x和y;outV的z和w表示宽和高,取值为像素数


  calcViewRectByWorldSphere(pv, radius, outV) {
    this.m_viewMat.transformVector3Self(pv);
    radius *= 1.15;
    outV.x = pv.x - radius;
    outV.y = pv.y - radius;
    outV.z = pv.z;
    pv.x += radius;
    pv.y += radius;
    this.m_projMat.transformPerspV4Self(outV);
    this.m_projMat.transformPerspV4Self(pv);
    pv.z = 1.0 / pv.w;
    outV.z = pv.x * pv.z;
    outV.w = pv.y * pv.z;
    outV.z *= this.m_viewHalfW;
    outV.w *= this.m_viewHalfH;
    outV.x *= pv.z;
    outV.y *= pv.z;
    outV.x *= this.m_viewHalfW;
    outV.y *= this.m_viewHalfH;
    outV.z = outV.z - outV.x;
    outV.w = outV.w - outV.y;
    outV.x += this.m_viewX;
    outV.y += this.m_viewY;
  } // 计算3D空间的球体在屏幕空间的最小包围矩形, outV的x,y表示矩形的x和y;outV的z和w表示宽和高,取值0.0 - 1.0之间


  calcScreenRectByWorldSphere(pv, radius, outV) {
    this.m_viewMat.transformVector3Self(pv);
    radius *= 1.15;
    outV.x = pv.x - radius;
    outV.y = pv.y - radius;
    pv.x += radius;
    pv.y += radius;
    this.m_projMat.transformPerspV4Self(outV);
    this.m_projMat.transformPerspV4Self(pv);
    pv.z = 1.0 / pv.w;
    outV.z = pv.x * pv.z;
    outV.w = pv.y * pv.z;
    outV.x *= pv.z;
    outV.y *= pv.z;
    outV.z = outV.z - outV.x;
    outV.w = outV.w - outV.y;
  }

  getInvertViewMatrix() {
    return this.m_invViewMat;
  }

  getZNear() {
    return this.m_zNear;
  }

  setZNear(value) {
    this.m_zNear = value;
  }

  getZFar() {
    return this.m_zFar;
  }

  setZFar(value) {
    this.m_zFar = value;
  }

  getNearPlaneWidth() {
    return this.m_nearPlaneWidth;
  }

  setNearPlaneWidth(value) {
    this.m_nearPlaneWidth = value;
  }

  getNearPlaneHeight() {
    return this.m_nearPlaneHeight;
  }

  setNearPlaneHeight(value) {
    this.m_nearPlaneHeight = value;
  }

  getFov() {
    return this.m_fovRadian;
  }

  __calcTestParam() {
    if (this.m_invViewMat == null) this.m_invViewMat = new Matrix4_1.default(); //Matrix4Pool.GetMatrix();

    this.m_invViewMat.copyFrom(this.m_viewMat);
    this.m_invViewMat.invert(); //

    let plane = null;
    let halfMinH = this.m_viewHalfH;
    let halfMinW = this.m_viewHalfW;
    let halfMaxH = this.m_viewHalfH;
    let halfMaxW = this.m_viewHalfW;

    if (this.m_perspectiveEnabled) {
      let tanv = Math.tan(this.m_fovRadian * 0.5);
      halfMinH = this.m_zNear * tanv;
      halfMinW = halfMinH * this.m_aspect;
      halfMaxH = this.m_zFar * tanv;
      halfMaxW = halfMaxH * this.m_aspect;
    } //console.log("CameraBase::__calcTestParam(), (halfMinW, halfMinH): "+halfMinW+", "+halfMinH);


    this.m_nearPlaneHalfW = halfMinW;
    this.m_nearPlaneHalfH = halfMinH; // inner view space

    this.m_nearWCV.setTo(0, 0, -this.m_zNear);
    this.m_farWCV.setTo(0, 0, -this.m_zFar);
    this.m_invViewMat.transformVectorSelf(this.m_nearWCV);
    this.m_invViewMat.transformVectorSelf(this.m_farWCV);
    this.m_wNV.x = this.m_farWCV.x - this.m_nearWCV.x;
    this.m_wNV.y = this.m_farWCV.y - this.m_nearWCV.y;
    this.m_wNV.z = this.m_farWCV.z - this.m_nearWCV.z;
    this.m_wNV.normalize(); // front face

    plane = this.m_wFruPlaneList[0];
    plane.nv.copyFrom(this.m_wNV);
    plane.distance = plane.nv.dot(this.m_farWCV);
    plane.position.copyFrom(this.m_farWCV); // back face

    plane = this.m_wFruPlaneList[1];
    plane.nv.copyFrom(this.m_wFruPlaneList[0].nv);
    plane.distance = plane.nv.dot(this.m_nearWCV);
    plane.position.copyFrom(this.m_nearWCV); //

    this.m_wFrustumVtxArr[8] = this.m_nearWCV;
    this.m_wFrustumVtxArr[9] = this.m_farWCV;
    this.m_wFrustumVtxArr[11] = this.m_wNV; // far face

    this.m_wFrustumVtxArr[0].setTo(-halfMaxW, -halfMaxH, -this.m_zFar);
    this.m_wFrustumVtxArr[1].setTo(halfMaxW, -halfMaxH, -this.m_zFar);
    this.m_wFrustumVtxArr[2].setTo(halfMaxW, halfMaxH, -this.m_zFar);
    this.m_wFrustumVtxArr[3].setTo(-halfMaxW, halfMaxH, -this.m_zFar); // near face

    this.m_wFrustumVtxArr[4].setTo(-halfMinW, -halfMinH, -this.m_zNear);
    this.m_wFrustumVtxArr[5].setTo(halfMinW, -halfMinH, -this.m_zNear);
    this.m_wFrustumVtxArr[6].setTo(halfMinW, halfMinH, -this.m_zNear);
    this.m_wFrustumVtxArr[7].setTo(-halfMinW, halfMinH, -this.m_zNear); //

    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[0]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[1]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[2]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[3]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[4]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[5]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[6]);
    this.m_invViewMat.transformVectorSelf(this.m_wFrustumVtxArr[7]); //

    this.m_frustumWAABB.max.setTo(-9999999, -9999999, -9999999);
    this.m_frustumWAABB.min.setTo(9999999, 9999999, 9999999);

    for (let i = 0; i < 8; ++i) {
      this.m_frustumWAABB.addPosition(this.m_wFrustumVtxArr[i]);
    }

    this.m_frustumWAABB.updateFast(); //let abCV = m_frustumWAABB.getCenter();
    // bottom

    let v0 = this.m_wFrustumVtxArr[0];
    let v1 = this.m_wFrustumVtxArr[4];
    this.m_tempV.x = v0.x - v1.x;
    this.m_tempV.y = v0.y - v1.y;
    this.m_tempV.z = v0.z - v1.z;
    v0 = this.m_wFrustumVtxArr[1];
    v1 = this.m_wFrustumVtxArr[5];
    this.m_tempV1.x = v0.x - v1.x;
    this.m_tempV1.y = v0.y - v1.y;
    this.m_tempV1.z = v0.z - v1.z;
    plane = this.m_wFruPlaneList[3];
    Vector3D_1.default.Cross(this.m_tempV1, this.m_tempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // top

    v0 = this.m_wFrustumVtxArr[3];
    v1 = this.m_wFrustumVtxArr[7];
    this.m_tempV.x = v0.x - v1.x;
    this.m_tempV.y = v0.y - v1.y;
    this.m_tempV.z = v0.z - v1.z;
    v0 = this.m_wFrustumVtxArr[2];
    v1 = this.m_wFrustumVtxArr[6];
    this.m_tempV1.x = v0.x - v1.x;
    this.m_tempV1.y = v0.y - v1.y;
    this.m_tempV1.z = v0.z - v1.z;
    plane = this.m_wFruPlaneList[2];
    Vector3D_1.default.Cross(this.m_tempV1, this.m_tempV, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // left

    v0 = this.m_wFrustumVtxArr[0];
    v1 = this.m_wFrustumVtxArr[4];
    this.m_tempV.x = v0.x - v1.x;
    this.m_tempV.y = v0.y - v1.y;
    this.m_tempV.z = v0.z - v1.z;
    v0 = this.m_wFrustumVtxArr[3];
    v1 = this.m_wFrustumVtxArr[7];
    this.m_tempV1.x = v0.x - v1.x;
    this.m_tempV1.y = v0.y - v1.y;
    this.m_tempV1.z = v0.z - v1.z;
    plane = this.m_wFruPlaneList[4];
    Vector3D_1.default.Cross(this.m_tempV, this.m_tempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0); // right

    v0 = this.m_wFrustumVtxArr[1];
    v1 = this.m_wFrustumVtxArr[5];
    this.m_tempV.x = v0.x - v1.x;
    this.m_tempV.y = v0.y - v1.y;
    this.m_tempV.z = v0.z - v1.z;
    v0 = this.m_wFrustumVtxArr[2];
    v1 = this.m_wFrustumVtxArr[6];
    this.m_tempV1.x = v0.x - v1.x;
    this.m_tempV1.y = v0.y - v1.y;
    this.m_tempV1.z = v0.z - v1.z;
    plane = this.m_wFruPlaneList[5];
    Vector3D_1.default.Cross(this.m_tempV, this.m_tempV1, plane.nv);
    plane.nv.normalize();
    plane.distance = plane.nv.dot(v0);
    plane.position.copyFrom(v0);
    this.m_fpNVArr[0].copyFrom(this.m_wFruPlaneList[0].nv);
    this.m_fpNVArr[1].copyFrom(this.m_wFruPlaneList[1].nv);
    this.m_fpNVArr[1].scaleBy(-1.0);
    this.m_fpNVArr[2].copyFrom(this.m_wFruPlaneList[2].nv);
    this.m_fpNVArr[3].copyFrom(this.m_wFruPlaneList[3].nv);
    this.m_fpNVArr[3].scaleBy(-1.0);
    this.m_fpNVArr[4].copyFrom(this.m_wFruPlaneList[4].nv);
    this.m_fpNVArr[4].scaleBy(-1.0);
    this.m_fpNVArr[5].copyFrom(this.m_wFruPlaneList[5].nv); //

    this.m_fpDisArr[0] = this.m_wFruPlaneList[0].distance;
    this.m_fpDisArr[1] = -this.m_wFruPlaneList[1].distance;
    this.m_fpDisArr[2] = this.m_wFruPlaneList[2].distance;
    this.m_fpDisArr[3] = -this.m_wFruPlaneList[3].distance;
    this.m_fpDisArr[4] = -this.m_wFruPlaneList[4].distance;
    this.m_fpDisArr[5] = this.m_wFruPlaneList[5].distance;
  }

  getWordFrustumWAABB() {
    return this.m_frustumWAABB;
  }

  getWordFrustumWAABBCenter() {
    return this.m_frustumWAABB.center;
  }

  getWordFrustumVtxArr() {
    return this.m_wFrustumVtxArr;
  }

  getWordFrustumPlaneArr() {
    return this.m_wFruPlaneList;
  }

  visiTestSphere2(w_cv, radius) {
    let boo = this.m_fpNVArr[0].dot(w_cv) - this.m_fpDisArr[0] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[1].dot(w_cv) - this.m_fpDisArr[1] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[2].dot(w_cv) - this.m_fpDisArr[2] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[3].dot(w_cv) - this.m_fpDisArr[3] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[4].dot(w_cv) - this.m_fpDisArr[4] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[5].dot(w_cv) - this.m_fpDisArr[5] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    return true;
  }

  visiTestSphere3(w_cv, radius, farROffset) {
    let boo = this.m_fpNVArr[0].dot(w_cv) - this.m_fpDisArr[0] + farROffset - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[1].dot(w_cv) - this.m_fpDisArr[1] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[2].dot(w_cv) - this.m_fpDisArr[2] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[3].dot(w_cv) - this.m_fpDisArr[3] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[4].dot(w_cv) - this.m_fpDisArr[4] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[5].dot(w_cv) - this.m_fpDisArr[5] - radius > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    return true;
  }

  visiTestPosition(pv) {
    let boo = this.m_fpNVArr[0].dot(pv) - this.m_fpDisArr[0] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[1].dot(pv) - this.m_fpDisArr[1] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[2].dot(pv) - this.m_fpDisArr[2] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[3].dot(pv) - this.m_fpDisArr[3] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[4].dot(pv) - this.m_fpDisArr[4] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    boo = this.m_fpNVArr[5].dot(pv) - this.m_fpDisArr[5] > MathConst_1.default.MATH_MIN_POSITIVE;
    if (boo) return false;
    return true;
  }

  visiTestPlane(nv, distance) {
    let f0 = nv.dot(this.m_wFruPlaneList[0].position) - distance;
    let f1 = f0 * (nv.dot(this.m_wFruPlaneList[1].position) - distance);
    if (f1 < MathConst_1.default.MATH_MIN_POSITIVE) return true;
    f1 = f0 * (nv.dot(this.m_wFruPlaneList[2].position) - distance);
    if (f1 < MathConst_1.default.MATH_MIN_POSITIVE) return true;
    f1 = f0 * (nv.dot(this.m_wFruPlaneList[3].position) - distance);
    if (f1 < MathConst_1.default.MATH_MIN_POSITIVE) return true;
    f1 = f0 * (nv.dot(this.m_wFruPlaneList[4].position) - distance);
    if (f1 < MathConst_1.default.MATH_MIN_POSITIVE) return true;
    f1 = f0 * (nv.dot(this.m_wFruPlaneList[5].position) - distance);
    if (f1 < MathConst_1.default.MATH_MIN_POSITIVE) return true;
    return false;
  } //this.m_wFruPlaneList
  // frustum intersect sphere in wrod space


  visiTestSphere(w_cv, radius) {
    let boo = this.m_frustumWAABB.sphereIntersect(w_cv, radius); //

    if (boo) {
      let pf0 = this.m_wFruPlaneList[0].intersectSphere(w_cv, radius);
      let pf1 = this.m_wFruPlaneList[1].intersectSphere(w_cv, radius); //trace("0 pf0,pf1: "+pf0+","+pf1);

      if (pf0 * pf1 >= 0) {
        //this.intersectBoo
        //trace("TT A0");
        if (this.m_wFruPlaneList[0].intersectBoo || this.m_wFruPlaneList[1].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = this.m_wFruPlaneList[2].intersectSphere(w_cv, radius);
      pf1 = this.m_wFruPlaneList[3].intersectSphere(w_cv, radius); //trace("1 pf0,pf1: "+pf0+","+pf1);

      if (pf0 * pf1 >= 0) {
        //trace("TT A1");
        if (this.m_wFruPlaneList[2].intersectBoo || this.m_wFruPlaneList[3].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = this.m_wFruPlaneList[4].intersectSphere(w_cv, radius);
      pf1 = this.m_wFruPlaneList[5].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        //trace("TT A2");
        if (this.m_wFruPlaneList[4].intersectBoo || this.m_wFruPlaneList[5].intersectBoo) {} else {
          return false;
        }
      }

      return true;
    }

    return false;
  } // visibility test
  // 可见性检测这边可以做的更精细，例如上一帧检测过的对象如果摄像机没有移动而且它自身也没有位置等变化，就可以不用检测
  // 例如精细检测可以分类: 圆球，圆柱体，长方体 等不同的检测模型计算方式会有区别


  visiTestAABB(ab) {
    //trace("ro.bounds.getCenter(): "+ro.bounds.getCenter()+","+ro.bounds.getRadius());
    //return m_frustumWAABB.sphereIntersectFast(ro.bounds.getCenter(),ro.bounds.getRadius());
    let w_cv = ab.center;
    let radius = ab.radius;
    let boo = this.m_frustumWAABB.sphereIntersect(w_cv, radius); //

    if (boo) {
      let pf0 = this.m_wFruPlaneList[0].intersectSphere(w_cv, radius);
      let pf1 = this.m_wFruPlaneList[1].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (this.m_wFruPlaneList[0].intersectBoo || this.m_wFruPlaneList[1].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = this.m_wFruPlaneList[2].intersectSphere(w_cv, radius);
      pf1 = this.m_wFruPlaneList[3].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (this.m_wFruPlaneList[2].intersectBoo || this.m_wFruPlaneList[3].intersectBoo) {} else {
          return false;
        }
      }

      pf0 = this.m_wFruPlaneList[4].intersectSphere(w_cv, radius);
      pf1 = this.m_wFruPlaneList[5].intersectSphere(w_cv, radius);

      if (pf0 * pf1 >= 0) {
        if (this.m_wFruPlaneList[4].intersectBoo || this.m_wFruPlaneList[5].intersectBoo) {} else {
          return false;
        }
      }

      return true;
    }

    return false;
  }

  setViewMatrix(viewMatrix) {
    this.m_viewMatrix = viewMatrix;
    this.m_changed = true;
  }

  update() {
    if (this.m_changed) {
      this.version++;
      this.m_changed = false;

      if (this.m_viewMatrix == null) {
        if (this.m_axisRotEnabled) {
          this.m_matrix.appendRotationPivot(this.m_rotDegree * MathConst_1.default.MATH_PI_OVER_180, this.m_rotAxis, this.m_rotPivotPoint);
        } else {
          this.m_matrix.identity();
          this.m_matrix.appendRotationEulerAngle(this.m_rotV.x * MathConst_1.default.MATH_PI_OVER_180, this.m_rotV.y * MathConst_1.default.MATH_PI_OVER_180, this.m_rotV.z * MathConst_1.default.MATH_PI_OVER_180);
        }

        if (this.m_lookRHEnabled) {
          this.m_viewMat.lookAtRH(this.m_camPos, this.m_lookAtPos, this.m_up);
        } else {
          this.m_viewMat.lookAtLH(this.m_camPos, this.m_lookAtPos, this.m_up);
        }

        this.m_viewMat.append(this.m_matrix);
      } else {
        this.m_viewMat.copyFrom(this.m_viewMatrix);
      }

      if (this.m_project2Enabled) {
        this.m_nearPlaneWidth = this.m_zNear * Math.tan(this.m_fovRadian * 0.5) * 2.0;
        this.m_nearPlaneHeight = this.m_nearPlaneWidth / this.m_aspect;
      } else {
        this.m_nearPlaneHeight = this.m_zNear * Math.tan(this.m_fovRadian * 0.5) * 2.0;
        this.m_nearPlaneWidth = this.m_aspect * this.m_nearPlaneHeight;
      }

      this.m_viewInvertMat.copyFrom(this.m_viewMat);
      this.m_viewInvertMat.invert(); //

      this.m_vpMat.identity();
      this.m_vpMat.copyFrom(this.m_viewMat);
      this.m_vpMat.append(this.m_projMat);

      this.__calcTestParam(); // very very important !!!


      this.updateUniformData();
    }
  }

  updateCamMatToUProbe(uniformProbe) {
    if (uniformProbe.isEnabled()) {
      uniformProbe.update();
      uniformProbe.getFS32At(0).set(this.m_viewMat.getLocalFS32(), 0);
      uniformProbe.getFS32At(1).set(this.m_projMat.getLocalFS32(), 0);
    }
  }

  updateUniformData() {
    if (this.uniformEnabled) {
      this.updateCamMatToUProbe(this.matUProbe);
      this.ufrustumProbe.setVec4DataAt(0, this.m_zNear, this.m_zFar, this.m_nearPlaneHalfW, this.m_nearPlaneHalfH);
      this.ufrustumProbe.update();
      this.ucameraPosProbe.setVec4DataAt(0, this.m_camPos.x, this.m_camPos.y, this.m_camPos.z, 1.0);
      this.ucameraPosProbe.update();
    }
  }

  destroy() {}

  lookRHEnabled() {
    return this.m_lookRHEnabled;
  }

  lookLHEnabled() {
    return !this.m_lookRHEnabled;
  }

  getVPMatrix() {
    return this.m_vpMat;
  }

  getViewMatrix() {
    return this.m_viewMat;
  }

  getViewInvMatrix() {
    return this.m_viewInvertMat;
  }

  getProjectMatrix() {
    return this.m_projMat;
  }

}

exports.default = CameraBase;

/***/ }),

/***/ "c62b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderConst_1 = __webpack_require__("e08e");

const RenderColorMask_1 = __webpack_require__("070b");

const RenderStateObject_1 = __webpack_require__("a5ba");
/**
 * 渲染器渲染运行时核心关键执行显示单元,一个unit代表着一个draw call所渲染的所有数据
 * renderer rendering runtime core executable display unit.
 */


class RPOUnit {
  constructor() {
    this.uid = -1;
    this.value = -1; // 记录自身和RPONode的对应关系

    this.__$rpuid = -1; // renderProcess uid

    this.__$rprouid = -1;
    this.shader = null; // 这个posotion和bounds的center会是同一个实例

    this.pos = null;
    this.bounds = null; // 记录对应的RODisplay的渲染所需的状态数据

    this.ibufType = 0; // UNSIGNED_SHORT or UNSIGNED_INT

    this.ibufStep = 2; // 2 or 4

    this.ivsIndex = 0;
    this.ivsCount = 0;
    this.insCount = 0;
    this.drawOffset = 0;
    this.partTotal = 0; // partTotal = partGroup.length

    this.partGroup = null;
    this.trisNumber = 0;
    this.visible = true;
    this.drawEnabled = true;
    this.drawMode = 0;
    this.renderState = 0;
    this.rcolorMask = 0; // 用于记录 renderState(低10位)和ColorMask(高10位) 的状态组合

    this.drawFlag = 0;
    this.vro = null; // transform uniform

    this.transUniform = null; // materiall uniform

    this.uniform = null; // 记录 material 对应的 shader program uid

    this.shdUid = -1;
    this.vtxUid = -1; // record tex group

    this.tro = null;
    this.texMid = -1;
    this.ubo = null;
    /**
     *  for example: [-70.0,1.0]
     */

    this.polygonOffset = null;
  }

  testDrawFlag() {
    if (this.shader.drawFlag != this.drawFlag) {
      this.shader.drawFlag = this.drawFlag;
      RenderStateObject_1.RenderStateObject.UseRenderState(this.renderState);
      RenderColorMask_1.RenderColorMask.UseRenderState(this.rcolorMask);
    }
  }

  getUid() {
    return this.uid;
  }

  getRPOUid() {
    return this.__$rpuid;
  }

  getRPROUid() {
    return this.__$rprouid;
  }

  getShaderUid() {
    return this.shdUid;
  }

  setIvsParam(ivsIndex, ivsCount) {
    this.ivsIndex = ivsIndex;
    this.ivsCount = ivsCount;
    this.drawOffset = ivsIndex * this.ibufStep;
    this.drawEnabled = this.visible && this.ivsCount > 0;
  }

  setVisible(boo) {
    this.visible = boo;
    this.drawEnabled = boo && this.ivsCount > 0; // if(DebugFlag.Flag_0 > 0) console.log("#### setVisible(): ", boo, "this.drawEnabled: ",this.drawEnabled);
  }

  setDrawFlag(renderState, rcolorMask) {
    this.renderState = renderState;
    this.rcolorMask = rcolorMask;
    this.drawFlag = (rcolorMask << 10) + renderState;
  }

  drawThis(rc) {
    const st = rc.status;
    st.drawCallTimes++;
    st.drawTrisNumber += this.trisNumber; // TODO(Vily): 下面这个判断流程需要优化(由于几何数据更改之后上传gpu的动作是一帧上传16个这样的速度下实现的，所以需要下面这句代码来保证不出错: [.WebGL-000037DC02C2B800] GL_INVALID_OPERATION: Insufficient buffer size)

    let ivsCount = this.indicesRes.getVTCount();
    if (this.ivsCount <= ivsCount) ivsCount = this.ivsCount;

    if (this.polygonOffset != null) {
      rc.setPolygonOffset(this.polygonOffset[0], this.polygonOffset[1]);
    } else {
      rc.resetPolygonOffset();
    }

    const rdm = RenderConst_1.RenderDrawMode;
    let gl = rc.RContext;

    switch (this.drawMode) {
      case rdm.ELEMENTS_TRIANGLES:
        // if(DebugFlag.Flag_0 > 0)console.log("RPOUnit::run(), TRIANGLES drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+"),drawOffset: "+this.drawOffset);
        //rc.RContext.drawElements(rc.TRIANGLES, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.TRIANGLES, ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ELEMENTS_LINES:
        //console.log("RPOUnit::run(), ELEMENTS_LINES drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+"),drawOffset: "+this.drawOffset);
        //rc.RContext.drawElements(rc.ELEMENTS_LINES, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.LINES, ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ELEMENTS_TRIANGLE_STRIP:
        //console.log("RPOUnit::run(), TRIANGLE_STRIP drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        //rc.RContext.drawElements(rc.TRIANGLE_STRIP, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.TRIANGLE_STRIP, ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ELEMENTS_INSTANCED_TRIANGLES:
        //console.log("RPOUnit::run(), drawElementsInstanced(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+", insCount: "+this.insCount+")");
        //rc.RContext.drawElementsInstanced(rc.TRIANGLES,this.ivsCount, this.ibufType, this.ivsIndex * this.ibufStep, this.insCount);
        gl.drawElementsInstanced(rc.TRIANGLES, ivsCount, this.ibufType, this.drawOffset, this.insCount);
        break;

      case rdm.ELEMENTS_TRIANGLE_FAN:
        //console.log("RPOUnit::run(), TRIANGLE_STRIP drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        //rc.RContext.drawElements(rc.TRIANGLE_FAN, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.TRIANGLE_FAN, ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ARRAYS_LINES:
        //console.log("RPOUnit::run(), ARRAYS_LINES drawArrays(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        gl.drawArrays(rc.LINES, this.ivsIndex, this.ivsCount);
        break;

      case rdm.ARRAYS_LINE_STRIP:
        //console.log("RPOUnit::run(), ARRAYS_LINE_STRIP drawArrays(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        gl.drawArrays(rc.LINE_STRIP, this.ivsIndex, this.ivsCount);
        break;

      default:
        break;
    }
  }

  drawPart(rc) {
    const st = rc.status;
    st.drawCallTimes++;
    st.drawTrisNumber += this.trisNumber; // TODO(Vily): 下面这个判断流程需要优化(由于几何数据更改之后上传gpu的动作是一帧上传16个这样的速度下实现的，所以需要下面这句代码来保证不出错: [.WebGL-000037DC02C2B800] GL_INVALID_OPERATION: Insufficient buffer size)

    let ivsCount = this.indicesRes.getVTCount();
    if (this.ivsCount <= ivsCount) ivsCount = this.ivsCount;

    if (this.polygonOffset != null) {
      rc.setPolygonOffset(this.polygonOffset[0], this.polygonOffset[1]);
    } else {
      rc.resetPolygonOffset();
    }

    const rdm = RenderConst_1.RenderDrawMode;
    let i = 0;
    let gl = rc.RContext;

    switch (this.drawMode) {
      case rdm.ELEMENTS_TRIANGLES:
        for (; i < this.partTotal;) {
          // 这里面可以增加一个回调函数,这个回调函数可以对uniform(或者transformUniform)做一些数据改变，进而来控制相应的状态
          // 因此可以通过改变uniform实现大量的显示绘制
          //  let count:number = this.partGroup[i++];
          //  let offset:number = this.partGroup[i++];
          //  gl.drawElements(rc.TRIANGLES, count, this.ibufType, offset);
          gl.drawElements(rc.TRIANGLES, this.partGroup[i++], this.ibufType, this.partGroup[i++]);
        }

        break;

      case rdm.ELEMENTS_LINES:
        for (; i < this.partTotal;) {
          // 这里面可以增加一个回调函数,这个回调函数可以对uniform(或者transformUniform)做一些数据改变，进而来控制相应的状态
          // 因此可以通过改变uniform实现大量的显示绘制
          //  let count:number = this.partGroup[i++];
          //  let offset:number = this.partGroup[i++];
          //  gl.drawElements(rc.TRIANGLES, count, this.ibufType, offset);
          gl.drawElements(rc.LINES, this.partGroup[i++], this.ibufType, this.partGroup[i++]);
        }

        break;

      case rdm.ELEMENTS_TRIANGLE_STRIP:
        //console.log("RPOUnit::run(), TRIANGLE_STRIP drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        //rc.RContext.drawElements(rc.TRIANGLE_STRIP, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.TRIANGLE_STRIP, this.ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ELEMENTS_INSTANCED_TRIANGLES:
        //console.log("RPOUnit::run(), drawElementsInstanced(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+", insCount: "+this.insCount+")");
        //rc.RContext.drawElementsInstanced(rc.TRIANGLES,this.ivsCount, this.ibufType, this.ivsIndex * this.ibufStep, this.insCount);
        gl.drawElementsInstanced(rc.TRIANGLES, this.ivsCount, this.ibufType, this.drawOffset, this.insCount);
        break;

      case rdm.ELEMENTS_TRIANGLE_FAN:
        //console.log("RPOUnit::run(), TRIANGLE_STRIP drawElements(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        //rc.RContext.drawElements(rc.TRIANGLE_FAN, this.ivsCount, this.ibufType,this.ivsIndex * this.ibufStep);
        gl.drawElements(rc.TRIANGLE_FAN, this.ivsCount, this.ibufType, this.drawOffset);
        break;

      case rdm.ARRAYS_LINES:
        //console.log("RPOUnit::run(), drawArrays(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        gl.drawArrays(rc.LINES, this.ivsIndex, this.ivsCount);
        break;

      case rdm.ARRAYS_LINE_STRIP:
        //console.log("RPOUnit::run(), drawArrays(ivsCount="+this.ivsCount+", ivsIndex="+this.ivsIndex+")");
        gl.drawArrays(rc.LINE_STRIP, this.ivsIndex, this.ivsCount);
        break;

      default:
        break;
    }
  }

  run2(rc) {
    //console.log("RPOUnit::run2(), this.tro: "+this.tro+", this.drawMode: "+this.drawMode);
    if (this.ubo != null) {
      this.ubo.run(rc);
    } //  if(this.shader == null)
    //  {
    //      console.log("this.shader == null unit this.uid: ",this.uid);
    //  }


    this.shader.useTransUniform(this.transUniform);
    this.shader.useUniform(this.uniform);
    this.testDrawFlag();
  }

  run(rc) {
    //console.log("RPOUnit::run(), this.tro: "+this.tro+", this.drawMode: "+this.drawMode);
    if (this.ubo != null) {
      this.ubo.run(rc);
    }

    this.vro.run();
    this.tro.run();
    this.shader.useTransUniform(this.transUniform);
    this.shader.useUniform(this.uniform);
    this.testDrawFlag();
  }

  runLockMaterial2(puniform) {
    this.testDrawFlag();
    this.shader.useUniform2ToCurrentShd(puniform == null ? this.uniform : puniform, this.transUniform);
  }

  runLockMaterial() {
    this.vro.run();
    this.testDrawFlag();
    this.shader.useUniform2ToCurrentShd(this.uniform, this.transUniform);
  }

  reset() {
    //  console.log("RPOUnit::reset(), uid: ",this.getUid());
    this.indicesRes = null;
    this.polygonOffset = null;

    this.vro.__$detachThis();

    this.vro = null;

    this.tro.__$detachThis();

    this.tro = null;
    this.texMid = -1;
    this.__$rprouid = -1;
    this.ubo = null;
    this.shdUid = -1;
    this.vtxUid = -1;
    this.uniform = null;
    this.transUniform = null;
    this.partGroup = null;
    this.ivsIndex = 0;
    this.ivsCount = 0;
    this.insCount = 0;
    this.partTotal = 0;
    this.drawMode = 0;
    this.drawFlag = 0x0;
    this.renderState = 0;
    this.rcolorMask = 0;
    this.drawEnabled = true;
    this.shader = null;
    this.bounds = null;
    this.pos = null;
  }

  destroy() {
    this.reset();
  }

  toString() {
    return "[RPOUnit(uid = " + this.uid + ")]";
  }

}

exports.default = RPOUnit;

/***/ }),

/***/ "c711":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 射线检测拾取代理对象

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const RaySelectedNode_1 = __importDefault(__webpack_require__("c120"));

const AABBCalc_1 = __webpack_require__("e160");

class RaySelector {
  constructor() {
    this.m_renderer = null;
    this.m_camera = null;
    this.m_headNode = null;
    this.m_rsn = null; // 最多检测256个对象

    this.m_hitList = new Uint8Array(256);
    this.m_rsnList = null;
    this.m_selectedNode = null;
    this.m_selectedTotal = 0;
    this.m_testMode = 0;
    this.m_invpv = new Vector3D_1.default();
    this.m_invtv = new Vector3D_1.default();
    this.m_rlpv = null;
    this.m_rltv = null;
    this.m_rlsiv = new Uint8Array(4);
    this.m_rlinvtv = new Vector3D_1.default();
    this.m_outv = new Vector3D_1.default();
    this.m_vecs = [null, null];
    this.m_gpuTestEnabled = false;
  }

  setRenderer(renderer) {
    this.m_renderer = renderer;
  }

  setRayTestMode(testMode) {
    this.m_testMode = testMode;
  }

  setRay(rlpv, rltv) {
    this.m_rlpv = rlpv;
    this.m_rltv = rltv;
  }

  getRay(out_rlpv, out_rltv) {
    out_rlpv.copyFrom(this.m_rlpv);
    out_rltv.copyFrom(this.m_rltv);
  }

  setCamera(cam) {
    this.m_camera = cam;
  }

  setCullingNodeHead(headNode) {
    this.m_headNode = headNode;

    if (this.m_rsnList == null) {
      this.m_rsnList = [];
      let i = 0;

      for (; i < 256; ++i) {
        this.m_rsnList.push(new RaySelectedNode_1.default());
      }
    }
  } //  setSelectedNode(node:RaySelectedNode):void
  //  {
  //      this.m_selectedNode = node;
  //  }


  getSelectedNode() {
    return this.m_selectedNode;
  } //  setSelectedNodes(nodes:RaySelectedNode[], total:number):void
  //  {
  //      //this.m_rsnList = nodes;
  //  }


  getSelectedNodes() {
    return this.m_rsnList;
  }

  getSelectedNodesTotal() {
    return this.m_selectedTotal;
  }

  sorting(low, high) {
    let arr = this.m_rsnList; //标记位置为待排序数组段的low处也就时枢轴值

    this.m_rsn = arr[low];

    while (low < high) {
      //  如果当前数字已经有序的位于我们的枢轴两端，我们就需要移动它的指针，是high或是low
      while (low < high && arr[high].dis >= this.m_rsn.dis) {
        --high;
      } // 如果当前数字不满足我们的需求，我们就需要将当前数字移动到它应在的一侧


      arr[low] = arr[high];

      while (low < high && arr[low].dis <= this.m_rsn.dis) {
        ++low;
      }

      arr[high] = arr[low];
    }

    arr[low] = this.m_rsn;
    return low;
  }

  snsort(low, high) {
    if (low < high) {
      let pos = this.sorting(low, high);
      this.snsort(low, pos - 1);
      this.snsort(pos + 1, high);
    }
  }

  run() {
    let nextNode = this.m_headNode; //console.log("RaySelect run() nextNode != null: "+(nextNode != null));

    if (nextNode != null) {
      let dis = 0.0;
      let rtv = this.m_rltv;
      let rpv = this.m_rlpv;
      let outv = this.m_outv;
      let node = null;
      let total = 0; //console.log("raySelector rpv,rtv: ", rpv, rtv);

      if (Math.abs(rtv.x) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.x = 1.0 / rtv.x;
      } else {
        this.m_rlinvtv.x = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (Math.abs(rtv.y) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.y = 1.0 / rtv.y;
      } else {
        this.m_rlinvtv.y = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (Math.abs(rtv.z) > MathConst_1.default.MATH_MIN_POSITIVE) {
        this.m_rlinvtv.z = 1.0 / rtv.z;
      } else {
        this.m_rlinvtv.z = MathConst_1.default.MATH_MAX_POSITIVE;
      }

      if (this.m_rlinvtv.x < 0) this.m_rlsiv[0] = 1;else this.m_rlsiv[0] = 0;
      if (this.m_rlinvtv.y < 0) this.m_rlsiv[1] = 1;else this.m_rlsiv[1] = 0;
      if (this.m_rlinvtv.z < 0) this.m_rlsiv[2] = 1;else this.m_rlsiv[2] = 0;

      while (nextNode != null) {
        if (nextNode.drawEnabled && nextNode.entity.mouseEnabled) {
          //if(AABB.IntersectionRL2(rtv,rpv, nextNode.bounds, outv))
          outv.subVecsTo(nextNode.bounds.center, rpv); // outv.x = nextNode.bounds.center.x - rpv.x;
          // outv.y = nextNode.bounds.center.y - rpv.y;
          // outv.z = nextNode.bounds.center.z - rpv.z;

          dis = outv.dot(rtv);
          outv.x -= dis * rtv.x;
          outv.y -= dis * rtv.y;
          outv.z -= dis * rtv.z;

          if (outv.getLengthSquared() <= nextNode.bounds.radius2) {
            // 如果只是几何检测(例如球体包围体的检测)就不需要在进入后续的aabb检测
            if (nextNode.rayTestState < 1) {
              this.m_vecs[0] = nextNode.bounds.min;
              this.m_vecs[1] = nextNode.bounds.max;

              if (AABBCalc_1.AABBCalc.IntersectionRL3(this.m_vecs, this.m_rlsiv, this.m_rlinvtv, rtv, rpv, outv)) {
                node = this.m_rsnList[total];
                node.entity = nextNode.entity;
                node.dis = this.m_rlinvtv.w;
                node.wpv.copyFrom(outv); //  console.log("H Hit Dis: "+rtv.dot(outv));
                //console.log("Ray hit test a renderNode.");

                ++total;
              }
            } //  else
            //  {
            //      //其他检测方式
            //  }

          }
        }

        nextNode = nextNode.next;
      }

      this.m_selectedNode = null;
      let i = 0;

      if (total > 0) {
        let invpv = this.m_invpv;
        let invtv = this.m_invtv;
        let entity = null;
        let flag = 0;
        let hitTotal = 0;
        let mat4 = null;
        let rayNode = null; //let pvdis: number = rtv.dot(rpv);
        //let preDis: number = 0.0;

        if (total > 1) {
          //console.log("### A total: ",total);
          //  this.snsort(0, total - 1);
          let polyTest = !this.m_gpuTestEnabled;

          for (i = 0; i < total; ++i) {
            rayNode = this.m_rsnList[i];
            rayNode.dis = MathConst_1.default.MATH_MAX_POSITIVE;
            rayNode.flag = 0;
            entity = this.m_rsnList[i].entity;

            if (entity.isPolyhedral()) {
              if (polyTest) {
                //console.log("a0 ",entity);
                mat4 = entity.getInvMatrix();
                mat4.transformOutVector3(rpv, invpv);
                mat4.deltaTransformOutVector(rtv, invtv);
                invtv.normalize();
                flag = entity.testRay(invpv, invtv, outv, true);
              } else {
                //console.log("a1 ",entity);
                flag = 0;
              }
            } else {
              //console.log("a2 ",entity);
              mat4 = entity.getInvMatrix();
              mat4.transformOutVector3(rpv, invpv);
              mat4.deltaTransformOutVector(rtv, invtv);
              invtv.normalize();
              flag = entity.testRay(invpv, invtv, outv, true);
            }

            if (flag > 0) {
              rayNode.flag = flag;
              rayNode.lpv.copyFrom(outv);
              entity.getMatrix().transformOutVector3(outv, rayNode.wpv); // rayNode.dis = rtv.dot(rayNode.wpv) - pvdis;

              rayNode.dis = Vector3D_1.default.Distance(rayNode.wpv, rpv); //console.log("rayNode.dis: ",rayNode.dis, entity);

              this.m_hitList[hitTotal] = i;
              ++hitTotal; //console.log("YYYYYYYYYYYYYYYes multi Ray hit mesh success.");
              // if (rayNode.dis > preDis) {
              //     this.m_selectedNode = rayNode;
              //     break;
              // }
            } else if (flag < 0) {
              //console.log(">>> a0 ",entity);
              //console.log("NNNNNNNNNNNNNNNNo multi Ray hit mesh 没有做进一步的检测.");
              this.m_hitList[hitTotal] = i;
              ++hitTotal; // if (rayNode.dis > preDis) {
              //     this.m_selectedNode = rayNode;
              //     break;
              // }
            } //  preDis = rayNode.dis;

          } // if (this.m_selectedNode == null && hitTotal > 0) {
          //     this.m_selectedNode = this.m_rsnList[this.m_hitList[0]];
          // }


          this.snsort(0, total - 1);

          for (i = 0; i < total; ++i) {
            //console.log(i+","+this.m_rsnList[i].entity,this.m_rsnList[i].flag);
            if (this.m_rsnList[i].flag > 0) {
              this.m_selectedNode = this.m_rsnList[i];
              break;
            }
          } //console.log("### B total: ",total);

        } else {
          rayNode = this.m_rsnList[0];
          rayNode.dis = MathConst_1.default.MATH_MAX_POSITIVE;
          entity = this.m_rsnList[0].entity;
          mat4 = entity.getInvMatrix();
          mat4.transformOutVector3(rpv, invpv);
          mat4.deltaTransformOutVector(rtv, invtv);
          invtv.normalize();
          flag = entity.testRay(invpv, invtv, outv, true); //console.log("one hit flag: " + flag);

          if (flag > 0) {
            rayNode.lpv.copyFrom(outv);
            entity.getMatrix().transformOutVector3(outv, rayNode.wpv); //rayNode.dis = rtv.dot(rayNode.wpv) - pvdis;

            rayNode.dis = Vector3D_1.default.Distance(rayNode.wpv, rpv);
            this.m_selectedNode = rayNode; //console.log("YYYYYYYYYYYYYYYes Ray hit mesh success.");
          } else if (flag < 0) {
            //console.log("NNNNNNNNNNNNNNNo Ray hit mesh 没有做进一步的检测.");
            this.m_selectedNode = rayNode;
          }
        } //console.log("YYYYYYYYYYYYYYYes Ray hit success.");

      }

      i = total;

      for (; i < this.m_selectedTotal; ++i) {
        //console.log("清理多余的 entity i: "+i);
        if (this.m_selectedNode != this.m_rsnList[i]) {
          this.m_rsnList[i].entity = null;
        }
      }

      this.m_selectedTotal = total; //  else
      //  {
      //      console.log("NNNNNNNNNNNNNNNo Ray hit failure.");
      //  }
    }
  }

  clear() {
    this.m_selectedNode = null;
  }

}

exports.default = RaySelector;

/***/ }),

/***/ "c758":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const BinaryReader_1 = __webpack_require__("f7ee");

const fflate = __importStar(__webpack_require__("9cb6")); // Parse an FBX file in Binary format


class BufPropertyParser {
  constructor() {
    this.ppFlag = 0;
    this.encoding = 0;
    this.ppType = "";
  }

  parseDirec(reader, params) {
    if (params.length < 1) {
      return [];
    } // let offset: number, type: string, arrayLength: number, encoding: number, compressedLength: number
    //[bufOffset, compressedLength, arrayLength, encoding, type];
    // console.log("BufPropertyParser::parseDirec(), params: ",params);


    let offset = params[0];
    let compressedLength = params[1];
    let arrayLength = params[2];
    let encoding = params[3];
    let type = params[4]; // let type: string = , arrayLength: number, encoding: number, compressedLength: number

    reader.setOffset(offset); // let length;
    // console.log("parseProperty(), type: ",type);

    switch (type) {
      case 'b':
      case 'c':
      case 'd':
      case 'f':
      case 'i':
      case 'l':
        if (encoding === 0) {
          switch (type) {
            case 'b':
            case 'c':
              return reader.getBooleanArray(arrayLength);

            case 'd':
              return reader.getFloat64Array(arrayLength);

            case 'f':
              return reader.getFloat32Array(arrayLength);

            case 'i':
              return reader.getInt32Array(arrayLength);

            case 'l':
              return reader.getInt64Array(arrayLength);
          }
        }

        if (typeof fflate === 'undefined') {
          console.error('BufPropertyParser::parseDirec() External library fflate.min.js required.');
        }

        let u8Arr = reader.getArrayU8Buffer(compressedLength); // let t = Date.now();
        // console.log("parseProperty reader2...u8Arr.length: ", u8Arr.length);

        const data = fflate.unzlibSync(u8Arr, null);
        let reader2 = new BinaryReader_1.BinaryReader(data.buffer); // console.log(type,"parseProperty reader2...data.length: ", MathConst.CalcCeilPowerOfTwo(data.length), data.length);
        // console.log("unzlibSync loss time: ", (Date.now() - t));
        // this.subLossTime += (Date.now() - t);
        // console.log("XXXX is Geometry data.length: ",data.length,", compressedLength: ",compressedLength);

        switch (type) {
          case 'b':
          case 'c':
            return reader2.getBooleanArray(arrayLength);

          case 'd':
            //return [bufOffset, bufSize, arrayLength];
            //this.m_ppParams = [bufOffset, bufSize, arrayLength];
            // TODO(vily): 为了测试千万级三角面的的数据读取
            // try{
            return reader2.getFloat64Array(arrayLength);
          // }catch(e) {
          // 	console.log("errrrro arrayLength: ",arrayLength);
          // 	throw Error(e);
          // }

          case 'f':
            return reader2.getFloat32Array(arrayLength);

          case 'i':
            return reader2.getInt32Array(arrayLength);

          case 'l':
            return reader2.getInt64Array(arrayLength);
        }

      default:
        throw new Error('BufPropertyParser::parseDirec() Unknown property type ' + type);
    }
  }

  getArrayByteLength(type, arrayLength) {
    switch (type) {
      case 'd':
      case 'l':
        return arrayLength * 8;

      case 'f':
      case 'i':
        return arrayLength * 4;

      default:
        break;
    }

    return arrayLength;
  }

  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    this.encoding = 0;
    this.ppType = type; // console.log("parseProperty(), type: ",type);

    switch (type) {
      case 'C':
        return reader.getBoolean();

      case 'D':
        return reader.getFloat64();

      case 'F':
        return reader.getFloat32();

      case 'I':
        return reader.getInt32();

      case 'L':
        return reader.getInt64();

      case 'R':
        length = reader.getUint32();
        return reader.getArrayBuffer(length);

      case 'S':
        length = reader.getUint32();
        return reader.getString(length);

      case 'Y':
        return reader.getInt16();

      case 'b':
      case 'c':
      case 'd':
      case 'f':
      case 'i':
      case 'l':
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed

        const compressedLength = reader.getUint32();
        this.encoding = encoding;
        let bufOffset = reader.getOffset();
        let skipLen = encoding === 0 ? this.getArrayByteLength(type, arrayLength) : compressedLength;

        if (this.ppFlag == 12) {
          // console.log("%%%%% skipLen: ",skipLen, type, encoding);
          reader.skip(skipLen);
          return [bufOffset, compressedLength, arrayLength, encoding, type];
        } else if (this.ppFlag == 131) {
          // console.log("%%%%% skipLen: ",skipLen, type, encoding);
          reader.skip(skipLen);
          return [];
        }

        if (encoding === 0) {
          switch (type) {
            case 'b':
            case 'c':
              return reader.getBooleanArray(arrayLength);

            case 'd':
              return reader.getFloat64Array(arrayLength);

            case 'f':
              return reader.getFloat32Array(arrayLength);

            case 'i':
              return reader.getInt32Array(arrayLength);

            case 'l':
              return reader.getInt64Array(arrayLength);
          }
        }

        if (typeof fflate === 'undefined') {
          console.error('BufPropertyParser::parseProperty() External library fflate.min.js required.');
        } // let u8Arr = new Uint8Array( reader.getArrayBuffer( compressedLength ) );
        // // console.log("parseProperty reader2...u8Arr.length: ", u8Arr.length);
        // const data = fflate.unzlibSync( u8Arr, null );
        // const reader2 = new BinaryReader( data.buffer );


        let u8Arr = reader.getArrayU8Buffer(compressedLength); // let t = Date.now();

        const data = fflate.unzlibSync(u8Arr, null);
        let reader2 = new BinaryReader_1.BinaryReader(data.buffer); // console.log(type,"parseProperty reader2...data.length: ", MathConst.CalcCeilPowerOfTwo(data.length), data.length);
        // console.log("unzlibSync loss time: ", (Date.now() - t));
        // this.subLossTime += (Date.now() - t);
        // console.log("XXXX is Geometry data.length: ",data.length,", compressedLength: ",compressedLength);

        switch (type) {
          case 'b':
          case 'c':
            return reader2.getBooleanArray(arrayLength);

          case 'd':
            //this.m_ppParams = [bufOffset, bufSize, arrayLength];
            // TODO(vily): 为了测试单个几何模型千万级三角面的的数据读取
            // try{
            return reader2.getFloat64Array(arrayLength);
          // }catch(e) {
          // 	console.log("errrrro arrayLength: ",arrayLength);
          // 	throw Error(e);
          // }

          case 'f':
            return reader2.getFloat32Array(arrayLength);

          case 'i':
            return reader2.getInt32Array(arrayLength);

          case 'l':
            return reader2.getInt64Array(arrayLength);
        }

      default:
        throw new Error('BufPropertyParser::parseProperty() Unknown property type ' + type);
    }
  }

}

exports.BufPropertyParser = BufPropertyParser;

/***/ }),

/***/ "c917":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class TaskDescriptor {
  constructor(type, src, moduleName) {
    this.info = null;
    this.inited = false;
    this.type = type;
    this.src = src;
    this.moduleName = moduleName;
  }

}

exports.TaskDescriptor = TaskDescriptor;

/***/ }),

/***/ "ca6c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class BitConst {
  static PushThreeBitValueToInt(target, value) {
    return (target << 3) + value;
  }

  static PopThreeBitValueFromInt(target) {
    BitConst.value = 7 & target;
    return target >> 3;
  }

  static ContainsBit(target, bit) {
    return (bit & target) > 0;
  }

  static RemoveBit(target, bit) {
    return ~bit & target;
  }

  static AddBit(target, bit) {
    return bit | target;
  } //


  static AssembleFromIntArray(intArray) {
    let i = 0;
    let bit = 0x0;
    let len = intArray.length;

    for (; i < len; ++i) {
      if (intArray[i] > 0) {
        bit |= 1 << i;
      }
    }

    return bit;
  }

}

BitConst.BIT_ZERO = 0;
BitConst.BIT_ONE_0 = 1; //0b1

BitConst.BIT_ONE_1 = 1 << 1; //0b10

BitConst.BIT_ONE_2 = 1 << 2; //0b100

BitConst.BIT_ONE_3 = 1 << 3; //0b1000

BitConst.BIT_ONE_4 = 1 << 4; //0b10000

BitConst.BIT_ONE_5 = 1 << 5; //0b100000

BitConst.BIT_ONE_6 = 1 << 6; //0b1000000

BitConst.BIT_ONE_7 = 1 << 7; //0b10000000

BitConst.BIT_ONE_8 = 1 << 8; //0b100000000

BitConst.BIT_ONE_9 = 1 << 9; //0b1000000000

BitConst.BIT_ONE_10 = 1 << 10; //0b10000000000

BitConst.BIT_ONE_11 = 1 << 11; //0b100000000000

BitConst.value = 0;
exports.default = BitConst;

/***/ }),

/***/ "cb29":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const VtxBufConst_2 = __webpack_require__("8a0a");

const ROVertexBuffer_1 = __importDefault(__webpack_require__("e7d2"));

const RenderConst_1 = __webpack_require__("e08e");
/**
 * mesh(Polygon face convex mesh or Parametric geometry Objecct:):
 *      1.基于面(例如三角面)描述的多面体实体(Polygon face geometry mesh,for example: triangle mesh)
 *      2.基于空间几何方程描述的空间几何体(Parametric geometry Objecct,for example: Sphere(px,py,pz,radius))
*/


class MeshBase {
  constructor(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    this.m_bufDataUsage = 0;
    this.m_bufDataList = null;
    this.m_bufDataStepList = null;
    this.m_bufStatusList = null;
    this.m_bufTypeList = null;
    this.m_bufSizeList = null;
    this.m_polyhedral = true; //private m_isDyn:boolean = false;
    // very important!!!

    this.m_layoutBit = 0x0;
    this.m_transMatrix = null;
    this.m_vbuf = null;
    this.m_ivs = null;
    /**
     * 强制更新 vertex indices buffer 数据, 默认值为false
     */

    this.forceUpdateIVS = false;
    /**
     * 是否启用线框模式数据, 默认值为false
     */

    this.wireframe = false;
    /**
     * vtx positons bounds AABB in the local space
     */

    this.bounds = null;
    this.normalType = VtxBufConst_2.VtxNormalType.GOURAND;
    this.normalScale = 1.0;
    this.vtxTotal = 0;
    this.trisNumber = 0; //RenderDrawMode

    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES; //  vtx postion in data stream used count

    this.vtCount = 0;
    this.vbWholeDataEnabled = true;
    this.drawInsBeginIndex = 0;
    this.drawInsStride = 0;
    this.drawInsTotal = 0;
    this.m_attachCount = 0;
    this.m_bufDataUsage = bufDataUsage; //this.m_isDyn = bufDataUsage == VtxBufConst.VTX_DYNAMIC_DRAW;
  }

  isUVSEnabled() {
    return this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_UVS_INDEX);
  }

  isNVSEnabled() {
    return this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_NVS_INDEX);
  }

  isCVSEnabled() {
    return this.isVBufEnabledAt(VtxBufConst_1.default.VBUF_CVS_INDEX);
  }

  toElementsTriangles() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES;
  }

  toElementsTriangleStrip() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLE_STRIP;
  }

  toElementsTriangleFan() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLE_FAN;
  }

  toElementsInstancedTriangles() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_INSTANCED_TRIANGLES;
  }

  toArraysLines() {
    this.drawMode = RenderConst_1.RenderDrawMode.ARRAYS_LINES;
    this.setPolyhedral(false);
  }

  toArraysLineStrip() {
    this.drawMode = RenderConst_1.RenderDrawMode.ARRAYS_LINE_STRIP;
    this.setPolyhedral(false);
  }

  toArraysPoints() {
    this.drawMode = RenderConst_1.RenderDrawMode.ARRAYS_POINTS;
    this.setPolyhedral(false);
  }

  toElementsLines() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_LINES;
    this.setPolyhedral(false);
  }

  toDisable() {
    this.drawMode = RenderConst_1.RenderDrawMode.DISABLE;
    this.setPolyhedral(false);
  }

  createIVSBYSize(size) {
    return size > 65535 ? new Uint32Array(size) : new Uint16Array(size);
  }

  createIVSByArray(arr) {
    return arr.length > 65535 ? new Uint32Array(arr) : new Uint16Array(arr);
  }

  updateWireframeIvs() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES;

    if (this.wireframe && this.m_ivs !== null) {
      let ivs = this.m_ivs;
      let len = ivs.length * 2;
      let wIvs;
      if (len < 65535) wIvs = new Uint16Array(len);else wIvs = new Uint32Array(len);
      let a;
      let b;
      let c;
      let k = 0;

      for (let i = 0, l = ivs.length; i < l; i += 3) {
        a = ivs[i + 0];
        b = ivs[i + 1];
        c = ivs[i + 2];
        wIvs[k] = a;
        wIvs[k + 1] = b;
        wIvs[k + 2] = b;
        wIvs[k + 3] = c;
        wIvs[k + 4] = c;
        wIvs[k + 5] = a;
        k += 6;
      }

      this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_LINES;
    }
  }

  buildEnd() {
    this.m_vbuf.setBufTypeList(this.m_bufTypeList);
    this.m_vbuf.setBufSizeList(this.m_bufSizeList);
    this.m_bufDataList = ROVertexBuffer_1.default.BufDataList;
    this.m_bufDataStepList = ROVertexBuffer_1.default.BufDataStepList;
    this.m_bufStatusList = ROVertexBuffer_1.default.BufStatusList;
  }

  setTransformMatrix(matrix) {
    this.m_transMatrix = matrix;
  }

  getTransformMatrix() {
    return this.m_transMatrix;
  }
  /**
   * @return 返回true是则表示这是基于三角面的可渲染多面体, 返回false则是一个数学方程描述的几何体(例如球体).
   *         如果是多面体实体,则可以进行三角面的相关计算等操作, 如果不是则需要进行相关的几何算法计算.
   */


  isPolyhedral() {
    return this.m_polyhedral;
  } // 设置自身是否是多面体实体，根据实际需要改变相关的状态值


  setPolyhedral(polyhedral) {
    this.m_polyhedral = polyhedral;
  }
  /**
   * 射线和自身的相交检测(多面体或几何函数(例如球体))
   * @rlpv            表示物体坐标空间的射线起点
   * @rltv            表示物体坐标空间的射线朝向
   * @outV            如果检测相交存放物体坐标空间的交点
   * @boundsHit       表示是否包围盒体已经和射线相交了
   * @return          返回值 -1 表示不会进行检测,1表示相交,0表示不相交
   */


  testRay(rlpv, rltv, outV, boundsHit) {
    return -1;
  }

  rebuild() {
    if (this.m_vbuf == null) {
      if (this.m_bufDataList != null) {
        console.log("MeshBase::rebuild()...");
        ROVertexBuffer_1.default.Reset();
        let i = 0;
        let len = this.m_bufDataList.length;

        for (; i < len; ++i) {
          ROVertexBuffer_1.default.AddFloat32Data(this.m_bufDataList[i], this.m_bufDataStepList[i], this.m_bufStatusList[i]);
        }

        this.m_vbuf = ROVertexBuffer_1.default.CreateBySaveData(this.getBufDataUsage());

        if (this.m_ivs != null) {
          this.m_vbuf.setUintIVSData(this.m_ivs);
          this.vtCount = this.m_ivs.length;
        }
      }
    }
  }

  __$attachVBuf() {
    if (this.m_vbuf == null) {
      // rebuild vbuf;
      this.rebuild();
    }

    ROVertexBuffer_1.default.__$$AttachAt(this.m_vbuf.getUid());

    return this.m_vbuf;
  }

  __$detachVBuf(vbuf) {
    if (this.m_vbuf != vbuf) {
      throw Error("Fatal Error!");
    }

    ROVertexBuffer_1.default.__$$DetachAt(this.m_vbuf.getUid());
  }

  isGeomDynamic() {
    return true;
  }

  getBufDataUsage() {
    return this.m_bufDataUsage;
  }
  /**
   * @returns vertex position buffer Float32Array
   */


  getVS() {
    return null;
  }
  /**
   * @returns vertex uv buffer Float32Array
   */


  getUVS() {
    return null;
  }
  /**
   * @returns vertex normal buffer Float32Array
   */


  getNVS() {
    return null;
  }
  /**
   * @returns vertex vtx color(r,g,b) buffer Float32Array
   */


  getCVS() {
    return null;
  }
  /**
   * @returns vertex indices buffer Uint16Array or Uint32Array
   */


  getIVS() {
    return this.m_ivs;
  }

  setVtxBufRenderData(vtxData) {
    if (vtxData != null) {
      this.m_bufTypeList = vtxData.getBufTypeList();
      this.m_bufSizeList = vtxData.getBufSizeList();
      this.setBufSortFormat(vtxData.getBufSortFormat());
    }
  }
  /**
   * @param layoutBit vertex shader vertex attributes layout bit status.
   *                  the value of layoutBit comes from the material shdder program.
   */


  setBufSortFormat(layoutBit) {
    if (layoutBit < 1) {
      console.error("vertex layoutBit is the error value(0x" + layoutBit.toString(16) + ") in MeshBase::setBufSortFormat(), the material instance must initialize.");
    }

    this.m_layoutBit = layoutBit;
  }

  getBufSortFormat() {
    return this.m_layoutBit;
  }

  setBufTypeList(list) {
    this.m_bufTypeList = list;
  }

  setBufSizeList(list) {
    this.m_bufSizeList = list;
  }

  getBufTypeList() {
    return this.m_bufTypeList;
  }

  getBufSizeList() {
    return this.m_bufSizeList;
  }

  isVBufEnabledAt(i) {
    return (i & this.m_layoutBit) > 0;
  }

  __$attachThis() {
    ++this.m_attachCount; //console.log("MeshBase::__$attachThis() this.m_attachCount: "+this.m_attachCount);
  }

  __$detachThis() {
    if (this.m_attachCount == 1) {
      --this.m_attachCount; //console.log("MeshBase::__$detachThis() this.m_attachCount: "+this.m_attachCount);

      this.__$dispose();
    } else {
      --this.m_attachCount; //console.log("MeshBase::__$detachThis() this.m_attachCount: "+this.m_attachCount);
    }

    if (this.m_attachCount < 1) {
      this.m_attachCount = 0;
    }
  }

  getAttachCount() {
    return this.m_attachCount;
  } // 释放被外部对象持有的资源


  __$dispose() {
    if (this.getAttachCount() < 1 && this.m_vbuf != null) {
      //console.log("MeshBase::__$dispose()... this.m_attachCount: "+this.m_attachCount);
      ROVertexBuffer_1.default.__$$DetachAt(this.m_vbuf.getUid());

      this.m_vbuf = null;
    }
  }

  isEnabled() {
    return this.m_vbuf != null;
  }

  isResFree() {
    return this.getAttachCount() < 1 && this.m_vbuf == null;
  }
  /**
   * really destroy this instance all data
   */


  __$destroy() {
    if (this.isResFree()) {
      //console.log("MeshBase::__$destroy()... this.m_attachCount: "+this.m_attachCount);
      this.m_ivs = null;
      this.m_bufDataList = null;
      this.m_bufDataStepList = null;
      this.m_bufStatusList = null;
      this.trisNumber = 0;
      this.m_transMatrix = null;
      this.m_bufTypeList = null;
      this.m_bufSizeList = null;
    }
  }

  toString() {
    return "[MeshBase()]";
  }

}

exports.default = MeshBase;

/***/ }),

/***/ "cbd5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ThreadSchedule_1 = __webpack_require__("3a1d");

const GeometryResourceSchedule_1 = __webpack_require__("2a59");

const ReceiverSchedule_1 = __webpack_require__("2931");

const TextureResourceSchedule_1 = __webpack_require__("eda7");

const CoSystem_1 = __webpack_require__("1173");

const CoRuntime_1 = __webpack_require__("b406");
/**
 * (引擎)数据/资源协同空间, 让一个应用程序的功能像种子一样，随着用户的使用而生根发芽枝叶茂盛，功能越加载越多，越使用越丰富
 * 使得基于算力&数据驱动的系统架构更趋于完善
 * 从cospace的角度看，每一个功能，都是可以动态载入并启动的模块集合。这些模块可能位于主线程也可能位于子线程，他们之间的协作情况由各自的依赖关系决定
 * cospace用以实现基于算力&数据驱动的能渐进生长方式的引擎/功能应用
 */


class CoSpace {
  constructor() {
    this.m_initing = true;
    this.m_receiver = new ReceiverSchedule_1.ReceiverSchedule();
    this.system = new CoSystem_1.CoSystem();
    this.runtime = new CoRuntime_1.CoRuntime();
    this.thread = new ThreadSchedule_1.ThreadSchedule(); // 静态模块

    this.geometry = new GeometryResourceSchedule_1.GeometryResourceSchedule(); // 静态模块

    this.texture = new TextureResourceSchedule_1.TextureResourceSchedule();
    this.m_timeoutId = -1;
  }
  /**
   * 设置线程中子模块间依赖关系的json描述字符串
   * @param graphJsonStr json描述字符串
   */


  setThreadDependencyGraphJsonString(jsonStr) {
    this.thread.setDependencyGraphJsonString(jsonStr);
  }

  setTaskModuleParams(taskModules) {
    if (taskModules != null) {
      this.geometry.setTaskModuleParams(taskModules);
      this.texture.setTaskModuleParams(taskModules);
    }
  }

  isInitialized() {
    return !this.m_initing;
  }
  /**
   * 初始化引擎数据资源协同空间实例
   * @param maxThreadsTotal 最大线程数量
   * @param threadCoreCodeUrl 线程源码字符串url
   * @param autoSendData 是否自动从任务池里取出并发送任务数据到子线程, 默认值是false
   */


  initialize(maxThreadsTotal, threadCoreCodeUrl, autoSendData = false, terminateDelayMS = 3000) {
    if (this.m_initing) {
      this.m_initing = false; // let dependencyGraphObj: object = {
      //     nodes: [
      //         { uniqueName: "dracoGeomParser", path: "static/cospace/modules/draco/ModuleDracoGeomParser.umd.js" },
      //         { uniqueName: "dracoWasmWrapper", path: "static/cospace/modules/dracoLib/w2.js" },
      //         { uniqueName: "ctmGeomParser", path: "static/cospace/modules/ctm/ModuleCTMGeomParser.umd.js" }
      //     ],
      //     maps: [
      //         { uniqueName: "dracoGeomParser", includes: [1] } // 这里[1]表示 dracoGeomParser 依赖数组中的第一个元素也就是 dracoWasmWrapper 这个代码模块
      //     ]
      // };
      // let jsonStr: string = JSON.stringify(dependencyGraphObj);
      // this.thread.setDependencyGraphJsonString(jsonStr);
      // 初始化多线程调度器

      this.thread.setParams(autoSendData, terminateDelayMS); // 初始化多线程调度器(多线程系统)

      this.thread.initialize(maxThreadsTotal, threadCoreCodeUrl);
      this.geometry.initialize(this.m_receiver, this.thread, null);
      this.texture.initialize(this.m_receiver, this.thread, null); // 启动循环定时调度

      this.update();
    }
  }
  /**
   * 定时调度
   */


  update() {
    let delay = 40; // 25 fps
    //console.log("this.thread.hasTaskData(): ",this.thread.hasTaskData());

    if (this.thread.isSupported() && (this.thread.hasTaskData() || this.m_receiver.getReceiversTotal() > 0)) {
      //console.log("mini time.",this.thread.hasTaskData(), this.m_receiver.getReceiversTotal());
      delay = 20; // 50 fps
    }

    this.thread.run();
    this.m_receiver.run();

    if (this.m_timeoutId > -1) {
      clearTimeout(this.m_timeoutId);
    }

    this.m_timeoutId = setTimeout(this.update.bind(this), delay);
  }

  destroy() {}

}

exports.CoSpace = CoSpace;

/***/ }),

/***/ "cc48":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SpaceCullingMask;

(function (SpaceCullingMask) {
  SpaceCullingMask[SpaceCullingMask["NONE"] = 0] = "NONE"; // 需要做摄像机的可见剔除

  SpaceCullingMask[SpaceCullingMask["CAMERA"] = 1] = "CAMERA"; // project occlusion volume

  SpaceCullingMask[SpaceCullingMask["POV"] = 2] = "POV"; // 包含在遮挡体内部的不会进行遮挡剔除计算

  SpaceCullingMask[SpaceCullingMask["INNER_POV_PASS"] = 3] = "INNER_POV_PASS"; // 摄像机和POV都要做遮挡剔除

  SpaceCullingMask[SpaceCullingMask["CAMERA_AND_POV"] = 4] = "CAMERA_AND_POV";
})(SpaceCullingMask || (SpaceCullingMask = {}));

exports.SpaceCullingMask = SpaceCullingMask;

/***/ }),

/***/ "cc7a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var EulerOrder;

(function (EulerOrder) {
  EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
  EulerOrder[EulerOrder["YZX"] = 1] = "YZX";
  EulerOrder[EulerOrder["ZXY"] = 2] = "ZXY";
  EulerOrder[EulerOrder["XZY"] = 3] = "XZY";
  EulerOrder[EulerOrder["YXZ"] = 4] = "YXZ";
  EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
})(EulerOrder || (EulerOrder = {}));

exports.EulerOrder = EulerOrder;

/***/ }),

/***/ "ccdf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RTTTextureProxy_1 = __importDefault(__webpack_require__("cfaf"));

const DepthTextureProxy_1 = __importDefault(__webpack_require__("acaa"));

const WrapperTextureProxy_1 = __importDefault(__webpack_require__("85b6"));

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));
/**
 * 本类作为所有RTT纹理对象的管理类
 */


class RTTTextureStore {
  constructor(renderProxy) {
    this.m_renderProxy = null; // reusable rtt texture resources for one renderer context

    this.m_rttTexs = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
    this.m_rttCubeTexs = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
    this.m_rttFloatTexs = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
    this.m_rttDepthTexs = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
    this.m_renderProxy = renderProxy;
  }

  getRenderProxy() {
    return this.m_renderProxy;
  }

  createWrapperTex(pw, ph, powerof2Boo = false) {
    let tex = new WrapperTextureProxy_1.default(pw, ph, powerof2Boo);
    return tex;
  }

  createRTTTex2D(pw, ph, powerof2Boo = false) {
    let tex = new RTTTextureProxy_1.default(pw, ph, powerof2Boo);
    return tex;
  }

  createDepthTex2D(pw, ph, powerof2Boo = false) {
    let tex = new DepthTextureProxy_1.default(pw, ph, powerof2Boo);
    return tex;
  }

  getCubeRTTTextureAt(i) {
    if (this.m_rttCubeTexs[i] != null) {
      this.m_rttCubeTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttCubeTexs[i];
    }

    this.m_rttCubeTexs[i] = this.createRTTTex2D(32, 32);
    this.m_rttCubeTexs[i].toCubeTexture();
    this.m_rttCubeTexs[i].name = "sys_cube_rttTex_" + i;
    this.m_rttCubeTexs[i].minFilter = TextureConst_1.default.LINEAR;
    this.m_rttCubeTexs[i].magFilter = TextureConst_1.default.LINEAR;

    this.m_rttCubeTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttCubeTexs[i];
  }

  createCubeRTTTextureAt(i, pw, ph) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;

    if (this.m_rttCubeTexs[i] != null) {
      this.m_rttCubeTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttCubeTexs[i];
    }

    this.m_rttCubeTexs[i] = this.createRTTTex2D(pw, ph);
    this.m_rttCubeTexs[i].toCubeTexture();
    this.m_rttCubeTexs[i].name = "sys_cube_rttTex_" + i;
    this.m_rttCubeTexs[i].minFilter = TextureConst_1.default.LINEAR;
    this.m_rttCubeTexs[i].magFilter = TextureConst_1.default.LINEAR;

    this.m_rttCubeTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttCubeTexs[i];
  }

  getRTTTextureAt(i) {
    if (this.m_rttTexs[i] != null) {
      this.m_rttTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttTexs[i];
    }

    this.m_rttTexs[i] = this.createRTTTex2D(32, 32);
    this.m_rttTexs[i].to2DTexture();
    this.m_rttTexs[i].name = "sys_rttTex_" + i;
    this.m_rttTexs[i].minFilter = TextureConst_1.default.LINEAR;
    this.m_rttTexs[i].magFilter = TextureConst_1.default.LINEAR;

    this.m_rttTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttTexs[i];
  }

  createRTTTextureAt(i, pw, ph) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;

    if (this.m_rttTexs[i] != null) {
      this.m_rttTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttTexs[i];
    }

    this.m_rttTexs[i] = this.createRTTTex2D(pw, ph);
    this.m_rttTexs[i].to2DTexture();
    this.m_rttTexs[i].name = "sys_rttTex_" + i;
    this.m_rttTexs[i].minFilter = TextureConst_1.default.LINEAR;
    this.m_rttTexs[i].magFilter = TextureConst_1.default.LINEAR;

    this.m_rttTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttTexs[i];
  }

  getDepthTextureAt(i) {
    if (this.m_rttDepthTexs[i] != null) {
      this.m_rttDepthTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttDepthTexs[i];
    }

    this.m_rttDepthTexs[i] = this.createDepthTex2D(64, 64);
    this.m_rttDepthTexs[i].to2DTexture();
    this.m_rttDepthTexs[i].name = "sys_depthTex_" + i;
    this.m_rttDepthTexs[i].minFilter = TextureConst_1.default.NEAREST;
    this.m_rttDepthTexs[i].magFilter = TextureConst_1.default.NEAREST;

    this.m_rttDepthTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttDepthTexs[i];
  }

  createDepthTextureAt(i, pw, ph) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;

    if (this.m_rttDepthTexs[i] != null) {
      this.m_rttDepthTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttDepthTexs[i];
    }

    this.m_rttDepthTexs[i] = this.createDepthTex2D(pw, ph);
    this.m_rttDepthTexs[i].to2DTexture();
    this.m_rttDepthTexs[i].name = "sys_depthTex_" + i;

    this.m_rttDepthTexs[i].__$setRenderProxy(this.m_renderProxy);

    return this.m_rttDepthTexs[i];
  }

  getRTTFloatTextureAt(i) {
    if (this.m_rttFloatTexs[i] != null) {
      this.m_rttFloatTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttFloatTexs[i];
    }

    let tex = this.createRTTTex2D(64, 64);
    tex.to2DTexture();
    this.m_rttFloatTexs[i] = tex;
    this.m_rttFloatTexs[i].name = "sys_rttFloatTex_" + i;
    tex.internalFormat = TextureFormat_1.default.RGBA16F;
    tex.srcFormat = TextureFormat_1.default.RGBA;
    tex.dataType = TextureDataType_1.default.FLOAT;
    tex.minFilter = TextureConst_1.default.NEAREST;
    tex.magFilter = TextureConst_1.default.NEAREST;

    if (RendererDevice_1.default.IsWebGL1()) {
      tex.dataType = TextureDataType_1.default.HALF_FLOAT_OES;
    }

    this.m_rttFloatTexs[i].__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

  createRTTFloatTextureAt(i, pw, ph) {
    pw = pw > 1 ? pw : 1;
    ph = ph > 1 ? ph : 1;

    if (this.m_rttFloatTexs[i] != null) {
      this.m_rttFloatTexs[i].__$setRenderProxy(this.m_renderProxy);

      return this.m_rttFloatTexs[i];
    }

    let tex = this.createRTTTex2D(pw, ph);
    tex.to2DTexture();
    this.m_rttFloatTexs[i] = tex;
    this.m_rttFloatTexs[i].name = "sys_rttFloatTex_" + i;
    tex.internalFormat = TextureFormat_1.default.RGBA16F;
    tex.srcFormat = TextureFormat_1.default.RGBA;
    tex.dataType = TextureDataType_1.default.FLOAT;
    tex.minFilter = TextureConst_1.default.NEAREST;
    tex.magFilter = TextureConst_1.default.NEAREST;

    if (RendererDevice_1.default.IsWebGL1()) {
      tex.dataType = TextureDataType_1.default.HALF_FLOAT_OES;
    }

    this.m_rttFloatTexs[i].__$setRenderProxy(this.m_renderProxy);

    return tex;
  }

}

exports.RTTTextureStore = RTTTextureStore;

/***/ }),

/***/ "ceac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const OBJDescriptorType_1 = __webpack_require__("a054");

exports.OBJModelDataType = OBJDescriptorType_1.OBJModelDataType;

const ThreadTask_1 = __webpack_require__("83a3");

const TaskDependency_1 = __webpack_require__("3b80");
/**
 * obj 几何模型数据加载/解析任务对象
 */


class OBJParseTask extends ThreadTask_1.ThreadTask {
  /**
   * @param src 子线程中代码模块的js文件url 或者 依赖的唯一名称
   */
  constructor(src) {
    super();
    this.m_listener = null;

    if (src.indexOf("/") > 0) {
      this.dependency = new TaskDependency_1.TaskJSFileDependency(src);
    } else {
      this.dependency = new TaskDependency_1.TaskUniqueNameDependency(src);
    }
  }

  setListener(l) {
    this.m_listener = l;
  }

  addBinaryData(buffer, url) {
    if (buffer != null) {
      this.addDataWithParam("", [buffer], {
        url: url
      });
    }
  }

  addURL(url) {
    if (url != "") {
      throw Error("illegal operation!!!");
    }
  } // return true, task finish; return false, task continue...


  parseDone(data, flag) {
    // console.log("OBJParseTask::parseDone(), this.m_listener != null:", this.m_listener != null, data);
    if (this.m_listener != null) {
      let modelData = data.data;
      this.m_listener.objParseFinish(modelData.models, data.descriptor.url);
    }

    return true;
  }

  destroy() {
    super.destroy();
    this.m_listener = null;
  }

}

exports.OBJParseTask = OBJParseTask;

/***/ }),

/***/ "cfaf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class RTTTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_type = TextureProxyType_1.TextureProxyType.RTT;
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
  }

  to2DTexture() {
    this.m_texTarget = TextureTarget_1.default.TEXTURE_2D;
  }

  toCubeTexture() {
    this.m_texTarget = TextureTarget_1.default.TEXTURE_CUBE;
  }

  setSize(fboTextureWidth, fboTextureHeight) {
    this.m_texWidth = fboTextureWidth;
    this.m_texHeight = fboTextureHeight;
  }

  enableMipmap() {
    this.minFilter = TextureConst_1.default.LINEAR_MIPMAP_LINEAR;
    this.magFilter = TextureConst_1.default.LINEAR;
    this.mipmapEnabled = true;
  }

  disableMipmap() {
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.mipmapEnabled = false;
  }

  uploadFromFbo(texResource, fboWidth, fboHeight) {
    let gl = texResource.getRC();
    let mEnabled = this.mipmapEnabled;
    this.mipmapEnabled = false;

    if (!texResource.hasResUid(this.getResUid())) {
      this.m_sampler = TextureTarget_1.default.GetValue(gl, this.m_texTarget);
      this.createTexBuf(texResource);
      texResource.bindToGpu(this.getResUid());
      this.bindTexture(gl, fboWidth, fboHeight);
      this.m_haveRData = true;
      this.m_texWidth = fboWidth;
      this.m_texHeight = fboHeight;

      this.__$buildParam(gl);
    } else if (this.getBufWidth() != fboWidth || this.getBufHeight() != fboHeight) {
      texResource.bindToGpu(this.getResUid());
      this.bindTexture(gl, fboWidth, fboHeight);
      this.m_texWidth = fboWidth;
      this.m_texHeight = fboHeight;

      this.__$buildParam(gl);
    }

    this.mipmapEnabled = mEnabled;
  }

  bindTexture(rgl, fboWidth, fboHeight) {
    let interType = TextureFormat_1.default.ToGL(rgl, this.internalFormat);
    let format = TextureFormat_1.default.ToGL(rgl, this.srcFormat);
    let type = TextureDataType_1.default.ToGL(rgl, this.dataType); //console.log(this,", fboWidth, fboHeight: ",fboWidth, fboHeight, interType,format);

    switch (this.m_texTarget) {
      case TextureTarget_1.default.TEXTURE_2D:
        rgl.texImage2D(rgl.TEXTURE_2D, 0, interType, fboWidth, fboHeight, 0, format, type, null);
        break;

      case TextureTarget_1.default.TEXTURE_CUBE:
        for (let i = 0; i < 6; ++i) {
          rgl.texImage2D(rgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, interType, fboWidth, fboHeight, 0, format, type, null);
        }

        break;

      case TextureTarget_1.default.TEXTURE_SHADOW_2D:
        rgl.texImage2D(rgl.TEXTURE_2D, 0, rgl.DEPTH_COMPONENT16, fboWidth, fboHeight, 0, rgl.DEPTH_COMPONENT, rgl.FLOAT, null);
        break;

      default:
        break;
    }
  }

  toString() {
    return "[RTTTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = RTTTextureProxy;

/***/ }),

/***/ "d2d9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var ThreadCodeSrcType;

(function (ThreadCodeSrcType) {
  /**
   * 线程中的js代码模块通过代码字符串构建
   */
  ThreadCodeSrcType[ThreadCodeSrcType["STRING_CODE"] = 0] = "STRING_CODE";
  /**
   * 线程中的js代码模块通过代码blob构建
   */

  ThreadCodeSrcType[ThreadCodeSrcType["BLOB_CODE"] = 1] = "BLOB_CODE";
  /**
   * 线程中的js代码模块通过外部js文件构建
   */

  ThreadCodeSrcType[ThreadCodeSrcType["JS_FILE_CODE"] = 2] = "JS_FILE_CODE";
  /**
   * 线程中的js代码模块通过代码模块唯一依赖名构建
   */

  ThreadCodeSrcType[ThreadCodeSrcType["DEPENDENCY"] = 3] = "DEPENDENCY";
})(ThreadCodeSrcType || (ThreadCodeSrcType = {}));

exports.ThreadCodeSrcType = ThreadCodeSrcType;

/***/ }),

/***/ "d314":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const TextureProxyType_1 = __webpack_require__("7918");

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class ImageCubeTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight) {
    super(texWidth, texHeight, false);
    this.m_imgDataList = null;
    this.m_texTarget = TextureTarget_1.default.TEXTURE_CUBE;
    this.m_type = TextureProxyType_1.TextureProxyType.ImageCube;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.dataType = TextureDataType_1.default.UNSIGNED_BYTE;
    this.mipmapEnabled = true;
  }

  setDataFromImageToFaceAt(index, img, miplevel = 0) {
    if (img != null) {
      if (this.m_imgDataList == null) {
        this.m_imgDataList = [null, null, null, null, null, null];
      }

      if (img.width > 0 && img.height > 0) {
        if (index == 0) {
          this.m_texWidth = img.width;
          this.m_texHeight = img.height;
          this.m_miplevel = miplevel;
        }

        this.m_imgDataList[index] = {
          imgData: img,
          miplevel: miplevel
        };
        this.m_haveRData = this.m_imgDataList[index] != null;
      }
    }
  }

  uploadData(texRes) {
    let gl = texRes.getRC();
    let imo = null;

    for (let i = 0; i < 6; ++i) {
      imo = this.m_imgDataList[i];
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.m_miplevel, TextureFormat_1.default.ToGL(gl, this.internalFormat), TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), imo.imgData);
    }
  }

  toString() {
    return "[ImageCubeTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      if (this.m_imgDataList != null) {
        for (let i = 0; i < 6; ++i) {
          if (this.m_imgDataList[i] != null) {
            this.m_imgDataList[i].imgData = null;
          }
        }
      }

      console.log("ImageCubeTextureProxy::destroy(), destroy a ImageCubeTextureProxy instance...");

      super.__$destroy();
    }
  }

}

exports.default = ImageCubeTextureProxy;

/***/ }),

/***/ "d35a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const MouseEvent_1 = __importDefault(__webpack_require__("1710"));

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const RendererParam_1 = __importDefault(__webpack_require__("c497"));

const RendererScene_1 = __importDefault(__webpack_require__("b161"));

const CameraStageDragSwinger_1 = __importDefault(__webpack_require__("0890"));

const CameraZoomController_1 = __importDefault(__webpack_require__("a46e"));

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

const VerifierScene_1 = __webpack_require__("4aad");

const Color4_1 = __importDefault(__webpack_require__("3930"));

class RenderingVerifier {
  constructor() {
    this.m_rscene = null;
    this.m_stageDragSwinger = new CameraStageDragSwinger_1.default();
    this.m_cameraZoomController = new CameraZoomController_1.default();
    this.m_profileInstance = null;
    this.m_verifierScene = new VerifierScene_1.VerifierScene();
    this.m_cameraUPY = false;
    this.m_lookV = new Vector3D_1.default(0.0, 0.0, 0.0);
  }

  initialize() {
    console.log("RenderingVerifier::initialize()......");
    document.title = "RenderingVerifier";

    if (this.m_rscene == null) {
      RendererDevice_1.default.SHADERCODE_TRACE_ENABLED = true;
      RendererDevice_1.default.VERT_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED = true;
      RendererDevice_1.default.SetWebBodyColor("white"); //RendererDevice.FRAG_SHADER_PRECISION_GLOBAL_HIGHP_ENABLED = false;

      DivLog_1.default.SetDebugEnabled(true);
      let color = new Color4_1.default();
      color.setRGB3f(0.0, 0.4185, 0.6896);
      DivLog_1.default.SetTextBgColor(color.getRGBUint24());
      DivLog_1.default.SetTextColor(0xeeeeee);
      DivLog_1.default.SetTextBgEnabled(false);
      DivLog_1.default.SetXY(2, 8);
      let rparam = new RendererParam_1.default(); //rparam.maxWebGLVersion = 1;

      rparam.setCamProject(45, 50.0, 10000.0);
      rparam.setAttriStencil(true);
      rparam.setAttriAntialias(true);
      rparam.setCamPosition(2000.0, 2000.0, 2000.0);

      if (this.m_cameraUPY) {
        rparam.setCamUpDirect(0.0, 1.0, 0.0);
      } else {
        rparam.setCamUpDirect(0.0, 0.0, 1.0);
      }

      rparam.setCamLookAtPos(this.m_lookV.x, this.m_lookV.y, this.m_lookV.z);
      this.m_rscene = new RendererScene_1.default();
      this.m_rscene.initialize(rparam, 5);
      this.m_rscene.updateCamera(); // this.m_profileInstance = new ProfileInstance();
      // this.m_profileInstance.initialize(this.m_rscene.getRenderer());

      this.m_rscene.addEventListener(MouseEvent_1.default.MOUSE_DOWN, this, this.mouseDown);
      this.m_rscene.addEventListener(MouseEvent_1.default.MOUSE_UP, this, this.mouseUp);
      this.m_rscene.enableMouseEvent(true);
      this.m_cameraZoomController.bindCamera(this.m_rscene.getCamera());
      this.m_cameraZoomController.initialize(this.m_rscene.getStage3D());
      this.m_cameraZoomController.syncLookAt = true;
      this.m_stageDragSwinger.initialize(this.m_rscene.getStage3D(), this.m_rscene.getCamera()); //this.m_profileInstance.initialize(this.m_rscene.getRenderer());

      this.m_rscene.setClearRGBColor3f(0.5, 0.5, 0.5); //   DivLog.ShowLog("renderer inited.");
      //   DivLog.ShowLog(RendererDevice.GPU_RENDERER);

      this.m_verifierScene.initialize(this.m_rscene);
      this.m_verifierScene.initTest();
    }
  }

  mouseDown(evt) {
    this.m_verifierScene.mouseDown(evt);
  }

  mouseUp(evt) {}

  run() {
    this.m_verifierScene.run();

    if (this.m_cameraUPY) {
      this.m_stageDragSwinger.runWithYAxis();
    } else {
      this.m_stageDragSwinger.runWithZAxis();
    } // this.m_stageDragSwinger.runWithCameraAxis();


    this.m_cameraZoomController.run(this.m_lookV, 30.0);
    this.m_rscene.run(true);

    if (this.m_profileInstance != null) {
      this.m_profileInstance.run();
    }
  }

}

exports.RenderingVerifier = RenderingVerifier;
exports.default = RenderingVerifier;

/***/ }),

/***/ "d53d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ShaderUniform {
  constructor() {
    this.uns = "";
    this.key = -1;
    this.program = null;
    this.types = null;
    this.uniformSize = 0;
    this.uniformNameList = null;
    this.locations = null;
    this.dataSizeList = null;
    this.dataList = null;
    this.calcModels = null;
    this.always = true;
    this.next = null;
  } // for fast data's operation


  getDataRefFromUniformName(ns) {
    if (this.uniformNameList != null) {
      let list = this.uniformNameList;
      let len = list.length;

      for (let i = 0; i < len; ++i) {
        if (ns == list[i]) {
          return this.dataList[i];
        }
      }
    }

    return null;
  } // for fast data's operation


  setDataRefFromUniformName(ns, dataRef) {
    if (this.uniformNameList != null) {
      let list = this.uniformNameList;
      let len = list.length;

      for (let i = 0; i < len; ++i) {
        if (ns == list[i]) {
          this.dataList[i] = dataRef;
          break;
        }
      }
    }
  }

  copyDataFromProbe(probe) {
    this.types = [];
    this.dataSizeList = [];

    for (let i = 0; i < probe.uniformsTotal; ++i) {
      this.types.push(probe.uniformTypes[i]);
      this.dataSizeList.push(probe.dataSizeList[i]);
    }

    this.uniformSize = probe.uniformsTotal;
  }

  useByLocation(rc, type, location, i) {}

  useByShd(rc, shd) {}

  use(rc) {}

  updateData() {}

  destroy() {}

}

exports.ShaderUniform = ShaderUniform; // for webgl1

class ShaderUniformV1 extends ShaderUniform {
  constructor() {
    super();
  }

  use(rc) {
    let i = 0;

    for (; i < this.uniformSize; ++i) {
      rc.useUniformV1(this.locations[i], this.types[i], this.dataList[i], this.dataSizeList[i]);
    }
  }

  useByLocation(rc, type, location, i) {
    rc.useUniformV1(location, type, this.dataList[i], this.dataSizeList[i]);
  }

  useByShd(rc, shd) {
    let i = 0;

    for (; i < this.uniformSize; ++i) {
      //rc.useUniformV1(shd.getUniformLocationByNS(this.uniformNameList[i]),shd.getUniformTypeByNS(this.uniformNameList[i]),this.dataList[i],this.dataSizeList[i]);
      rc.useUniformV1(shd.getUniformLocationByNS(this.uniformNameList[i]), this.types[i], this.dataList[i], this.dataSizeList[i]);
    }
  }

  updateData() {
    if (this.calcModels != null) {
      let len = this.calcModels.length;
      let model = null;

      for (let i = 0; i < len; ++i) {
        model = this.calcModels[i];
        model.buildData();
        model.updateMaterialDataList(this.dataList);
        model.initializeParam();
      }
    }
  }

  destroy() {
    let i = 0;
    let len = this.dataList.length;

    for (; i < len; ++i) {
      this.dataList[i] = null;
    }

    if (this.calcModels != null) {
      len = this.calcModels.length;

      for (i = 0; i < len; ++i) {
        this.calcModels[i].destroy();
        this.calcModels[i] = null;
      }
    }

    this.dataList = null;
    this.types = null;
    this.locations = null;
    this.dataSizeList = null;
    this.calcModels = null;
  }

}

exports.ShaderUniformV1 = ShaderUniformV1; // for webgl2

class ShaderUniformV2 extends ShaderUniform {
  constructor() {
    super();
  }

  use(rc) {
    // new DebugFlag
    // if(this.uns == "ggg" && DebugFlag.Flag_0 > 0) {
    //     let arr = this.dataList[0].slice(0);
    //     console.log("ggg arr: ",arr);
    // }
    let i = 0;

    for (; i < this.uniformSize; ++i) {
      rc.useUniformV2(this.locations[i], this.types[i], this.dataList[i], this.dataSizeList[i], 0);
    }
  }

  useByLocation(rc, type, location, i) {
    rc.useUniformV2(location, type, this.dataList[i], this.dataSizeList[i], 0);
  }

  useByShd(rc, shd) {
    let i = 0;

    for (; i < this.uniformSize; ++i) {
      //rc.useUniformV2(shd.getUniformLocationByNS(this.uniformNameList[i]),shd.getUniformTypeByNS(this.uniformNameList[i]),this.dataList[i],this.dataSizeList[i],0);
      rc.useUniformV2(shd.getUniformLocationByNS(this.uniformNameList[i]), this.types[i], this.dataList[i], this.dataSizeList[i], 0);
    }
  }

  updateData() {
    if (this.calcModels != null) {
      let len = this.calcModels.length;
      let model = null;

      for (let i = 0; i < len; ++i) {
        model = this.calcModels[i];
        model.buildData();
        model.updateMaterialDataList(this.dataList);
        model.initializeParam();
      }
    }
  }

  destroy() {
    let i = 0;
    let len = this.dataList.length;

    for (; i < len; ++i) {
      this.dataList[i] = null;
    }

    if (this.calcModels != null) {
      len = this.calcModels.length;

      for (i = 0; i < len; ++i) {
        this.calcModels[i].destroy();
        this.calcModels[i] = null;
      }
    }

    this.dataList = null;
    this.types = null;
    this.locations = null;
    this.dataSizeList = null;
    this.calcModels = null;
    this.program = null;
  }

}

exports.ShaderUniformV2 = ShaderUniformV2;
/**
 * 只有一个mat4的uniform对象
 * only one mat4 type uniform object
 */

class ShaderMat4Uniform extends ShaderUniform {
  constructor() {
    super();
  }

  use(rc) {
    rc.useUniformMat4(this.locations[0], this.dataList[0]);
  }

  useByLocation(rc, type, location, i) {
    rc.useUniformMat4(location, this.dataList[0]);
  }

  useByShd(rc, shd) {
    rc.useUniformMat4(shd.getUniformLocationByNS(this.uniformNameList[0]), this.dataList[0]);
  }

  destroy() {
    this.dataList[0] = null;
    this.dataList = null;
    this.types = null;
    this.locations = null;
    this.dataSizeList = null;
  }

}

exports.ShaderMat4Uniform = ShaderMat4Uniform;
exports.default = ShaderUniform;

/***/ }),

/***/ "d7e2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));
/**
 * 在 renderer process 中 通过和摄像机之间的距离, 对可渲染对象渲染先后顺序的排序
 */


class CameraDsistanceSorter {
  constructor(rc) {
    this.m_rc = null;
    this.m_rc = rc;
  }

  sortRODisplay(nodes, nodesTotal) {
    let camPos = this.m_rc.getCamera().getPosition();

    for (let i = 0; i < nodesTotal; ++i) {
      nodes[i].value = -Vector3D_1.default.DistanceSquared(nodes[i].bounds.center, camPos); //nodes[i].value = nodes[i].pos.y;
    }

    return 0;
  }

}

exports.default = CameraDsistanceSorter;

/***/ }),

/***/ "d872":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformDataSlot_1 = __webpack_require__("5326");

const ShaderUniformProbe_1 = __importDefault(__webpack_require__("3077"));

const UniformVec4Probe_1 = __importDefault(__webpack_require__("3024"));

const ShaderGlobalUniform_1 = __importDefault(__webpack_require__("7279"));

class ShaderUniformContext {
  constructor(rcuid, dataTotal = 256) {
    this.m_rcuid = 0;
    this.m_udSlot = null;
    this.m_rcuid = rcuid;
    this.m_udSlot = new UniformDataSlot_1.UniformDataSlot(rcuid, dataTotal);
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_rcuid;
  }

  createShaderUniformProbe() {
    let probe = new ShaderUniformProbe_1.default(this.m_udSlot);
    return probe;
  }

  createUniformVec4Probe(vec4Total) {
    let probe = new UniformVec4Probe_1.default(this.m_udSlot, vec4Total);
    return probe;
  }

  createGlobalUinformFromProbe(uProbe, uniformNames = null) {
    let suo = this.createShaderGlobalUniform();
    this.updateGlobalUinformDataFromProbe(suo, uProbe, uniformNames);
    return suo;
  }

  updateGlobalUinformDataFromProbe(psuo, uProbe, uniformNames = null) {
    let suo = psuo;
    suo.uniformNameList = uniformNames != null ? uniformNames : uProbe.uniformNames;
    suo.copyDataFromProbe(uProbe);
    uProbe.update();
  }

  createShaderGlobalUniform() {
    let suo = new ShaderGlobalUniform_1.default(this.m_udSlot);
    return suo;
  }

  createShaderGlobalUniformFromProbe(uProbe, puns, uniformNames = null) {
    let suo = new ShaderGlobalUniform_1.default(this.m_udSlot);
    suo.uns = puns;
    suo.uniformNameList = uniformNames != null ? uniformNames : uProbe.uniformNames;
    suo.copyDataFromProbe(uProbe);
    uProbe.update();
    return suo;
  }

  createShaderGlobalUniformFromProbeAt(uProbe, puns, uniformNames = null, index) {
    let suo = new ShaderGlobalUniform_1.default(this.m_udSlot);
    suo.uns = puns;
    suo.uniformNameList = uniformNames != null ? uniformNames : uProbe.uniformNames;

    if (index < 0) {
      suo.copyDataFromProbe(uProbe);
    } else {
      suo.copyDataFromProbeAt(index, uProbe);
    }

    uProbe.update();
    return suo;
  }

  cloneShaderGlobalUniform(psuo) {
    let suo = psuo;
    return suo.clone();
  }

}

exports.ShaderUniformContext = ShaderUniformContext;

/***/ }),

/***/ "d958":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RSEntityFlag_1 = __importDefault(__webpack_require__("11e6"));

const ShaderUniformContext_1 = __webpack_require__("d872");

const RODataBuilder_1 = __importDefault(__webpack_require__("36cb"));

const RenderProcessBuider_1 = __importDefault(__webpack_require__("3c81"));

const ROVtxBuilder_1 = __importDefault(__webpack_require__("1e15"));

const RendererInstanceContext_1 = __webpack_require__("0e01");

const RPOUnitBuilder_1 = __webpack_require__("eca0");

const RPONodeBuilder_1 = __importDefault(__webpack_require__("442e"));

const DispEntity3DManager_1 = __importDefault(__webpack_require__("1264"));
/**
 * kernal system instance, it is the renderer instance for the renderer runtime, it is very very very important class.
 */


class RendererInstance {
  constructor() {
    this.___$$$$$$$Author = "VilyLei(vily313@126.com)";
    this.m_uid = -1;
    this.m_entity3DMana = null;
    this.m_processes = [];
    this.m_processesLen = 0;
    this.m_sprocesses = [];
    this.m_sprocessesLen = 0;
    this.m_renderProxy = null;
    this.m_adapter = null;
    this.m_dataBuilder = null;
    this.m_renderInsContext = null;
    this.m_batchEnabled = true;
    this.m_processFixedState = true;
    this.m_rpoUnitBuilder = new RPOUnitBuilder_1.RPOUnitBuilder();
    this.m_rpoNodeBuilder = new RPONodeBuilder_1.default();
    this.m_processBuider = new RenderProcessBuider_1.default();
    this.m_roVtxBuilder = null;
    this.m_stage3D = null;
    this.m_fixProcess = null;
    this.m_uid = RendererInstance.s_uid++;
    this.m_renderInsContext = new RendererInstanceContext_1.RendererInstanceContext(this.m_uid);
  }

  __$setStage3D(stage3D) {
    if (stage3D != null && this.m_stage3D == null) {
      this.m_stage3D = stage3D;
    }
  }

  getUid() {
    return this.m_uid;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_uid;
  }

  getRPONodeBuilder() {
    return this.m_rpoNodeBuilder;
  }

  getDataBuilder() {
    return this.m_dataBuilder;
  }

  getRendererContext() {
    return this.m_renderInsContext;
  }

  getRenderProxy() {
    if (this.m_renderProxy != null) {
      return this.m_renderProxy;
    }

    this.m_renderProxy = this.m_renderInsContext.getRenderProxy();
    return this.m_renderProxy;
  }

  getStage3D() {
    return this.m_renderProxy.getStage3D();
  }

  getViewX() {
    return this.m_adapter.getViewportX();
  }

  getViewY() {
    return this.m_adapter.getViewportY();
  }

  getViewWidth() {
    return this.m_adapter.getViewportWidth();
  }

  getViewHeight() {
    return this.m_adapter.getViewportHeight();
  }

  getCamera() {
    return this.m_renderInsContext.getCamera();
  }

  createCamera() {
    return null;
  }

  useCamera(camera, syncCamView = false) {}

  useMainCamera() {}

  updateCamera() {
    if (this.m_renderProxy != null) {
      this.m_renderProxy.updateCamera();
    }
  }

  initialize(param = null, camera = null, shdProgramBuider = null) {
    if (this.m_dataBuilder == null && camera != null) {
      this.m_batchEnabled = param.batchEnabled;
      this.m_processFixedState = param.processFixedState;
      this.m_renderProxy = this.m_renderInsContext.getRenderProxy();
      this.m_uid = this.m_renderProxy.getUid();
      this.m_dataBuilder = new RODataBuilder_1.default(shdProgramBuider);
      this.m_roVtxBuilder = new ROVtxBuilder_1.default();
      this.m_renderInsContext.setCameraParam(param.camProjParam.x, param.camProjParam.y, param.camProjParam.z);
      let contextParam = new RendererInstanceContext_1.RendererInstanceContextParam();
      contextParam.uniformContext = new ShaderUniformContext_1.ShaderUniformContext(this.m_renderProxy.getRCUid());
      contextParam.camera = camera;
      contextParam.stage = this.m_stage3D;
      contextParam.builder = this.m_dataBuilder;
      contextParam.vtxBuilder = this.m_roVtxBuilder;
      contextParam.shaderProgramBuilder = shdProgramBuider;
      this.m_renderInsContext.initialize(param, camera, contextParam);
      this.m_adapter = this.m_renderProxy.getRenderAdapter();
      this.m_dataBuilder.initialize(this.m_renderProxy, this.m_rpoUnitBuilder, this.m_processBuider, this.m_roVtxBuilder);
      this.m_renderInsContext.initManager(this.m_dataBuilder);
      this.m_entity3DMana = new DispEntity3DManager_1.default(this.m_uid, this.m_dataBuilder, this.m_rpoUnitBuilder, this.m_processBuider);
      this.m_fixProcess = this.createSeparatedProcess();
      this.appendProcess(this.m_batchEnabled, this.m_processFixedState);
    }
  }
  /**
   * 获取渲染器可渲染对象管理器状态(版本号)
   */


  getRendererStatus() {
    return this.m_entity3DMana.version;
  }
  /**
   * update all data or status of the renderer runtime
   * should call this function per frame
   */


  update() {
    this.m_renderProxy.Texture.update();
    this.m_renderProxy.Vertex.update();
    this.m_entity3DMana.update();
  }

  updateAllProcess() {
    for (let i = 0; i < this.m_processesLen; ++i) {
      this.m_processes[i].update();
    }
  }

  updateProcessAt(processIndex) {
    if (processIndex > -1 && processIndex < this.m_processesLen) {
      this.m_processes[processIndex].update();
    }
  }

  setEntityManaListener(listener) {
    this.m_entity3DMana.setListener(listener);
  }
  /**
   * add an entity to the renderer process of the renderer instance
   * @param entity IRenderEntity instance(for example: DisplayEntity class instance)
   * @param processIndex this destination renderer process index of the m_processes array.
   * @param deferred if the value is true,the entity will not to be immediately add to the renderer process by its id
   */


  addEntity(entity, processIndex = 0, deferred = true) {
    if (entity != null) {
      if (entity.__$testRendererEnabled()) {
        if (processIndex > -1 && processIndex < this.m_processesLen) {
          this.m_entity3DMana.addEntity(entity, this.m_processes[processIndex].getUid(), deferred);
        }
      }
    }
  }

  addEntityToProcess(entity, process, deferred = true) {
    if (process != null && entity != null) {
      if (entity.__$testRendererEnabled()) {
        if (process.getRCUid() == this.m_uid) {
          this.m_entity3DMana.addEntity(entity, process.getUid(), deferred);
        }
      }
    }
  }
  /**
   * 将已经在渲染运行时中的entity移动到指定 process uid 的 render process 中去
   * move rendering runtime displayEntity to different renderer process
   */


  moveEntityToProcessAt(entity, dstProcessIndex) {
    if (entity != null && entity.getRendererUid() == this.m_uid) {
      if (entity.isInRendererProcess()) {
        if (dstProcessIndex > -1 && dstProcessIndex < this.m_processesLen) {
          let srcUid = entity.getDisplay().__$$runit.getRPROUid();

          let src = this.m_processBuider.getNodeByUid(srcUid);
          let dst = this.m_processes[dstProcessIndex];

          if (src != dst) {
            src.removeDispUnit(entity.getDisplay());
            entity.__$rseFlag = dst.getSortEnabled() ? RSEntityFlag_1.default.AddSortEnabled(entity.__$rseFlag) : RSEntityFlag_1.default.RemoveSortEnabled(entity.__$rseFlag);
            dst.addDisp(entity.getDisplay());
          }
        }
      }
    }
  }

  moveEntityToProcess(entity, dstProcess) {
    if (dstProcess != null && entity != null && entity.getRendererUid() == this.m_uid) {
      if (entity.isInRendererProcess()) {
        let srcUid = entity.getDisplay().__$$runit.getRPROUid();

        let src = this.m_processBuider.getNodeByUid(srcUid);

        if (src != dstProcess) {
          let dst = dstProcess;
          src.removeDispUnit(entity.getDisplay());
          entity.__$rseFlag = dstProcess.getSortEnabled() ? RSEntityFlag_1.default.AddSortEnabled(entity.__$rseFlag) : RSEntityFlag_1.default.RemoveSortEnabled(entity.__$rseFlag);
          dst.addDisp(entity.getDisplay());
        }
      }
    }
  }
  /**
   * remove entity from the renderer instance
   * @param entity IRenderEntity instance
   */


  removeEntity(entity) {
    if (entity != null && entity.getRendererUid() == this.m_uid) {
      this.m_entity3DMana.removeEntity(entity);

      entity.__$setRenderProxy(null);
    }
  }
  /**
   * remove entity from the renderer process
   * @param IRenderEntity IRenderEntity instance
   * @param process RenderProcess instance
   */


  removeEntityFromProcess(entity, process) {
    if (process != null && process.getRCUid() == this.m_uid) {
      if (entity != null && entity.getRendererUid() == this.m_uid) {
        process.removeDisp(entity.getDisplay());

        entity.__$setRenderProxy(null);
      }
    }
  }
  /**
   * remove entity from the renderer process by process index
   * @param IRenderEntity IRenderEntity instance
   * @param processIndex RenderProcess instance index in renderer instance
   */


  removeEntityByProcessIndex(entity, processIndex) {
    if (processIndex >= 0 && processIndex < this.m_processesLen) {
      if (entity != null && entity.getRendererUid() == this.m_uid) {
        this.m_processes[processIndex].removeDisp(entity.getDisplay());

        entity.__$setRenderProxy(null);
      }
    }
  }

  setProcessSortEnabledAt(processIndex, sortEnabled) {
    if (processIndex >= 0 && processIndex < this.m_processesLen) {
      this.m_processes[processIndex].setSortEnabled(sortEnabled);
    }
  }

  setProcessSortEnabled(process, sortEnabled) {
    if (process != null && process.getRCUid() == this.m_uid) {
      let p = process;
      p.setSortEnabled(sortEnabled);
    }
  }
  /**
   * get the renderer process by process index
   * @param processIndex IRenderProcess instance index in renderer instance
   */


  getRenderProcessAt(processIndex) {
    return this.m_processes[processIndex];
  }
  /**
   * append a new renderer process instance
   * @param batchEnabled batch renderer runtime resource data
   * @param processFixedState the process is fix renderer state
   * @returns
   */


  appendProcess(batchEnabled = true, processFixedState = false) {
    this.m_processBuider.setCreateParams(this.m_dataBuilder.getRenderShader(), this.m_rpoNodeBuilder, this.m_rpoUnitBuilder, this.m_renderProxy.Vertex, batchEnabled, processFixedState);
    let process = this.m_processBuider.create();
    this.m_processes.push(process);
    process.setRendererParam(this.m_renderProxy, this.m_processesLen);
    ++this.m_processesLen;
    return process;
  }
  /**
   * append a independent new renderer process instance, and separate the renderer process from the renderer rendering control
   * @param batchEnabled batch renderer runtime resource data
   * @param processFixedState the process is fix renderer state
   */


  createSeparatedProcess(batchEnabled = true, processFixedState = false) {
    this.m_processBuider.setCreateParams(this.m_dataBuilder.getRenderShader(), this.m_rpoNodeBuilder, this.m_rpoUnitBuilder, this.m_renderProxy.Vertex, batchEnabled, processFixedState);
    let process = this.m_processBuider.create();
    this.m_sprocesses.push(process);
    process.setRendererParam(this.m_renderProxy, this.m_sprocessesLen);
    return process;
  }

  setRendererProcessParam(index, batchEnabled, processFixedState) {
    if (index > -1 && index < this.m_processesLen) {
      this.m_processes[index].setRenderParam(batchEnabled, processFixedState);
    }
  }

  getProcessAt(index) {
    if (index > -1 && index < this.m_processesLen) {
      return this.m_processes[index];
    }

    return null;
  }

  showInfoAt(index) {
    if (index > -1 && index < this.m_processesLen) {
      this.m_processes[index].showInfo();
    }
  }

  getProcessesTotal() {
    return this.m_processesLen;
  }

  updateMaterialUniformToCurrentShd(material) {
    this.m_dataBuilder.getRenderShader().useUniformToCurrentShd(material.__$uniform);
  }
  /**
   * Deprecated(废弃, 不推荐使用)
   * 绘制已经完全加入渲染器了渲染资源已经准备完毕的entity
   * 要锁定Material才能用这种绘制方式,再者这个,这种方式比较耗性能，只能用在特殊的地方
   */


  drawEntityByLockMaterial(entity, useGlobalUniform = false, forceUpdateUniform = true) {
    if (entity != null && entity.getVisible() && entity.getRendererUid() == this.m_uid && !this.m_renderProxy.isContextLost()) {
      this.m_fixProcess.drawLockMaterialByDisp(entity.getDisplay(), useGlobalUniform, forceUpdateUniform);
    }
  }
  /**
   * 在任意阶段绘制一个指定的 entity,只要其资源数据准备完整
   */


  drawEntity(entity, useGlobalUniform = false, forceUpdateUniform = true) {
    if (entity != null && entity.getVisible() && !this.m_renderProxy.isContextLost()) {
      // console.log("***8** rendewrer ins drawEntity(), entity: ",entity, entity.getRendererUid() == this.m_uid);
      if (entity.getRendererUid() == this.m_uid) {
        this.m_fixProcess.drawDisp(entity.getDisplay(), useGlobalUniform, forceUpdateUniform);
      } else if (entity.__$testRendererEnabled()) {
        this.m_entity3DMana.addEntity(entity, this.m_fixProcess.getUid(), false);
      }
    }
  }
  /**
   * run the specific renderer process by its index in the renderer instance
   * @param index the renderer process index in the renderer instance
   */


  runAt(index) {
    if (!this.m_renderProxy.isContextLost()) {
      this.m_processes[index].run();
    }
  }

  runProcess(process) {
    if (process.getRCUid() == this.m_uid && !this.m_renderProxy.isContextLost()) {
      process.run();
    }
  }

  runFromIndexTo(index) {
    if (!this.m_renderProxy.isContextLost()) {
      for (let i = index; i < this.m_processesLen; ++i) {
        this.m_processes[i].run();
      }
    }
  }
  /**
   * run all renderer processes in the renderer instance
   */


  run() {
    if (this.m_entity3DMana.isHaveEntity() && !this.m_renderProxy.isContextLost()) {
      for (let i = 0; i < this.m_processesLen; ++i) {
        this.m_processes[i].run();
      }
    }
  }

  getRenderUnitsTotal() {
    let total = 0;

    for (let i = 0; i < this.m_processesLen; ++i) {
      total += this.m_processes[i].getUnitsTotal();
    }

    return total;
  }

  renderflush() {
    this.m_renderProxy.flush();
  }

  toString() {
    return "[RendererInstance(uid = " + this.m_uid + ")]";
  }

}

RendererInstance.s_uid = 0;
exports.RendererInstance = RendererInstance;
exports.default = RendererInstance;

/***/ }),

/***/ "d9d1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DracoGeomParseTask_1 = __webpack_require__("dba0");

const DracoGeomParseTaskDataRouter_1 = __webpack_require__("7c58");
/**
 * draco 几何模型数据加载和解析
 */


class DracoGeomBuilder {
  constructor(taskModuleUrl, dracoWasmVersion = 2) {
    this.m_inited = true;
    this.m_thrSchedule = null;
    this.m_meshBuf = null;
    this.m_listener = null;
    this.m_dracoTask = null;
    this.m_wasmUrl = "";
    this.m_segRangeList = null;
    this.m_taskModuleUrl = taskModuleUrl;
    this.m_dracoWasmVersion = dracoWasmVersion;
  }

  setListener(l) {
    this.m_listener = l;

    if (this.m_dracoTask != null) {
      this.m_dracoTask.setListener(l);
    }
  }

  initialize(threadSchedule, urlDir = "static/cospace/modules/dracoLib/") {
    if (this.m_inited) {
      this.m_inited = false;
      this.m_thrSchedule = threadSchedule;
      let wasmUrl = "d2.md";
      let wapperUrl = "w2.js";

      switch (this.m_dracoWasmVersion) {
        case 1:
          wasmUrl = "d1.md";
          wapperUrl = "w1.js";
          break;

        case 3:
          wasmUrl = "d3.md";
          wapperUrl = "w3.js";
          break;

        default:
          break;
      }

      this.buildTask(urlDir + wapperUrl, urlDir + wasmUrl);
    }
  }

  parseBinaryData(bufData, segRangeList = null) {
    if (bufData != null) {
      if (segRangeList == null || segRangeList.length < 2) {
        this.m_segRangeList = [-1, -1];
      } else {
        this.m_segRangeList = segRangeList.slice(0);
      }

      this.m_meshBuf = bufData;

      if (this.m_dracoTask != null) {
        if (!this.m_dracoTask.isFinished()) {
          console.error("the draco mesh parseing do not finish, can not load other draco data.");
        }

        this.m_dracoTask.reset();
        this.m_dracoTask.setParseSrcData(this.m_meshBuf, this.m_segRangeList);
      }
    }
  }

  parseSingleSegData(bufData, url, index = 0) {
    if (bufData != null) {
      console.log("parseSingleSegData() A, this.m_dracoTask.getTaskClass(): ", this.m_dracoTask.getTaskClass());
      this.m_dracoTask.setSingleSegData(bufData, url, index);
    }
  }
  /**
   * 加载未加密的draco模型文件
   * @param dracoDataUrl draco模型文件url
   * @param segRangeList draco模型文件字节分段信息
   */


  load(dracoDataUrl, segRangeList = null) {
    if (segRangeList == null || segRangeList.length < 2) {
      this.m_segRangeList = [-1, -1];
    } else {
      this.m_segRangeList = segRangeList.slice(0);
    }

    if (this.m_dracoTask != null) {
      if (!this.m_dracoTask.isFinished()) {
        console.error("the draco mesh parseing do not finish, can not load other draco data.");
      }

      this.m_dracoTask.reset();
    }

    this.loadDracoFile(dracoDataUrl);
  }

  loadDracoFile(dracoDataUrl) {
    const reader = new FileReader();

    reader.onload = e => {
      this.m_meshBuf = reader.result;
      this.m_dracoTask.setParseSrcData(this.m_meshBuf, this.m_segRangeList);
    };

    const request = new XMLHttpRequest();
    request.open("GET", dracoDataUrl, true);
    request.responseType = "blob";

    request.onload = () => {
      reader.readAsArrayBuffer(request.response);
    };

    request.send(null);
  }

  buildTask(wapperUrl, wasmUrl) {
    this.m_wasmUrl = wasmUrl;
    let threadSchedule = this.m_thrSchedule;

    if (threadSchedule != null) {
      // 创建和多线程关联的任务, 通过外部js文件url的形式创建任务实例
      // this.m_dracoTask = new DracoGeomParseTask( this.m_taskModuleUrl, threadSchedule );
      // 创建和多线程关联的任务, 通过外部js文件的依赖唯一名称的形式创建任务实例
      this.m_dracoTask = new DracoGeomParseTask_1.DracoGeomParseTask("dracoGeomParser", threadSchedule);
      this.m_dracoTask.setListener(this.m_listener); // 初始化draco解析所需的基本库, 因为有依赖管理器，这一句代码可以不用(依赖关系机制会完成对应的功能)
      //threadSchedule.initModules([wapperUrl]);
      // 多线程任务调度器绑定当前的 draco task

      threadSchedule.bindTask(this.m_dracoTask);

      if (!threadSchedule.hasRouterByTaskClass(this.m_dracoTask.getTaskClass())) {
        // 设置draco解析任务功能所需的数据路由
        let router = new DracoGeomParseTaskDataRouter_1.DracoGeomParseTaskDataRouter(this.m_dracoTask.getTaskClass(), wasmUrl);
        threadSchedule.setTaskDataRouter(router);
      }
    }
  }
  /**
   * 销毁当前实例
   */


  destroy() {
    if (this.m_dracoTask != null) {
      this.m_dracoTask.destroy();
      this.m_dracoTask = null;
    }

    this.m_meshBuf = null;
    this.m_listener = null;
    this.m_thrSchedule = null;
  }

}

exports.DracoGeomBuilder = DracoGeomBuilder;

/***/ }),

/***/ "da6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class TextureResSlot {
  constructor() {
    this.m_texResource = null;
    this.m_bufferUpdater = null;
    this.m_textureTotal = 0;
    this.m_textureMap = new Map();
    this.m_freeMap = new Map();
    this.m_texUid = 0;
    this.m_freeUids = [];

    if (TextureResSlot.s_ins != null) {
      throw Error("This Class is a singleton class!!!");
    }

    TextureResSlot.s_ins = null;
  }

  static GetInstance() {
    if (TextureResSlot.s_ins != null) {
      return TextureResSlot.s_ins;
    }

    TextureResSlot.s_ins = new TextureResSlot();
    return TextureResSlot.s_ins;
  }

  getFreeUid() {
    if (this.m_freeUids.length > 0) {
      return this.m_freeUids.pop();
    }

    let uid = this.m_texUid++;
    return uid;
  }
  /**
   * 将texture实例添加到统一管理的 TextureResSlot中
   * 这个函数不允许其他地方调用
   */


  __$$addTexture(texture) {
    if (texture != null && !this.m_textureMap.has(texture.getUid())) {
      this.m_textureMap.set(texture.getUid(), texture);
      this.m_textureTotal++;
    }
  }

  getTextureByUid(uid) {
    return this.m_textureMap.get(uid);
  }

  hasTextureByUid(uid) {
    return this.m_textureMap.has(uid);
  }

  removeTextureByUid(uid) {
    if (this.m_textureMap.has(uid)) {
      let tex = this.m_textureMap.get(uid);

      if (tex.getAttachCount() < 1) {
        if (this.m_freeMap.has(uid)) {
          this.m_freeMap.delete(uid);
        }

        tex.__$destroy();

        tex.__$$removeFromSlot();

        this.m_textureMap.delete(uid);
        this.m_freeUids.push(uid);
        this.m_textureTotal--;
        return tex;
      }
    }

    return null;
  }
  /**
   * @returns get runtime all textures amount
   */


  getTextureTotal() {
    return this.m_textureTotal;
  }

  setRenderProxy(renderProxy) {
    this.m_texResource = renderProxy.Texture;
  }

  setBufferUpdater(bufferUpdater) {
    this.m_bufferUpdater = bufferUpdater;
  }

  getFreeResUidMap() {
    return this.m_freeMap;
  }

  isGpuEnabledByResUid(resUid) {
    return this.m_texResource.hasResUid(resUid);
  } // 先使用map hash拦截的方式,来决定buf和renderer context避免重复的单次关联


  addRenderBuffer(buf, bufResUid) {
    if (this.m_bufferUpdater != null) {
      this.m_bufferUpdater.__$addBuf(buf, bufResUid);
    }
  }

  addFreeUid(uid) {
    this.m_freeMap.set(uid, 0);
  }

  removeFreeUid(uid) {
    if (this.m_freeMap.has(uid)) {
      this.m_freeMap.delete(uid);
    }
  }

}

TextureResSlot.s_ins = null;
exports.default = TextureResSlot;

/***/ }),

/***/ "dba0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const TaskDependency_1 = __webpack_require__("3b80");

const ThreadTask_1 = __webpack_require__("83a3");

const DracoTaskCMD_1 = __webpack_require__("2e55");
/**
 * draco 几何模型数据解析任务对象
 */


class DracoGeomParseTask extends ThreadTask_1.ThreadTask {
  /**
   * @param src 子线程中代码模块的js文件url 或者 依赖的唯一名称
   * @param thrScheDule 多线程调度器
   */
  constructor(src, thrScheDule) {
    super();
    this.m_enabled = true;
    this.m_listener = null;
    this.m_models = [];
    this.m_srcBuf = null;
    this.m_segs = null;
    this.m_segIndex = 0;
    this.m_single = false;

    if (src.indexOf("/") > 0) {
      this.dependency = new TaskDependency_1.TaskJSFileDependency(src);
    } else {
      this.dependency = new TaskDependency_1.TaskUniqueNameDependency(src);
    }

    this.m_thrScheDule = thrScheDule;
  }

  setListener(l) {
    this.m_listener = l;
  }

  reset() {
    super.reset();
    this.m_models = [];
    this.m_segIndex = 0;
    this.m_segs = null;
    this.m_enabled = true;
  }

  setSingleSegData(bufData, url, index = 0) {
    if (bufData != null) {
      this.m_single = true;
      this.addDataWithParam(DracoTaskCMD_1.DracoTaskCMD.PARSE, [new Uint8Array(bufData)], {
        beginI: 0,
        endI: bufData.byteLength,
        status: 0,
        url: url,
        index: index
      });
    }
  }

  parseData(bufData, beginI, endI) {
    if (bufData != null) {
      this.m_enabled = false;
      this.addDataWithParam(DracoTaskCMD_1.DracoTaskCMD.PARSE, [new Uint8Array(bufData)], {
        beginI: beginI,
        endI: endI,
        status: 0
      });
    }
  }

  parseNextSeg() {
    if (this.m_enabled && this.m_segs != null && this.m_segIndex < this.m_segs.length) {
      let tot = this.m_thrScheDule.getMaxThreadsTotal() > 0 ? this.m_thrScheDule.getMaxThreadsTotal() : 1;

      for (let i = 0; i < tot; i++) {
        if (this.m_segIndex < this.m_segs.length) {
          let begin = this.m_segs[this.m_segIndex];
          let end = this.m_segs[this.m_segIndex + 1];

          if (begin < 0) {
            begin = 0;
          }

          if (end < 8 || end > this.m_srcBuf.byteLength) {
            end = this.m_srcBuf.byteLength;
          }

          let buf = this.m_srcBuf.slice(begin, end);
          this.parseData(buf, 0, buf.byteLength);
          this.m_segIndex += 2;
        } else {
          break;
        }
      }
    }
  }

  setParseSrcData(bufData, segs) {
    if (bufData != null && segs != null && this.m_segs == null) {
      this.m_single = false;
      this.m_segIndex = 0;
      this.m_srcBuf = bufData;
      this.m_segs = segs;
      this.setParseTotal(segs.length / 2);
      this.parseNextSeg();
    }
  } // return true, task finish; return false, task continue...


  parseDone(data, flag) {
    console.log("XXXX DracoGeomParseTask::parseDone(), data: ", data);

    switch (data.taskCmd) {
      case DracoTaskCMD_1.DracoTaskCMD.PARSE:
        this.m_enabled = true;
        let model = data.data.model;
        if (model.normals == undefined) model.normals = null;
        if (model.uvsList == undefined) model.uvsList = null;

        if (this.m_single) {
          let desc = data.descriptor;
          this.m_listener.dracoParseSingle(model, desc.url, desc.index);
        } else {
          this.m_parseIndex++;
          this.m_models.push(model);

          if (this.m_listener != null) {
            if (this.isFinished()) {
              this.m_listener.dracoParseFinish(this.m_models, this.getParseTotal());
            } else {
              this.parseNextSeg();
              this.m_listener.dracoParse(model, this.getParsedIndex(), this.getParseTotal());
            }
          }
        }

        break;

      default:
        break;
    }

    return true;
  }

  destroy() {
    super.destroy();
    this.m_listener = null;
    this.m_srcBuf = null;
    this.m_models = [];
    this.m_segIndex = 0;
    this.m_segs = null;
  }

}

exports.DracoGeomParseTask = DracoGeomParseTask;

/***/ }),

/***/ "dc2b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/
// 只是用于视觉表现上的渲染控制, 而和transform或者非渲染的逻辑无关
// 一个 RODisplay 和一个 IRPODisplay一一对应, 一个RODisplay也只会和一个renderer相关联

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderConst_1 = __webpack_require__("e08e");

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

class RODisplay {
  constructor() {
    this.m_uid = 0;
    this.m_material = null; // 只是持有引用不做任何管理操作

    this.m_matFS32 = null;
    this.name = "RODisplay"; // render yes or no

    this.visible = true;
    this.ivsIndex = 0;
    this.ivsCount = 0; // only use in drawElementsInstanced()...

    this.trisNumber = 0;
    this.insCount = 0;
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES;
    this.vbuf = null; // record render state: shadowMode(one byte) + depthTestMode(one byte) + blendMode(one byte) + cullFaceMode(one byte)
    // its value come from: RendererState.CreateRenderState("default", CullFaceMode.BACK,RenderBlendMode.NORMAL,DepthTestMode.OPAQUE);

    this.renderState = RendererState_1.default.NORMAL_STATE;
    this.rcolorMask = RendererState_1.default.COLOR_MASK_ALL_TRUE; // mouse interaction enabled flag

    this.mouseEnabled = false;
    this.m_partGroup = null;
    this.m_trans = null; // 只能由渲染系统内部调用

    this.__$ruid = -1; // 用于关联IRPODisplay对象

    this.__$rpuid = -1; // 用于关联RPONode对象

    this.__$$rsign = RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER;
    this.__$$runit = null;
    this.m_uid = RODisplay.s_uid++;
  } // draw parts group: [ivsCount0,ivsIndex0, ivsCount1,ivsIndex1, ivsCount2,ivsIndex2, ...]


  getPartGroup() {
    return this.m_partGroup;
  }

  createPartGroup(partsTotal) {
    if (partsTotal < 1) {
      partsTotal = 1;
    }

    this.m_partGroup = new Uint16Array(partsTotal * 2);
  }

  setDrawPartAt(index, ivsIndex, ivsCount) {
    index *= 2;
    this.m_partGroup[index] = ivsCount;
    this.m_partGroup[++index] = ivsIndex;
  }

  getUid() {
    return this.m_uid;
  }

  setTransform(trans) {
    this.m_trans = trans;
    this.m_matFS32 = trans.getLocalFS32();
  }

  getTransform() {
    return this.m_trans;
  }

  getMatrixFS32() {
    return this.m_matFS32;
  }

  enableDrawInstanced(offset, instanceCount) {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_INSTANCED_TRIANGLES;
    this.ivsIndex = offset;
    this.insCount = instanceCount;
  }

  disableDrawInstanced() {
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES;
  }

  getMaterial() {
    return this.m_material;
  }

  setMaterial(m) {
    if (this.m_material != null) {
      if (this.m_material != m) {
        this.m_material.__$detachThis();

        if (m != null) {
          m.__$attachThis();
        }
      }
    }

    this.m_material = m;
  }

  copyFrom(display) {
    this.vbuf = display.vbuf;
    this.ivsIndex = display.ivsIndex;
    this.ivsCount = display.ivsCount;
    this.setMaterial(display.getMaterial());
  }

  toString() {
    return "RODisplay(name=" + this.name + ",uid=" + this.getUid() + ", __$ruid=" + this.__$ruid + ")";
  }

  destroy() {
    // 如果只有自己持有 this.m_material, 则destroy this.m_material
    // 这里还需要优化
    if (this.m_material != null) {
      this.m_material.__$detachThis();

      this.m_material.destroy();
      this.m_material = null;
    }

    this.m_matFS32 = null;
    this.vbuf = null;
    this.__$ruid = -1;
    this.__$rpuid = -1;
    this.__$$rsign = RenderConst_1.DisplayRenderSign.NOT_IN_RENDERER;
    this.ivsIndex = 0;
    this.ivsCount = 0;
    this.m_partGroup = null;
    this.__$$runit = null;
  }

  static GetFreeId() {
    if (RODisplay.m_freeIdList.length > 0) {
      return RODisplay.m_freeIdList.pop();
    }

    return -1;
  }

  static GetByUid(uid) {
    return RODisplay.m_unitList[uid];
  }

  static IsEnabledByUid(uid) {
    return RODisplay.m_unitFlagList[uid] == RODisplay.s_FLAG_BUSY;
  }

  static Create() {
    let unit = null;
    let index = RODisplay.GetFreeId(); //console.log("RODisplay::Create(), RODisplay.m_unitList.length: "+RODisplay.m_unitList.length);

    if (index >= 0) {
      unit = RODisplay.m_unitList[index];
      RODisplay.m_unitFlagList[index] = RODisplay.s_FLAG_BUSY;
    } else {
      unit = new RODisplay();
      RODisplay.m_unitList.push(unit);
      RODisplay.m_unitFlagList.push(RODisplay.s_FLAG_BUSY);
      RODisplay.m_unitListLen++;
    }

    return unit;
  }

  static Restore(pdisp) {
    if (pdisp != null && RODisplay.m_unitFlagList[pdisp.getUid()] == RODisplay.s_FLAG_BUSY) {
      let uid = pdisp.getUid();
      RODisplay.m_freeIdList.push(uid);
      RODisplay.m_unitFlagList[uid] = RODisplay.s_FLAG_FREE;
      pdisp.destroy();
    }
  }

}

RODisplay.s_uid = 0;
RODisplay.s_FLAG_BUSY = 1;
RODisplay.s_FLAG_FREE = 0;
RODisplay.m_unitFlagList = [];
RODisplay.m_unitListLen = 0;
RODisplay.m_unitList = [];
RODisplay.m_freeIdList = [];
exports.default = RODisplay;

/***/ }),

/***/ "de9d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const AABB2D_1 = __importDefault(__webpack_require__("e2fe"));

const RenderFilter_1 = __importDefault(__webpack_require__("722e"));

const RenderMaskBitfield_1 = __importDefault(__webpack_require__("8333"));

const RODrawState_1 = __webpack_require__("7c63");

const RenderColorMask_1 = __webpack_require__("070b");

const RenderStateObject_1 = __webpack_require__("a5ba");

const RAdapterContext_1 = __importDefault(__webpack_require__("090c"));

const RenderAdapter_1 = __importDefault(__webpack_require__("1216"));

const RenderFBOProxy_1 = __importDefault(__webpack_require__("56c5"));

const RCExtension_1 = __importDefault(__webpack_require__("030e"));

const ROVertexResource_1 = __importDefault(__webpack_require__("74c3"));

const ROTextureResource_1 = __importDefault(__webpack_require__("984e"));

const RSTBuilder_1 = __importDefault(__webpack_require__("e035"));

const RendererState_1 = __importDefault(__webpack_require__("29ef"));

const Stencil_1 = __webpack_require__("8171");

const VROBase_1 = __importDefault(__webpack_require__("919c"));

const RenderingColorMask_1 = __webpack_require__("e602");

const RenderingState_1 = __webpack_require__("53d3");

const RPStatus_1 = __webpack_require__("9f82");

class RenderProxyParam {
  constructor() {
    this.materialUpdater = null;
    this.vtxBufUpdater = null;
    this.vtxBuilder = null;
    this.uniformContext = null;
  }

}

exports.RenderProxyParam = RenderProxyParam;
/**
 * 真正位于高频运行的渲染管线中的被使用的渲染关键代理对象
 */

class RenderProxy {
  constructor(rcuid) {
    this.RGBA = 0;
    this.UNSIGNED_BYTE = 0;
    this.TRIANGLE_STRIP = 0;
    this.TRIANGLE_FAN = 0;
    this.TRIANGLES = 0;
    this.LINES = 0;
    this.LINE_STRIP = 0;
    this.UNSIGNED_SHORT = 0;
    this.UNSIGNED_INT = 0;
    this.COLOR = 0;
    this.DEPTH = 0;
    this.STENCIL = 0;
    this.DEPTH_STENCIL = 0;
    this.MAX = 0;
    this.MIN = 0;
    /**
     * WebGL GPU Context instance
     */

    this.RContext = null;
    this.RDrawState = null;
    this.Vertex = null;
    this.Texture = null;
    this.VtxBufUpdater = null;
    this.MaterialUpdater = null;
    this.uniformContext = null;
    this.adapter = null;
    this.stencil = null;
    this.renderingState = null;
    this.colorMask = null;
    this.m_uid = 0;
    this.m_camUBO = null;
    this.m_adapter = null;
    this.m_adapterContext = new RAdapterContext_1.default();
    this.m_rc = null;
    this.m_perspectiveEnabled = true;
    this.m_viewPortRect = new AABB2D_1.default(0, 0, 800, 600);
    this.m_cameraNear = 0.1;
    this.m_cameraFar = 5000.0;
    this.m_cameraFov = 45.0;
    this.m_maxWebGLVersion = 2;
    this.m_WEBGL_VER = 2; // main camera

    this.m_camera = null;
    this.m_camSwitched = false; // 是否舞台尺寸和view自动同步一致

    this.m_autoSynViewAndStage = true;
    this.status = new RPStatus_1.RPStatus();
    this.m_initMainCamera = true;
    this.m_uid = rcuid;
  }
  /**
   * @returns return system gpu context
   */


  getRC() {
    return this.m_rc;
  }

  getUid() {
    return this.m_uid;
  }
  /**
   * @returns return renderer context unique id
   */


  getRCUid() {
    return this.m_uid;
  }

  isAutoSynViewAndStage() {
    return this.m_autoSynViewAndStage;
  }

  enableSynViewAndStage() {
    this.m_autoSynViewAndStage = true;
  }

  lockViewport() {
    this.m_adapter.lockViewport();
  }

  unlockViewport() {
    this.m_adapter.unlockViewport();
  }

  getDiv() {
    return this.m_adapter.getDiv();
  }

  getCanvas() {
    return this.m_adapter.getCanvas();
  }

  cameraLock() {
    this.m_camera.lock();
  }

  cameraUnlock() {
    this.m_camera.unlock();
  }

  getCamera() {
    return this.m_camera;
  }

  updateCamera() {
    return this.m_camera.update();
  }

  createCameraUBO(shd) {//  if(this.m_camUBO == null)
    //  {
    //      this.m_camUBO = ShaderUBOBuilder.createUBOWithDataFloatsCount("UBlock_Camera", shd, 32);
    //      this.m_camUBO.setSubDataArrAt(0, m_camera.getViewMatrix().getLocalFS32());
    //      this.m_camUBO.setSubDataArrAt(16, m_camera.getProjectMatrix().getLocalFS32());
    //      this.m_camUBO.run();
    //  }
  }

  updateCameraDataFromCamera(camera) {
    if (camera != null) {
      if (this.m_camSwitched || camera != this.m_camera) {
        this.m_camSwitched = camera != this.m_camera;
        camera.updateCamMatToUProbe(this.m_camera.matUProbe);

        if (this.m_camUBO != null) {
          this.m_camUBO.setSubDataArrAt(0, camera.matUProbe.getFS32At(0));
          this.m_camUBO.setSubDataArrAt(16, camera.matUProbe.getFS32At(1)); //this.m_camUBO.setSubDataArrAt(0, camera.getViewMatrix().getLocalFS32());
          //this.m_camUBO.setSubDataArrAt(16, camera.getProjectMatrix().getLocalFS32());
        }
      }
    }
  }

  useCameraData() {
    if (this.m_camUBO != null) {
      this.m_camUBO.run();
    }
  }

  getActiveAttachmentTotal() {
    return this.m_adapter.getActiveAttachmentTotal();
  }

  drawInstanced(count, offset, instanceCount) {
    if (this.m_WEBGL_VER == 2) {
      this.m_rc.drawElementsInstanced(this.TRIANGLES, count, this.UNSIGNED_SHORT, offset, instanceCount);
    } else {
      RCExtension_1.default.ANGLE_instanced_arrays.drawElementsInstancedANGLE(this.TRIANGLES, count, offset, instanceCount);
    }
  }

  createUBOBufferByBytesCount(bytesCount) {
    let buf = this.m_rc.createBuffer();
    this.m_rc.bindBuffer(this.m_rc.UNIFORM_BUFFER, buf);
    this.m_rc.bufferData(this.m_rc.UNIFORM_BUFFER, bytesCount, this.m_rc.DYNAMIC_DRAW);
    return buf;
  }

  createUBOBufferByDataArray(dataArray) {
    let buf = this.m_rc.createBuffer();
    this.m_rc.bindBuffer(this.m_rc.UNIFORM_BUFFER, buf);
    this.m_rc.bufferData(this.m_rc.UNIFORM_BUFFER, dataArray, this.m_rc.DYNAMIC_DRAW);
    return buf;
  }

  bindUBOBuffer(buf) {
    this.m_rc.bindBuffer(this.m_rc.UNIFORM_BUFFER, buf);
  }

  deleteUBOBuffer(buf) {
    this.m_rc.deleteBuffer(buf);
  }

  bufferDataUBOBuffer(dataArr) {
    this.m_rc.bufferData(this.m_rc.UNIFORM_BUFFER, dataArr, this.m_rc.STATIC_DRAW);
  }

  bindBufferBaseUBOBuffer(bindingIndex, buf) {
    this.m_rc.bindBufferBase(this.m_rc.UNIFORM_BUFFER, bindingIndex, buf);
  }

  setWebGLMaxVersion(webgl_ver) {
    if (webgl_ver == 1 || webgl_ver == 2) {
      this.m_maxWebGLVersion = webgl_ver;
    }
  }

  getContext() {
    return this.m_adapterContext;
  }

  getStage3D() {
    return this.m_adapterContext.getStage();
  }

  getRenderAdapter() {
    return this.m_adapter;
  }

  getRenderContext() {
    return this.m_adapter.getRenderContext();
  }

  setCameraParam(fov, near, far) {
    this.m_cameraFov = fov;
    this.m_cameraNear = near;
    this.m_cameraFar = far;
  }

  getMouseXYWorldRay(rl_position, rl_tv) {
    let stage = this.m_adapterContext.getStage();
    this.m_camera.getWorldPickingRayByScreenXY(stage.mouseX, stage.mouseY, rl_position, rl_tv);
  }

  testViewPortChanged(px, py, pw, ph) {
    return this.m_viewPortRect.testEqualWithParams(px, py, pw, ph);
  }

  testRCViewPortChanged(px, py, pw, ph) {
    return this.m_adapterContext.testViewPortChanged(px, py, pw, ph);
  }

  getViewX() {
    return this.m_viewPortRect.x;
  }

  getViewY() {
    return this.m_viewPortRect.y;
  }

  getViewWidth() {
    return this.m_viewPortRect.width;
  }

  getViewHeight() {
    return this.m_viewPortRect.height;
  }

  setViewPort(px, py, pw, ph) {
    this.m_autoSynViewAndStage = false;
    this.m_viewPortRect.setTo(px, py, pw, ph);
    let stage = this.m_adapterContext.getStage();

    if (stage != null) {
      stage.setViewPort(pw, py, pw, ph);
      this.updateCameraView();
    }

    this.m_adapterContext.setViewport(px, py, pw, ph);
  }

  setRCViewPort(px, py, pw, ph, autoSynViewAndStage = false) {
    this.m_autoSynViewAndStage = autoSynViewAndStage;
    this.m_adapterContext.setViewport(px, py, pw, ph);
  }

  reseizeRCViewPort() {
    this.m_adapter.unlockViewport();
    this.m_adapter.reseizeViewPort();
  }

  updateCameraView() {
    if (this.m_camera != null) {
      let rect = this.m_viewPortRect;
      this.m_camera.setViewXY(rect.x, rect.y);
      this.m_camera.setViewSize(rect.width, rect.height);
    }
  }

  resizeCallback() {
    // console.log("XXX resizeCallback(), m_autoSynViewAndStage: "+this.m_autoSynViewAndStage);
    if (this.m_autoSynViewAndStage) {
      let rect = this.m_viewPortRect;
      rect.setSize(this.m_adapterContext.getRCanvasWidth(), this.m_adapterContext.getRCanvasHeight());
      this.createMainCamera();
      console.log("resizeCallback(), viewW,viewH: ", rect.width + "," + rect.height);
      this.m_adapterContext.setViewport(rect.x, rect.y, rect.width, rect.height);
      this.updateCameraView();
    }
  }

  createMainCamera() {
    if (this.m_initMainCamera) {
      this.m_initMainCamera = false;
      this.m_camera.uniformEnabled = true;
      let rect = this.m_viewPortRect;

      if (this.m_perspectiveEnabled) {
        this.m_camera.perspectiveRH(Math.PI * this.m_cameraFov / 180.0, rect.width / rect.height, this.m_cameraNear, this.m_cameraFar);
      } else {
        this.m_camera.orthoRH(this.m_cameraNear, this.m_cameraFar, -0.5 * rect.height, 0.5 * rect.height, -0.5 * rect.width, 0.5 * rect.width);
      }

      this.updateCameraView();
    }
  }

  readPixels(px, py, width, height, format, dataType, pixels) {
    this.m_adapter.readPixels(px, py, width, height, format, dataType, pixels);
  }

  getGLVersion() {
    return this.m_WEBGL_VER;
  }

  buildCameraParam() {
    let camera = this.m_camera;

    if (camera.matUProbe == null) {
      camera.matUProbe = this.uniformContext.createShaderUniformProbe();
      camera.matUProbe.addMat4Data(new Float32Array(16), 1);
      camera.matUProbe.addMat4Data(new Float32Array(16), 1);
    }

    if (camera.ufrustumProbe == null) {
      camera.ufrustumProbe = this.uniformContext.createShaderUniformProbe();
      camera.ufrustumProbe.addVec4Data(new Float32Array([camera.getZNear(), camera.getZFar(), camera.getNearPlaneWidth() * 0.5, camera.getNearPlaneHeight() * 0.5]), 1);
    }

    if (camera.ucameraPosProbe == null) {
      camera.ucameraPosProbe = this.uniformContext.createShaderUniformProbe();
      camera.ucameraPosProbe.addVec4Data(new Float32Array([500.0, 500.0, 500.0, 1.0]), 1);
    }
  }

  initialize(param, camera, stage, proxyParam) {
    if (this.m_rc != null) {
      return;
    }

    this.m_camera = camera;
    let posV3 = param.camPosition;
    let lookAtPosV3 = param.camLookAtPos;
    let upV3 = param.camUpDirect;
    if (stage != null) stage.uProbe = proxyParam.uniformContext.createUniformVec4Probe(1);
    this.m_perspectiveEnabled = param.cameraPerspectiveEnabled;
    this.m_adapterContext.autoSyncRenderBufferAndWindowSize = param.autoSyncRenderBufferAndWindowSize;
    this.m_adapterContext.setResizeCallback(() => {
      this.resizeCallback();
    });
    this.m_adapterContext.setWebGLMaxVersion(this.m_maxWebGLVersion);
    this.m_adapterContext.initialize(this.m_uid, stage, param.getDiv(), param.getRenderContextAttri());
    this.m_WEBGL_VER = this.m_adapterContext.getWebGLVersion();
    this.m_rc = this.m_adapterContext.getRC();
    let selfT = this;
    let gl = this.m_rc;
    let vtxRes = new ROVertexResource_1.default(this.m_uid, gl, proxyParam.vtxBuilder);
    let texRes = new ROTextureResource_1.default(this.m_uid, gl);
    this.m_vtxRes = vtxRes;
    selfT.Vertex = vtxRes;
    selfT.Texture = texRes;
    selfT.MaterialUpdater = proxyParam.materialUpdater;
    selfT.VtxBufUpdater = proxyParam.vtxBufUpdater;
    selfT.uniformContext = proxyParam.uniformContext;
    let rstate = new RODrawState_1.RODrawState();
    rstate.setRenderContext(this.m_adapterContext); // RendererState.Initialize(rstate, new VROBase());

    let obj = RendererState_1.default;
    new RSTBuilder_1.default().initialize(obj, rstate, new VROBase_1.default());
    selfT.RState = rstate;
    selfT.RContext = this.m_rc;
    selfT.stencil = new Stencil_1.Stencil(rstate);
    selfT.renderingState = new RenderingState_1.RenderingState(RendererState_1.default);
    selfT.colorMask = new RenderingColorMask_1.RenderingColorMask(RendererState_1.default);
    this.buildCameraParam();
    let rect = this.m_viewPortRect;
    rect.setSize(this.m_adapterContext.getRCanvasWidth(), this.m_adapterContext.getRCanvasHeight());
    this.m_adapter = new RenderAdapter_1.default(this.m_uid, texRes);
    this.m_adapter.initialize(this.m_adapterContext, param, rstate, this.uniformContext.createUniformVec4Probe(1));
    selfT.adapter = this.m_adapter;

    if (this.m_autoSynViewAndStage) {
      let stage = this.m_adapterContext.getStage();

      if (stage != null) {
        rect.setSize(rect.width, rect.height);
      }
    }

    this.createMainCamera();
    this.m_adapterContext.setViewport(rect.x, rect.y, rect.width, rect.height);
    this.m_camera.lookAtRH(posV3, lookAtPosV3, upV3);
    this.m_camera.update();
    selfT.RGBA = gl.RGBA;
    selfT.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
    selfT.TRIANGLE_STRIP = gl.TRIANGLE_STRIP;
    selfT.TRIANGLE_FAN = gl.TRIANGLE_FAN;
    selfT.TRIANGLES = gl.TRIANGLES;
    selfT.LINES = this.m_rc.LINES;
    selfT.LINE_STRIP = gl.LINE_STRIP;
    selfT.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    selfT.UNSIGNED_INT = gl.UNSIGNED_INT;
    selfT.COLOR = gl.COLOR;
    selfT.DEPTH = gl.DEPTH;
    selfT.STENCIL = gl.STENCIL;
    selfT.DEPTH_STENCIL = gl.DEPTH_STENCIL;

    if (this.m_WEBGL_VER > 1) {
      selfT.MIN = gl.MIN;
      selfT.MAX = gl.MAX;
    } else {
      selfT.MIN = RCExtension_1.default.EXT_blend_minmax.MIN_EXT;
      selfT.MAX = RCExtension_1.default.EXT_blend_minmax.MAX_EXT;
    }

    let classRenderFilter = RenderFilter_1.default;
    classRenderFilter.NEAREST = gl.NEAREST;
    classRenderFilter.LINEAR = gl.LINEAR;
    classRenderFilter.LINEAR_MIPMAP_LINEAR = gl.LINEAR_MIPMAP_LINEAR;
    classRenderFilter.NEAREST_MIPMAP_NEAREST = gl.NEAREST_MIPMAP_NEAREST;
    classRenderFilter.LINEAR_MIPMAP_NEAREST = gl.LINEAR_MIPMAP_NEAREST;
    classRenderFilter.NEAREST_MIPMAP_LINEAR = gl.NEAREST_MIPMAP_LINEAR;
    let classRenderMaskBitfield = RenderMaskBitfield_1.default;
    classRenderMaskBitfield.COLOR_BUFFER_BIT = gl.COLOR_BUFFER_BIT;
    classRenderMaskBitfield.DEPTH_BUFFER_BIT = gl.DEPTH_BUFFER_BIT;
    classRenderMaskBitfield.STENCIL_BUFFER_BIT = gl.STENCIL_BUFFER_BIT;
    RenderFBOProxy_1.default.SetRenderer(this.m_adapterContext);
  }

  flush() {
    this.m_rc.flush();
  }

  setClearRGBColor3f(pr, pg, pb) {
    let cvs = this.m_adapter.bgColor;
    cvs[0] = pr;
    cvs[1] = pg;
    cvs[2] = pb;
  }

  setClearColor(color) {
    color.toArray(this.m_adapter.bgColor);
  }
  /**
   * @param colorUint24 uint24 number rgb color value, example: 0xff0000, it is red rolor
   * @param alpha the default value is 1.0
   */


  setClearUint24Color(colorUint24, alpha = 1.0) {
    let cvs = this.m_adapter.bgColor;
    cvs[0] = (colorUint24 >> 16 & 0x0000ff) / 255.0;
    cvs[1] = (colorUint24 >> 8 & 0x0000ff) / 255.0;
    cvs[2] = (colorUint24 & 0x0000ff) / 255.0;
    cvs[3] = alpha;
  }

  setClearRGBAColor4f(pr, pg, pb, pa) {
    let cvs = this.m_adapter.bgColor;
    cvs[0] = pr;
    cvs[1] = pg;
    cvs[2] = pb;
    cvs[3] = pa;
  }

  getClearRGBAColor4f(color4) {
    color4.fromArray(this.m_adapter.bgColor);
  }

  getViewportWidth() {
    return this.m_adapter.getViewportWidth();
  }

  getViewportHeight() {
    return this.m_adapter.getViewportHeight();
  }

  setRenderToBackBuffer() {
    this.m_adapter.setRenderToBackBuffer();
  }

  clearBackBuffer() {
    this.m_adapter.clear();
  }

  clearDepth(depth = 1.0) {
    this.m_adapter.clearDepth(depth);
  }

  renderBegin() {
    this.m_camera.update();
    this.m_adapter.renderBegin();
  }

  renderEnd() {}

  useRenderStateByName(stateName) {
    RenderStateObject_1.RenderStateObject.UseRenderStateByName(stateName);
  }

  setScissorEnabled(boo) {
    this.m_adapterContext.setScissorEnabled(boo);
  }

  setScissorRect(px, py, pw, ph) {
    this.m_adapterContext.setScissorRect(px, py, pw, ph);
  }

  useRenderColorMask(state) {
    RenderColorMask_1.RenderColorMask.UseRenderState(state);
  }

  unlockRenderColorMask() {
    RenderColorMask_1.RenderColorMask.Unlock();
  }

  lockRenderColorMask() {
    RenderColorMask_1.RenderColorMask.Lock();
  }

  useRenderState(state) {
    RenderStateObject_1.RenderStateObject.UseRenderState(state);
  }

  unlockRenderState() {
    RenderStateObject_1.RenderStateObject.Unlock();
  }

  lockRenderState() {
    RenderStateObject_1.RenderStateObject.Lock();
  }
  /**
   * set the updating times total that update vertex data to gpu in one frame time
   * @param total updating times total, the min value is 4, the default value is 16
   */


  setVtxUpdateTimesTotal(total) {
    this.m_vtxRes.setVtxUpdateTimesTotal(total);
  }
  /**
   * @param faceFlipped the value is true, frontFace is CW. the value is false, frontFace is CCW.
   */


  setFrontFaceFlipped(faceFlipped) {
    this.m_adapter.setFrontFaceFlipped(faceFlipped);
  }

  enabledPolygonOffset() {
    this.m_adapter.enabledPolygonOffset();
  }

  disabledPolygonOffset() {
    this.m_adapter.disabledPolygonOffset();
  }
  /*
   * specifies the scale factors and units to calculate depth values.
   * @param factor the value is a GLfloat which sets the scale factor for the variable depth offset for each polygon. The default value is 0.
   * @param units the value is a which sets the multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. The default value is 0.
   */


  setPolygonOffset(factor, units = 0.0) {
    this.m_adapter.setPolygonOffset(factor, units);
  }
  /*
   * reset the scale factors and units value is default value(0.0).
   */


  resetPolygonOffset() {
    this.m_adapter.resetPolygonOffset();
  }

  loseContext() {
    this.m_adapter.loseContext();
  }
  /**
   * @returns return gpu context lost status
   */


  isContextLost() {
    return this.m_adapter.isContextLost();
  }

  setViewProbeValue(x, y, width, height) {
    this.m_adapter.setViewProbeValue(x, y, width, height);
  }

  toString() {
    return "[Object RenderProxy()]";
  }

}

exports.RenderProxy = RenderProxy;
exports.default = RenderProxy;

/***/ }),

/***/ "df25":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RawTexData_1 = __importDefault(__webpack_require__("68aa"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class RawDataTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_bytes = null;
    this.m_subDataList = null;
    this.m_texDatasLen = 0;
    this.m_texData = null;
    this.m_texDatas = null;
    this.minFilter = TextureConst_1.default.LINEAR;
  }
  /**
   * 设置 Bytes 纹理的纹理数据
   */


  setDataFromBytes(bytes, miplevel = 0, imgWidth = -1, imgHeight = -1, offsetx = 0, offsety = 0, rebuild = false) {
    if (bytes != null && imgWidth > 0 && imgHeight > 0) {
      if (miplevel < 0) miplevel = 0;
      if (miplevel > 15) miplevel = 15;

      if (miplevel >= this.m_texDatasLen) {
        this.m_texDatasLen = miplevel + 1;
      }

      this.m_haveRData = true;
      let td = this.m_texData;

      if (td != null) {
        if (this.m_texData.miplevel != miplevel) {
          if (this.m_texDatas == null) this.m_texDatas = [this.m_texData, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
          td = this.m_texDatas[miplevel];

          if (td == null) {
            td = RawTexData_1.default.Create();
            td.miplevel = miplevel;
            rebuild = true;
            this.m_texDatas[miplevel] = td;
          }
        }
      } else {
        this.m_texData = td = RawTexData_1.default.Create();
        td.miplevel = miplevel;
        rebuild = true;
      }

      if (td.data != bytes || td.offsetx != offsetx || td.offsety != offsety) {
        if (miplevel == 0) {
          this.m_texWidth = imgWidth;
          this.m_texHeight = imgHeight;
          this.m_bytes = bytes;
        }

        td.data = bytes;
        td.status = 0; // 0表示 更新纹理数据而不会重新开辟空间, 1表示需要重新开辟空间并更新纹理数据, -1表示不需要更新

        if (td.width < imgWidth || td.height < imgHeight || rebuild) {
          td.width = imgWidth;
          td.height = imgHeight;
          td.status = 1;
        }

        td.offsetx = offsetx;
        td.offsety = offsety;
      }

      this.version++;
    } else {
      console.error("bytes != null: " + (bytes != null) + ",imgWidth > 0: " + (imgWidth > 0) + ",imgHeight > 0: " + (imgHeight > 0));
    }
  }

  uploadData(texRes) {
    if (this.m_texData != null) {
      this.dataUploadToGpu(texRes.getRC(), this.m_texData, this.m_texDatas, true);
    }
  }

  __$updateToGpu(texRes) {
    // 这里之所以用这种方式判断，是为了运行时支持多 gpu context
    //console.log("RawDataTexture,__$updateToGpu, version: ",this.version,",resHas("+this.getResUid()+"):",texRes.hasResUid(this.getResUid()));
    if (this.version > 0 && texRes.hasResUid(this.getResUid())) {
      let gl = texRes.getRC();
      let len = this.m_subDataList != null ? this.m_subDataList.length : 0;

      this.__$updateToGpuBegin(texRes);

      if (len > 0) {
        let i = 0;
        let d = null;
        let interType = TextureFormat_1.default.ToGL(gl, this.internalFormat);
        let format = TextureFormat_1.default.ToGL(gl, this.srcFormat);
        let type = TextureDataType_1.default.ToGL(gl, this.dataType);

        for (; i < len; ++i) {
          d = this.m_subDataList.pop();
          d.updateToGpu(gl, this.m_sampler, interType, format, type, false);
          RawTexData_1.default.Restore(d);
        } //concole.log("#####upload sub texture pix data!");

      }

      if (this.m_texData != null) {
        this.dataUploadToGpu(gl, this.m_texData, this.m_texDatas);

        this.__$buildParam(gl);

        this.m_generateMipmap = true;
      }

      this.__$updateToGpuEnd(gl);
    }
  } // 对mipmap level 的纹理数据的部分更新


  setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel = 0) {
    if (this.m_subDataList == null) {
      this.m_subDataList = [];
    }

    let d = RawTexData_1.default.Create();
    d.data = bytes;
    d.status = 0;
    d.miplevel = miplevel;
    d.offsetx = px;
    d.offsety = py;
    d.width = twidth;
    d.height = theight; //console.log("setPartDataFromeBytes, pos("+px+","+py+"),size("+twidth+","+twidth+")");

    this.m_subDataList.push(d);
    this.version++;
  }

  getPixels(px, py, pw, ph, outBytes) {
    if (this.m_bytes != null && outBytes != null) {
      let segSize = this.unpackAlignment;
      let s = pw * ph * segSize;

      if (outBytes.length == s) {
        let i = py;
        let j = px;
        let i_max = i + ph;
        let j_max = j + pw;
        let k = 0;

        switch (this.srcFormat) {
          case TextureFormat_1.default.ALPHA:
            for (; i < i_max; ++i) {
              for (j = px; j < j_max; ++j) {
                s = i * this.m_texWidth + j;
                outBytes[k] = this.m_bytes[s];
                k++;
              }
            }

            break;

          case TextureFormat_1.default.RGBA:
            for (; i < i_max; ++i) {
              for (j = px; j < j_max; ++j) {
                s = (i * this.m_texWidth + j) * segSize;
                outBytes[k] = this.m_bytes[s];
                outBytes[k + 1] = this.m_bytes[s + 1];
                outBytes[k + 2] = this.m_bytes[s + 2];
                outBytes[k + 3] = this.m_bytes[s + 3];
                k++;
              }
            }

            break;

          case TextureFormat_1.default.RGB:
            for (; i < i_max; ++i) {
              for (j = px; j < j_max; ++j) {
                s = (i * this.m_texWidth + j) * segSize;
                outBytes[k] = this.m_bytes[s];
                outBytes[k + 1] = this.m_bytes[s + 1];
                outBytes[k + 2] = this.m_bytes[s + 2];
                k++;
              }
            }

            break;

          default:
            break;
        }
      } else {
        console.warn("outBytes.length != (pw * ph * pixelSegSize)");
      }
    }
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      this.version = 0;

      if (this.m_texDatas != null) {
        for (let i = 0; i < this.m_texDatasLen; ++i) {
          RawTexData_1.default.Restore(this.m_texDatas[i]);
        }

        this.m_texDatasLen = 0;
        this.m_texDatas = null;
        this.m_texData = null;
      }

      if (this.m_texData != null) {
        RawTexData_1.default.Restore(this.m_texData);
        this.m_texData = null;
      }

      this.m_bytes = null;
      console.log("RawDataTextureProxy::destroy(), destroy a RawDataTextureProxy instance...");

      super.__$destroy();
    }
  }

  toString() {
    return "[RawDataTextureProxy(width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = RawDataTextureProxy;

/***/ }),

/***/ "df9d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RPONodeLinker {
  constructor() {
    this.m_uid = -1; // 用于唯一记录运行时的自己唯一id

    this.m_begin = null;
    this.m_end = null;
    this.m_unitMap = new Map();
    this.m_unitTexMap = new Map();
    this.m_FLAG_BUSY = 1;
    this.m_FLAG_FREE = 0;
    this.m_vtxFlagList = [];
    this.m_vtxIndexFlagList = [];
    this.m_vtxfreeIList = [];
    this.m_vtxList = [];
    this.m_vtxListLen = 0;
    this.m_texFlagList = [];
    this.m_texIndexFlagList = [];
    this.m_texfreeIList = [];
    this.m_texList = [];
    this.m_texListLen = 0;
    this.m_uid = RPONodeLinker.s_uid++;
  }

  getFreeVtxId() {
    if (this.m_vtxfreeIList.length > 0) {
      return this.m_vtxfreeIList.pop();
    }

    return -1;
  }

  getVtxIndex() {
    let unitI = -1;
    let index = this.getFreeVtxId();

    if (index >= 0) {
      unitI = index;
      this.m_vtxList[index] = 0;
      this.m_vtxFlagList[index] = this.m_FLAG_BUSY;
    } else {
      unitI = this.m_vtxListLen;
      this.m_vtxList.push(0);
      this.m_vtxIndexFlagList.push(this.m_FLAG_FREE);
      this.m_vtxFlagList.push(this.m_FLAG_BUSY);
      this.m_vtxListLen++;
    }

    return unitI;
  }

  restoreVtxIndex(index) {
    if (this.m_vtxFlagList[index] == this.m_FLAG_BUSY) {
      this.m_vtxfreeIList.push(index);
      this.m_vtxFlagList[index] = this.m_FLAG_FREE;
      this.m_vtxList[index] = 0;
    }
  }

  attachVtxAt(index) {
    ++this.m_vtxList[index]; //console.log("uid: "+this.m_uid+" RPONodeLinker::attachVtxAt(), this.m_vtxList["+index+"]: "+this.m_vtxList[index]);
  }

  detachVtxAt(index) {
    if (this.m_vtxList[index] > 0) {
      --this.m_vtxList[index];

      if (this.m_vtxList[index] < 1) {
        this.restoreVtxIndex(index);
      }
    } //console.log("uid: "+this.m_uid+" RPONodeLinker::detachVtxAt(), this.m_vtxList["+index+"]: "+this.m_vtxList[index]);

  }

  getVtxTotalAt(index) {
    return this.m_vtxList[index];
  }

  getFreeTexId() {
    if (this.m_texfreeIList.length > 0) {
      return this.m_texfreeIList.pop();
    }

    return -1;
  }

  getTexIndex() {
    let unitI = -1;
    let index = this.getFreeTexId();

    if (index >= 0) {
      unitI = index;
      this.m_texList[index] = 0;
      this.m_texFlagList[index] = this.m_FLAG_BUSY;
    } else {
      unitI = this.m_texListLen;
      this.m_texList.push(0);
      this.m_texIndexFlagList.push(this.m_FLAG_FREE);
      this.m_texFlagList.push(this.m_FLAG_BUSY);
      this.m_texListLen++;
    }

    return unitI;
  }

  restoreTexIndex(index) {
    if (this.m_texFlagList[index] == this.m_FLAG_BUSY) {
      this.m_texfreeIList.push(index);
      this.m_texFlagList[index] = this.m_FLAG_FREE;
      this.m_texList[index] = 0;
    }
  }

  attachTexAt(index) {
    ++this.m_texList[index]; //console.log("uid: "+this.m_uid+" RPONodeLinker::attachTexAt(), this.m_texList["+index+"]: "+this.m_texList[index]);
  }

  detachTexAt(index) {
    if (this.m_texList[index] > 0) {
      --this.m_texList[index];

      if (this.m_texList[index] < 1) {
        this.restoreTexIndex(index);
      }
    } //console.log("uid: "+this.m_uid+" RPONodeLinker::detachTexAt(), this.m_texList["+index+"]: "+this.m_texList[index]);

  }

  getTexTotalAt(index) {
    return this.m_texList[index];
  }

  destroy() {
    this.clear();
  }

  clear() {
    this.m_begin = this.m_end = null;
    this.m_unitMap = new Map();
    this.m_unitTexMap = new Map();
    this.m_vtxFlagList = [];
    this.m_vtxIndexFlagList = [];
    this.m_vtxList = [];
    this.m_vtxfreeIList = [];
    this.m_vtxListLen = 0;
    this.m_texFlagList = [];
    this.m_texIndexFlagList = [];
    this.m_texList = [];
    this.m_texfreeIList = [];
    this.m_texListLen = 0;
  }

  getBegin() {
    return this.m_begin;
  }

  containsNode(node) {
    let pnode = this.m_unitMap.get(node.vtxUid);

    if (pnode != null) {
      let key = (31 + pnode.rvroI) * 131;
      key *= key + pnode.texMid;
      return node.rtokey == key;
    }

    return false;
  }

  addNodeAndSort(node) {
    //  注意，这里可以管理组合方式, 例如可以做更多条件的排序
    //  有些需要排序, 有些不需要排序
    //trace("RPONodeLinker::addNodeAndSort(), node: "+node);
    // 首先依据相同的顶点紧凑排序, 然后再以纹理组合排列, 因此用 顶点的key与tex序列的key组合为一个新的key
    //console.log("addNodeAndSort node.vtxUid: ",node.vtxUid, node.unit.__$dispNS);
    let pnode = this.m_unitMap.get(node.vtxUid);

    if (pnode == null) {
      this.m_unitMap.set(node.vtxUid, node);
      node.rvroI = this.getVtxIndex();
      this.attachVtxAt(node.rvroI);
      let key = (31 + node.rvroI) * 131;
      key *= key + node.texMid;
      node.rtokey = key;
      node.rtroI = this.getTexIndex();
      this.m_unitTexMap.set(key, node.rtroI);
      this.attachTexAt(node.rtroI); //console.log("RPONodeLinker::addNodeAndSort(), append a new node.");
    } else {
      node.rvroI = pnode.rvroI;
      this.attachVtxAt(node.rvroI);
      let key = (31 + node.rvroI) * 131;
      key *= key + node.texMid;

      if (this.m_unitTexMap.has(key)) {
        node.rtroI = this.m_unitTexMap.get(key);
      } else {
        node.rtroI = this.getTexIndex();
        this.m_unitTexMap.set(key, node.rtroI);
      }

      node.rtokey = key;
      this.attachTexAt(node.rtroI); //console.log("RPONodeLinker::addNodeAndSort(), append a new pnode != m_end: "+(pnode != this.m_end));

      if (pnode != this.m_end) {
        if (pnode.texMid == node.texMid) {
          pnode.next.prev = node;
          node.next = pnode.next;
          node.prev = pnode;
          pnode.next = node;
        } else {
          // combine the same textures ro
          while (pnode != null) {
            if (pnode.vtxUid != node.vtxUid) {
              pnode = pnode.prev;
              pnode.next.prev = node;
              node.next = pnode.next;
              node.prev = pnode;
              pnode.next = node;
              break;
            } else {
              if (pnode.texMid == node.texMid) {
                pnode.next.prev = node;
                node.next = pnode.next;
                node.prev = pnode;
                pnode.next = node;
                break;
              }

              if (pnode.next == this.m_end) {
                if (this.m_end.vtxUid != node.vtxUid) {
                  // append after pnode
                  pnode.next.prev = node;
                  node.next = pnode.next;
                  node.prev = pnode;
                  pnode.next = node;
                } else {
                  pnode = null;
                }

                break;
              }

              pnode = pnode.next;
            }
          }
        } // 如果纹理相同, 再次将纹理相同的排在一起
        //console.log("RPONodeLinker::addNodeAndSort(), insert a new node 0.");

      } else {
        pnode = null;
      }
    }

    if (pnode == null) {
      if (this.m_begin == null) {
        this.m_end = this.m_begin = node;
      } else {
        if (this.m_end.prev != null) {
          this.m_end.next = node;
          node.prev = this.m_end;
          this.m_end = node; //trace("RPONodeLinker::addNodeAndSort(), insert a node to link 1.");
        } else {
          this.m_begin.next = node;
          node.prev = this.m_end;
          this.m_end = node; //trace("RPONodeLinker::addNodeAndSort(), insert a node to link 2.");
        }
      }

      this.m_end.next = null;
    }
  }

  showInfo() {
    let nextNode = this.getBegin();

    if (nextNode != null) {
      let vtxStr = "";
      let texStr = "";
      let ivsCountStr = "";

      while (nextNode != null) {
        vtxStr += nextNode.vtxUid + ",";
        texStr += nextNode.texMid + ",";
        ivsCountStr += nextNode.ivsCount + ",";
        nextNode = nextNode.next;
      }

      console.log("RPONodeLinker::showInfo(), vtx: " + vtxStr);
      console.log("RPONodeLinker::showInfo(), tex: " + texStr);
      console.log("RPONodeLinker::showInfo(), ivs: " + ivsCountStr);
    }
  }

  removeNodeAndSort(node) {
    //trace("RPONodeLinker::removeNodeAndSort(), node: "+node);
    let pnode = this.m_unitMap.get(node.vtxUid);

    if (pnode != node) {
      pnode = null;
    } else {
      this.m_unitMap.set(node.vtxUid, null);

      if (node.next != null && node.next.vtxUid == node.vtxUid) {
        this.m_unitMap.set(node.vtxUid, node.next);
      } else if (node.prev != null && node.prev.vtxUid == node.vtxUid) {
        this.m_unitMap.set(node.vtxUid, node.prev);
      } else {
        this.m_unitMap.delete(node.vtxUid);
      }
    }

    if (node == this.m_begin) {
      if (node == this.m_end) {
        this.m_begin = this.m_end = null;
      } else {
        this.m_begin = node.next;
        this.m_begin.prev = null;
      }
    } else if (node == this.m_end) {
      this.m_end = node.prev;
      this.m_end.next = null;
    } else {
      node.next.prev = node.prev;
      node.prev.next = node.next;
    }

    this.detachVtxAt(node.rvroI);
    this.detachTexAt(node.rtroI);
    node.prev = null;
    node.next = null;
  }

  addNode(node) {
    if (this.m_begin == null) {
      this.m_end = this.m_begin = node;
    } else {
      if (this.m_end.prev != null) {
        this.m_end.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      } else {
        this.m_begin.next = node;
        node.prev = this.m_end;
        this.m_end = node;
      }
    }

    this.m_end.next = null;
  }

  removeNode(node) {
    if (node == this.m_begin) {
      if (node == this.m_end) {
        this.m_begin = this.m_end = null;
      } else {
        this.m_begin = node.next;
        this.m_begin.prev = null;
      }
    } else if (node == this.m_end) {
      this.m_end = node.prev;
      this.m_end.next = null;
    } else {
      node.next.prev = node.prev;
      node.prev.next = node.next;
    }

    node.prev = null;
    node.next = null;
  }

}

RPONodeLinker.s_uid = 0;
exports.default = RPONodeLinker;

/***/ }),

/***/ "e035":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const RenderColorMask_1 = __webpack_require__("070b");

const RenderStateObject_1 = __webpack_require__("a5ba");

const RenderConst_1 = __webpack_require__("e08e");

class RSTBuilder {
  constructor() {
    this.m_inited = true;
  }

  buildToRST(state) {
    let b = new RSTBuilder();
    b.initialize(state, this.m_Rstate, this.m_VRO);
  }

  initialize(state, rstate, vro) {
    if (this.m_inited && state.rstb == null) {
      state.rstb = this;
      this.m_inited = false;
      this.m_Rstate = rstate;
      this.m_VRO = vro;
      const rso = RenderStateObject_1.RenderStateObject;
      const rcm = RenderColorMask_1.RenderColorMask;
      const gbm = RenderConst_1.GLBlendMode;
      const gbe = RenderConst_1.GLBlendEquation;
      const cfm = RenderConst_1.CullFaceMode;
      const dtm = RenderConst_1.DepthTestMode;
      const rbm = RenderConst_1.RenderBlendMode;
      state.Rstate = rstate;
      state.VRO = vro;
      rcm.Rstate = rstate;
      rso.Rstate = rstate;
      state.COLOR_MASK_ALL_TRUE = rcm.Create("all_true", true, true, true, true);
      state.COLOR_MASK_ALL_FALSE = rcm.Create("all_false", false, false, false, false);
      state.COLOR_MASK_RED_TRUE = rcm.Create("red_true", true, false, false, false);
      state.COLOR_MASK_GREEN_TRUE = rcm.Create("green_true", false, true, false, false);
      state.COLOR_MASK_BLUE_TRUE = rcm.Create("blue_true", false, false, true, false);
      state.COLOR_MASK_ALPHA_TRUE = rcm.Create("alpha_true", false, false, false, true);
      state.COLOR_MASK_RED_FALSE = rcm.Create("red_false", false, true, true, true);
      state.COLOR_MASK_GREEN_FALSE = rcm.Create("green_false", true, false, true, true);
      state.COLOR_MASK_BLUE_FALSE = rcm.Create("blue_false", true, true, false, true);
      state.COLOR_MASK_ALPHA_FALSE = rcm.Create("alpha_false", true, true, true, false);

      if (RSTBuilder.m_rbmInited) {
        RSTBuilder.m_rbmInited = false;
        rbm.NORMAL = rso.CreateBlendMode("NORMAL", gbm.ONE, gbm.ZERO, gbe.FUNC_ADD);
        rbm.OPAQUE = rso.CreateBlendMode("OPAQUE", gbm.ONE, gbm.ZERO, gbe.FUNC_ADD);
        rbm.TRANSPARENT = rso.CreateBlendMode("TRANSPARENT", gbm.SRC_ALPHA, gbm.ONE_MINUS_SRC_ALPHA, gbe.FUNC_ADD);
        rbm.ALPHA_ADD = rso.CreateBlendMode("ALPHA_ADD", gbm.ONE, gbm.ONE_MINUS_SRC_ALPHA, gbe.FUNC_ADD);
        rbm.ADD = rso.CreateBlendMode("ADD", gbm.SRC_ALPHA, gbm.ONE, gbe.FUNC_ADD);
        rbm.ADD_LINEAR = rso.CreateBlendMode("ADD_LINEAR", gbm.ONE, gbm.ONE, gbe.FUNC_ADD);
        rbm.INVERSE_ALPHA = rso.CreateBlendMode("INVERSE_ALPHA", gbm.ONE, gbm.SRC_ALPHA, gbe.FUNC_ADD);
        rbm.BLAZE = rso.CreateBlendMode("BLAZE", gbm.SRC_COLOR, gbm.ONE, gbe.FUNC_ADD);
        rbm.OVERLAY = rso.CreateBlendMode("OVERLAY", gbm.DST_COLOR, gbm.DST_ALPHA, gbe.FUNC_ADD);
        rbm.OVERLAY2 = rso.CreateBlendMode("OVERLAY2", gbm.DST_COLOR, gbm.SRC_ALPHA, gbe.FUNC_ADD);
      }

      state.NORMAL_STATE = rso.Create("normal", cfm.BACK, rbm.NORMAL, dtm.OPAQUE);
      state.BACK_CULLFACE_NORMAL_STATE = state.NORMAL_STATE;
      state.FRONT_CULLFACE_NORMAL_STATE = rso.Create("front_normal", cfm.FRONT, rbm.NORMAL, dtm.OPAQUE);
      state.NONE_CULLFACE_NORMAL_STATE = rso.Create("none_normal", cfm.NONE, rbm.NORMAL, dtm.OPAQUE);
      state.ALL_CULLFACE_NORMAL_STATE = rso.Create("all_cull_normal", cfm.FRONT_AND_BACK, rbm.NORMAL, dtm.OPAQUE);
      state.BACK_NORMAL_ALWAYS_STATE = rso.Create("back_normal_always", cfm.BACK, rbm.NORMAL, dtm.ALWAYS);
      state.BACK_TRANSPARENT_STATE = rso.Create("back_transparent", cfm.BACK, rbm.TRANSPARENT, dtm.TRANSPARENT_SORT);
      state.BACK_TRANSPARENT_ALWAYS_STATE = rso.Create("back_transparent_always", cfm.BACK, rbm.TRANSPARENT, dtm.ALWAYS);
      state.NONE_TRANSPARENT_STATE = rso.Create("none_transparent", cfm.NONE, rbm.TRANSPARENT, dtm.TRANSPARENT_SORT);
      state.NONE_TRANSPARENT_ALWAYS_STATE = rso.Create("none_transparent_always", cfm.NONE, rbm.TRANSPARENT, dtm.ALWAYS);
      state.FRONT_CULLFACE_GREATER_STATE = rso.Create("front_greater", cfm.FRONT, rbm.NORMAL, dtm.TRUE_GREATER);
      state.BACK_ADD_BLENDSORT_STATE = rso.Create("back_add_blendSort", cfm.BACK, rbm.ADD, dtm.TRANSPARENT_SORT);
      state.BACK_ADD_ALWAYS_STATE = rso.Create("back_add_always", cfm.BACK, rbm.ADD, dtm.ALWAYS);
      state.BACK_ALPHA_ADD_ALWAYS_STATE = rso.Create("back_alpha_add_always", cfm.BACK, rbm.ALPHA_ADD, dtm.ALWAYS);
      state.NONE_ADD_ALWAYS_STATE = rso.Create("none_add_always", cfm.NONE, rbm.ADD, dtm.ALWAYS);
      state.NONE_ADD_BLENDSORT_STATE = rso.Create("none_add_blendSort", cfm.NONE, rbm.ADD, dtm.TRANSPARENT_SORT);
      state.NONE_ALPHA_ADD_ALWAYS_STATE = rso.Create("none_alpha_add_always", cfm.NONE, rbm.ALPHA_ADD, dtm.ALWAYS);
      state.FRONT_ADD_ALWAYS_STATE = rso.Create("front_add_always", cfm.FRONT, rbm.ADD, dtm.ALWAYS);
      state.FRONT_TRANSPARENT_STATE = rso.Create("front_transparent", cfm.FRONT, rbm.TRANSPARENT, dtm.TRANSPARENT_SORT);
      state.FRONT_TRANSPARENT_ALWAYS_STATE = rso.Create("front_transparent_always", cfm.FRONT, rbm.TRANSPARENT, dtm.ALWAYS);
      state.NONE_CULLFACE_NORMAL_ALWAYS_STATE = rso.Create("none_normal_always", cfm.NONE, rbm.NORMAL, dtm.ALWAYS);
      state.BACK_ALPHA_ADD_BLENDSORT_STATE = rso.Create("back_alpha_add_blendSort", cfm.BACK, rbm.ALPHA_ADD, dtm.TRANSPARENT_SORT);
    }
  }

  createBlendMode(name, srcColor, dstColor, blendEquation = 0) {
    return RenderStateObject_1.RenderStateObject.CreateBlendMode(name, srcColor, dstColor, blendEquation);
  }

  createBlendModeSeparate(name, srcColor, dstColor, srcAlpha = 0, dstAlpha = 0, blendEquation = 0) {
    return RenderStateObject_1.RenderStateObject.CreateBlendModeSeparate(name, srcColor, dstColor, srcAlpha, dstAlpha, blendEquation);
  }

  createRenderState(objName, cullFaceMode, blendMode, depthTestMode) {
    return RenderStateObject_1.RenderStateObject.Create(objName, cullFaceMode, blendMode, depthTestMode);
  }

  createRenderColorMask(objName, rBoo, gBoo, bBoo, aBoo) {
    return RenderColorMask_1.RenderColorMask.Create(objName, rBoo, gBoo, bBoo, aBoo);
  }

  getRenderStateByName(objName) {
    return RenderStateObject_1.RenderStateObject.GetRenderStateByName(objName);
  }

  getRenderColorMaskByName(objName) {
    return RenderColorMask_1.RenderColorMask.GetColorMaskByName(objName);
  }

  unlockBlendMode() {
    RenderStateObject_1.RenderStateObject.UnlockBlendMode();
  }

  lockBlendMode(cullFaceMode) {
    RenderStateObject_1.RenderStateObject.LockBlendMode(cullFaceMode);
  }

  unlockDepthTestMode() {
    RenderStateObject_1.RenderStateObject.UnlockDepthTestMode();
  }

  lockDepthTestMode(depthTestMode) {
    RenderStateObject_1.RenderStateObject.LockDepthTestMode(depthTestMode);
  }

  resetState() {
    RenderColorMask_1.RenderColorMask.Reset();
    RenderStateObject_1.RenderStateObject.Reset();
    this.m_Rstate.reset();

    this.m_VRO.__$resetVRO();
  }

  reset(context) {
    RenderColorMask_1.RenderColorMask.Reset();
    RenderStateObject_1.RenderStateObject.Reset();
    this.m_Rstate.setRenderContext(context);
    this.m_Rstate.reset();
  }

  resetInfo() {}

  setDepthTestEnable(enable) {
    this.m_Rstate.setDepthTestEnable(enable);
  }

  setBlendEnable(enable) {
    this.m_Rstate.setBlendEnable(enable);
  }

}

RSTBuilder.m_rbmInited = true;
exports.default = RSTBuilder;

/***/ }),

/***/ "e08e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class RenderDrawMode {}

RenderDrawMode.ELEMENTS_TRIANGLES = 1;
RenderDrawMode.ELEMENTS_TRIANGLE_STRIP = 2;
RenderDrawMode.ELEMENTS_TRIANGLE_FAN = 3;
RenderDrawMode.ELEMENTS_INSTANCED_TRIANGLES = 4;
RenderDrawMode.ARRAYS_LINES = 5;
RenderDrawMode.ARRAYS_LINE_STRIP = 6;
RenderDrawMode.ARRAYS_POINTS = 7;
RenderDrawMode.ELEMENTS_LINES = 8;
RenderDrawMode.DISABLE = 0;
exports.RenderDrawMode = RenderDrawMode; // blend mode

class RenderBlendMode {}

RenderBlendMode.NORMAL = 1;
RenderBlendMode.OPAQUE = 1;
RenderBlendMode.TRANSPARENT = 2;
RenderBlendMode.ALPHA_ADD = 3;
RenderBlendMode.ADD = 4;
RenderBlendMode.ADD_LINEAR = 5;
RenderBlendMode.INVERSE_ALPHA = 6;
RenderBlendMode.BLAZE = 7;
RenderBlendMode.OVERLAY = 8;
RenderBlendMode.OVERLAY2 = 8;
RenderBlendMode.DISABLE = 0;
exports.RenderBlendMode = RenderBlendMode;
/**
 * gl.NEVER:           Never pass.
 * gl.LESS:            Pass if (ref & mask) <  (stencil & mask).
 * gl.EQUAL:           Pass if (ref & mask) =  (stencil & mask).
 * gl.LEQUAL:          Pass if (ref & mask) <= (stencil & mask).
 * gl.GREATER:         Pass if (ref & mask) >  (stencil & mask).
 * gl.NOTEQUAL:        Pass if (ref & mask) != (stencil & mask).
 * gl.GEQUAL:          Pass if (ref & mask) >= (stencil & mask).
 * gl.ALWAYS:          Always pass.
 */

class GLStencilFunc {}

GLStencilFunc.NEVER = 1;
GLStencilFunc.LESS = 1;
GLStencilFunc.EQUAL = 1;
GLStencilFunc.GREATER = 1;
GLStencilFunc.NOTEQUAL = 1;
GLStencilFunc.GEQUAL = 1;
GLStencilFunc.ALWAYS = 1;
exports.GLStencilFunc = GLStencilFunc;
/**
 * gl.KEEP              Keeps the current value.
 * gl.ZERO              Sets the stencil buffer value to 0.
 * gl.REPLACE           Sets the stencil buffer value to the reference value as specified by WebGLRenderingContext.stencilFunc().
 * gl.INCR              Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
 * gl.INCR_WRAP         Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
 * gl.DECR              Decrements the current stencil buffer value. Clamps to 0.
 * gl.DECR_WRAP         Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0.
 * gl.INVERT            Inverts the current stencil buffer value bitwise.
 */

class GLStencilOp {}

GLStencilOp.KEEP = 1;
GLStencilOp.ZERO = 1;
GLStencilOp.REPLACE = 1;
GLStencilOp.INCR = 1;
GLStencilOp.INCR_WRAP = 1;
GLStencilOp.DECR = 1;
GLStencilOp.DECR_WRAP = 1;
GLStencilOp.INVERT = 1;
exports.GLStencilOp = GLStencilOp;

class GLBlendMode {}

GLBlendMode.ZERO = 1;
GLBlendMode.ONE = 1;
GLBlendMode.SRC_COLOR = 1;
GLBlendMode.DST_COLOR = 1;
GLBlendMode.SRC_ALPHA = 1;
GLBlendMode.DST_ALPHA = 1;
GLBlendMode.ONE_MINUS_SRC_ALPHA = 1;
exports.GLBlendMode = GLBlendMode;

class GLBlendEquation {}

GLBlendEquation.FUNC_ADD = 1;
GLBlendEquation.FUNC_SUBTRACT = 1;
GLBlendEquation.FUNC_REVERSE_SUBTRACT = 1;
GLBlendEquation.MIN_EXT = 1;
GLBlendEquation.MAX_EXT = 1;
GLBlendEquation.MIN = 1;
GLBlendEquation.MAX = 1;
exports.GLBlendEquation = GLBlendEquation;

class CullFaceMode {}

CullFaceMode.BACK = 1;
CullFaceMode.FRONT = 2;
CullFaceMode.FRONT_AND_BACK = 3;
CullFaceMode.NONE = 0;
CullFaceMode.DISABLE = 0;
exports.CullFaceMode = CullFaceMode;

class DepthTestMode {}

DepthTestMode.NEVER = 1; //glDepthMask(false); glDepthFunc(GL_ALWAYS);

DepthTestMode.ALWAYS = 2; //glDepthMask(true); glDepthFunc(GL_LEQUAL);

DepthTestMode.SKY = 3;
DepthTestMode.TRUE_LESS_EQUAL = 3; //glDepthMask(true); glDepthFunc(GL_LESS);

DepthTestMode.OPAQUE = 4;
DepthTestMode.TRUE_LESS = 4; //glDepthMask(false); glDepthFunc(GL_EQUAL);

DepthTestMode.OPAQUE_OVERHEAD = 5;
DepthTestMode.FALSE_EQUAL = 5; //glDepthMask(false); glDepthFunc(GL_LESS);

DepthTestMode.FALSE_LESS = 6;
DepthTestMode.BLEND = 6;
DepthTestMode.BLEND_SORT = 6;
DepthTestMode.TRANSPARENT_SORT = 6; //glDepthMask(TRUE); glDepthFunc(GL_LEQUAL);

DepthTestMode.TRUE_LEQUAL = 7;
DepthTestMode.WIRE_FRAME = 7; //
//glDepthMask(false); glDepthFunc(GL_LEQUAL);

DepthTestMode.FALSE_LEQUAL = 8;
DepthTestMode.DECALS = 8; //glDepthMask(false); glDepthFunc(GL_ALWAYS);

DepthTestMode.NEXT_LAYER = 11;
DepthTestMode.WIRE_FRAME_NEXT = 12; //glDepthMask(true); glDepthFunc(GL_EQUAL);

DepthTestMode.TRUE_EQUAL = 13; //glDepthMask(true); glDepthFunc(GL_GREATER);

DepthTestMode.TRUE_GREATER = 14; //glDepthMask(true); glDepthFunc(GL_GEQUAL);

DepthTestMode.TRUE_GEQUAL = 15;
DepthTestMode.DISABLE = 0;
exports.DepthTestMode = DepthTestMode;
var DisplayRenderSign;

(function (DisplayRenderSign) {
  // 还没有加入 renderer
  DisplayRenderSign[DisplayRenderSign["NOT_IN_RENDERER"] = -1] = "NOT_IN_RENDERER"; // 正在进入 renderer

  DisplayRenderSign[DisplayRenderSign["GO_TO_RENDERER"] = 1] = "GO_TO_RENDERER"; // 真正存在于 renderer, 也就是直接可以在 process 中使用了

  DisplayRenderSign[DisplayRenderSign["LIVE_IN_RENDERER"] = 2] = "LIVE_IN_RENDERER";
})(DisplayRenderSign = exports.DisplayRenderSign || (exports.DisplayRenderSign = {}));

/***/ }),

/***/ "e12d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const GeometryModelDataType_1 = __webpack_require__("58fc");

exports.GeometryModelDataType = GeometryModelDataType_1.GeometryModelDataType;

const ThreadTask_1 = __webpack_require__("83a3");

const TaskDependency_1 = __webpack_require__("3b80");
/**
 * fbx 几何模型数据加载/解析任务对象
 */


class FBXParseTask extends ThreadTask_1.ThreadTask {
  /**
   * @param src 子线程中代码模块的js文件url 或者 依赖的唯一名称
   */
  constructor(src) {
    super();
    this.m_listener = null;

    if (src.indexOf("/") > 0) {
      this.dependency = new TaskDependency_1.TaskJSFileDependency(src);
    } else {
      this.dependency = new TaskDependency_1.TaskUniqueNameDependency(src);
    }
  }

  setListener(l) {
    this.m_listener = l;
  }

  addBinaryData(buffer, url) {
    if (buffer != null) {
      this.addDataWithParam("", [buffer], {
        url: url
      });
    }
  }

  addURL(url) {
    if (url != "") {
      throw Error("illegal operation!!!");
    }
  } // return true, task finish; return false, task continue...


  parseDone(data, flag) {
    console.log("FBXParseTask::parseDone(), this.m_listener != null:", this.m_listener != null, data);

    if (this.m_listener != null) {
      let modelData = data.data;
      this.m_listener.fbxParseFinish(modelData.models, modelData.transform, data.descriptor.url, modelData.index, modelData.total);
    }

    return true;
  }

  destroy() {
    super.destroy();
    this.m_listener = null;
  }

}

exports.FBXParseTask = FBXParseTask;

/***/ }),

/***/ "e160":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class AABBCalc {
  IntersectRL(ltv, lpv, ab) {
    let f = 0;
    let tmin = (ab.min.x - lpv.x) / ltv.x;
    let tmax = (ab.max.x - lpv.x) / ltv.x; //console.log("AABB::IntersectRL uses...");

    if (tmin > tmax) {
      f = tmax;
      tmax = tmin;
      tmin = f;
    } //	console.log("\n");
    //	console.log("tmin: "+tmin+",tmax: "+tmax);


    let tymin = (ab.min.y - lpv.y) / ltv.y;
    let tymax = (ab.max.y - lpv.y) / ltv.y; //	console.log("tymin: "+tymin+",tymax: "+tymax);

    if (tymin > tymax) {
      f = tymax;
      tymax = tymin;
      tymin = f;
    }

    if (tmin > tymax || tymin > tmax) return false;
    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;
    let tzmin = (ab.min.z - lpv.z) / ltv.z;
    let tzmax = (ab.max.z - lpv.z) / ltv.z; //	console.log("tzmin: "+tzmin+",tzmax: "+tzmax);
    //	console.log("\n");

    if (tzmin > tzmax) {
      f = tzmax;
      tzmax = tzmin;
      tzmin = f;
    }

    if (tmin > tzmax || tzmin > tmax) return false;
    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax;
    return true;
  }
  /*
  static IntersectionRL3(vecs:IVector3D[],rsigns:Uint8Array,ltInvtv:IVector3D, ltv:IVector3D, lpv:IVector3D,outV:IVector3D):boolean
  {
      let tmin:number, tmax:number, tymin:number, tymax:number;//, tzmin:number, tzmax:number;
      
      tmin = (vecs[rsigns[0]].x - lpv.x) * ltInvtv.x;
      tmax = (vecs[1-rsigns[0]].x - lpv.x) * ltInvtv.x;
      tymin = (vecs[rsigns[1]].y - lpv.y) * ltInvtv.y;
      tymax = (vecs[1-rsigns[1]].y - lpv.y) * ltInvtv.y;
      if ((tmin > tymax) || (tymin > tmax))
          return false;
      if (tymin > tmin)
          tmin = tymin;
      if (tymax < tmax)
          tmax = tymax;
      
      tymin = (vecs[rsigns[2]].z - lpv.z) * ltInvtv.z;
      tymax = (vecs[1-rsigns[2]].z - lpv.z) * ltInvtv.z;
      if ((tmin > tymax) || (tymin > tmax))
          return false;
      if (tymin > tmin)
          tmin = tymin;
      if (tymax < tmax)
          tmax = tymax;
          
      outV.copyFrom(ltv);
      outV.scaleBy(tmin);
      outV.addBy(lpv);
      console.log("T Hit outV: "+outV.toString());
      return true;
  }
  //*/


  static IntersectionRL3(vecs, rsigns, ltInvtv, ltv, lpv, outV) {
    ltInvtv.w = (vecs[rsigns[0]].x - lpv.x) * ltInvtv.x;
    ltv.w = (vecs[1 - rsigns[0]].x - lpv.x) * ltInvtv.x;
    outV.x = (vecs[rsigns[1]].y - lpv.y) * ltInvtv.y;
    outV.y = (vecs[1 - rsigns[1]].y - lpv.y) * ltInvtv.y;
    if (ltInvtv.w > outV.y || outV.x > ltv.w) return false;
    if (outV.x > ltInvtv.w) ltInvtv.w = outV.x;
    if (outV.y < ltv.w) ltv.w = outV.y;
    outV.x = (vecs[rsigns[2]].z - lpv.z) * ltInvtv.z;
    outV.y = (vecs[1 - rsigns[2]].z - lpv.z) * ltInvtv.z;
    if (ltInvtv.w > outV.y || outV.x > ltv.w) return false;
    if (outV.x > ltInvtv.w) ltInvtv.w = outV.x;
    if (outV.y < ltv.w) ltv.w = outV.y;
    outV.copyFrom(ltv);
    outV.scaleBy(ltInvtv.w);
    outV.addBy(lpv);
    ltv.w = 1.0; //console.log("T Hit outV: "+outV.toString());

    return true;
  }

  static IntersectionRL1(ltv, lpv, ab, outV) {
    let f = 0;
    let tmin = (ab.min.x - lpv.x) / ltv.x;
    let tmax = (ab.max.x - lpv.x) / ltv.x; //console.log("AABB::IntersectRL uses...");

    if (tmin > tmax) {
      f = tmax;
      tmax = tmin;
      tmin = f;
    } //	console.log("\n");
    //	console.log("tmin: "+tmin+",tmax: "+tmax);


    let tymin = (ab.min.y - lpv.y) / ltv.y;
    let tymax = (ab.max.y - lpv.y) / ltv.y; //	console.log("tymin: "+tymin+",tymax: "+tymax);

    if (tymin > tymax) {
      f = tymax;
      tymax = tymin;
      tymin = f;
    }

    if (tmin > tymax || tymin > tmax) return false;
    if (tymin > tmin) tmin = tymin;
    if (tymax < tmax) tmax = tymax;
    let tzmin = (ab.min.z - lpv.z) / ltv.z;
    let tzmax = (ab.max.z - lpv.z) / ltv.z; //	console.log("tzmin: "+tzmin+",tzmax: "+tzmax);
    //	console.log("\n");

    if (tzmin > tzmax) {
      f = tzmax;
      tzmax = tzmin;
      tzmin = f;
    }

    if (tmin > tzmax || tzmin > tmax) return false;
    if (tzmin > tmin) tmin = tzmin;
    if (tzmax < tmax) tmax = tzmax; //	console.log("XXXXXXXXX tmin: "+tmin+",tmax: "+tmax);

    outV.copyFrom(ltv);
    outV.scaleBy(tmin);
    outV.addBy(lpv); // console.log("L Hit outV: " + outV.toString());
    //outV.copyFrom(ltv);
    //outV.scaleBy(tmax);
    //outV.addBy(lpv);
    //console.log("tmax outV: "+outV.toString());

    return true;
  } //
  // 检测射线和AABB是否相交,如果相交计算出交点存放于 outV 中, 这个检测计算是精准高效的
  // @param				ltv		射线的切向
  // @param				lpv		射线上的一点
  // @param				ab		updateFast() 过的 AABB 实例
  // @param				outV	存放交点的 Vector3D实例
  //


  static IntersectionRL2(ltv, lpv, ab, outV) {
    // 计算包围球
    //let dis:number = StraightLine.CalcPVSquaredDis2(ltv, lpv, ab.center);
    outV.x = ab.center.x - lpv.x;
    outV.y = ab.center.y - lpv.y;
    outV.z = ab.center.z - lpv.z; //

    let dis = outV.dot(ltv);
    outV.x -= dis * ltv.x;
    outV.y -= dis * ltv.y;
    outV.z -= dis * ltv.z;

    if (outV.getLengthSquared() > ab.radius2) {
      //console.log("Hit shp failure.");
      return false;
    } // 包含起点，则一定相交


    if (ab.containsV(lpv)) {
      outV.copyFrom(lpv);
      return true;
    } // 确定 x 轴线


    if (lpv.x < ab.min.x) {
      // 说明 起点在 ab 的 -x 侧
      if (ltv.x > 0.0) {
        // 有可能和min x面相交
        dis = (ab.min.x - lpv.x) / ltv.x;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsYZ(outV.y, outV.z)) {
          return true;
        }
      }
    } else if (lpv.x > ab.max.x) {
      // 说明 起点在 ab 的 +x 侧
      if (ltv.x < 0.0) {
        // 有可能和max x面相交
        dis = (ab.max.x - lpv.x) / ltv.x;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsYZ(outV.y, outV.z)) {
          return true;
        }
      }
    } // 确定 y 轴线


    if (lpv.y < ab.min.y) {
      // 说明 起点在 ab 的 -y 侧
      if (ltv.y > 0.0) {
        // 有可能和min y面相交
        dis = (ab.min.y - lpv.y) / ltv.y;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXZ(outV.x, outV.z)) {
          return true;
        }
      }
    } else if (lpv.y > ab.max.y) {
      // 说明 起点在 ab 的 +y 侧
      if (ltv.y < 0.0) {
        // 有可能和max y面相交
        dis = ab.max.y;
        dis = (ab.max.y - lpv.y) / ltv.y;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXZ(outV.x, outV.z)) {
          return true;
        }
      }
    } // 确定 z 轴线


    if (lpv.z < ab.min.z) {
      // 说明 起点在 ab 的 -z 侧
      if (ltv.z > 0.0) {
        // 有可能和min y面相交
        dis = (ab.min.z - lpv.z) / ltv.z;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXY(outV.x, outV.y)) {
          return true;
        }
      }
    } else if (lpv.z > ab.max.z) {
      // 说明 起点在 ab 的 +z 侧
      if (ltv.z < 0.0) {
        // 有可能和max z面相交
        dis = (ab.max.z - lpv.z) / ltv.z;
        outV.copyFrom(ltv);
        outV.scaleBy(dis);
        outV.addBy(lpv);

        if (ab.containsXY(outV.x, outV.y)) {
          return true;
        }
      }
    }

    return false;
  }

}

exports.AABBCalc = AABBCalc;

/***/ }),

/***/ "e214":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const AbsGeomBase_1 = __importDefault(__webpack_require__("f48d"));

class Plane extends AbsGeomBase_1.default {
  constructor() {
    super(...arguments);
    this.nv = new Vector3D_1.default(0.0, 1.0, 0.0);
    this.distance = 0.0;
    this.intersectBoo = false;
  }

  intersectStraightLinePos(straightL, outV) {
    // intersection or parallel
    let td = this.nv.dot(straightL.tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = this.nv.dot(straightL.position) - this.distance;
      outV.x = straightL.tv.x * 100000.0 + straightL.position.x;
      outV.y = straightL.tv.y * 100000.0 + straightL.position.y;
      outV.z = straightL.tv.z * 100000.0 + straightL.position.z; //

      td = this.nv.dot(outV) - this.distance;
      td = dis / (dis - td);
      outV.subtractBy(straightL.position);
      outV.scaleBy(td);
      outV.addBy(straightL.position);
      return 1;
    }

    td = this.nv.dot(straightL.position) - this.distance;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(straightL.position);
      return 2;
    }

    return 0;
  }

  intersectStraightLinePos2(sl_pos, sl_tv, outV) {
    // intersection or parallel
    let td = this.nv.dot(sl_tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = this.nv.dot(sl_pos) - this.distance;
      outV.x = sl_tv.x * 100000.0 + sl_pos.x;
      outV.y = sl_tv.y * 100000.0 + sl_pos.y;
      outV.z = sl_tv.z * 100000.0 + sl_pos.z; //

      td = this.nv.dot(outV) - this.distance;
      td = dis / (dis - td);
      outV.subtractBy(sl_pos);
      outV.scaleBy(td);
      outV.addBy(sl_pos);
      return 1;
    }

    td = this.nv.dot(sl_pos) - this.distance;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(sl_pos);
      return 2;
    }

    return 0;
  }

  intersectRadialLinePos(radL, outV) {
    let dis = this.nv.dot(radL.position) - this.distance;

    if (dis > MathConst_1.default.MATH_MIN_POSITIVE) {
      // radL position in plane positive space
      let td = this.nv.dot(radL.tv);

      if (td < 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(radL.position, radL.tv, outV);
      }
    } else if (dis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // radL position in plane negative space
      let td2 = this.nv.dot(radL.tv);

      if (td2 > 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(radL.position, radL.tv, outV);
      }
    } else {
      let td3 = this.nv.dot(radL.tv);

      if (td3 > MathConst_1.default.MATH_MIN_POSITIVE || td3 < MathConst_1.default.MATH_MAX_NEGATIVE) {
        outV.copyFrom(radL.position);
        return 1;
      }

      outV.copyFrom(radL.position);
      return 2;
    }

    return -1;
  }

  intersectRadialLinePos2(rl_pos, rl_tv, outV) {
    let dis = this.nv.dot(rl_pos) - this.distance;

    if (dis > MathConst_1.default.MATH_MIN_POSITIVE) {
      // radL position in plane positive space
      let td = this.nv.dot(rl_tv);

      if (td < 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(rl_pos, rl_tv, outV);
      }
    } else if (dis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // radL position in plane negative space
      let td = this.nv.dot(rl_tv);

      if (td > 0.0) {
        // calc intersection position
        return this.intersectStraightLinePos2(rl_pos, rl_tv, outV);
      }
    } else {
      let td3 = this.nv.dot(rl_tv);

      if (td3 > MathConst_1.default.MATH_MIN_POSITIVE || td3 < MathConst_1.default.MATH_MAX_NEGATIVE) {
        outV.copyFrom(rl_pos);
        return 1;
      }

      outV.copyFrom(rl_pos);
      return 2;
    }

    return -1;
  }

  containsPoint(pos) {
    let f = this.nv.dot(pos) - this.distance;

    if (f > MathConst_1.default.MATH_MIN_POSITIVE) {
      return 1;
    } else if (f < MathConst_1.default.MATH_MAX_NEGATIVE) {
      return -1;
    }

    return 0;
  }

  intersectSphere(cv, radius) {
    this.intersectBoo = false;
    let f = this.nv.dot(cv) - this.distance;

    if (f > MathConst_1.default.MATH_MIN_POSITIVE) {
      this.intersectBoo = f <= radius;
      return 1;
    } else if (f < MathConst_1.default.MATH_MAX_NEGATIVE) {
      this.intersectBoo = -f <= radius;
      return -1;
    }

    return 0;
  }

  intersectAABB(minV, maxV) {
    this.intersectBoo = false;
    let pv = AbsGeomBase_1.default.__tV0;
    pv.setXYZ(maxV.x, minV.y, maxV.z);
    let flag = this.containsPoint(pv);
    pv.setXYZ(maxV.x, minV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, minV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, minV.y, maxV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(maxV.x, maxV.y, maxV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(maxV.x, maxV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, maxV.y, minV.z);
    flag += this.containsPoint(pv);
    pv.setXYZ(minV.x, maxV.y, maxV.z);
    flag += this.containsPoint(pv);
    this.intersectBoo = flag < 8;
    if (flag < -7) return -1;
    if (flag > 7) return 1;
    return 0;
  } // 判断一个球体是否和一个平面的负空间相交


  intersectSphNegSpace(cv, radius) {
    //this.intersectBoo = (this.nv.dot(cv) - this.distance - radius) < MathConst.MATH_MIN_POSITIVE;				
    //this.intersectBoo = (this.nv.dot(cv) - this.distance) < radius;				
    this.intersectBoo = Math.abs(this.nv.dot(cv) - this.distance) < radius;
  }

  update() {
    this.nv.normalize();
  }

  updateFast() {
    this.nv.normalize();
  }

  static PlaneIntersectSphere(pnv, pdis, cv, radius) {
    Plane.IntersectBoo = false;
    Plane.IntersectSatus = 0;
    pdis = pnv.dot(cv) - pdis;

    if (pdis > MathConst_1.default.MATH_MIN_POSITIVE) {
      Plane.IntersectBoo = pdis <= radius;
      Plane.IntersectSatus = 1;
    } else if (pdis < MathConst_1.default.MATH_MAX_NEGATIVE) {
      Plane.IntersectBoo = -pdis <= radius;
      Plane.IntersectSatus = -1;
    }
  }

  static CalcPVCloseV(plane, posV, outV) {
    let value = plane.distance - posV.dot(plane.nv);
    outV.setTo(value * plane.nv.x, value * plane.nv.y, value * plane.nv.z);
    outV.addBy(posV);
  }

  static CalcPVCloseV2(pnv, pd, posV, outV) {
    let value = pd - posV.dot(pnv);
    outV.setTo(value * pnv.x, value * pnv.y, value * pnv.z); //outV.scaleBy(value);

    outV.addBy(posV);
  }

  static IntersectionSLV2(planeNV, planeDis, sl_pos, sl_tv, outV) {
    // intersection or parallel
    let td = planeNV.dot(sl_tv);

    if (td > MathConst_1.default.MATH_MIN_POSITIVE || td < MathConst_1.default.MATH_MAX_NEGATIVE) {
      // intersection
      let dis = planeNV.dot(sl_pos) - planeDis;
      outV.x = sl_tv.x * 100000.0 + sl_pos.x;
      outV.y = sl_tv.y * 100000.0 + sl_pos.y;
      outV.z = sl_tv.z * 100000.0 + sl_pos.z; //

      td = planeNV.dot(outV) - planeDis;
      td = dis / (dis - td);
      outV.subtractBy(sl_pos);
      outV.scaleBy(td);
      outV.addBy(sl_pos);
      return 1;
    }

    td = planeNV.dot(sl_pos) - planeDis;

    if (td <= MathConst_1.default.MATH_MIN_POSITIVE || td >= MathConst_1.default.MATH_MAX_NEGATIVE) {
      // plane contains line
      outV.copyFrom(sl_pos);
      return 2;
    }

    return 0;
  }

  toString() {
    return "Plane(position=" + this.position.toString() + ", nv=" + this.nv.toString() + ")";
  }

}

Plane.IntersectBoo = false;
Plane.IntersectSatus = 0;
exports.default = Plane;

/***/ }),

/***/ "e2fe":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class AABB2D {
  constructor(px = 0.0, py = 0.0, pwidth = 100.0, pheight = 100.0) {
    this.m_right = 100;
    this.m_top = 100;
    this.x = 0;
    this.y = 0;
    this.width = 100;
    this.height = 100;
    this.x = px;
    this.y = py;
    this.width = pwidth;
    this.height = pheight;
    this.update();
  }

  copyFrom(dst) {
    this.x = dst.x;
    this.y = dst.y;
    this.width = dst.width;
    this.height = dst.height;
    this.m_right = dst.m_right;
    this.m_top = dst.m_top;
  }

  clone() {
    return new AABB2D(this.x, this.y, this.width, this.height);
  }
  /**
   * 当前矩形是否包含某一点(同一坐标空间的点)
   * @param x坐标
   * @param y坐标
   * @returns 返回当前矩形是否包含这个坐标位置
   */


  containsXY(vx, vy) {
    if (vx < this.x || vx > this.m_right) return false;
    if (vy < this.y || vy > this.m_top) return false;
    return true;
  }
  /**
   * 当前矩形是否包含目标矩形
   * @param dst 目标矩形
   * @returns 返回当前矩形是否包含目标矩形
   */


  contains(dst) {
    if (dst.x >= this.x && dst.m_right <= this.m_right) {
      if (dst.y >= this.y && dst.m_top <= this.m_top) {
        return true;
      }
    }

    return true;
  }
  /**
   * 当前矩形是否和目标矩形相交
   * @param dst 目标矩形
   * @returns 返回当前矩形是否和目标矩形相交
   */


  intersect(dst) {
    if (dst.x > this.m_right) return false;
    if (dst.m_right < this.x) return false;
    if (dst.y > this.m_top) return false;
    if (dst.m_top < this.y) return false;
    return true;
  }

  setTo(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.m_right = this.width + this.x;
    this.m_top = this.height + this.y;
  }

  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.m_right = this.width + this.x;
    this.m_top = this.height + this.y;
  }

  testEqual(dst) {
    return this.x != dst.x || this.y != dst.y || this.width != dst.width || this.height != dst.height;
  }

  testEqualWithParams(px, py, pw, ph) {
    return this.x != px || this.y != py || this.width != pw || this.height != ph;
  }

  update() {
    this.m_right = this.width + this.x;
    this.m_top = this.height + this.y;
  }

  flipY(height) {
    this.y = height = this.y;
    this.m_right = this.width + this.x;
    this.m_top = this.height + this.y;
  }

  getX() {
    return this.x;
  }

  getY() {
    return this.y;
  }

  getRight() {
    return this.m_right;
  }

  getTop() {
    return this.m_top;
  }

}

exports.default = AABB2D;

/***/ }),

/***/ "e602":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class RenderingColorMask {
  constructor(st) {
    let t = this;
    t.ALL_TRUE = st.COLOR_MASK_ALL_TRUE;
    t.ALL_FALSE = st.COLOR_MASK_ALL_FALSE;
    t.RED_TRUE = st.COLOR_MASK_RED_TRUE;
    t.GREEN_TRUE = st.COLOR_MASK_GREEN_TRUE;
    t.BLUE_TRUE = st.COLOR_MASK_BLUE_TRUE;
    t.ALPHA_TRUE = st.COLOR_MASK_ALPHA_TRUE;
    t.RED_FALSE = st.COLOR_MASK_RED_FALSE;
    t.GREEN_FALSE = st.COLOR_MASK_GREEN_FALSE;
    t.BLUE_FALSE = st.COLOR_MASK_BLUE_FALSE;
    t.ALPHA_FALSE = st.COLOR_MASK_ALPHA_FALSE;
  }

}

exports.RenderingColorMask = RenderingColorMask;

/***/ }),

/***/ "e7ce":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderCodeBuffer_1 = __importDefault(__webpack_require__("faa5"));

const ShaderUniformData_1 = __importDefault(__webpack_require__("b3bd"));

const MaterialBase_1 = __importDefault(__webpack_require__("0fc4"));

class PixelPickIndexShaderBuffer extends ShaderCodeBuffer_1.default {
  constructor() {
    super();
    this.m_uniqueName = "";
  }

  initialize(texEnabled) {
    //console.log("PixelPickIndexShaderBuffer::initialize()...");
    this.m_uniqueName = "PixelPickIndexShd";
  }

  getFragShaderCode() {
    let fragCode = `#version 300 es
precision highp float;
uniform vec4 u_param;
in vec3 v_viewPos;
//in float v_length;
layout(location = 0) out vec4 FragColor0;
void main()
{
vec4 p = vec4(length(v_viewPos.xyz));
p.x = floor(p.x)/256.0;
p.y = floor(fract(p.x) * 256.0)/255.0;
p.x = floor(p.x) / 255.0;
p.z = fract(p.z);
FragColor0 = vec4(p.xyz,u_param.w);
}
`;
    return fragCode;
  }

  getVertShaderCode() {
    let vtxCode = `#version 300 es
precision highp float;
layout(location = 0) in vec3 a_vs;
uniform mat4 u_objMat;
uniform mat4 u_viewMat;
uniform mat4 u_projMat;
out vec3 v_viewPos;
//out float v_length;
void main(){
mat4 viewMat4 = u_viewMat * u_objMat;
vec4 viewPos = viewMat4 * vec4(a_vs, 1.0);
v_viewPos = viewPos.xyz;
//v_length = length(viewPos.xyz);
gl_Position = u_projMat * viewPos;
}
`;
    return vtxCode;
  }

  getUniqueShaderName() {
    //console.log("H ########################### this.m_uniqueName: "+this.m_uniqueName);
    return this.m_uniqueName;
  }

  toString() {
    return "[PixelPickIndexShaderBuffer()]";
  }

  static GetInstance() {
    return PixelPickIndexShaderBuffer.s_instance;
  }

}

PixelPickIndexShaderBuffer.s_instance = new PixelPickIndexShaderBuffer();
exports.PixelPickIndexShaderBuffer = PixelPickIndexShaderBuffer;

class PixelPickIndexMaterial extends MaterialBase_1.default {
  constructor() {
    super();
    this.m_paramArray = new Float32Array([1.0, 1.0, 1.0, 1.0]);
    this.m_1over255 = 1.0 / 255.0;
  }

  getCodeBuf() {
    return PixelPickIndexShaderBuffer.GetInstance();
  }

  setIndex(index) {
    this.m_paramArray[3] = index * this.m_1over255;
  }

  getIndex() {
    return this.m_paramArray[3] / this.m_1over255;
  }

  createSelfUniformData() {
    let oum = new ShaderUniformData_1.default();
    oum.uniformNameList = ["u_param"];
    oum.dataList = [this.m_paramArray];
    return oum;
  }

}

exports.default = PixelPickIndexMaterial;

/***/ }),

/***/ "e7d2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufConst_1 = __importDefault(__webpack_require__("8a0a"));

const ROVtxBufUidStore_1 = __importDefault(__webpack_require__("710f"));

const VtxCombinedBuf_1 = __importDefault(__webpack_require__("f0f0"));

const VtxSeparatedBuf_1 = __importDefault(__webpack_require__("7a04"));

const RenderConst_1 = __webpack_require__("e08e");

class ROVertexBuffer {
  constructor(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    this.m_uid = 0;
    this.m_vtxBuf = null;
    this.m_ivs = null;
    this.m_bufDataUsage = 0;
    this.m_ibufStep = 2; // 2 or 4

    this.m_bufTypeList = null;
    this.m_bufSizeList = null;
    this.layoutBit = 0x0;
    this.vertexVer = 0;
    this.indicesVer = 0;
    this.version = 0;
    this.drawMode = RenderConst_1.RenderDrawMode.ELEMENTS_TRIANGLES;
    this.bufData = null;
    this.m_uid = ROVertexBuffer.s_uid++;
    this.m_bufDataUsage = bufDataUsage;
  }

  setVtxBuf(vtxBuf) {
    if (vtxBuf != this) {
      this.m_vtxBuf = vtxBuf;

      if (vtxBuf != null) {
        vtxBuf.layoutBit = this.layoutBit;
      }
    }
  }

  setBufDataUsage(bufDataUsage) {
    this.m_bufDataUsage = bufDataUsage;
  }

  getUid() {
    return this.m_uid;
  }

  getType() {
    return this.m_vtxBuf.getType();
  }

  setBufTypeList(list) {
    this.m_bufTypeList = list;
  }

  setBufSizeList(list) {
    this.m_bufSizeList = list;
  }

  getBufTypeList() {
    return this.m_bufTypeList;
  }

  getBufSizeList() {
    return this.m_bufSizeList;
  }

  getIBufStep() {
    return this.m_ibufStep;
  }

  getBufDataUsage() {
    return this.m_bufDataUsage;
  }

  getBuffersTotal() {
    return this.m_vtxBuf.getBuffersTotal();
  }

  getAttribsTotal() {
    return this.m_vtxBuf.getAttribsTotal();
  }

  getF32DataAt(index) {
    return this.m_vtxBuf.getF32DataAt(index);
  }

  getIvsData() {
    return this.m_ivs;
  }

  setF32DataAt(index, float32Arr, stepFloatsTotal, setpOffsets) {
    this.m_vtxBuf.setF32DataAt(index, float32Arr, stepFloatsTotal, setpOffsets);
    this.vertexVer++;
  }

  setUintIVSData(uint16Or32Arr, status = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    if (uint16Or32Arr instanceof Uint16Array) {
      this.m_ibufStep = 2;

      if (uint16Or32Arr.length > 65535) {
        throw Error("its type is not Uint32Array.");
      }
    } else if (uint16Or32Arr instanceof Uint32Array) {
      this.m_ibufStep = 4;
    } else {
      console.error("Error: uint16Or32Arr is not an Uint32Array or an Uint16Array bufferArray instance !!!!");
      return;
    }

    this.m_ivs = uint16Or32Arr;

    if (uint16Or32Arr != null) {
      this.indicesVer++;
    }
  }

  setData4fAt(vertexI, attribI, px, py, pz, pw) {
    if (this.m_vtxBuf != null) {
      this.m_vtxBuf.setData4fAt(vertexI, attribI, px, py, pz, pw);
      this.vertexVer++;
    }
  }

  setData3fAt(vertexI, attribI, px, py, pz) {
    if (this.m_vtxBuf != null) {
      this.m_vtxBuf.setData3fAt(vertexI, attribI, px, py, pz);
      this.vertexVer++;
    }
  }

  setData2fAt(vertexI, attribI, px, py) {
    if (this.m_vtxBuf != null) {
      this.m_vtxBuf.setData2fAt(vertexI, attribI, px, py);
      this.vertexVer++;
    }
  }
  /**
   * this function is only an empty function.
   */


  destroy() {}

  __$destroy() {
    console.log("ROVertexBuffer::__$destroy()... " + this);
    this.m_vtxBuf.destroy();

    if (this.m_vtxBuf.getType() < 1) {
      ROVertexBuffer.s_combinedBufs.push(this.m_vtxBuf);
    } else {
      ROVertexBuffer.s_separatedBufs.push(this.m_vtxBuf);
    }

    this.m_vtxBuf = null;
    this.m_ivs = null;
    this.bufData = null;
    this.m_bufTypeList = null;
    this.m_bufSizeList = null;
  }

  toString() {
    return "ROVertexBuffer(uid = " + this.m_uid + ")";
  }

  static GetFreeId() {
    if (ROVertexBuffer.s_freeIdList.length > 0) {
      return ROVertexBuffer.s_freeIdList.pop();
    }

    return -1;
  }

  static GetVtxByUid(uid) {
    return ROVertexBuffer.s_unitList[uid];
  }

  static Create(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    let unit = null;
    let index = ROVertexBuffer.GetFreeId();

    if (index >= 0) {
      unit = ROVertexBuffer.s_unitList[index];
      unit.setBufDataUsage(bufDataUsage);
      ROVertexBuffer.s_unitFlagList[index] = ROVertexBuffer.s_FLAG_BUSY;
    } else {
      unit = new ROVertexBuffer(bufDataUsage);
      ROVertexBuffer.s_unitList.push(unit);
      ROVertexBuffer.s_unitFlagList.push(ROVertexBuffer.s_FLAG_BUSY);
      ROVertexBuffer.s_unitListLen++;
    }

    unit.vertexVer = 0;
    unit.indicesVer = 0;
    unit.version++; //console.log("ROVertexBuffer::Create(), ROVertexBuffer.s_unitList.length: "+ROVertexBuffer.s_unitList.length+", new buf: "+unit);

    ROVertexBuffer.s_vtxStore.__$attachAt(unit.getUid());

    return unit;
  }

  static __$Restore(pobj) {
    if (pobj != null && ROVertexBuffer.s_unitFlagList[pobj.getUid()] == ROVertexBuffer.s_FLAG_BUSY) {
      //console.log("ROVertexBuffer::__$Restore, pobj: "+pobj);
      let uid = pobj.getUid();
      ROVertexBuffer.s_freeIdList.push(uid);
      ROVertexBuffer.s_unitFlagList[uid] = ROVertexBuffer.s_FLAG_FREE;

      pobj.__$destroy();
    }
  }

  static __$$AttachAt(uid) {
    ROVertexBuffer.s_vtxStore.__$attachAt(uid);
  }

  static __$$DetachAt(uid) {
    ROVertexBuffer.s_vtxStore.__$detachAt(uid);
  }

  static Reset() {
    ROVertexBuffer.BufDataList = [];
    ROVertexBuffer.s_stride = 0;
    ROVertexBuffer.BufStatusList = [];
    ROVertexBuffer.BufDataStepList = [];
    ROVertexBuffer.vtxFS32 = null;
    ROVertexBuffer.vbWholeDataEnabled = false;
    ROVertexBuffer.dynBufSegEnabled = false;
    ROVertexBuffer.useBufByIndexEnabled = false;
  }

  static AddFloat32Data(float32Arr, step, status = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    ROVertexBuffer.BufDataList.push(float32Arr);
    ROVertexBuffer.BufDataStepList.push(step);
    ROVertexBuffer.BufStatusList.push(status);
    ROVertexBuffer.s_stride += step;
  }

  static CreateBySaveData(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW, layoutBit = 0x0) {
    let i = 0;
    let k = 0;
    let stride = 0;
    let bufTot = ROVertexBuffer.BufDataStepList.length;
    let offsetList = [];

    for (; i < bufTot; i++) {
      offsetList.push(stride);
      stride += ROVertexBuffer.BufDataStepList[i];
    }

    let tot = ROVertexBuffer.BufDataList[0].length / ROVertexBuffer.BufDataStepList[0];
    let vtxfs32 = new Float32Array(stride * tot);
    let j = 0;
    let segLen = 0;
    let parrf32 = null;
    let subArr = null;

    for (i = 0; i < tot; ++i) {
      k = i * stride;

      for (j = 0; j < bufTot; ++j) {
        segLen = ROVertexBuffer.BufDataStepList[j];
        parrf32 = ROVertexBuffer.BufDataList[j];
        subArr = parrf32.subarray(i * segLen, (i + 1) * segLen);
        vtxfs32.set(subArr, k);
        k += segLen;
      }
    }

    let vb = ROVertexBuffer.Create(bufDataUsage);
    vb.layoutBit = layoutBit;

    if (ROVertexBuffer.s_combinedBufs.length > 0) {
      let vtx = ROVertexBuffer.s_combinedBufs.pop();
      vb.setVtxBuf(vtx);
    } else {
      vb.setVtxBuf(new VtxCombinedBuf_1.default(vb.getBufDataUsage()));
    }

    vb.setF32DataAt(0, vtxfs32, stride, offsetList);
    return vb;
  }

  static CreateVtxCombinedBuf(vtxfs32, bufDataStepList, bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW, layoutBit = 0x0) {
    let i = 0;
    let stride = 0;
    let bufTot = bufDataStepList.length;
    let offsetList = [];

    for (; i < bufTot; i++) {
      offsetList.push(stride);
      stride += bufDataStepList[i];
    }

    let vb = ROVertexBuffer.Create(bufDataUsage);
    vb.layoutBit = layoutBit;

    if (ROVertexBuffer.s_combinedBufs.length > 0) {
      let vtx = ROVertexBuffer.s_combinedBufs.pop();
      vb.setVtxBuf(vtx);
    } else {
      vb.setVtxBuf(new VtxCombinedBuf_1.default(vb.getBufDataUsage()));
    }

    vb.setF32DataAt(0, vtxfs32, stride, offsetList);
    return vb;
  }

  static UpdateCombinedBufData(vb) {
    let i = 0;
    let k = 0;
    let stride = 0;
    let bufTot = ROVertexBuffer.BufDataStepList.length;
    let tot = ROVertexBuffer.BufDataList[0].length / ROVertexBuffer.BufDataStepList[0];
    let vtxfs32 = vb.getF32DataAt(0);
    let newBoo = ROVertexBuffer.s_stride * tot != vtxfs32.length;
    let offsetList = null;

    if (newBoo) {
      offsetList = [];
      vtxfs32 = new Float32Array(ROVertexBuffer.s_stride * tot);

      for (; i < bufTot; i++) {
        offsetList.push(stride);
        stride += ROVertexBuffer.BufDataStepList[i];
      }
    } else {
      stride = ROVertexBuffer.s_stride;
    }

    let j = 0;
    let segLen = 0;
    let parrf32 = null;
    let subArr = null;

    for (i = 0; i < tot; ++i) {
      k = i * stride;

      for (j = 0; j < bufTot; ++j) {
        segLen = ROVertexBuffer.BufDataStepList[j];
        parrf32 = ROVertexBuffer.BufDataList[j];
        subArr = parrf32.subarray(i * segLen, (i + 1) * segLen);
        vtxfs32.set(subArr, k);
        k += segLen;
      }
    }

    if (newBoo) {
      vb.setF32DataAt(0, vtxfs32, stride, offsetList);
    } else {
      vb.setF32DataAt(0, vtxfs32, stride, null);
    }
  }

  static UpdateBufData(vb) {
    if (vb.getType() == 0) {
      ROVertexBuffer.UpdateCombinedBufData(vb);
    } else {
      ROVertexBuffer.UpdateSeparatedBufData(vb);
    }
  }

  static CreateByBufDataSeparate(bufData, bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW, layoutBit = 0x0) {
    let i = 0;
    let stride = 0;
    let bufTot = bufData.getAttributesTotal();
    let offsetList = new Array(bufTot);
    offsetList.fill(0);
    let vb = ROVertexBuffer.Create(bufDataUsage);
    vb.layoutBit = layoutBit;

    if (ROVertexBuffer.s_separatedBufs.length > 0) {
      let vtx = ROVertexBuffer.s_separatedBufs.pop();
      vb.setVtxBuf(vtx);
    } else {
      vb.setVtxBuf(new VtxSeparatedBuf_1.default());
    }

    for (i = 0; i < bufTot; i++) {
      vb.setF32DataAt(i, bufData.getAttributeDataAt(i, 0), stride, offsetList);
    }

    vb.setUintIVSData(bufData.getIndexDataAt(0));
    vb.bufData = bufData;
    return vb;
  }

  static CreateBySaveDataSeparate(bufDataUsage = VtxBufConst_1.default.VTX_STATIC_DRAW) {
    let i = 0;
    let stride = 0;
    let bufTot = ROVertexBuffer.BufDataStepList.length;
    let offsetList = new Array(bufTot);
    let vb = ROVertexBuffer.Create(bufDataUsage);

    if (ROVertexBuffer.s_separatedBufs.length > 0) {
      let vtx = ROVertexBuffer.s_separatedBufs.pop();
      vb.setVtxBuf(vtx);
    } else {
      vb.setVtxBuf(new VtxSeparatedBuf_1.default());
    }

    for (i = 0; i < bufTot; i++) {
      vb.setF32DataAt(i, ROVertexBuffer.BufDataList[i], stride, offsetList);
    }

    return vb;
  }

  static UpdateSeparatedBufData(vb) {
    let bufTot = ROVertexBuffer.BufDataStepList.length;
    let offsetList = new Array(bufTot); // console.log("ROVertexBuffer::CreateBySaveDataSeparate(), bufTot: "+bufTot);

    for (let i = 0; i < bufTot; i++) {
      vb.setF32DataAt(i, ROVertexBuffer.BufDataList[i], 0, offsetList);
    }

    return vb;
  }

  static GetVtxAttachCountAt(vtxUid) {
    return ROVertexBuffer.s_vtxStore.getAttachCountAt(vtxUid);
  }

  static GetVtxAttachAllCount() {
    return ROVertexBuffer.s_vtxStore.getAttachAllCount();
  }
  /**
   * 放在帧循环中自动定时清理资源 system memory vertex data
   */


  static ClearTest() {
    --ROVertexBuffer.s_timeDelay;

    if (ROVertexBuffer.s_timeDelay < 1) {
      ROVertexBuffer.s_timeDelay = 128; // 管理作为数据

      let store = ROVertexBuffer.s_vtxStore;

      if (store.__$getRemovedListLen() > 0) {
        let list = store.__$getRemovedList();

        let len = list.length;
        let i = 0;
        let vtxUid = 0;
        let vb = null;
        let maxSteps = 32;
        len = len > maxSteps ? maxSteps : len;

        for (; i < len; ++i) {
          vtxUid = list.shift();

          if (store.getAttachCountAt(vtxUid) < 1) {
            console.log("ROVertexBuffer remove a instance, vtxUid: " + vtxUid);
            vb = ROVertexBuffer.GetVtxByUid(vtxUid);

            ROVertexBuffer.__$Restore(vb);
          }
        }
      }
    }
  }

}

ROVertexBuffer.s_uid = 0;
ROVertexBuffer.s_combinedBufs = [];
ROVertexBuffer.s_separatedBufs = [];
ROVertexBuffer.s_FLAG_BUSY = 1;
ROVertexBuffer.s_FLAG_FREE = 0;
ROVertexBuffer.s_unitFlagList = [];
ROVertexBuffer.s_unitListLen = 0;
ROVertexBuffer.s_unitList = [];
ROVertexBuffer.s_freeIdList = [];
ROVertexBuffer.s_vtxStore = new ROVtxBufUidStore_1.default();
ROVertexBuffer.s_stride = 0;
ROVertexBuffer.BufDataList = null;
ROVertexBuffer.BufDataStepList = null;
ROVertexBuffer.BufStatusList = null;
ROVertexBuffer.vtxDataFS32 = null;
ROVertexBuffer.vbWholeDataEnabled = false;
ROVertexBuffer.dynBufSegEnabled = false;
ROVertexBuffer.useBufByIndexEnabled = false;
ROVertexBuffer.vtxFS32 = null;
ROVertexBuffer.s_timeDelay = 128;
exports.default = ROVertexBuffer;

/***/ }),

/***/ "e87b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const UniformConst_1 = __importDefault(__webpack_require__("ab73"));

class ViewParamUniformBuilder {
  create(rc, shdp) {
    let param = UniformConst_1.default.ViewportParam;
    if (shdp.hasUniformByName(param.name)) return rc.uniformContext.createShaderGlobalUniformFromProbe(rc.getRenderAdapter().uViewProbe, param.name, [param.name]);
    return null;
  }

  getIDNS() {
    return "ViewParamUniformBuilder";
  }

}

exports.default = ViewParamUniformBuilder;

/***/ }),

/***/ "eaee":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const TextureTarget_1 = __importDefault(__webpack_require__("5deb"));

const TextureProxy_1 = __importDefault(__webpack_require__("0851"));

class FloatCubeTextureProxy extends TextureProxy_1.default {
  constructor(texWidth, texHeight) {
    super(texWidth, texHeight, false);
    this.m_imgDataList = null;
    this.m_texTarget = TextureTarget_1.default.TEXTURE_CUBE;
    this.m_type = TextureProxyType_1.TextureProxyType.FloatCube;
    this.internalFormat = TextureFormat_1.default.RGBA16F;
    this.dataType = TextureDataType_1.default.FLOAT;
    this.mipmapEnabled = true;
  }

  toAlphaFormat() {
    this.srcFormat = TextureFormat_1.default.ALPHA;
    this.internalFormat = TextureFormat_1.default.ALPHA;
    this.unpackAlignment = 1;
  }

  toRedFormat() {
    this.srcFormat = TextureFormat_1.default.RED;
    this.internalFormat = TextureFormat_1.default.RED;
    this.unpackAlignment = 1;
  }

  toRGBFormat() {
    this.unpackAlignment = 1;
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB16F;
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.mipmapEnabled = false;
  }

  toRGBAFormat() {
    this.unpackAlignment = 4;
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA16F;
  }

  toRGBFormatFloat32F() {
    this.unpackAlignment = 1;
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB32F;
    this.minFilter = TextureConst_1.default.NEAREST;
    this.magFilter = TextureConst_1.default.NEAREST;
    this.mipmapEnabled = false;
  }

  toRGBAFormatFloat32F() {
    this.unpackAlignment = 4;
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA32F;
  }

  toRGBAFormatHalfFloat() {
    this.unpackAlignment = 1;
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.dataType = TextureDataType_1.default.HALF_FLOAT;
    this.internalFormat = TextureFormat_1.default.RGBA16F;
  }

  setDataFromBytesToFaceAt(index, bytes, pw, ph, miplevel = 0) {
    if (this.m_imgDataList == null) {
      this.m_imgDataList = [null, null, null, null, null, null];
    }

    if (pw > 0 && ph > 0) {
      if (index == 0 && miplevel < 1) {
        this.m_texWidth = pw;
        this.m_texHeight = ph;
        this.m_miplevel = miplevel;
      }

      if (this.m_imgDataList[index] == null) {
        this.m_imgDataList[index] = new Array(16);
      }

      let arr = this.m_imgDataList[index];
      arr[miplevel] = {
        width: pw,
        height: ph,
        imgData: bytes,
        miplevel: miplevel
      };
      this.m_haveRData = arr[miplevel].imgData != null;
    }
  }

  uploadData(texRes) {
    let gl = texRes.getRC();
    let imo = null;
    let width = this.getWidth();
    let height = this.getHeight();
    let pw;
    let ph;

    for (let i = 0; i < 6; ++i) {
      let arr = this.m_imgDataList[i];

      if (this.mipmapEnabled && this.m_generateMipmap) {
        imo = arr[0];
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, TextureFormat_1.default.ToGL(gl, this.internalFormat), width, height, 0, TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), imo.imgData);
      } else {
        pw = width;
        ph = height;
        let j = 0;

        for (; pw > 0 || ph > 0;) {
          if (arr[j] != null) {
            imo = arr[j];
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, TextureFormat_1.default.ToGL(gl, this.internalFormat), pw, ph, 0, TextureFormat_1.default.ToGL(gl, this.srcFormat), TextureDataType_1.default.ToGL(gl, this.dataType), imo.imgData);
          }

          if (pw > 0) pw >>= 1;
          if (ph > 0) ph >>= 1;
          ++j;
        }
      }
    }

    this.version = 0;
  }

  toString() {
    return "[FloatCubeTextureProxy(name:" + this.name + ",uid=" + this.getUid() + ",width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

  __$destroy() {
    if (this.getAttachCount() < 1) {
      if (this.m_imgDataList != null) {
        for (let i = 0; i < 6; ++i) {
          if (this.m_imgDataList[i] != null) {
            this.m_imgDataList[i].imgData = null;
          }
        }
      }

      console.log("FloatCubeTextureProxy::destroy(), destroy a FloatCubeTextureProxy instance...");

      super.__$destroy();
    }
  }

}

exports.default = FloatCubeTextureProxy;

/***/ }),

/***/ "eca0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2019-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const PoolNodeBuilder_1 = __importDefault(__webpack_require__("2be1"));

const RPOUnit_1 = __importDefault(__webpack_require__("c62b")); //import PoolNodeBuilder = PoolNodeBuilderT.vox.base.PoolNodeBuilder;
// 这个类的实例，和每一个RPOUnit或者RODisplay关联(通过唯一的uid)


class RCRPObj {
  constructor() {
    // 这里假定最多有 16 个 RenerProcess, 每一个数组元素存放的是 RPONode 的uid, 数组的序号对应的是RenerProcess 的uid
    this.idsFlag = 0x0;
    this.count = 0; // 如果只有加入一个process的时候则有效

    this.rprocessUid = -1;
  }

  reset() {
    this.idsFlag = 0;
  }

}

RCRPObj.RenerProcessMaxTotal = 16;
exports.RCRPObj = RCRPObj;

class RPOUnitBuilder extends PoolNodeBuilder_1.default {
  constructor() {
    super(...arguments);
    this.m_rcpoList = [];
  }
  /**
   * the sub class override this function, for real implement.
   */


  createNode() {
    let po = new RCRPObj();
    po.reset();
    this.m_rcpoList.push(po);
    return new RPOUnit_1.default();
  }
  /**
   * the sub class override this function, for real implement.
   */


  restoreUid(uid) {
    this.m_rcpoList[uid].reset();
  }

  testRPNodeExists(dispRUid, rprocessUid) {
    return (this.m_rcpoList[dispRUid].idsFlag & 1 << rprocessUid) > 0;
  }

  testRPNodeNotExists(dispRUid, rprocessUid) {
    return (this.m_rcpoList[dispRUid].idsFlag & 1 << rprocessUid) < 1;
  }

  setRPNodeParam(dispRUid, rprocessUid, rponodeUid) {
    let po = this.m_rcpoList[dispRUid];
    let flag = 1 << rprocessUid;

    if (rponodeUid > -1) {
      if ((po.idsFlag & flag) < 1) {
        ++po.count;
        po.rprocessUid = rprocessUid;
        po.idsFlag = po.idsFlag | flag;
      }
    } else {
      if ((po.idsFlag & flag) > 0) {
        --po.count;
        po.idsFlag = po.idsFlag & ~flag;
      }
    }

    return po.count;
  }

  getRCRPObj(dispRUid) {
    return this.m_rcpoList[dispRUid];
  }

}

exports.RPOUnitBuilder = RPOUnitBuilder;

/***/ }),

/***/ "eda7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const DataUnit_1 = __webpack_require__("74ee");

const ResourceSchedule_1 = __webpack_require__("7de1");

const TextureDataUnit_1 = __webpack_require__("bd49");

const PNGParserListerner_1 = __webpack_require__("b2a0");

const ModuleNS_1 = __webpack_require__("8eb0");

class TextureResourceSchedule extends ResourceSchedule_1.ResourceSchedule {
  constructor() {
    super();
    this.m_waitingUnits = [];
  }

  addUrlToTask(unit) {
    let url = unit.url;

    switch (unit.data.dataFormat) {
      case DataUnit_1.DataFormat.Jpg:
        break;

      case DataUnit_1.DataFormat.Png:
        this.m_pngListener.addUrlToTask(url);
        break;

      default:
        console.error("TextureResourceSchedule::createDataUnit(), illegal data format:", unit.data.dataFormat, ", its url: ", url);
        break;
    }
  }
  /**
   * 被子类覆盖，以便实现具体功能
   */


  createDataUnit(url, dataFormat, immediate = false) {
    TextureDataUnit_1.DataUnitLock.lockStatus = 207;
    let unit = new TextureDataUnit_1.TextureDataUnit();
    unit.lossTime = Date.now();
    unit.immediate = immediate;
    unit.data = new TextureDataUnit_1.TextureDataContainer();
    unit.data.dataFormat = dataFormat;
    unit.url = url;

    if (this.isInitialized()) {
      this.addUrlToTask(unit);
    } else {
      this.m_waitingUnits.push(unit);
    } // switch (unit.data.dataFormat) {
    // 	case DataFormat.Jpg:
    // 		break;
    // 	case DataFormat.Png:
    // 		this.m_pngListener.addUrlToTask(url);
    // 		break;
    // 	default:
    // 		console.error("TextureResourceSchedule::createDataUnit(), illegal data format:",unit.data.dataFormat,", its url: ", url);
    // 		break;
    // }


    return unit;
  }
  /**
   * 被子类覆盖，以便实现具体功能
   */


  initTask(unitPool, threadSchedule, receiverSchedule, taskModules) {
    for (let i = 0; i < taskModules.length; ++i) {
      const module = taskModules[i];
      console.log("TextureResourceSchedule::initTask(), module.name ", module.name);

      switch (module.name) {
        case ModuleNS_1.ModuleNS.pngParser:
          this.m_pngListener = new PNGParserListerner_1.PNGParserListerner(unitPool, threadSchedule, module, receiverSchedule);
          break;

        default:
          break;
      }
    }

    let units = this.m_waitingUnits;

    for (let i = 0; i < units.length; i++) {
      // console.log("XXXXXX texture deferred units["+i+"]: ", units[i]);
      this.addUrlToTask(units[i]);
    }

    this.m_waitingUnits = [];
  }
  /**
   * 销毁当前实例
   */


  destroy() {
    super.destroy();
    this.m_waitingUnits = [];

    if (this.m_pngListener != null) {
      this.m_pngListener.destroy();
      this.m_pngListener = null;
    }
  }

}

exports.TextureResourceSchedule = TextureResourceSchedule;

/***/ }),

/***/ "ee5a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const EventBase_1 = __importDefault(__webpack_require__("a996"));

class EvtNode {
  constructor() {
    this.type = 0;
    this.m_listeners = [];
    this.m_hosts = [];
    this.m_phases = [];
  }

  createEvent(target = null, currentTarget = null) {
    let evt = new EventBase_1.default();
    evt.type = this.type;
    evt.target = target;
    evt.currentTarget = currentTarget;
    return evt;
  }

  addListener(target, func, phase = 0) {
    let i = this.m_hosts.length - 1;

    for (; i >= 0; --i) {
      if (target === this.m_hosts[i]) {
        break;
      }
    }

    if (i < 0) {
      this.m_hosts.push(target);
      this.m_listeners.push(func);
      this.m_phases.push(phase);
    } else {
      console.warn("event target(", target, ") has existed.");
    }
  }

  removeListener(target, func) {
    let i = this.m_hosts.length - 1;

    for (; i >= 0; --i) {
      if (target === this.m_hosts[i]) {
        this.m_hosts.splice(i, 1);
        this.m_listeners.splice(i, 1);
        this.m_phases.splice(i, 1);
        break;
      }
    }
  } // @return      1 is send evt yes,0 is send evt no


  dispatch(evt) {
    let flag = 0;
    let len = this.m_hosts.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || evt.phase == this.m_phases[i]) {
        this.m_listeners[i].call(this.m_hosts[i], evt);
        flag = 1;
      }
    }

    return flag;
  } //@return if the evt can be dispatched in this node,it returns 1,otherwise it returns 0


  passTestEvt(evt) {
    let len = this.m_hosts.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || evt.phase == this.m_phases[i]) {
        return 1;
        break;
      }
    }

    return 0;
  }

  passTestPhase(phase) {
    let len = this.m_hosts.length;

    for (let i = 0; i < len; ++i) {
      if (this.m_phases[i] < 1 || phase == this.m_phases[i]) {
        return 1;
        break;
      }
    }

    return 0;
  }

  destroy() {
    this.m_hosts = [];
    this.m_listeners = [];
    this.m_phases = [];
  }

}

exports.default = EvtNode;

/***/ }),

/***/ "eed9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const HttpFileLoader_1 = __webpack_require__("5b39");

const GeometryDataUnit_1 = __webpack_require__("aeff");

const DivLog_1 = __importDefault(__webpack_require__("3bda"));

const DracoGeomBuilder_1 = __webpack_require__("d9d1");

class DracoParserListerner {
  constructor(unitPool, threadSchedule, module, receiverSchedule) {
    this.m_parseTask = null;
    this.m_moduleUrl = module.url;
    this.m_dirUrl = module.params[0];
    this.m_unitPool = unitPool;
    this.m_threadSchedule = threadSchedule;
    this.m_receiverSchedule = receiverSchedule;
  }

  addUrlToTask(url) {
    console.log("### DracoParserListerner()::addUrlToTask(), url: ", url);

    if (!this.m_unitPool.hasUnitByUrl(url)) {
      if (this.m_parseTask == null) {
        console.log("### DracoParserListerner()::addUrlToTask(), build task..., this.m_dirUrl: ", this.m_dirUrl); // 建立 draco 模型数据builder(包含加载和解析)

        let task = new DracoGeomBuilder_1.DracoGeomBuilder(this.m_moduleUrl);
        task.initialize(this.m_threadSchedule, this.m_dirUrl);
        task.setListener(this);
        this.m_parseTask = task;
      }

      console.log("### DracoParserListerner()::addUrlToTask(), start load url: ", url);
      new HttpFileLoader_1.HttpFileLoader().load(url, (buf, url) => {
        DivLog_1.default.ShowLogOnce("正在解析Draco数据...");
        this.m_parseTask.parseSingleSegData(buf, url);
      }, (progress, url) => {
        let k = Math.round(100 * progress);
        DivLog_1.default.ShowLogOnce("draco file loading " + k + "%");
      }, (status, url) => {
        console.error("load draco mesh data error, url: ", url);
      });
    }
  }

  dracoParseSingle(model, url, index) {
    if (this.m_unitPool.hasUnitByUrl(url)) {
      let unit = this.m_unitPool.getUnitByUrl(url);

      if (unit != null) {
        unit.lossTime = Date.now() - unit.lossTime;
        unit.data.models = [model];
        GeometryDataUnit_1.DataUnitLock.lockStatus = 209;
        unit.toCpuPhase();

        if (unit.immediate) {
          // console.log("geom data receive at once.");
          this.m_receiverSchedule.testUnit(unit);
        }
      }
    }
  } // 单个draco segment 几何数据解析结束之后的回调


  dracoParse(model, index, total) {} // 所有 draco segment 几何数据解析结束之后的回调，表示本次加载解析任务结束


  dracoParseFinish(models, total) {}

  destroy() {
    if (this.m_parseTask != null) {
      this.m_parseTask.destroy();
      this.m_parseTask = null;
    }

    this.m_unitPool = null;
    this.m_threadSchedule = null;
    this.m_receiverSchedule = null;
  }

}

exports.DracoParserListerner = DracoParserListerner;

/***/ }),

/***/ "f044":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

class VtxBufID {
  static CreateNewID() {
    return VtxBufID.s_uid++;
  }

}

VtxBufID.s_uid = 0;
exports.default = VtxBufID;

/***/ }),

/***/ "f0f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VtxBufID_1 = __importDefault(__webpack_require__("f044"));

class VtxCombinedBuf {
  constructor(bufDataUsage) {
    this.m_uid = -1;
    this.m_total = 0;
    this.layoutBit = 0x0;
    this.m_offsetList = null;
    this.m_f32 = null;
    this.m_f32Stride = 0;
    this.m_uid = VtxBufID_1.default.CreateNewID();
  }

  getUid() {
    return this.m_uid;
  }

  getType() {
    return 0;
  }

  getBuffersTotal() {
    return 1;
  }

  getAttribsTotal() {
    return this.m_offsetList.length;
  }

  getF32DataAt(index) {
    return this.m_f32;
  }

  setF32DataAt(index, float32Arr, stepFloatsTotal, setpOffsets) {
    if (setpOffsets != null) this.m_offsetList = setpOffsets;
    this.m_f32Stride = stepFloatsTotal; //console.log("VtxCombinedBuf::setF32DataAt(),"+this+" m_f32.length: "+float32Arr.length+", this.m_f32PreSize: "+this.m_f32PreSize);

    this.m_f32 = float32Arr;
  }

  setData4fAt(vertexI, attribI, px, py, pz, pw) {
    vertexI = this.m_f32Stride * vertexI + this.m_offsetList[attribI];
    this.m_f32[vertexI++] = px;
    this.m_f32[vertexI++] = py;
    this.m_f32[vertexI++] = pz;
    this.m_f32[vertexI++] = pw;
  }

  setData3fAt(vertexI, attribI, px, py, pz) {
    vertexI = this.m_f32Stride * vertexI + this.m_offsetList[attribI]; //console.log("VtxCombinedBuf::setData3fAt(), vertexI: "+vertexI+",this.m_f32Stride: "+this.m_f32Stride);

    this.m_f32[vertexI++] = px;
    this.m_f32[vertexI++] = py;
    this.m_f32[vertexI++] = pz;
  }

  setData2fAt(vertexI, attribI, px, py) {
    vertexI = this.m_f32Stride * vertexI + this.m_offsetList[attribI]; //console.log("VtxCombinedBuf::setData2fAt(), vertexI: "+vertexI+",this.m_f32Stride: "+this.m_f32Stride);

    this.m_f32[vertexI++] = px;
    this.m_f32[vertexI++] = py;
  }

  destroy() {
    console.log("VtxCombinedBuf::__$destroy()... ", this);
    this.m_offsetList = null;
    this.m_f32 = null;
  }

  toString() {
    return "VtxCombinedBuf(uid = " + this.m_uid + ")";
  }

}

exports.default = VtxCombinedBuf;

/***/ }),

/***/ "f208":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

Object.defineProperty(exports, "__esModule", {
  value: true
});

class ShaderCompileInfo {
  constructor() {
    this.info = "";
  }

}

exports.default = ShaderCompileInfo;

/***/ }),

/***/ "f3a2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * IShaderCodeObject instance uuid
 */

var ShaderCodeUUID;

(function (ShaderCodeUUID) {
  /**
   * nothing shader code object
   */
  ShaderCodeUUID["None"] = "";
  /**
   * the default value is PBR light shader code object that it comes from the system shader lib.
   */

  ShaderCodeUUID["Default"] = "pbr";
  /**
   * lambert light shader code object that it comes from the system shader lib.
   */

  ShaderCodeUUID["Lambert"] = "lambert";
  /**
   * PBR light shader code object that it comes from the system shader lib.
   */

  ShaderCodeUUID["PBR"] = "pbr";
})(ShaderCodeUUID || (ShaderCodeUUID = {}));

exports.ShaderCodeUUID = ShaderCodeUUID;

/***/ }),

/***/ "f48d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class AbsGeomBase {
  constructor() {
    // unique id
    this.id = -1;
    this.position = new Vector3D_1.default();
  }

  update() {}

  updateFast() {}

}

AbsGeomBase.__tV0 = new Vector3D_1.default();
AbsGeomBase.__tV1 = new Vector3D_1.default();
AbsGeomBase.__tV2 = new Vector3D_1.default();
exports.AbsGeomBase = AbsGeomBase;
exports.default = AbsGeomBase;

/***/ }),

/***/ "f689":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Euler_1 = __webpack_require__("a053");

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

const LoaderUtils_1 = __webpack_require__("0063");

function convertArrayBufferToString(buffer, from, to) {
  if (from === undefined) from = 0;
  if (to === undefined) to = buffer.byteLength;
  return LoaderUtils_1.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
}

exports.convertArrayBufferToString = convertArrayBufferToString;

function isFbxFormatASCII(text) {
  const CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\'];
  let cursor = 0;

  function read(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }

  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);

    if (num === CORRECT[i]) {
      return false;
    }
  }

  return true;
}

exports.isFbxFormatASCII = isFbxFormatASCII;

function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);

  if (match) {
    const version = parseInt(match[1]);
    return version;
  }

  throw new Error('FBXLoader: Cannot find the version number for the file given.');
}

exports.getFbxVersion = getFbxVersion;
let tempVec3 = new Vector3D_1.default();
let tempEuler = new Euler_1.Euler(); // generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e

function generateTransform(transformData) {
  // let lTransform: Matrix4 = new Matrix4();
  // return lTransform;
  const lTranslationM = new Matrix4_1.default();
  const lPreRotationM = new Matrix4_1.default();
  const lRotationM = new Matrix4_1.default();
  const lPostRotationM = new Matrix4_1.default();
  const lScalingM = new Matrix4_1.default();
  const lScalingPivotM = new Matrix4_1.default();
  const lScalingOffsetM = new Matrix4_1.default();
  const lRotationOffsetM = new Matrix4_1.default();
  const lRotationPivotM = new Matrix4_1.default();
  const lParentGX = new Matrix4_1.default();
  const lParentLX = new Matrix4_1.default();
  const lGlobalT = new Matrix4_1.default();
  let degToRad = MathConst_1.default.DegreeToRadian;
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setTranslation(tempVec3.fromArray(transformData.translation));

  if (transformData.preRotation) {
    const array = transformData.preRotation.map(degToRad);
    array.push(transformData.eulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }

  if (transformData.rotation) {
    const array = transformData.rotation.map(degToRad);
    array.push(transformData.eulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }

  if (transformData.postRotation) {
    const array = transformData.postRotation.map(degToRad);
    array.push(transformData.eulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }

  if (transformData.scale) lScalingM.setScale(tempVec3.fromArray(transformData.scale)); // Pivots and offsets

  if (transformData.scalingOffset) lScalingOffsetM.setTranslation(tempVec3.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setTranslation(tempVec3.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setTranslation(tempVec3.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setTranslation(tempVec3.fromArray(transformData.rotationPivot)); // parent transform

  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }

  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM); // Global Rotation

  const lParentGRM = new Matrix4_1.default();
  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling

  const lParentTM = new Matrix4_1.default();
  lParentTM.copyTranslation(lParentGX);
  const lParentGRSM = lParentTM.clone().invertThis().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invertThis().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4_1.default();

  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM); // console.log("XXXX MF 5, lGlobalRS: ",lGlobalRS);
  } else {
    let v3 = new Vector3D_1.default();
    lParentLX.getScale(v3);
    const lParentLSM = new Matrix4_1.default().setScale(v3);
    const lParentLSM_inv = lParentLSM.clone().invertThis();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }

  const lRotationPivotM_inv = lRotationPivotM.clone().invertThis();
  const lScalingPivotM_inv = lScalingPivotM.clone().invertThis(); // Calculate the local transform matrix

  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4_1.default().copyTranslation(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyTranslation(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS); // from global to local

  lTransform.premultiply(lParentGX.invertThis());
  return lTransform;
}

exports.generateTransform = generateTransform; // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html

const enumsEuler = ['ZYX', 'YZX', 'XZY', 'ZXY', 'YXZ', 'XYZ'];

function getEulerOrder(order) {
  order = order || 0;

  if (order === 6) {
    console.warn('FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');
    return enumsEuler[0];
  }

  return enumsEuler[order];
}

exports.getEulerOrder = getEulerOrder;

function isFbxFormatBinary(buffer) {
  const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0';
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}

exports.isFbxFormatBinary = isFbxFormatBinary; // Converts FBX ticks into real time seconds.

function convertFBXTimeToSeconds(time) {
  return time / 46186158000;
}

exports.convertFBXTimeToSeconds = convertFBXTimeToSeconds; // Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser

function parseNumberArray(value) {
  const array = value.split(',').map(function (val) {
    return parseFloat(val);
  });
  return array;
}

exports.parseNumberArray = parseNumberArray;

function append(a, b) {
  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}

exports.append = append;
const dataArray = new Array(1024);

function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }

  return a;
}

exports.slice = slice; // extracts the data from the correct position in the FBX array based on indexing type

function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;

  switch (infoObject.mappingType) {
    case 'ByPolygonVertex':
      index = polygonVertexIndex;
      break;

    case 'ByPolygon':
      index = polygonIndex;
      break;

    case 'ByVertice':
      index = vertexIndex;
      break;

    case 'AllSame':
      index = infoObject.indices[0];
      break;

    default:
      console.warn('FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);
  }

  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}

exports.getData = getData;

/***/ }),

/***/ "f7ee":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const LoaderUtils_1 = __webpack_require__("0063");

class BinaryReader {
  constructor(buffer, littleEndian) {
    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== undefined ? littleEndian : true;
  }

  getOffset() {
    return this.offset;
  }

  size() {
    return this.dv.buffer.byteLength;
  }

  skip(length) {
    this.offset += length;
  }

  setOffset(offset) {
    this.offset = offset;
  } // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.


  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }

  getBooleanArray(size) {
    // const a = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a.push( this.getBoolean() );
    // }
    // return a;
    const a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getBoolean();
    }

    return a;
  }

  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }

  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }

  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }

  getInt32Array(size) {
    // const a: number[] = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a.push( this.getInt32() );
    // }
    // return a;
    const a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getInt32();
    }

    return a;
  }

  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  } // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer


  getInt64() {
    let low, high;

    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    } // calculate negative value


    if (high & 0x80000000) {
      high = ~high & 0xFFFFFFFF;
      low = ~low & 0xFFFFFFFF;
      if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;
      low = low + 1 & 0xFFFFFFFF;
      return -(high * 0x100000000 + low);
    }

    return high * 0x100000000 + low;
  }

  getInt64Array(size) {
    // const a: number[] = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a.push( this.getInt64() );
    // }
    // return a;
    const a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getInt64();
    }

    return a;
  } // Note: see getInt64() comment


  getUint64() {
    let low, high;

    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }

    return high * 0x100000000 + low;
  }

  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }

  getFloat32Array(size) {
    // const a = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a.push( this.getFloat32() );
    // }
    // return a;
    const a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getFloat32();
    }

    return a;
  }

  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value; // try{
    // const value = this.dv.getFloat64( this.offset, this.littleEndian );
    // this.offset += 8;
    // return value;
    // }catch(e) {
    // 	console.log("EEEEEerror this.offset: ",this.offset);
    // 	throw Error(e);
    // }
    // return 0;
  }

  getFloat64Array(size) {
    // const a: number[] = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a.push( this.getFloat64() );
    // }
    // return a;
    const a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getFloat64(); // try{
      // 	a[i] = this.getFloat64();
      // }catch(e) {
      // 	console.log("EEEEEerror size: ",size);
      // 	throw Error(e);
      // }
    }

    return a;
  }

  getArrayBuffer(size) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size);
    this.offset += size;
    return value; // let u8Arr = new Uint8Array( this.dv.buffer );
    // const value = u8Arr.subarray( this.offset, this.offset + size );
    // this.offset += size;
    // // console.log("getArrayBuffer() use size: ", size);
    // return value.buffer;
    // console.log("aaa",value.length);
    // return (value.slice()).buffer;
  }

  getArrayU8Buffer(size) {
    let u8Arr = new Uint8Array(this.dv.buffer);
    const value = u8Arr.subarray(this.offset, this.offset + size);
    this.offset += size; // console.log("getArrayU8Buffer() use size: ", size);

    return value;
  }

  getArrayU8BufferByOffset(offset, size) {
    let u8Arr = new Uint8Array(this.dv.buffer);
    return u8Arr.subarray(offset, offset + size);
  }

  getString(size) {
    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
    // let a: number[] = [];
    // for ( let i = 0; i < size; i ++ ) {
    // 	a[ i ] = this.getUint8();
    // }
    let a = new Array(size);

    for (let i = 0; i < size; i++) {
      a[i] = this.getUint8();
    }

    const nullByte = a.indexOf(0);
    if (nullByte >= 0) a = a.slice(0, nullByte);
    return LoaderUtils_1.LoaderUtils.decodeText(new Uint8Array(a));
  }

}

exports.BinaryReader = BinaryReader;

/***/ }),

/***/ "f928":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureConst_1 = __importDefault(__webpack_require__("8d98"));

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const TextureDataType_1 = __importDefault(__webpack_require__("1f61"));

const RawDataTextureProxy_1 = __importDefault(__webpack_require__("df25"));

class FloatTextureProxy extends RawDataTextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_type = TextureProxyType_1.TextureProxyType.Float;
    this.minFilter = TextureConst_1.default.LINEAR;
    this.internalFormat = TextureFormat_1.default.RGBA16F;
    this.dataType = TextureDataType_1.default.FLOAT;
    this.unpackAlignment = 4;
  }

  toAlphaFormat() {
    this.srcFormat = TextureFormat_1.default.ALPHA;
    this.internalFormat = TextureFormat_1.default.ALPHA;
    this.unpackAlignment = 1;
  }

  toRedFormat() {
    this.srcFormat = TextureFormat_1.default.RED;
    this.internalFormat = TextureFormat_1.default.RED;
    this.unpackAlignment = 1;
  }

  toRGBFormat() {
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB16F;
    this.unpackAlignment = 1;
  }

  toRGBAFormat() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.unpackAlignment = 4;
  }

  toRGBAFloatFormat() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA16F;
    this.unpackAlignment = 4;
  }

  setDataFromBytes(bytes, miplevel = 0, imgWidth = -1, imgHeight = -1, offsetx = 0, offsety = 0, rebuild = false) {
    super.setDataFromBytes(bytes, miplevel, imgWidth, imgHeight, offsetx, offsety, rebuild);
  }

  setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel = 0) {
    super.setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel);
  }

  getPixels(px, py, pw, ph, outBytes) {
    super.getPixels(px, py, pw, ph, outBytes);
  }

  toString() {
    return "[FloatTextureProxy(width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = FloatTextureProxy;

/***/ }),

/***/ "fa60":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const VROBase_1 = __importDefault(__webpack_require__("919c"));

class VaoVertexRenderObj extends VROBase_1.default {
  constructor() {
    super();
    /**
     * vao buffer object
     */

    this.vao = null;
    this.m_uid = VaoVertexRenderObj.s_uid++;
  }

  run() {
    if (this.m_rc.testVROUid(this.m_uid)) {
      // console.log("VaoVertexRenderObj::run(), rcuid: ",this.m_rc.getRCUid(),this.m_vtxUid, this.m_uid);
      this.m_rc.bindVertexArray(this.vao);

      if (this.m_rc.testRIOUid(this.m_vtxUid) || VROBase_1.default.s_mid != this.m_mid) {
        // if (this.m_rc.testRIOUid(this.m_vtxUid)) {
        // console.log("VaoVertexRenderObj::run(), testRIOUid()..");
        VROBase_1.default.s_mid = this.m_mid;
        this.m_rc.bindEleBuf(this.ibuf);
      }
    }
  }

  __$destroy() {
    console.log("VaoVertexRenderObj::__$destroy()..., " + this);
    VROBase_1.default.s_midMap.delete(this.m_mid);
    this.m_mid = 0;
    this.m_vtxUid = -1;
    this.ibuf = null;
    this.vao = null;
    this.m_rc = null;
  }

  restoreThis() {
    if (this.vao != null) {
      this.m_rc.deleteVertexArray(this.vao);
    }

    VaoVertexRenderObj.Restore(this);
  }

  toString() {
    return "VaoVertexRenderObj(uid = " + this.m_uid + ", type=" + this.m_mid + ")";
  }

  static HasMid(mid) {
    return VROBase_1.default.s_midMap.has(mid);
  }

  static GetByMid(mid) {
    return VROBase_1.default.s_midMap.get(mid);
  }

  static GetFreeId() {
    if (VaoVertexRenderObj.s_freeIdList.length > 0) {
      return VaoVertexRenderObj.s_freeIdList.pop();
    }

    return -1;
  }

  static Create(rc, mid, pvtxUid) {
    let unit = null;
    let index = VaoVertexRenderObj.GetFreeId();

    if (index >= 0) {
      unit = VaoVertexRenderObj.s_unitList[index];
      VaoVertexRenderObj.s_unitFlagList[index] = VaoVertexRenderObj.s_FLAG_BUSY;
      unit.setMidAndBufUid(mid, pvtxUid);
    } else {
      unit = new VaoVertexRenderObj();
      unit.setMidAndBufUid(mid, pvtxUid);
      VaoVertexRenderObj.s_unitList.push(unit);
      VaoVertexRenderObj.s_unitFlagList.push(VaoVertexRenderObj.s_FLAG_BUSY);
      VaoVertexRenderObj.s_unitListLen++;
    }

    unit.setRC(rc);
    VROBase_1.default.s_midMap.set(mid, unit);
    return unit;
  }

  static Restore(pobj) {
    //console.log("VaoVRO Restore XXXX ("+pobj.getUid()+")pobj.m_attachCount: ",pobj.m_attachCount);
    if (pobj != null && pobj.m_attachCount < 1 && VaoVertexRenderObj.s_unitFlagList[pobj.getUid()] == VaoVertexRenderObj.s_FLAG_BUSY) {
      let uid = pobj.getUid();
      VaoVertexRenderObj.s_freeIdList.push(uid);
      VaoVertexRenderObj.s_unitFlagList[uid] = VaoVertexRenderObj.s_FLAG_FREE;

      pobj.__$destroy();
    }
  }

}

VaoVertexRenderObj.s_uid = 0;
VaoVertexRenderObj.s_FLAG_BUSY = 1;
VaoVertexRenderObj.s_FLAG_FREE = 0;
VaoVertexRenderObj.s_unitFlagList = [];
VaoVertexRenderObj.s_unitListLen = 0;
VaoVertexRenderObj.s_unitList = [];
VaoVertexRenderObj.s_freeIdList = [];
exports.default = VaoVertexRenderObj;

/***/ }),

/***/ "faa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ShaderCodeUUID_1 = __webpack_require__("f3a2");

const ShaderCodeBuilder_1 = __importDefault(__webpack_require__("4a54"));

const MaterialPipeType_1 = __webpack_require__("5216");

const ShaderCodeUniform_1 = __webpack_require__("3113");

const ShaderTextureBuilder_1 = __webpack_require__("4efa");

class ShaderCodeBuffer {
  constructor() {
    this.m_coder = null;
    this.m_shaderCodeObj = null;
    this.m_texList = null;
    this.m_texEnabled = true;
    this.pipeline = null;
    this.gamma = false;
    this.vertColorEnabled = false;
    this.premultiplyAlpha = false;
    this.shadowReceiveEnabled = false;
    this.lightEnabled = false;
    this.fogEnabled = false;
    this.envAmbientLightEnabled = false;
    this.brightnessOverlayEnabeld = false;
    this.glossinessEnabeld = true;
    this.pipeTypes = null;
    this.keysString = "";
    /**
     * 是否自适应转换shader版本
     */

    this.adaptationShaderVersion = true;

    if (ShaderCodeBuffer.s_coder == null) {
      ShaderCodeBuffer.s_uniform = new ShaderCodeUniform_1.ShaderCodeUniform();
      ShaderCodeBuffer.s_coder = new ShaderCodeBuilder_1.default(ShaderCodeBuffer.s_uniform);

      ShaderCodeBuffer.s_uniform.__$setCodeBuilder(ShaderCodeBuffer.s_coder);

      ShaderCodeBuffer.s_texBulder = new ShaderTextureBuilder_1.ShaderTextureBuilder(ShaderCodeBuffer.s_coder);
    }
  }

  reset() {
    this.m_coder = ShaderCodeBuffer.s_coder;
    this.m_uniform = ShaderCodeBuffer.s_uniform;
    this.m_texBuilder = ShaderCodeBuffer.s_texBulder;
    this.m_texture = this.m_uniform;
    this.m_coder.reset();
    this.m_texList = null;
    this.pipeTypes = null;
    this.gamma = false;
    this.vertColorEnabled = false;
    this.premultiplyAlpha = false;
    this.shadowReceiveEnabled = false;
    this.lightEnabled = false;
    this.fogEnabled = false;
    this.envAmbientLightEnabled = false;
    this.brightnessOverlayEnabeld = false;
    this.glossinessEnabeld = true;
    this.keysString = "";
  }

  clear() {
    this.m_coder = null;
  }

  getUniform() {
    return this.m_uniform;
  }

  getTexture() {
    return this.m_texture;
  }

  getTexBuilder() {
    return this.m_texBuilder;
  }

  setShaderCodeObject(obj) {
    this.m_shaderCodeObj = obj;
  }

  getShaderCodeObject() {
    return this.m_shaderCodeObj;
  }

  getShaderCodeObjectUUID() {
    return ShaderCodeUUID_1.ShaderCodeUUID.None;
  }

  getShaderCodeBuilder() {
    return ShaderCodeBuffer.s_coder;
  }

  static GetPreCompileInfo() {
    return ShaderCodeBuffer.s_coder.getPreCompileInfo();
  }

  initialize(texEnabled) {
    // if (ShaderCodeBuffer.__$s_csBuf != null) {
    //     if (ShaderCodeBuffer.__$s_csBuf != this) {
    //         ShaderCodeBuffer.__$s_csBuf.initialize(texEnabled);
    //     }
    // }
    this.m_texEnabled = texEnabled;
    this.bufInitWithPipeline();
  }

  buildDefine() {
    if (this.premultiplyAlpha) {
      this.m_coder.addDefine("VOX_PREMULTIPLY_ALPHA");
      this.keysString += "A";
    }

    if (this.vertColorEnabled) {
      this.m_coder.addDefine("VOX_USE_VTX_COLOR");
      this.keysString += "UVC";
    }

    if (this.brightnessOverlayEnabeld) {
      this.m_coder.addDefine("VOX_USE_BRIGHTNESS_OVERLAY_COLOR");
      this.keysString += "UBOC";
    }

    if (this.glossinessEnabeld) {
      this.m_coder.addDefine("VOX_USE_GLOSSINESS");
      this.keysString += "UG";
    }
  }

  buildPipelineParams() {
    if (this.pipeline != null) {
      if (this.pipeTypes == null) this.pipeTypes = [];
      let MPT = MaterialPipeType_1.MaterialPipeType;
      if (this.lightEnabled && !this.pipeTypes.includes(MPT.GLOBAL_LIGHT)) this.pipeTypes.push(MPT.GLOBAL_LIGHT);
      if (this.shadowReceiveEnabled && !this.pipeTypes.includes(MPT.VSM_SHADOW)) this.pipeTypes.push(MPT.VSM_SHADOW);
      if (this.fogEnabled && !this.pipeTypes.includes(MPT.FOG_EXP2)) this.pipeTypes.push(MPT.FOG_EXP2);
      if (this.envAmbientLightEnabled && !this.pipeTypes.includes(MPT.ENV_AMBIENT_LIGHT)) this.pipeTypes.push(MPT.ENV_AMBIENT_LIGHT);
    }
  }

  getTexturesFromPipeline(outList) {
    if (this.pipeline != null) {
      this.pipeline.getTextures(this.m_coder, outList, this.pipeTypes);
    }
  }

  bufInitWithPipeline() {
    if (this.pipeline != null) {
      this.buildPipelineParams();
      this.pipeline.buildSharedUniforms(this.pipeTypes);
      this.pipeline.createKeys(this.pipeTypes);
      this.keysString += this.pipeline.getKeysString();
    }
  }

  isTexEanbled() {
    return this.m_texEnabled;
  }

  setIRenderTextureList(texList) {
    this.m_texList = texList;
  }

  getIRenderTextureList() {
    return this.m_texList;
  }

  buildShader() {}

  getFragShaderCode() {
    //if (ShaderCodeBuffer.__$s_csBuf != this) return ShaderCodeBuffer.__$s_csBuf.getFragShaderCode();
    return this.m_coder.buildFragCode();
  }

  getVertShaderCode() {
    //if (ShaderCodeBuffer.__$s_csBuf != this) return ShaderCodeBuffer.__$s_csBuf.getVertShaderCode();
    return this.m_coder.buildVertCode();
  }

  getUniqueShaderName() {
    //if (ShaderCodeBuffer.__$s_csBuf != this) return ShaderCodeBuffer.__$s_csBuf.getUniqueShaderName();
    throw Error("Illgel operation !!!");
    return "";
  }

  toString() {
    return "[ShaderCodeBuffer()]";
  }

}

exports.default = ShaderCodeBuffer;

/***/ }),

/***/ "fae3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _setPublicPath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1eb2");
/* harmony import */ var _entry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a176");
/* harmony import */ var _entry__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_entry__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _entry__WEBPACK_IMPORTED_MODULE_1__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _entry__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));




/***/ }),

/***/ "fbd5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

const AABB_1 = __importDefault(__webpack_require__("fecb"));

const Matrix4_1 = __importDefault(__webpack_require__("18c7"));

class EntityLayout {
  constructor() {
    this.m_scaleV = new Vector3D_1.default();
    this.m_tempMat = new Matrix4_1.default();
    this.m_currMat = new Matrix4_1.default();
    this.m_aabb = new AABB_1.default();
    this.m_sizeScale = 1.0;
  }

  getAABB() {
    return this.m_aabb;
  }

  calcAABB(entities, transforms) {
    let mat = this.m_tempMat;
    let transform;
    let currMat = this.m_currMat;
    let aabb = this.m_aabb;

    for (let k = 0; k < entities.length; ++k) {
      // transform = transforms[ k ];
      // if(transform != null) {
      // 	mat.identity();
      // 	mat.setRotationEulerAngle(0.5 * Math.PI, 0.0,0.0);
      // 	currMat.copyFrom(transform);
      // 	currMat.append(mat);				
      // 	entities[k].getTransform().setParentMatrix(currMat);
      // 	entities[k].update();
      // }
      entities[k].update();
      if (k > 0) aabb.union(entities[k].getGlobalBounds());else aabb.copyFrom(entities[k].getGlobalBounds());
    }

    aabb.update();
    return aabb;
  }

  fixToPosition(entities, transforms, fixV3, baseSize = 300.0) {
    let mat = this.m_tempMat;
    let transform;
    let currMat = this.m_currMat;
    let aabb = this.m_aabb;

    for (let k = 0; k < entities.length; ++k) {
      transform = transforms[k];
      mat.identity();
      mat.setRotationEulerAngle(0.5 * Math.PI, 0.0, 0.0);

      if (transform != null) {
        currMat.copyFrom(transform);
        currMat.append(mat);
        entities[k].getTransform().setParentMatrix(currMat);
      } else {
        currMat.copyFrom(mat);
        entities[k].getTransform().setParentMatrix(currMat);
      }

      entities[k].update();
      if (k > 0) aabb.union(entities[k].getGlobalBounds());else aabb.copyFrom(entities[k].getGlobalBounds());
    }

    aabb.update();
    let sx = baseSize / aabb.getWidth();
    let sy = baseSize / aabb.getHeight();
    let sz = baseSize / aabb.getLong();
    sx = Math.min(sx, sy, sz);
    this.m_sizeScale = sx;
    this.m_scaleV.setXYZ(sx, sx, sx);
    let cv = aabb.center;
    let offsetV = new Vector3D_1.default(fixV3.x - cv.x, fixV3.y - cv.y, fixV3.z - cv.z);
    offsetV.scaleBy(sx);

    for (let k = 0; k < entities.length; ++k) {
      transform = transforms[k];
      mat.identity();
      mat.setScale(this.m_scaleV);
      mat.setRotationEulerAngle(0.5 * Math.PI, 0.0, 0.0);
      mat.setTranslation(offsetV);

      if (transform != null) {
        currMat.copyFrom(transform);
        currMat.append(mat);
        entities[k].getTransform().setParentMatrix(currMat);
      } else {
        currMat.copy(mat);
        entities[k].getTransform().setParentMatrix(currMat);
      }

      entities[k].update();
      if (k > 0) aabb.union(entities[k].getGlobalBounds());else aabb.copyFrom(entities[k].getGlobalBounds());
    }

    aabb.update();
  }

  getSizeScale() {
    return this.m_sizeScale;
  }

}

exports.EntityLayout = EntityLayout;

/***/ }),

/***/ "fc07":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

const AttributeLine_1 = __importDefault(__webpack_require__("2e8a"));

const UniformLine_1 = __importDefault(__webpack_require__("78e9"));

class ShaderCodeParser {
  constructor() {
    this.m_texNSMap = new Map();
    this.attriNSList = null;
    this.attriSizeList = null;
    this.uniformNameListStr = "";
    this.texUniformNameListStr = "";
    this.attributes = [null, null, null, null, null, null, null, null, null, null, null, null];
    this.uniforms = null;
    this.texTotal = 0;
    this.fragOutputTotal = 0;
  }

  reset() {
    this.attriNSList = null;
    this.uniformNameListStr = "";
    this.texUniformNameListStr = "";
    let i = 0;

    for (; i < 12; ++i) {
      this.attributes[i] = null;
    }

    this.uniforms = null;
    this.m_texNSMap.clear();
    this.texTotal = 0;
  }

  parseVShaderCode(vshdsrc) {
    let semicolonReg = new RegExp(";", "g");
    vshdsrc = vshdsrc.replace(semicolonReg, ";\n");
    vshdsrc = vshdsrc.replace("{", "{\n");
    vshdsrc = vshdsrc.replace("}", "\n}"); //

    let ENTER = "\n";
    let i = vshdsrc.indexOf(ENTER);
    let j = 0; //

    let codeList = [];
    let str = "";
    let subStr = ""; //trace("-----------------parseVShaderCode begin----------------------");

    let regSpace = new RegExp(" ", "g");

    while (i >= 0) {
      str = vshdsrc.slice(j, i);

      if (str.length > 0) {
        subStr = str.replace(regSpace, "");

        if (subStr.indexOf("//") != 0) {
          codeList.push(str);
        }
      }

      j = i + 1;
      i = vshdsrc.indexOf(ENTER, j);
    }

    str = vshdsrc.slice(j, vshdsrc.length);

    if (str.length > 0) {
      subStr = str.replace(regSpace, "");

      if (subStr.indexOf("//") != 0) {
        codeList.push(str);
      }
    }

    let UNIFORM = "uniform ";
    let len = codeList.length;
    let attri = null;
    i = 0;

    for (; i < 12; ++i) {
      this.attributes[i] = null;
    }

    this.attriNSList = [];
    this.attriSizeList = []; //

    let uniform = null;
    if (this.uniforms == null) this.uniforms = []; //if(this.uniformNameList == null)this.uniformNameList = [];
    //

    i = 0;
    let flagLayout = false;
    let flagAttri = false;

    while (i < len) {
      str = codeList[i];
      flagLayout = str.indexOf("layout") >= 0;
      flagAttri = str.indexOf("attribute ") >= 0;

      if (flagLayout && str.indexOf("location") > 0 || flagAttri) {
        attri = new AttributeLine_1.default();
        attri.layoutEnabled = flagLayout;
        attri.parseCode(str); //this.attributes.push( attri );

        this.attributes[attri.attriType] = attri;
        this.attriNSList.push(attri.name);
        this.attriSizeList.push(attri.typeSize);
      } else if (str.indexOf(UNIFORM) >= 0) {
        uniform = new UniformLine_1.default();

        if (uniform.parseCode(str)) {
          this.uniforms.push(uniform); //this.uniformNameList.push( uniform.name );

          this.uniformNameListStr += uniform.name + ",";

          if (uniform.isTex && !this.m_texNSMap.has(uniform.name)) {
            console.log("use vtx texture !!!");
            this.m_texNSMap.set(uniform.name, 1);
            this.texUniformNameListStr += uniform.name + ",";
            this.texTotal++;
          }
        }
      }

      ++i;
    } //trace("-----------------parseVShaderCode end----------------------");

  }

  parseFShaderCode(fshdsrc) {
    let semicolonReg = new RegExp(";", "g");
    fshdsrc = fshdsrc.replace(semicolonReg, ";\n");
    fshdsrc = fshdsrc.replace("{", "{\n");
    fshdsrc = fshdsrc.replace("}", "\n}"); //

    let ENTER = "\n";
    let i = fshdsrc.indexOf(ENTER);
    let j = 0; //

    let codeList = [];
    let str = "";
    let subStr = ""; //console.log("-----------------parseFShaderCode begin----------------------");

    let regSpace = new RegExp(" ", "g");

    while (i >= 0) {
      str = fshdsrc.slice(j, i);

      if (str.length > 0) {
        subStr = str.replace(regSpace, "");

        if (subStr.indexOf("//") != 0) {
          codeList.push(str);
        }
      }

      j = i + 1;
      i = fshdsrc.indexOf(ENTER, j);
    }

    str = fshdsrc.slice(j, fshdsrc.length);

    if (str.length > 0) {
      subStr = subStr.replace(regSpace, "");

      if (subStr.indexOf("//") != 0) {
        codeList.push(str); //trace(str);
      }
    }

    let UNIFORM = "uniform ";
    let len = codeList.length;
    let uniform = null;
    if (this.uniforms == null) this.uniforms = [];
    i = 0;

    while (i < len) {
      str = codeList[i];

      if (str.indexOf(UNIFORM) >= 0 && this.uniformNameListStr.indexOf(UNIFORM) < 0) {
        uniform = new UniformLine_1.default();

        if (uniform.parseCode(str)) {
          this.uniforms.push(uniform);
          this.uniformNameListStr += uniform.name + ",";

          if (uniform.isTex && !this.m_texNSMap.has(uniform.name)) {
            this.m_texNSMap.set(uniform.name, 1);
            this.texUniformNameListStr += uniform.name + ",";
            this.texTotal++;
          } else {//this.uniformNameList.push( uniform.name );
          }
        }
      }

      ++i;
    }

    let outputKey = "layout";

    if (RendererDevice_1.default.IsWebGL1()) {
      outputKey = "gl_FragData";
    }

    i = fshdsrc.indexOf(outputKey);
    this.fragOutputTotal = 0;

    while (i > 0) {
      this.fragOutputTotal++;
      i = fshdsrc.indexOf(outputKey, i + 2);
    }

    if (this.fragOutputTotal < 1) {
      this.fragOutputTotal = 1;
    } //trace("-----------------parseFShaderCode end----------------------,texTotal: "+texTotal);

  }

}

exports.default = ShaderCodeParser;

/***/ }),

/***/ "fce7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class ThreadConfigure {}
/**
 * 当前线程调度中同时存在的任务最大数量
 */


ThreadConfigure.MAX_TASKS_TOTAL = 1024;
exports.ThreadConfigure = ThreadConfigure;

/***/ }),

/***/ "fe7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const TextureProxyType_1 = __webpack_require__("7918");

const TextureFormat_1 = __importDefault(__webpack_require__("ffc0"));

const RawDataTextureProxy_1 = __importDefault(__webpack_require__("df25"));

class BytesTextureProxy extends RawDataTextureProxy_1.default {
  constructor(texWidth, texHeight, powerof2Boo = false) {
    super(texWidth, texHeight, powerof2Boo);
    this.m_type = TextureProxyType_1.TextureProxyType.Bytes;
  }

  toAlphaFormat() {
    this.srcFormat = TextureFormat_1.default.ALPHA;
    this.internalFormat = TextureFormat_1.default.ALPHA;
    this.unpackAlignment = 1;
  }

  toRedFormat() {
    this.srcFormat = TextureFormat_1.default.RED;
    this.internalFormat = TextureFormat_1.default.RED;
    this.unpackAlignment = 1;
  }

  toRGBFormat() {
    this.srcFormat = TextureFormat_1.default.RGB;
    this.internalFormat = TextureFormat_1.default.RGB;
    this.unpackAlignment = 3;
  }

  toRGBAFormat() {
    this.srcFormat = TextureFormat_1.default.RGBA;
    this.internalFormat = TextureFormat_1.default.RGBA;
    this.unpackAlignment = 4;
  }

  setDataFromBytes(bytes, miplevel = 0, imgWidth = -1, imgHeight = -1, offsetx = 0, offsety = 0, rebuild = false) {
    super.setDataFromBytes(bytes, miplevel, imgWidth, imgHeight, offsetx, offsety, rebuild);
  }

  setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel = 0) {
    super.setPartDataFromeBytes(bytes, px, py, twidth, theight, miplevel);
  }

  getPixels(px, py, pw, ph, outBytes) {
    super.getPixels(px, py, pw, ph, outBytes);
  }

  toString() {
    return "[BytesTextureProxy(width=" + this.getWidth() + ",height=" + this.getHeight() + ")]";
  }

}

exports.default = BytesTextureProxy;

/***/ }),

/***/ "fecb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const MathConst_1 = __importDefault(__webpack_require__("6e01"));

const Vector3D_1 = __importDefault(__webpack_require__("8e17"));

class AABB {
  constructor() {
    this.min = new Vector3D_1.default();
    this.max = new Vector3D_1.default();
    this.version = -1;
    this.radius = 50;
    this.radius2 = 2500;
    this.center = new Vector3D_1.default(0.0, 0.0, 0.0);
    this.m_long = 100.0;
    this.m_width = 100.0;
    this.m_height = 100.0;
    this.m_halfLong = 50.0;
    this.m_halfWidth = 50.0;
    this.m_halfHeight = 50.0;
    this.m_tempV = new Vector3D_1.default();
    this.reset();
  }

  getLong() {
    return this.m_long;
  }

  getWidth() {
    return this.m_width;
  }

  getHeight() {
    return this.m_height;
  }

  reset() {
    let v = this.min;
    v.x = v.y = v.z = MathConst_1.default.MATH_MAX_POSITIVE;
    v = this.max;
    v.x = v.y = v.z = MathConst_1.default.MATH_MIN_NEGATIVE;
  }

  equals(ab) {
    return this.min.equalsXYZ(ab.min) && this.max.equalsXYZ(ab.max);
  }

  setVolume(width, height, long) {
    this.m_width = width;
    this.m_height = height;
    this.m_long = long; //

    this.m_halfLong = 0.5 * this.m_long;
    this.m_halfWidth = 0.5 * this.m_width;
    this.m_halfHeight = 0.5 * this.m_height; //

    this.max.x = this.center.x + this.m_halfWidth;
    this.max.y = this.center.y + this.m_halfHeight;
    this.max.z = this.center.z + this.m_halfLong; //

    this.min.x = this.center.x - this.m_halfWidth;
    this.min.y = this.center.y - this.m_halfHeight;
    this.min.z = this.center.z - this.m_halfLong;
    this.radius2 = this.m_halfWidth * this.m_halfWidth + this.m_halfHeight * this.m_halfHeight + this.m_halfLong * this.m_halfLong;
    this.radius = Math.sqrt(this.radius2);
  }

  union(ab) {
    this.addPosition(ab.min);
    this.addPosition(ab.max);
    return this;
  }

  addPosition(pv) {
    if (this.min.x > pv.x) this.min.x = pv.x;
    if (this.min.y > pv.y) this.min.y = pv.y;
    if (this.min.z > pv.z) this.min.z = pv.z;
    if (this.max.x < pv.x) this.max.x = pv.x;
    if (this.max.y < pv.y) this.max.y = pv.y;
    if (this.max.z < pv.z) this.max.z = pv.z;
  }

  addXYZ(pvx, pvy, pvz) {
    if (this.min.x > pvx) this.min.x = pvx;
    if (this.min.y > pvy) this.min.y = pvy;
    if (this.min.z > pvz) this.min.z = pvz;
    if (this.max.x < pvx) this.max.x = pvx;
    if (this.max.y < pvy) this.max.y = pvy;
    if (this.max.z < pvz) this.max.z = pvz;
  }

  addXYZFloat32Arr(vs, step = 3) {
    let len = vs.length;
    let pvx = 0.0;
    let pvy = 0.0;
    let pvz = 0.0;

    for (let i = 0; i < len;) {
      pvx = vs[i];
      pvy = vs[i + 1];
      pvz = vs[i + 2];
      i += step;
      if (this.min.x > pvx) this.min.x = pvx;
      if (this.min.y > pvy) this.min.y = pvy;
      if (this.min.z > pvz) this.min.z = pvz;
      if (this.max.x < pvx) this.max.x = pvx;
      if (this.max.y < pvy) this.max.y = pvy;
      if (this.max.z < pvz) this.max.z = pvz;
    }
  }

  addXYZFloat32AndIndicesArr(vs, indices) {
    let len = indices.length;
    let pvx = 0.0;
    let pvy = 0.0;
    let pvz = 0.0;
    let i;

    for (let k = 0; k < len; k++) {
      i = k * 3;
      pvx = vs[i++];
      pvy = vs[i++];
      pvz = vs[i];
      if (this.min.x > pvx) this.min.x = pvx;
      if (this.min.y > pvy) this.min.y = pvy;
      if (this.min.z > pvz) this.min.z = pvz;
      if (this.max.x < pvx) this.max.x = pvx;
      if (this.max.y < pvy) this.max.y = pvy;
      if (this.max.z < pvz) this.max.z = pvz;
    }
  }

  getClosePosition(in_pos, out_pos, bias = 0.0) {
    out_pos.copyFrom(in_pos);

    if (out_pos.x < this.min.x) {
      out_pos.x = this.min.x + bias;
    } else if (out_pos.x > this.max.x) {
      out_pos.x = this.max.x - bias;
    }

    if (out_pos.y < this.min.y) {
      out_pos.y = this.min.y + bias;
    } else if (out_pos.y > this.max.y) {
      out_pos.y = this.max.y - bias;
    }

    if (out_pos.z < this.min.z) {
      out_pos.z = this.min.z + bias;
    } else if (out_pos.z > this.max.z) {
      out_pos.z = this.max.z - bias;
    }
  } // @param	v	Vector3D instance


  containsV(v) {
    if (v.x < this.max.x || v.x > this.max.x) return false;
    if (v.y < this.max.y || v.y > this.max.y) return false;
    if (v.z < this.max.z || v.z > this.max.z) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsXY(vx, vy) {
    if (vx < this.min.x || vx > this.max.x) return false;
    if (vy < this.min.y || vy > this.max.y) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsXZ(vx, vz) {
    if (vx < this.min.x || vx > this.max.x) return false;
    if (vz < this.min.z || vz > this.max.z) return false;
    return true;
  } // 是否包含某一点(同一坐标空间的点)


  containsYZ(vy, vz) {
    if (vy < this.min.y || vy > this.max.y) return false;
    if (vz < this.min.z || vz > this.max.z) return false;
    return true;
  }

  copyFrom(ab) {
    //this.setRadius(ab.getRadius());
    this.radius = ab.radius;
    this.radius2 = ab.radius2; //this.setRadiusSquared(ab.getRadiusSquared());

    this.min.copyFrom(ab.min);
    this.max.copyFrom(ab.max); //this.getOCenter().copyFrom(ab.getOCenter());

    this.center.copyFrom(ab.center);
    this.updateVolume();
    return this;
  }

  expand(bias) {
    this.min.subtractBy(bias);
    this.max.addBy(bias);
    return this;
  }

  updateVolume() {
    this.m_width = this.max.x - this.min.x;
    this.m_height = this.max.y - this.min.y;
    this.m_long = this.max.z - this.min.z;
    this.m_halfLong = 0.5 * this.m_long;
    this.m_halfWidth = 0.5 * this.m_width;
    this.m_halfHeight = 0.5 * this.m_height;
    ++this.version;
    return this;
  }

  updateThis() {
    this.center.x = 0.5 * this.m_width;
    this.center.y = 0.5 * this.m_height;
    this.center.z = 0.5 * this.m_long;
    this.m_halfLong = this.center.z;
    this.m_halfWidth = this.center.x;
    this.m_halfHeight = this.center.y;
    this.radius2 = this.m_halfWidth * this.m_halfWidth + this.m_halfHeight * this.m_halfHeight + this.m_halfLong * this.m_halfLong;
    this.radius = Math.sqrt(this.radius2);
    this.center.addBy(this.min); // this.center.x += this.min.x;
    // this.center.y += this.min.y;
    // this.center.z += this.min.z;

    ++this.version;
  }

  update() {
    // x
    this.m_width = this.max.x;

    if (this.min.x > this.max.x) {
      this.max.x = this.min.x;
      this.min.x = this.m_width;
    }

    this.m_width = this.max.x - this.min.x; // y

    this.m_height = this.max.y;

    if (this.min.y > this.max.y) {
      this.max.y = this.min.y;
      this.min.y = this.m_height;
    }

    this.m_height = this.max.y - this.min.y; // z

    this.m_long = this.max.z;

    if (this.min.z > this.max.z) {
      this.max.z = this.min.z;
      this.min.z = this.m_long;
    }

    this.m_long = this.max.z - this.min.z;
    this.updateThis();
  }

  updateFast() {
    this.m_width = this.max.x - this.min.x;
    this.m_height = this.max.y - this.min.y;
    this.m_long = this.max.z - this.min.z;
    this.updateThis();
  }

  toString() {
    return "[AABB(min->" + this.min + ",size(" + this.m_width + "," + this.m_height + "," + this.m_long + "))]";
  } // max vecs sphere range intersect calc


  sphereIntersect(centerV, radius) {
    this.m_tempV.x = this.center.x - centerV.x;
    this.m_tempV.y = this.center.y - centerV.y;
    this.m_tempV.z = this.center.z - centerV.z;
    let dis = this.m_tempV.getLengthSquared();

    if (dis < this.radius2) {
      return true;
    }

    radius += this.radius;
    radius *= radius;
    return radius >= dis;
  }

}

exports.default = AABB;

/***/ }),

/***/ "ffc0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/***************************************************************************/

/*                                                                         */

/*  Copyright 2018-2022 by                                                 */

/*  Vily(vily313@126.com)                                                  */

/*                                                                         */

/***************************************************************************/

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const RendererDevice_1 = __importDefault(__webpack_require__("3b73"));

class TextureFormat {
  static ToGL(gl, format) {
    const tf = TextureFormat;

    switch (format) {
      case tf.RGBA:
        break;

      case tf.R8:
        return gl.R8;
        break;

      case tf.RGB:
        return gl.RGB;
        break;

      case tf.RGB8:
        return gl.RGB8;
        break;

      case tf.RGBA8:
        return gl.RGBA8;
        break;

      case tf.ALPHA:
        return gl.ALPHA;
        break;

      case tf.RGB16F:
        if (RendererDevice_1.default.IsWebGL2()) {
          return gl.RGB16F;
        }

        return gl.RGB;
        break;

      case tf.RGBA16F:
        if (RendererDevice_1.default.IsWebGL2()) {
          return gl.RGBA16F;
        }

        return gl.RGBA;
        break;

      case tf.RGB32F:
        if (RendererDevice_1.default.IsWebGL2()) gl.RGB32F;
        return gl.RGB;
        break;

      case tf.RGBA32F:
        if (RendererDevice_1.default.IsWebGL2()) gl.RGBA32F;
        return gl.RGBA;
        break;

      case TextureFormat.RED:
        return gl.RED;
        break;

      case tf.DEPTH_COMPONENT:
        return gl.DEPTH_COMPONENT;
        break;

      case tf.DEPTH_STENCIL:
        return gl.DEPTH_STENCIL;
        break;

      default:
        break;
    }

    return gl.RGBA;
  }

}

TextureFormat.R8 = 101;
TextureFormat.RGB = 110;
TextureFormat.RED = 111;
TextureFormat.RGBA = 121;
TextureFormat.RGB8 = 122;
TextureFormat.RGBA8 = 123;
TextureFormat.ALPHA = 132;
TextureFormat.RGB16F = 331;
TextureFormat.RGBA16F = 332;
TextureFormat.RGB32F = 341;
TextureFormat.RGBA32F = 342;
TextureFormat.DEPTH_COMPONENT = 351;
TextureFormat.DEPTH_STENCIL = 352;
exports.default = TextureFormat;

/***/ })

/******/ });
});